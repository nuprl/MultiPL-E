language: rs
name: HumanEval_161_solve
results:
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    for (i, &c) in s.chars().enumerate()\
    \ {\n        let (lower, upper) = if c.is_ascii_lowercase() { (true, false) }\
    \ else { (false, true) };\n        s = s.split_at_chars(i).fold(s, |s, c| s.chars().next().map(|c|\
    \ if lower { c.to_ascii_lowercase().collect() } else { c.to_ascii_uppercase().collect()\
    \ }).collect());\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpph7iu0ld.rs:15:13\n   |\n\
    15 |     for (i, &c) in s.chars().enumerate() {\n   |             ^^     ---------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0599]: no method named `split_at_chars`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpph7iu0ld.rs:17:15\n\
    \   |\n17 | ...   s = s.split_at_chars(i).fold(s, |s, c| s.chars().next().map(|c|\
    \ if lower { c.to_ascii_lowercase().collect() } else { c.to_ascii_upp...\n   |\
    \             ^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_at`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve_internal(s.chars().collect::<Vec<_>>()).to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve_internal` in this scope\n  -->\
    \ /tmp/tmpfbyzti5_.rs:14:5\n   |\n14 |     solve_internal(s.chars().collect::<Vec<_>>()).to_string()\n\
    \   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars()\n        .filter_map(|&c| {\n           \
    \ match c {\n                'a' => Some('b'),\n                'b' => Some('a'),\n\
    \                _ => Some(c),\n            }\n        })\n        .fold(String::new(),\
    \ |acc, &c| {\n            acc.insert(0, &c.to_string());\n            acc\n \
    \       })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpicw02z3h.rs:15:22\n   |\n\
    15 |         .filter_map(|&c| {\n   |                      ^--\n   |         \
    \             ||\n   |                      |expected due to this\n   |      \
    \                expected `char`, found reference\n   |                      help:\
    \ did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpicw02z3h.rs:22:36\n\
    \   |\n22 |         .fold(String::new(), |acc, &c| {\n   |                   \
    \                 ^--\n   |                                    ||\n   |      \
    \                              |expected due to this\n   |                   \
    \                 expected `char`, found reference\n   |                     \
    \               help: did you mean `c`: `&char`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        String::new()\n    } else\
    \ {\n        let mut new_s = s;\n        let mut last_char = false;\n        for\
    \ c in s.chars() {\n            if !c.is_ascii_lowercase() {\n               \
    \ new_s = new_s.chars().map(|x| match x {\n                    'A' => {\n    \
    \                    x.to_ascii_lowercase()\n                    }\n         \
    \           'a' => {\n                        x.to_ascii_uppercase()\n       \
    \             }\n                    _ => x,\n                }).collect::<String>();\n\
    \            } else {\n                new_s = new_s.chars().map(|x| match x {\n\
    \                    'A' => {\n                        x.to_ascii_uppercase()\n\
    \                    }\n                    'a' => {\n                       \
    \ x.to_ascii_lowercase()\n                    }\n                    _ => x,\n\
    \                }).collect::<String>();\n            }\n            last_char\
    \ = c;\n        }\n        if !new_s.is_empty() && !last_char {\n            new_s\
    \ = String::from(&new_s[1..]);\n        }\n        new_s\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8vbzoyk.rs:41:25\n   |\n\
    18 |         let mut last_char = false;\n   |                             -----\
    \ expected due to this value\n...\n41 |             last_char = c;\n   |     \
    \                    ^ expected `bool`, found `char`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    match s.chars().count() {\n        0 => s,\n      \
    \  1 => s.to_string(),\n        _ => {\n            let mut s = String::from(s);\n\
    \            for c in &s.chars() {\n                match c.to_ascii_lowercase()\
    \ {\n                    Some(c) => c.to_ascii_uppercase(),\n                \
    \    None => c.to_ascii_lowercase(),\n                }\n            }\n     \
    \       s\n        }\n    }\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmp3om7w2ty.rs:19:22\n\
    \   |\n19 |             for c in &s.chars() {\n   |                      -^^^^^^^^^\n\
    \   |                      |\n   |                      `&Chars<'_>` is not an\
    \ iterator\n   |                      help: consider removing the leading `&`-reference\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n \
    \  = note: `Iterator` is implemented for `&mut std::str::Chars<'_>`, but not for\
    \ `&std::str::Chars<'_>`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `&Chars<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| match c {\n        c if c.is_ascii_letter()\
    \ => c.to_ascii_lowercase().to_string(),\n        c => c.to_string(),\n    }).collect::<Vec<_>>().join(\"\
    \").to_string()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpu9nhusbx.rs:15:16\n   |\n15 |         c if\
    \ c.is_ascii_letter() => c.to_ascii_lowercase().to_string(),\n   |           \
    \     ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s: String = s.to_owned();\n    let mut result\
    \ = s.clone();\n    \n    for i in 0..s.len() {\n        if s.chars().any(|c|\
    \ *c >= 'a' && *c <= 'z') {\n            let c = s.chars().filter(|c| *c >= 'a'\
    \ && *c <= 'z').count() as u32;\n            let mut i = s.len();\n          \
    \  while i > 0 {\n                *s = s[i / 2..i / 2].to_lowercase().to_string();\n\
    \                i /= 2;\n            }\n        }\n        else {\n         \
    \   *s = s.to_lowercase().to_string();\n        }\n        s = s.to_owned();\n\
    \        result = result.concat(*s);\n    }\n    \n    result\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpz53zj1rp.rs:18:30\n\
    \   |\n18 |         if s.chars().any(|c| *c >= 'a' && *c <= 'z') {\n   |     \
    \                         ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpz53zj1rp.rs:18:43\n   |\n18 |         if s.chars().any(|c| *c >=\
    \ 'a' && *c <= 'z') {\n   |                                           ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz53zj1rp.rs:22:22\n   |\n22 |              \
    \   *s = s[i / 2..i / 2].to_lowercase().to_string();\n   |                 --\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `String`\n\
    \   |                 |\n   |                 expected due to the type of this\
    \ binding\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmpz53zj1rp.rs:22:17\n   |\n22 |              \
    \   *s = s[i / 2..i / 2].to_lowercase().to_string();\n   |                 ^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: the left-hand-side of an assignment\
    \ must have a statically known size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz53zj1rp.rs:27:18\n\
    \   |\n27 |             *s = s.to_lowercase().to_string();\n   |             --\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `String`\n   | \
    \            |\n   |             expected due to the type of this binding\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpz53zj1rp.rs:27:13\n   |\n27 |             *s = s.to_lowercase().to_string();\n\
    \   |             ^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror[E0599]: no method\
    \ named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpz53zj1rp.rs:30:25\n\
    \   |\n30 |         result = result.concat(*s);\n   |                        \
    \ ^^^^^^ method not found in `String`\n\nerror: aborting due to 7 previous err"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        String::from(\"no solution\"\
    )\n    } else {\n        match s[0] {\n            'a' => {\n                if\
    \ s.len() == 1 {\n                    String::from(\"no solution\")\n        \
    \        } else {\n                    s.swap(0, 1).to_string()\n            \
    \    }\n            }\n            'b' => {\n                if s.len() == 2 {\n\
    \                    String::from(\"no solution\")\n                } else {\n\
    \                    s.swap(0, 2).to_string()\n                }\n           \
    \ }\n            'c' => {\n                if s.len() == 3 {\n               \
    \     String::from(\"no solution\")\n                } else {\n              \
    \      s.swap(0, 3).to_string()\n                }\n            }\n          \
    \  'd' => {\n                if s.len() == 4 {\n                    String::from(\"\
    no solution\")\n                } else {\n                    s.swap(0, 4).to_string()\n\
    \                }\n            }\n            'e' => {\n                if s.len()\
    \ == 5 {\n                    String::from(\"no solution\")\n                }\
    \ else {\n                    s.swap(0, 5).to_string()\n                }\n  \
    \          }\n            'f' => {\n                if s.len() == 6 {\n      \
    \              String::from(\"no solution\")\n                } else {\n     \
    \               s.swap(0, 6).to_string()\n                }\n            }\n \
    \           'g' => {\n                if s.len() == 7 {\n                    String::from(\"\
    no solution\")\n                } else {\n                    s.swap(0, 7).to_string()\n\
    \                }\n            }\n            'h' => {\n                if s.len()\
    \ == 8 {\n                    String::from(\"no solution\")\n                }\
    \ else {\n                    s.swap(0, 8).to_string()\n                }\n  \
    \          }\n            'i' => {\n                if s.len() == 9 {\n      \
    \              String::from(\"no solution\")\n                } else {\n     \
    \               s.swap(0, 9).to_string()\n                }\n            }\n \
    \           'j' => {\n                if s.len() == 10 {\n                   \
    \ String::from(\"no solution\")\n                } else {\n                  \
    \  s.swap(0, 10).to_string()\n                }\n            }\n            'k'\
    \ => {\n                if s.len() == 11 {\n                    String::from(\"\
    no solution\")\n                } else {\n                    s.swap(0, 11).to_string()\n\
    \                }\n            }\n            'l' => {\n                if s.len()\
    \ == 12 {\n                    String::from(\"no solution\")\n               \
    \ } else {\n                    s.swap(0, 12).to_string()\n                }\n\
    \            }\n            'm' => {\n                if s.len() == 13 {\n   \
    \                 String::from(\"no solution\")\n                } else {\n  \
    \                  s.swap(0, 13).to_string()\n                }\n            }\n\
    \            'n' => {\n                if s.len() == 14 {\n                  \
    \  String::from(\"no solution\")\n                } else {\n                 \
    \   s.swap(0, 14).\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvh1t7dpg.rs:126:3\n\
    \    |\n13  | fn solve(s: String) -> String {\n    |                         \
    \      - unclosed delimiter\n...\n16  |     } else {\n    |            - unclosed\
    \ delimiter\n17  |         match s[0] {\n    |                    - unclosed delimiter\n\
    ...\n109 |             'n' => {\n    |                    - unclosed delimiter\n\
    ...\n112 |                 } else {\n    |                        - this delimiter\
    \ might not be properly closed...\n113 |                     s.swap(0, 14).\n\
    114 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    126 | }\n    |   ^\n\nerror: unexpected token: `}`\n   --> /tmp/tmpvh1t7dpg.rs:114:1\n\
    \    |\n114 | }\n    | ^\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpvh1t7dpg.rs:17:15\n   |\n17 |         match s[0]\
    \ {\n   |               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpvh1t7dpg.rs:22:23\n   |\n22 |          \
    \           s.swap(0, 1).to_string()\n   |                       ^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpvh1t7dpg.rs:29:23\n   |\n29 |          \
    \           s.swap(0, 2).to_string()\n   |                       ^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpvh1t7dpg.rs:36:23\n   |\n36 |          \
    \           s.swap(0, 3).to_string()\n   |        "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    loop {\n        let mut s = s.chars();\n\
    \        if s.next().is_none() {\n            break;\n        }\n        if s.next().unwrap().is_lowercase()\
    \ {\n            let mut v = s.next().unwrap().to_uppercase();\n            for\
    \ c in s.next() {\n                v = v.chars().next().unwrap().to_uppercase()\
    \ + c;\n            }\n            s = v;\n        } else {\n            let mut\
    \ v = s.next().unwrap().to_lowercase();\n            for c in s.next() {\n   \
    \             v = v.chars().next().unwrap().to_lowercase() + c;\n            }\n\
    \            s = v;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `ToUppercase` in\
    \ the current scope\n  --> /tmp/tmpyd80gkbr.rs:23:23\n   |\n23 |             \
    \    v = v.chars().next().unwrap().to_uppercase() + c;\n   |                 \
    \      ^^^^^ method not found in `ToUppercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyd80gkbr.rs:25:17\n   |\n16 |         let mut s = s.chars();\n\
    \   |                     --------- expected due to this value\n...\n25 |    \
    \         s = v;\n   |                 ^ expected struct `Chars`, found struct\
    \ `ToUppercase`\n\nerror[E0599]: no method named `chars` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpyd80gkbr.rs:29:23\n   |\n29 |          \
    \       v = v.chars().next().unwrap().to_lowercase() + c;\n   |              \
    \         ^^^^^ method not found in `ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyd80gkbr.rs:31:17\n   |\n16 |         let mut s = s.chars();\n\
    \   |                     --------- expected due to this value\n...\n31 |    \
    \         s = v;\n   |                 ^ expected struct `Chars`, found struct\
    \ `ToLowercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    // write your code in here\n    if s.len() == 0 {\n\
    \        String::from(\"0\")\n    } else {\n        let mut result = String::new();\n\
    \        let mut last = 0;\n        let mut last2: usize = 0;\n        for i in\
    \ s.chars() {\n            if i.is_ascii() {\n                result.push(i);\n\
    \            } else {\n                if last == 0 {\n                    result.push(i\
    \ as char);\n                } else {\n                    result.push(String::from_utf8(s[last2..last].to_vec()).unwrap());\n\
    \                    result.push(i as char);\n                }\n            }\n\
    \            last = i;\n            last2 = i;\n        }\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_vec` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpm90vypzv.rs:28:66\n   |\n28 |                     result.push(String::from_utf8(s[last2..last].to_vec()).unwrap());\n\
    \   |                                                                  ^^^^^^\
    \ method not found in `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm90vypzv.rs:28:33\n\
    \   |\n28 |                     result.push(String::from_utf8(s[last2..last].to_vec()).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpm90vypzv.rs:32:20\n   |\n19 |         let mut last = 0;\n   |  \
    \                      - expected due to this value\n...\n32 |             last\
    \ = i;\n   |                    ^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm90vypzv.rs:33:21\n   |\n20 |         let mut\
    \ last2: usize = 0;\n   |                        ----- expected due to this type\n\
    ...\n33 |             last2 = i;\n   |                     ^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut chars = s.chars();\n  \
    \  while let Some(ch) = chars.next() {\n        let mut ch = ch;\n        if ch.is_uppercase()\
    \ {\n            ch = ch.to_lowercase();\n        } else {\n            ch = ch.to_uppercase();\n\
    \        }\n        s = s.chars().next().unwrap().to_string().push_str(&ch);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0fdza800.rs:19:18\n   |\n\
    17 |         let mut ch = ch;\n   |                      -- expected due to this\
    \ value\n18 |         if ch.is_uppercase() {\n19 |             ch = ch.to_lowercase();\n\
    \   |                  ^^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0fdza800.rs:21:18\n   |\n17 |\
    \         let mut ch = ch;\n   |                      -- expected due to this\
    \ value\n...\n21 |             ch = ch.to_uppercase();\n   |                 \
    \ ^^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0fdza800.rs:23:60\n   |\n23 |         s = s.chars().next().unwrap().to_string().push_str(&ch);\n\
    \   |                                                            ^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fdza800.rs:23:13\n\
    \   |\n14 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n23 |         s = s.chars().next().unwrap().to_string().push_str(&ch);\n \
    \  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmp0fdza800.rs:23:51\n   |\n23 |         s = s.chars().next().unwrap().to_string().push_str(&ch);\n\
    \   |             ------------------------------------- ^^^^^^^^ this call modifies\
    \ its receiver in-place\n   |             |\n   |             you probably want\
    \ to use this value after calling the method...\n   = note: ...instead of the\
    \ `()` output of method `push_str`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut out = String::new();\n\n    for ch in s.chars()\
    \ {\n        match ch {\n            c if is_letter_case(c) => out.push_str(&(ch.to_lowercase())),\n\
    \            c if !is_letter_case(c) => out.push_str(&(ch.to_uppercase())),\n\
    \            _ => out.push_str(&*ch)\n        }\n    }\n\n    out\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_letter_case` in this scope\n  -->\
    \ /tmp/tmpm_68zki3.rs:18:18\n   |\n18 |             c if is_letter_case(c) =>\
    \ out.push_str(&(ch.to_lowercase())),\n   |                  ^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `is_letter_case` in\
    \ this scope\n  --> /tmp/tmpm_68zki3.rs:19:19\n   |\n19 |             c if !is_letter_case(c)\
    \ => out.push_str(&(ch.to_uppercase())),\n   |                   ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm_68zki3.rs:18:52\n\
    \   |\n18 |             c if is_letter_case(c) => out.push_str(&(ch.to_lowercase())),\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `ToLowercase`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm_68zki3.rs:19:53\n   |\n19 |             c if !is_letter_case(c)\
    \ => out.push_str(&(ch.to_uppercase())),\n   |                               \
    \                      ^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpm_68zki3.rs:20:32\n\
    \   |\n20 |             _ => out.push_str(&*ch)\n   |                        \
    \        ^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.len() == 0 {\n        String::from(\"\")\n   \
    \ } else {\n        let mut result: String = \"\";\n        for ch in s.chars()\
    \ {\n            if let Some(i) = get_index(&ch) {\n                let mut res\
    \ = s.chars().take(i).collect::<String>();\n                res.reverse();\n \
    \               result += String::from(res);\n            } else {\n         \
    \       result += String::from(ch);\n            }\n        }\n        result\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_index` in this scope\n  --> /tmp/tmpnarv4vqw.rs:19:30\n\
    \   |\n19 |             if let Some(i) = get_index(&ch) {\n   |              \
    \                ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnarv4vqw.rs:17:34\n   |\n17 |         let mut result: String\
    \ = \"\";\n   |                         ------   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                         |        |\n   |      \
    \                   |        expected struct `String`, found `&str`\n   |    \
    \                     expected due to this\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpnarv4vqw.rs:21:21\n\
    \   |\n21 |                 res.reverse();\n   |                     ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnarv4vqw.rs:22:27\n   |\n22 |              \
    \   result += String::from(res);\n   |                           ^^^^^^^^^^^^^^^^^\n\
    \   |                           |\n   |                           expected `&str`,\
    \ found struct `String`\n   |                           help: consider borrowing\
    \ here: `&String::from(res)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnarv4vqw.rs:24:27\n\
    \   |\n24 |                 result += String::from(ch);\n   |                \
    \           ^^^^^^^^^^^^^^^^\n   |                           |\n   |         \
    \                  expected `&str`, found struct `String`\n   |              \
    \             help: consider borrowing here: `&String::from(ch)`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() { return String::new(); }\n    let\
    \ mut s = String::from(s);\n    if s[0].is_alpha() {\n        let char = s[0]\
    \ as char;\n        if char == char::ToLower || char == char::ToUpper {\n    \
    \        let mut c = s.clone();\n            c.chars().for_each(|c| *c = match\
    \ c {\n                char::ToLower => char::ToUpper,\n                char::ToUpper\
    \ => char::ToLower,\n                _ => c,\n            });\n            s.truncate(1);\n\
    \            s.append(c);\n        } else {\n            s.truncate(1);\n    \
    \        s.append(char);\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpougr8yxh.rs:16:8\n   |\n16 |     if s[0].is_alpha() {\n   |        ^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpougr8yxh.rs:17:20\n   |\n17 |         let char = s[0] as char;\n\
    \   |                    ^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no associated item named `ToLower` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpougr8yxh.rs:18:26\n   |\n18 |   \
    \      if char == char::ToLower || char == char::ToUpper {\n   |             \
    \             ^^^^^^^ associated item not found in `char`\n\nerror[E0599]: no\
    \ associated item named `ToUpper` found for type `char` in the current scope\n\
    \  --> /tmp/tmpougr8yxh.rs:18:51\n   |\n18 |         if char == char::ToLower\
    \ || char == char::ToUpper {\n   |                                           \
    \        ^^^^^^^ associated item not found in `char`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpougr8yxh.rs:20:36\n   |\n20 |        \
    \     c.chars().for_each(|c| "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = s.clone();\n    res.chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            if let Some(c) = c.to_lowercase()\
    \ {\n                res.replace(c.to_ascii_lowercase(), c.to_ascii_uppercase(),\
    \ ());\n            } else {\n                res.replace(c.to_ascii_uppercase(),\
    \ c.to_ascii_lowercase(), ());\n            }\n        } else {\n            res.replace(c.to_lowercase(),\
    \ c.to_uppercase(), ());\n        }\n    });\n    res\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawiri1wv.rs:17:20\n   |\n\
    17 |             if let Some(c) = c.to_lowercase() {\n   |                   \
    \ ^^^^^^^   ---------------- this expression has type `ToLowercase`\n   |    \
    \                |\n   |                    expected struct `ToLowercase`, found\
    \ enum `Option`\n   |\n   = note: expected struct `ToLowercase`\n            \
    \    found enum `Option<_>`\n\nerror[E0061]: this function takes 2 arguments but\
    \ 3 arguments were supplied\n   --> /tmp/tmpawiri1wv.rs:18:21\n    |\n18  |  \
    \               res.replace(c.to_ascii_lowercase(), c.to_ascii_uppercase(), ());\n\
    \    |                     ^^^^^^^ ----------------------  ----------------------\
    \  -- supplied 3 arguments\n    |                     |\n    |               \
    \      expected 2 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \   --> /tmp/tmpawiri1wv.rs:20:21\n    |\n20  |                 res.replace(c.to_ascii_uppercase(),\
    \ c.to_ascii_lowercase(), ());\n    |                     ^^^^^^^ ----------------------\
    \  ----------------------  -- supplied 3 arguments\n    |                    \
    \ |\n    |                     expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 2 arguments but 3 arguments\
    \ were supplied\n   --> /tmp/tmpawiri1wv.rs:23:17\n    |\n23  |             res.replace(c.to_lowercase(),\
    \ c.to_uppercase(), ());\n    |                 ^^^^^^^ ----------------  ----------------\
    \  -- supplied 3 arguments\n    |                 |\n    |                 expected\
    \ 2 arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    char_reverse(s)\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_reverse` in this scope\n  -->\
    \ /tmp/tmpjd9f66k0.rs:14:5\n   |\n14 |     char_reverse(s)\n   |     ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().enumerate().filter(|&(i, c)| *c == ascii_lowercase[*i]).map(|&(i,\
    \ c)| \n        if *i == 0 {\n            let mut c = c * 2;\n            while\
    \ *c < ascii_lowercase[*c] {\n                c *= 2;\n            }\n       \
    \     *c = ascii_uppercase[*c];\n            c\n        } else {\n           \
    \ c\n        })\n        .fold(\"\".to_string(), |mut acc, c| {\n            let\
    \ n = s.find(|&(_, c2)| c2 != c);\n            acc + &s[0..n] + &s[n..]\n    \
    \    })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ascii_lowercase` in this scope\n  -->\
    \ /tmp/tmpkaf0owxo.rs:14:50\n   |\n14 |     s.chars().enumerate().filter(|&(i,\
    \ c)| *c == ascii_lowercase[*i]).map(|&(i, c)| \n   |                        \
    \                          ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ascii_lowercase` in this scope\n  --> /tmp/tmpkaf0owxo.rs:17:24\n\
    \   |\n17 |             while *c < ascii_lowercase[*c] {\n   |               \
    \         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ascii_uppercase` in this scope\n  --> /tmp/tmpkaf0owxo.rs:20:18\n   |\n\
    20 |             *c = ascii_uppercase[*c];\n   |                  ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpkaf0owxo.rs:14:44\n   |\n14 |     s.chars().enumerate().filter(|&(i,\
    \ c)| *c == ascii_lowercase[*i]).map(|&(i, c)| \n   |                        \
    \                    ^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpkaf0owxo.rs:14:66\n   |\n14 |     s.chars().enumerate().filter(|&(i,\
    \ c)| *c == ascii_lowercase[*i]).map(|&(i, c)| \n   |                        \
    \                                          ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkaf0owxo.rs:14:76\n   |\n14 |     s.chars().enumerate().filter(|&(i,\
    \ c)| *c == ascii_lowercase[*i]).map(|&(i, c)| \n   |                        \
    \                                                    ^^^^^^-\n   |           \
    \                                                                 |     |\n  \
    \ |                                                                          \
    \  |     expected due to this\n   |                                          \
    \                                  expected tuple, found reference\n   |\n   =\
    \ note:  expected tuple `(usize, char)`\n           found reference `&_`\n\nerror[E0631]:\
    \ type mismatch in closure arguments\n    --> /tmp/tmpkaf0owxo.rs:26:23\n    \
    \ |\n26   |             let n = s.find(|&(_, c2)| c2 != c);\n     |          \
    \             ^^^^ ------------------ found signature of `fn(&"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().count() == 0 {\n        return String::from(s);\n\
    \    }\n\n    let mut result = String::from(s);\n    for c in s.chars().into_iter()\
    \ {\n        if c == 'a' {\n            result = result.rev();\n        }\n  \
    \      \n        if c == 'A' {\n            result = result.rev();\n        }\n\
    \        \n        if c == '#' {\n            result = result.rev();\n       \
    \ }\n        \n        if c == '@' {\n            result = result.rev();\n   \
    \     }\n        \n        if c.is_lowercase() {\n            result = result.rev();\n\
    \        }\n        \n        if c.is_uppercase() {\n            result = result.rev();\n\
    \        }\n    }\n    \n    result\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpipu4eo1x.rs:21:29\n\
    \    |\n21  |               result = result.rev();\n    |                    \
    \           ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpipu4eo1x.rs:25:29\n\
    \    |\n25  |               result = result.rev();\n    |                    \
    \           ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpipu4eo1x.rs:29:29\n\
    \    |\n29  |               result = result.rev();\n    |                    \
    \           ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpipu4eo1x.rs:33:29\n\
    \    |\n33  |               result = result.rev();\n    |                    \
    \           ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpipu4eo1x.rs:37:29\n\
    \    |\n37  |               result = result.rev();\n    |                    \
    \           ^^^ `String` is not an i"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    if s.is_empty() {\n        \"\".to_string()\n\
    \    }\n    else {\n        \n        let mut c = s[0];\n        let mut rs =\
    \ s.chars().enumerate().collect::<Vec<_>>();\n        \n        for i in rs {\n\
    \            \n            if i.1.to_ascii_lowercase() == c.to_ascii_lowercase()\
    \ {\n                \n                let mut t = String::new();\n          \
    \      \n                for j in i.0..(s.len() - 1) {\n                    \n\
    \                    t.push(s[j]);\n                }\n                \n    \
    \            t.push(c);\n                \n                t = t.to_ascii_lowercase();\n\
    \                \n                for j in i.0..(t.len() - 1) {\n           \
    \         \n                    t.push(t[j]);\n                }\n           \
    \     \n                t.push(c);\n                \n                return t;\n\
    \            }\n            else {\n                \n                c = i.1.to_ascii_lowercase();\n\
    \            }\n        }\n        \n        \n        return String::from(s);\n\
    \    }\n    \n    return String::from(s);\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3z1yww8f.rs:16:9\n   |\n\
    15 | /     if s.is_empty() {\n16 | |         \"\".to_string()\n   | |        \
    \ ^^^^^^^^^^^^^^ expected `()`, found struct `String`\n17 | |     }\n18 | |  \
    \   else {\n...  |\n54 | |         return String::from(s);\n55 | |     }\n   |\
    \ |_____- expected this to be `()`\n   |\nhelp: consider using a semicolon here\n\
    \   |\n16 |         \"\".to_string();\n   |                       +\nhelp: consider\
    \ using a semicolon here\n   |\n55 |     };\n   |      +\nhelp: you might have\
    \ meant to return this value\n   |\n16 |         return \"\".to_string();\n  \
    \ |         ++++++               +\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmp3z1yww8f.rs:20:21\n   |\n20 |        \
    \ let mut c = s[0];\n   |                     ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3z1yww8f.rs:31:28\n   |\n31 |                     t.push(s[j]);\n\
    \   |                            ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usi"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.to_lowercase();\n    for c in s.chars()\
    \ {\n        if c.is_uppercase() {\n            s = s.to_uppercase();\n      \
    \  } else {\n            s = s.to_lowercase();\n        }\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0506]: cannot assign to `s` because it is borrowed\n    --> /tmp/tmps9a_7thk.rs:17:13\n\
    \     |\n15   |     for c in s.chars() {\n     |              ---------\n    \
    \ |              |\n     |              borrow of `s` occurs here\n     |    \
    \          borrow later used here\n16   |         if c.is_uppercase() {\n17  \
    \ |             s = s.to_uppercase();\n     |             ^ assignment to borrowed\
    \ `s` occurs here\n     |\n     = note: borrow occurs due to deref coercion to\
    \ `str`\nnote: deref defined here\n\nerror[E0506]: cannot assign to `s` because\
    \ it is borrowed\n    --> /tmp/tmps9a_7thk.rs:19:13\n     |\n15   |     for c\
    \ in s.chars() {\n     |              ---------\n     |              |\n     |\
    \              borrow of `s` occurs here\n     |              borrow later used\
    \ here\n...\n19   |             s = s.to_lowercase();\n     |             ^ assignment\
    \ to borrowed `s` occurs here\n     |\n     = note: borrow occurs due to deref\
    \ coercion to `str`\nnote: deref defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0506`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| match c {\n        c if c.is_ascii()\
    \ && c.is_ascii() == c.to_ascii_lowercase() => c.to_ascii_uppercase(),\n     \
    \   _ => c,\n    }).collect().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb10qzt0o.rs:15:46\n   |\n\
    15 |         c if c.is_ascii() && c.is_ascii() == c.to_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        String::from(\"\")\n   \
    \ } else {\n        let mut s = String::from(s);\n        let mut s_iter = s.chars().enumerate().rev().collect::<Vec<_>>();\n\
    \        while let (index, c) = s_iter.next() {\n            if c.is_uppercase()\
    \ {\n                s.insert(index, c.to_lowercase());\n            } else if\
    \ c.is_lowercase() {\n                s.insert(index, c.to_uppercase());\n   \
    \         }\n        }\n        s\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp29n66vhj.rs:18:48\n     |\n18   |         let mut s_iter = s.chars().enumerate().rev().collect::<Vec<_>>();\n\
    \     |                                                ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Rev<Enumerate<Chars<'_>>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp29n66vhj.rs:18:54\n   |\n18 |\
    \           let mut s_iter = s.chars().enumerate().rev().collect::<Vec<_>>();\n\
    \   |                                                        ^^^^^^^ method cannot\
    \ be called on `Rev<Enumerate<Chars<'_>>>` due to unsatisfied trait bounds\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `Enumerate<Chars<'_>>:\
    \ DoubleEndedIterator`\n           which is required by `Rev<Enumerate<Chars<'_>>>:\
    \ Iterator`\n           `Rev<Enumerate<Chars<'_>>>: Iterator`\n           which\
    \ is required by `&mut Rev<Enumerate<Chars<'_>>>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().enumerate().filter_map(|(i, c)| {\n     \
    \   let mut c = c.to_lowercase();\n        if c.is_ascii_lowercase() {\n     \
    \       c = c.to_uppercase();\n        }\n        Some((c.chars(), i))\n    }).collect::<Vec<_>>().sort_by_key(|(_,\
    \ i)| i).reverse()\n        .fold(s.to_owned(), |mut acc, (letters, i)| {\n  \
    \          acc.replace(i, i, letters);\n            acc\n        }).to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmplfqgwvqz.rs:16:14\n   |\n16 |         if\
    \ c.is_ascii_lowercase() {\n   |              ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `ToLowercase`\n\nerror[E0599]: no method named `to_uppercase` found for struct\
    \ `ToLowercase` in the current scope\n  --> /tmp/tmplfqgwvqz.rs:17:19\n   |\n\
    17 |             c = c.to_uppercase();\n   |                   ^^^^^^^^^^^^ method\
    \ not found in `ToLowercase`\n\nerror[E0599]: no method named `chars` found for\
    \ struct `ToLowercase` in the current scope\n  --> /tmp/tmplfqgwvqz.rs:19:17\n\
    \   |\n19 |         Some((c.chars(), i))\n   |                 ^^^^^ method not\
    \ found in `ToLowercase`\n\nerror[E0599]: no method named `reverse` found for\
    \ unit type `()` in the current scope\n  --> /tmp/tmplfqgwvqz.rs:20:52\n   |\n\
    20 |     }).collect::<Vec<_>>().sort_by_key(|(_, i)| i).reverse()\n   |      \
    \                                              ^^^^^^^ method not found in `()`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res: String = \"\".to_string();\n    let mut\
    \ lower = true;\n    for c in s.chars() {\n        if c.is_lowercase() {\n   \
    \         lower = false;\n        }\n        if !c.is_lowercase() {\n        \
    \    lower = true;\n        }\n        if c.is_uppercase() {\n            lower\
    \ = true;\n        }\n        if !c.is_uppercase() {\n            lower = false;\n\
    \        }\n        res += if !lower { c.to_lowercase() } else { c.to_uppercase()\
    \ };\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqpvzb7wm.rs:29:28\n   |\n\
    29 |         res += if !lower { c.to_lowercase() } else { c.to_uppercase() };\n\
    \   |                            ^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqpvzb7wm.rs:29:54\n\
    \   |\n29 |         res += if !lower { c.to_lowercase() } else { c.to_uppercase()\
    \ };\n   |                                                      ^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `ToUppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars();\n    let mut res = s.clone();\n\
    \    \n    loop {\n        match s.next() {\n            Some(c) => res.push((match\
    \ c.to_lowercase() {\n                'a' => c = 'A',\n                'b' =>\
    \ c = 'B',\n                'c' => c = 'C',\n                'd' => c = 'D',\n\
    \                'e' => c = 'E',\n                'f' => c = 'F',\n          \
    \      'g' => c = 'G',\n                'h' => c = 'H',\n                'i' =>\
    \ c = 'I',\n                'j' => c = 'J',\n                'k' => c = 'K',\n\
    \                'l' => c = 'L',\n                'm' => c = 'M',\n          \
    \      'n' => c = 'N',\n                'o' => c = 'O',\n                'p' =>\
    \ c = 'P',\n                'q' => c = 'Q',\n                'r' => c = 'R',\n\
    \                's' => c = 'S',\n                't' => c = 'T',\n          \
    \      'u' => c = 'U',\n                'v' => c = 'V',\n                'w' =>\
    \ c = 'W',\n                'x' => c = 'X',\n                'y' => c = 'Y',\n\
    \                'z' => c = 'Z',\n                _ => c\n            })),\n \
    \           None => break,\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp_9xgrhsk.rs:19:33\n\
    \   |\n19 |             Some(c) => res.push((match c.to_lowercase() {\n   |  \
    \                               ^\n...\n47 |             })),\n   |          \
    \    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n19 ~             Some(c) => res.push(match c.to_lowercase()\
    \ {\n20 |                 'a' => c = 'A',\n21 |                 'b' => c = 'B',\n\
    22 |                 'c' => c = 'C',\n23 |                 'd' => c = 'D',\n24\
    \ |                 'e' => c = 'E',\n ...\n\nerror[E0599]: no method named `push`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmp_9xgrhsk.rs:19:28\n\
    \   |\n19 |             Some(c) => res.push((match c.to_lowercase() {\n   |  \
    \                          ^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_9xgrhsk.rs:20:17\n   |\n19 |             Some(c)\
    \ => res.push((match c.to_lowercase() {\n   |                                \
    \        ---------------- this expression has type `ToLowercase`\n20 |       \
    \          'a' => c = 'A',\n   |                 ^^^ expected struct `ToLowercase`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_9xgrhsk.rs:21:17\n\
    \   |\n19 |             Some(c) => res.push((match c.to_lowercase() {\n   |  \
    \                                      ---------------- this expression has type\
    \ `ToLowercase`\n20 |                 'a' => c = 'A',\n21 |                 'b'\
    \ => c = 'B',\n   |                 ^^^ expected struct `ToLowercase`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_9xgrhsk.rs:22:17\n   |\n19 |\
    \             Some(c) => res.push((match c.to_lowercase() {\n   |            \
    \                            ---------------- this expression has type `ToLowercase`\n\
    ...\n22 |                 'c' => c = 'C',\n   |                 ^^^ expected struct\
    \ `ToLowercase`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_9xgrhsk.rs:23:17\n\
    \   |\n19 |             Some(c) => res.push((match c.to_lowercase() {\n   |  \
    \                  "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().collect::<Vec<_>>().into_iter().map(|c| {\n\
    \        match (c as char).to_lowercase() {\n            Some('a') => {\n    \
    \            c.to_uppercase().to_string()\n            },\n            Some('z')\
    \ => {\n                c.to_lowercase().to_string()\n            },\n       \
    \     _ => c.to_string(),\n        }\n    }).collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhcmn3eh.rs:16:13\n   |\n\
    15 |         match (c as char).to_lowercase() {\n   |               --------------------------\
    \ this expression has type `ToLowercase`\n16 |             Some('a') => {\n  \
    \ |             ^^^^^^^^^ expected struct `ToLowercase`, found enum `Option`\n\
    \   |\n   = note: expected struct `ToLowercase`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplhcmn3eh.rs:19:13\n   |\n15 |\
    \         match (c as char).to_lowercase() {\n   |               --------------------------\
    \ this expression has type `ToLowercase`\n...\n19 |             Some('z') => {\n\
    \   |             ^^^^^^^^^ expected struct `ToLowercase`, found enum `Option`\n\
    \   |\n   = note: expected struct `ToLowercase`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter_map(|c| {\n        match c {\n   \
    \         'a' => c.to_ascii_lowercase(),\n            'A' => c.to_ascii_uppercase(),\n\
    \            '#' => c,\n            _ => c,\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixbuc81r.rs:16:20\n   |\n\
    16 |             'a' => c.to_ascii_lowercase(),\n   |                    ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |             'a' => Some(c.to_ascii_lowercase()),\n   |           \
    \         +++++                      +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut r = String::new();\n  \
    \  for c in s.chars() {\n        if c.is_ascii() {\n            r.push(c.to_lowercase());\n\
    \        } else {\n            r.push(c.to_uppercase());\n        }\n    }\n \
    \   r\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx11x1uql.rs:18:20\n   |\n\
    18 |             r.push(c.to_lowercase());\n   |                    ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx11x1uql.rs:20:20\n   |\n20 |             r.push(c.to_uppercase());\n\
    \   |                    ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| match c {\n        'a'...'z' => {\n\
    \            let mut c = c.to_lowercase();\n            c = 'a' + c + 'z' - 'a';\n\
    \            char::from(c).to_string()\n        }\n        'A'...'Z' => {\n  \
    \          let mut c = c.to_uppercase();\n            c = 'A' + c + 'Z' - 'A';\n\
    \            char::from(c).to_string()\n        }\n        _ => c.to_string(),\n\
    \    })\n    .collect::<String>()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpc6d0m5jm.rs:15:12\n\
    \   |\n15 |         'a'...'z' => {\n   |            ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpc6d0m5jm.rs:20:12\n\
    \   |\n20 |         'A'...'Z' => {\n   |            ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = warning: this is accepted in the current edition\
    \ (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0369]: cannot add `ToLowercase` to `char`\n  --> /tmp/tmpc6d0m5jm.rs:17:21\n\
    \   |\n17 |             c = 'a' + c + 'z' - 'a';\n   |                 --- ^ -\
    \ ToLowercase\n   |                 |\n   |                 char\n\nerror[E0277]:\
    \ the trait bound `char: From<ToLowercase>` is not satisfied\n  --> /tmp/tmpc6d0m5jm.rs:18:13\n\
    \   |\n18 |             char::from(c).to_string()\n   |             ^^^^^^^^^^\
    \ the trait `From<ToLowercase>` is not implemented for `char`\n   |\n   = help:\
    \ the trait `From<u8>` is implemented for `char`\n\nerror[E0369]: cannot add `ToUppercase`\
    \ to `char`\n  --> /tmp/tmpc6d0m5jm.rs:22:21\n   |\n22 |             c = 'A' +\
    \ c + 'Z' - 'A';\n   |                 --- ^ - ToUppercase\n   |             \
    \    |\n   |                 char\n\nerror[E0277]: the trait bound `char: From<ToUppercase>`\
    \ is not satisfied\n  --> /tmp/tmpc6d0m5jm.rs:23:13\n   |\n23 |             char::from(c).to_string()\n\
    \   |             ^^^^^^^^^^ the trait `From<ToUppercase>` is not implemented\
    \ for `char`\n   |\n   = help: the trait `From<u8>` is implemented for `char`\n\
    \nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors\
    \ have detailed explanations: E0277, E0369.\nFor mo"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if !s.is_ascii() {\n        String::from(s.chars().collect::<Vec<_>>().into_iter().cloned().collect());\n\
    \    }\n    else if let Some(mut char) = s.chars().next_back() {\n        while\
    \ let Some(mut c) = char {\n            let is_upper = c.is_uppercase();\n   \
    \         char = c.to_uppercase();\n            if char == c {\n             \
    \   char = c.to_lowercase();\n            }\n            else if char == c {\n\
    \                char.is_ascii_lowercase() || char.is_ascii_uppercase()\n    \
    \                || char == c.to_lowercase()\n                    || char == c.to_uppercase()\n\
    \                    || char == c.to_ascii_lowercase()\n                    ||\
    \ char == c.to_ascii_uppercase()\n                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxqbtodp_.rs:68:3\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n17 |     else if let Some(mut char) = s.chars().next_back()\
    \ {\n   |                                                        - unclosed delimiter\n\
    18 |         while let Some(mut c) = char {\n   |                            \
    \          - unclosed delimiter\n...\n24 |             else if char == c {\n \
    \  |                               - this delimiter might not be properly closed...\n\
    ...\n56 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    68 | }\n   |   ^\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<char>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpxqbtodp_.rs:15:64\n     |\n15   |\
    \         String::from(s.chars().collect::<Vec<_>>().into_iter().cloned().collect());\n\
    \     |                                                                ^^^^^^\
    \ expected reference, found `char`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<char>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpxqbtodp_.rs:15:73\n \
    \  |\n15 |           String::from(s.chars().collect::<Vec<_>>().into_iter().cloned().collect());\n\
    \   |                                                                        \
    \   ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<char>>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `<std::vec::IntoIter<char> as Iterator>::Item = &_`\n\
    \           which is required by `Cloned<std::vec::IntoIter<char>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<char>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<char>>: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxqbtodp_.rs:14:22\n   |\n14 |       if !s.is_ascii()\
    \ {\n   |  ______________________^\n15 | |         String::from(s.chars"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() { return String::new(); }\n    let\
    \ mut s = s;\n    \n    let mut result = String::new();\n    while let Some(char)\
    \ = (s.chars().find(|c| c >= 'a' && c <= 'z') || s.chars().find(|c| c >= 'A' &&\
    \ c <= 'Z')) {\n        match char {\n            Some(old_c) => result = result.chars().map(|c|\n\
    \                match c {\n                    c if c.is_lowercase() => c.to_uppercase().into(),\n\
    \                    c if c.is_uppercase() => c.to_lowercase().into(),\n     \
    \               c => c\n                })\n                .join(''),\n     \
    \       None => result = result.chars().map(|c|\n                match c {\n \
    \                   c if c.is_lowercase() => c.to_lowercase().into(),\n      \
    \              c if c.is_uppercase() => c.to_uppercase().into(),\n           \
    \         c => c\n                })\n                .join(''),\n        }\n\
    \        s = s.replace(char, None);\n    }\n    match result {\n        Some(res)\
    \ => res,\n        None => String::new()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmp1zdhai9n.rs:26:24\n   |\n\
    26 |                 .join(''),\n   |                        ^ empty character\
    \ literal\n\nerror: empty character literal\n  --> /tmp/tmp1zdhai9n.rs:33:24\n\
    \   |\n33 |                 .join(''),\n   |                        ^ empty character\
    \ literal\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zdhai9n.rs:18:53\n\
    \   |\n18 |     while let Some(char) = (s.chars().find(|c| c >= 'a' && c <= 'z')\
    \ || s.chars().find(|c| c >= 'A' && c <= 'Z')) {\n   |                       \
    \                              ^^^\n   |                                     \
    \                |\n   |                                                     expected\
    \ `&char`, found `char`\n   |                                                \
    \     help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1zdhai9n.rs:18:65\n   |\n18 |     while let Some(char) = (s.chars().find(|c|\
    \ c >= 'a' && c <= 'z') || s.chars().find(|c| c >= 'A' && c <= 'Z')) {\n   | \
    \                                                                ^^^\n   |   \
    \                                                              |\n   |       \
    \                                                          expected `&char`, found\
    \ `char`\n   |                                                               \
    \  help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1zdhai9n.rs:18:29\n   |\n18 |     while let Some(char) = (s.chars().find(|c|\
    \ c >= 'a' && c <= 'z') || s.chars().find(|c| c >= 'A' && c <= 'Z')) {\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zdhai9n.rs:18:97\n\
    \   |\n18 |     while let Some(char) = (s.chars().find(|c| c >= 'a' && c <= 'z')\
    \ || s.chars().find(|c| c >= 'A' && c <= 'Z')) {\n   |                       \
    \                                                                          ^^^\n\
    \   |                            "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    let mut s = s\n    let len = s.len();\n    \n\
    \    for i in 1..len {\n        \n        if s.is_ascii_alpha() {\n          \
    \  \n            let sub = &s[0..i];\n            let mut res = String::from(sub.to_string());\n\
    \            \n            if sub.chars().any(|c| c.is_ascii_uppercase()) {\n\
    \                res = res.to_ascii_uppercase();\n            }\n            if\
    \ sub.chars().any(|c| c.is_ascii_lowercase()) {\n                res = res.to_ascii_lowercase();\n\
    \            }\n            \n            s.swap(0, i);\n            s = res.to_owned();\n\
    \        }\n        \n    }\n    \n    \n    return s;\n}\n\nfn main() {\n   \
    \ let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp70wj7yer.rs:15:18\n\
    \   |\n15 |     let mut s = s\n   |                  ^ help: add `;` here\n16\
    \ |     let len = s.len();\n   |     --- unexpected token\n\nerror[E0599]: no\
    \ method named `is_ascii_alpha` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp70wj7yer.rs:20:14\n   |\n20 |         if s.is_ascii_alpha() {\n\
    \   |              ^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror[E0599]: no method named `swap` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp70wj7yer.rs:32:15\n   |\n32 | \
    \            s.swap(0, i);\n   |               ^^^^ method not found in `String`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve(s, \"\", false)\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmpwiekolbx.rs:14:5\n   |\n14 |     solve(s, \"\", false)\n   |  \
    \   ^^^^^ -  --  ----- supplied 3 arguments\n   |     |\n   |     expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpwiekolbx.rs:13:4\n   |\n13 |\
    \ fn solve(s: String) -> String {\n   |    ^^^^^ ---------\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    match s.chars().first() {\n        None => s,\n   \
    \     Some(x) => match x.to_ascii_lowercase().chars().take(s.len() - x.len_utf8())\
    \ {\n            None => s,\n            Some(x) => x.iter().map(|y| y.to_ascii_uppercase()).collect::<String>()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `first` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpqw4ya8tx.rs:14:21\n   |\n14 |     match s.chars().first()\
    \ {\n   |                     ^^^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| if c.is_alphabetic { c.to_uppercase()\
    \ } else { c.to_lowercase() }).collect()\n        .map(|c| c.to_string())\n  \
    \      .concat()\n        .rev()\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `is_alphabetic` on type\
    \ `char`\n  --> /tmp/tmpaypihs18.rs:14:28\n   |\n14 |     s.chars().map(|c| if\
    \ c.is_alphabetic { c.to_uppercase() } else { c.to_lowercase() }).collect()\n\
    \   |                            ^^^^^^^^^^^^^ method, not a field\n   |\nhelp:\
    \ use parentheses to call the method\n   |\n14 |     s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_uppercase() } else { c.to_lowercase() }).collect()\n   |            \
    \                             ++\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmpaypihs18.rs:14:70\n   |\n14 |     s.chars().map(|c| if\
    \ c.is_alphabetic { c.to_uppercase() } else { c.to_lowercase() }).collect()\n\
    \   |                                            ----------------          ^^^^^^^^^^^^^^^^\
    \ expected struct `ToUppercase`, found struct `ToLowercase`\n   |            \
    \                                |\n   |                                     \
    \       expected because of this\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0615.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n\n    for &c in s.chars() {\n     \
    \   if c.is_letter() {\n            s.to_lowercase();\n        } else {\n    \
    \        s.to_uppercase();\n        }\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6ek33rr.rs:16:9\n   |\n\
    16 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    fn helper(mut s: String, ix: usize) -> String {\n \
    \       if ix < s.len() {\n            if s[i].is_ascii_lowercase() {\n      \
    \          s.swap(0, ix)\n            } else {\n                s.swap(ix, 0)\n\
    \            }\n            helper(s, ix + 1)\n        } else {\n            s\n\
    \        }\n    }\n    helper(s, 0)\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpjw5krf6r.rs:16:18\n\
    \   |\n16 |             if s[i].is_ascii_lowercase() {\n   |                 \
    \ ^ help: a local variable with a similar name exists: `ix`\n\nerror[E0599]: no\
    \ method named `swap` found for struct `String` in the current scope\n  --> /tmp/tmpjw5krf6r.rs:17:19\n\
    \   |\n17 |                 s.swap(0, ix)\n   |                   ^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `swap` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpjw5krf6r.rs:19:19\n   |\n19 | \
    \                s.swap(ix, 0)\n   |                   ^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().rev().collect::<String>(|s| s.chars().collect::<String>(|c|\
    \ if c.is_letter() {\n        String::from(rev(c)).to_string()\n    } else {\n\
    \        c.to_string()\n    }))\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rev` in this scope\n  --> /tmp/tmp7bbfvfph.rs:15:22\n\
    \   |\n15 |         String::from(rev(c)).to_string()\n   |                   \
    \   ^^^ not found in this scope\n\nerror[E0282]: type annotations needed\n  -->\
    \ /tmp/tmp7bbfvfph.rs:14:40\n   |\n14 |     s.chars().rev().collect::<String>(|s|\
    \ s.chars().collect::<String>(|c| if c.is_letter() {\n   |                   \
    \                     ^ consider giving this closure parameter a type\n   |\n\
    \   = note: type must be known at this point\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n    --> /tmp/tmp7bbfvfph.rs:14:21\n\
    \     |\n14   |       s.chars().rev().collect::<String>(|s| s.chars().collect::<String>(|c|\
    \ if c.is_letter() {\n     |  _____________________^^^^^^^___________-\n     |\
    \ |                     |\n     | |                     expected 0 arguments\n\
    15   | |         String::from(rev(c)).to_string()\n16   | |     } else {\n17 \
    \  | |         c.to_string()\n18   | |     }))\n     | |______- supplied 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0282, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut chars = s.chars();\n    let mut rev_chars =\
    \ chars.rev();\n\n    if chars.is_empty() {\n        rev_chars\n    } else {\n\
    \        for char in chars {\n            if char == chars.first().unwrap() {\n\
    \                chars.pop();\n                chars.next();\n            }\n\
    \        }\n        rev_chars.reverse();\n    }\n\n    if chars.is_empty() {\n\
    \        rev_chars\n    } else {\n        rev_chars.to_owned()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpcznzvxzk.rs:17:14\n   |\n17 |     if chars.is_empty()\
    \ {\n   |              ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcznzvxzk.rs:18:9\n   |\n17 | /     if chars.is_empty()\
    \ {\n18 | |         rev_chars\n   | |         ^^^^^^^^^ expected `()`, found struct\
    \ `Rev`\n19 | |     } else {\n20 | |         for char in chars {\n...  |\n26 |\
    \ |         rev_chars.reverse();\n27 | |     }\n   | |_____- expected this to\
    \ be `()`\n   |\n   = note: expected unit type `()`\n                 found struct\
    \ `Rev<Chars<'_>>`\n\nerror[E0599]: no method named `first` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpcznzvxzk.rs:21:30\n   |\n21 |          \
    \   if char == chars.first().unwrap() {\n   |                              ^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `pop` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmpcznzvxzk.rs:22:23\n \
    \  |\n22 |                 chars.pop();\n   |                       ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `Rev` in the current scope\n  --> /tmp/tmpcznzvxzk.rs:26:19\n   |\n26\
    \ |         rev_chars.reverse();\n   |                   ^^^^^^^ method not found\
    \ in `Rev<Chars<'_>>`\n\nerror[E0599]: no method named `is_empty` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpcznzvxzk.rs:29:14\n   |\n29 |  \
    \   if chars.is_empty() {\n   |              ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcznzvxzk.rs:30:9\n   |\n13 | fn\
    \ solve(s: String) -> String {\n   |                        ------ expected `String`\
    \ because of return type\n...\n30 |         rev_chars\n   |         ^^^^^^^^^\
    \ expected struct `String`, found struct `Rev`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Rev<Chars<'_>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcznzvxzk.rs:32:9\n   |\n13 | fn solve(s: String) -> String\
    \ {\n   |                        ------ expected "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve(s, \"\", \"\")\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmpi59828ay.rs:14:5\n   |\n14 |     solve(s, \"\", \"\")\n   |   \
    \  ^^^^^ -  --  -- supplied 3 arguments\n   |     |\n   |     expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpi59828ay.rs:13:4\n   |\n13 |\
    \ fn solve(s: String) -> String {\n   |    ^^^^^ ---------\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return s;\n    }\n    let\
    \ mut s1 = String::new();\n    let mut s2 = String::new();\n    let mut i = 1;\n\
    \    while i <= s.len() {\n        if s[0..i].chars().all(|c| is_letter(&c)) {\n\
    \            i += 1;\n        }\n        else {\n            i += 1;\n       \
    \     s[i] = s.chars().fold('', |c, i| if i > 0 { c } else { c + 'a' });\n   \
    \     }\n    }\n    s2.push_str(&s1);\n    s2\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmp_87zhwvg.rs:26:36\n   |\n\
    26 |             s[i] = s.chars().fold('', |c, i| if i > 0 { c } else { c + 'a'\
    \ });\n   |                                    ^ empty character literal\n\nerror[E0425]:\
    \ cannot find function `is_letter` in this scope\n  --> /tmp/tmp_87zhwvg.rs:21:36\n\
    \   |\n21 |         if s[0..i].chars().all(|c| is_letter(&c)) {\n   |        \
    \                            ^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_87zhwvg.rs:26:13\n\
    \   |\n26 |             s[i] = s.chars().fold('', |c, i| if i > 0 { c } else {\
    \ c + 'a' });\n   |             ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_87zhwvg.rs:26:53\n\
    \   |\n26 |             s[i] = s.chars().fold('', |c, i| if i > 0 { c } else {\
    \ c + 'a' });\n   |                                                     ^ expected\
    \ `char`, found `u8`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.to_string();\n    let mut index = 0;\n\
    \n    loop {\n        if let Some(pos) = s.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz\"\
    ) {\n            let c = s[pos];\n\n            if let Some(next) = s[pos + 1]\
    \ {\n                let c = c.to_uppercase();\n                let next = next.to_lowercase();\n\
    \                s = &s[..pos] + &c + &next;\n            } else {\n         \
    \       s = &s[..pos] + &c;\n            }\n\n            index += 1;\n      \
    \  } else {\n            break;\n        }\n    }\n\n    s\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_first_not_of` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpgmwc7s2_.rs:18:30\n   |\n18 |         if\
    \ let Some(pos) = s.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz\") {\n   |\
    \                              ^^^^^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgmwc7s2_.rs:19:21\n\
    \   |\n19 |             let c = s[pos];\n   |                     ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgmwc7s2_.rs:21:33\n   |\n21 |             if let Some(next) = s[pos\
    \ + 1] {\n   |                                 ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `&_` to `&str`\n  --> /tmp/tmpgmwc7s2_.rs:24:31\n\
    \   |\n24 |                 s = &s[..pos] + &c + &next;\n   |                \
    \     --------- ^ -- &_\n   |                     |\n   |                    \
    \ &str\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369, E0599.\nFor more information about an err"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.to_string();\n    let mut new_s = s;\n\
    \    let mut i = 0;\n\n    while i < s.len() {\n        if s.chars().next().is_none()\
    \ {\n            break;\n        }\n\n        if s.chars().next().unwrap().is_lowercase()\
    \ {\n            s.swap(i, i + 1);\n            i += 1;\n        } else if s.chars().next().unwrap().is_uppercase()\
    \ {\n            s.swap(i, i + 1);\n            i += 1;\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfvgyl4df.rs:24:15\n   |\n24 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `swap` found for struct `String` in the current scope\n  --> /tmp/tmpfvgyl4df.rs:27:15\n\
    \   |\n27 |             s.swap(i, i + 1);\n   |               ^^^^ method not\
    \ found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().any(|&x| x >= 'a' && x <= 'z') {\n   \
    \     String::from(s.chars().map(|&x| if x >= 'a' && x <= 'z' { x.to_ascii_lowercase()\
    \ } else { x.to_ascii_uppercase() }).collect::<String>())\n    } else {\n    \
    \    String::from(s.chars().cloned().reverse().collect::<String>())\n    }\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp69v3wco8.rs:14:23\n   |\n\
    14 |     if s.chars().any(|&x| x >= 'a' && x <= 'z') {\n   |                 \
    \      ^--\n   |                       ||\n   |                       |expected\
    \ due to this\n   |                       expected `char`, found reference\n \
    \  |                       help: did you mean `x`: `&char`\n   |\n   = note: \
    \  expected type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp69v3wco8.rs:15:37\n   |\n15 | ...   String::from(s.chars().map(|&x|\
    \ if x >= 'a' && x <= 'z' { x.to_ascii_lowercase() } else { x.to_ascii_uppercase()\
    \ }).collect::<Strin...\n   |                                   ^--\n   |    \
    \                               ||\n   |                                   |expected\
    \ due to this\n   |                                   expected `char`, found reference\n\
    \   |                                   help: did you mean `x`: `&char`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp69v3wco8.rs:17:32\n\
    \     |\n17   |         String::from(s.chars().cloned().reverse().collect::<String>())\n\
    \     |                                ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: no method named\
    \ `reverse` found for struct `Cloned` in the current scope\n  --> /tmp/tmp69v3wco8.rs:17:41\n\
    \   |\n17 |         String::from(s.chars().cloned().reverse().collect::<String>())\n\
    \   |                                         ^^^^^^^ method not found in `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().any(|&c| c.is_ascii_lowercase()) {\n \
    \       let mut r = s.to_ascii_lowercase();\n        for c in r.chars() {\n  \
    \          *c = match c.to_ascii_uppercase() {\n                Ok(c) => c,\n\
    \                Err(_) => c.to_ascii_lowercase()\n            }\n        }\n\
    \        r\n    } else {\n        s\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8rtjtkzm.rs:14:23\n   |\n\
    14 |     if s.chars().any(|&c| c.is_ascii_lowercase()) {\n   |               \
    \        ^--\n   |                       ||\n   |                       |expected\
    \ due to this\n   |                       expected `char`, found reference\n \
    \  |                       help: did you mean `c`: `&char`\n   |\n   = note: \
    \  expected type `char`\n           found reference `&_`\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp8rtjtkzm.rs:17:13\n   |\n17 | \
    \            *c = match c.to_ascii_uppercase() {\n   |             ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8rtjtkzm.rs:18:17\n   |\n17 |             *c\
    \ = match c.to_ascii_uppercase() {\n   |                        ----------------------\
    \ this expression has type `char`\n18 |                 Ok(c) => c,\n   |    \
    \             ^^^^^ expected `char`, found enum `Result`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Result<_, _>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8rtjtkzm.rs:19:17\n   |\n17 |             *c = match c.to_ascii_uppercase()\
    \ {\n   |                        ---------------------- this expression has type\
    \ `char`\n18 |                 Ok(c) => c,\n19 |                 Err(_) => c.to_ascii_lowercase()\n\
    \   |                 ^^^^^^ expected `char`, found enum `Result`\n   |\n   =\
    \ note: expected type `char`\n              found enum `Result<_, _>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut len = s.chars().count();\n\
    \    let mut i = 0;\n    while i < len {\n        if s.chars().nth(i).unwrap().is_lowercase()\
    \ {\n            // Reverse letters from lower to upper.\n            let mut\
    \ c = s.chars().nth(i).unwrap();\n            c.swap(c.len_utf8());\n        \
    \    s.push_str(&c);\n        }\n        else {\n            // Keep the same\
    \ letters.\n            i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n \
    \   let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpljds9h4c.rs:21:15\n   |\n21 |             c.swap(c.len_utf8());\n\
    \   |               ^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpljds9h4c.rs:22:24\n   |\n22 |             s.push_str(&c);\n\
    \   |                        ^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    if s.chars().any(|c|\
    \ c <= 'Z' || c >= 'a') {\n        for c in s.chars().cloned() {\n           \
    \ if c <= 'Z' || c >= 'a' {\n                s = s.chars().map(|c| if c <= 'Z'\
    \ then c + ('a' - 'A') else c + ('A' - 'a')).collect::<String>();\n          \
    \  }\n        }\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmp09d2tr5o.rs:18:51\n  \
    \ |\n18 |                 s = s.chars().map(|c| if c <= 'Z' then c + ('a' - 'A')\
    \ else c + ('A' - 'a')).collect::<String>();\n   |                           \
    \            --          ^^^^ expected `{`\n   |                             \
    \          |\n   |                                       this `if` expression\
    \ has a condition, but no block\n   |\nhelp: try placing this code inside a block\n\
    \   |\n18 |                 s = s.chars().map(|c| if c <= 'Z' { then } c + ('a'\
    \ - 'A') else c + ('A' - 'a')).collect::<String>();\n   |                    \
    \                               +      +\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp09d2tr5o.rs:16:28\n \
    \    |\n16   |         for c in s.chars().cloned() {\n     |                 \
    \           ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp09d2tr5o.rs:16:18\n   |\n16 |         for c in s.chars().cloned()\
    \ {\n   |                  ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp09d2tr5o.rs:16:18\n   |\n16 |     \
    \    for c in s.chars().cloned() {\n   |                  ^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found reference\n   |\n   = note:   expected type `char`\n         \
    \  found reference `&_`\n   = note: required because of the requirements on the\
    \ impl of `Iterator` for `Cloned<Chars<'_>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter_map(|&c| {\n        if c.is_digit()\
    \ {\n            Some(c.to_string())\n        } else {\n            Some(c.to_ascii_lowercase())\n\
    \        }\n    }).fold(String::from(\"\"), |mut acc, &c| {\n        if c.is_ascii_lowercase()\
    \ {\n            acc.to_ascii_uppercase()\n        } else if c.is_ascii_uppercase()\
    \ {\n            acc.to_ascii_lowercase()\n        } else {\n            acc\n\
    \        }\n    });\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ewv23ph.rs:14:27\n   |\n\
    14 |     s.chars().filter_map(|&c| {\n   |                           ^--\n   |\
    \                           ||\n   |                           |expected due to\
    \ this\n   |                           expected `char`, found reference\n   |\
    \                           help: did you mean `c`: `&char`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ewv23ph.rs:13:24\n   |\n13 | fn solve(s: String) -> String\
    \ {\n   |    -----               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n...\n28 |     });\n   |       - help: remove this semicolon\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    match s.chars().filter_map(|c| c >= 'a' && c <= 'z').cloned()\
    \ {\n        None => s.to_lowercase(),\n        Some(_) => s.to_uppercase(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6mswv4z5.rs:14:36\n   |\n\
    14 |     match s.chars().filter_map(|c| c >= 'a' && c <= 'z').cloned() {\n   |\
    \                                    ^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n14 |     match\
    \ s.chars().filter_map(|c| Some(c >= 'a' && c <= 'z')).cloned() {\n   |      \
    \                              +++++                    +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6mswv4z5.rs:15:9\n   |\n14 |     match s.chars().filter_map(|c|\
    \ c >= 'a' && c <= 'z').cloned() {\n   |           -------------------------------------------------------\n\
    \   |           |                    |\n   |           |                    the\
    \ expected closure\n   |           this expression has type `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp6mswv4z5.rs:14:32: 14:56]>>`\n15 |         None => s.to_lowercase(),\n\
    \   |         ^^^^ expected struct `Cloned`, found enum `Option`\n   |\n   = note:\
    \ expected struct `Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmp6mswv4z5.rs:14:32:\
    \ 14:56]>>`\n                found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6mswv4z5.rs:16:9\n   |\n14 |     match s.chars().filter_map(|c|\
    \ c >= 'a' && c <= 'z').cloned() {\n   |           -------------------------------------------------------\n\
    \   |           |                    |\n   |           |                    the\
    \ expected closure\n   |           this expression has type `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp6mswv4z5.rs:14:32: 14:56]>>`\n15 |         None => s.to_lowercase(),\n\
    16 |         Some(_) => s.to_uppercase(),\n   |         ^^^^^^^ expected struct\
    \ `Cloned`, found enum `Option`\n   |\n   = note: expected struct `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp6mswv4z5.rs:14:32: 14:56]>>`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.to_owned();\n    \n    while !s.is_empty()\
    \ {\n        let i = s.chars().count();\n        if let Some(c) = s.chars().skip(i-1).find(|c|\
    \ c == '#') {\n            if let Some(c2) = s.chars().skip(i-1).find(|c| c !=\
    \ '#') {\n                if let Some(c3) = s.chars().skip(i-1).find(|c| c !=\
    \ '#') {\n                    if let Some(c4) = s.chars().skip(i-1).find(|c| c\
    \ != '#') {\n                        if c == 'a' {\n                         \
    \   s = s.insert(i, String::from(\"A\"));\n                        } else if c\
    \ == 'B' {\n                            s = s.insert(i, String::from(\"b\"));\n\
    \                        } else if c == 'c' {\n                            s =\
    \ s.insert(i, String::from(\"C\"));\n                        } else if c == 'd'\
    \ {\n                            s = s.insert(i, String::from(\"D\"));\n     \
    \                   } else if c == 'E' {\n                            s = s.insert(i,\
    \ String::from(\"e\"));\n                        } else if c == 'F' {\n      \
    \                      s = s.insert(i, String::from(\"F\"));\n               \
    \         } else if c == 'G' {\n                            s = s.insert(i, String::from(\"\
    g\"));\n                        } else if c == 'h' {\n                       \
    \     s = s.insert(i, String::from(\"H\"));\n                        } else if\
    \ c == 'i' {\n                            s = s.insert(i, String::from(\"i\"));\n\
    \                        } else if c == 'j' {\n                            s =\
    \ s.insert(i, String::from(\"J\"));\n                        } else if c == 'k'\
    \ {\n                            s = s.insert(i, String::from(\"k\"));\n     \
    \                   } else if c == 'l' {\n                            s = s.insert(i,\
    \ String::from(\"L\"));\n                        } else if c == 'm' {\n      \
    \                      s = s.insert(i, String::from(\"m\"));\n               \
    \         } else if c == 'n' {\n                            s = s.insert(i, String::from(\"\
    n\"));\n                        } else if c == 'O' {\n                       \
    \     s = s.insert(i, String::from(\"O\"));\n                        } else if\
    \ c == 'p' {\n                            s = s.insert(i, String::from(\"p\"));\n\
    \                        } else if c == 'Q' {\n                            s =\
    \ s.insert(i, String::from(\"Q\"));\n                        } else if c == 'r'\
    \ {\n                            s = s.insert(i, String::from(\"R\"));\n     \
    \                   } else if c == 's' {\n                            s = s.insert(i,\
    \ String::from(\"S\"));\n                        } else if c == 't' {\n      \
    \                      s = s.insert(i, String::from(\"t\"));\n               \
    \         } else if c == 'u\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7u63y9f6.rs:75:3\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n16 |     while !s.is_empty() {\n   |          \
    \               - unclosed delimiter\n17 |         let i = s.chars().count();\n\
    18 |         if let Some(c) = s.chars().skip(i-1).find(|c| c == '#') {\n   | \
    \                                                                - unclosed delimiter\n\
    19 |             if let Some(c2) = s.chars().skip(i-1).find(|c| c != '#') {\n\
    \   |                                                                      - unclosed\
    \ delimiter\n20 |                 if let Some(c3) = s.chars().skip(i-1).find(|c|\
    \ c != '#') {\n   |                                                          \
    \                - unclosed delimiter\n21 |                     if let Some(c4)\
    \ = s.chars().skip(i-1).find(|c| c != '#') {\n   |                           \
    \                                                   - this delimiter might not\
    \ be properly closed...\n...\n63 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n75 | }\n   |   ^\n\nerror: expected `while`, `for`,\
    \ `loop` or `{` after a label\n  --> /tmp/tmp7u63y9f6.rs:63:1\n   |\n63 | }\n\
    \   | ^ expected `while`, `for`, `loop` or `{` after a label\n\nerror: expected\
    \ expression, found `}`\n  --> /tmp/tmp7u63y9f6.rs:63:1\n   |\n63 | }\n   | ^\
    \ expected expression\n\nerror[E0277]: can't compare `&char` with `char`\n  -->\
    \ /tmp/tmp7u63y9f6.rs:18:57\n   |\n18 |         if let Some(c) = s.chars().skip(i-1).find(|c|\
    \ c == '#') {\n   |                                                         ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7u63y9f6.rs:19:62\n\
    \   |\n19 |             if let Some(c2) = s.chars().skip(i-1).find(|c| c != '#')\
    \ {\n   |                                                              ^^ no implementation\
    \ for `&char ="
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::from(\"\");\n    for i in s.chars().cloned()\
    \ {\n        if let Some(k) = String::from(&i.to_uppercase()) {\n            res.push_str(k.clone());\n\
    \        } else {\n            res.push_str(i.clone());\n        }\n    }\n  \
    \  if res.chars().count() == 0 {\n        res.push_str(s.chars().cloned().reverse().collect());\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpvmwivc0b.rs:15:24\n     |\n15   |     for i in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpvmwivc0b.rs:15:14\n\
    \   |\n15 |     for i in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpvmwivc0b.rs:15:14\n   |\n15 |     for i in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvmwivc0b.rs:16:16\n   |\n16 |\
    \         if let Some(k) = String::from(&i.to_uppercase()) {\n   |           \
    \     ^^^^^^^   ------------------------------- this expression has type `String`\n\
    \   |                |\n   |                expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpvmwivc0b.rs:23:32\n     |\n23   |         res.push_str(s.chars().cloned().reverse().collect());\n\
    \     |                                ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: no method named"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve1(s)\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve1` in this scope\n  --> /tmp/tmpraorr_w9.rs:14:5\n\
    \   |\n14 |     solve1(s)\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut new_str = s;\n    let mut char = String::from(\"\
    \");\n    \n    for ch in new_str {\n        match char.chars().next().unwrap()\
    \ {\n            Some(first_letter) => {\n                match char.chars().next().unwrap()\
    \ {\n                    Some(second_letter) => {\n                        char\
    \ = char.to_lowercase() + second_letter + first_letter.to_uppercase();\n     \
    \               },\n                    None => char = char.to_lowercase() + first_letter,\n\
    \                }\n            },\n            None => char = char.to_lowercase()\
    \ + ch,\n        }\n    }\n    char\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpu37kgha6.rs:17:15\n\
    \   |\n17 |     for ch in new_str {\n   |               ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu37kgha6.rs:19:13\n   |\n18 |         match char.chars().next().unwrap()\
    \ {\n   |               ---------------------------- this expression has type\
    \ `char`\n19 |             Some(first_letter) => {\n   |             ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpu37kgha6.rs:27:13\n   |\n18 |         match char.chars().next().unwrap()\
    \ {\n   |               ---------------------------- this expression has type\
    \ `char`\n...\n27 |             None => char = char.to_lowercase() + ch,\n   |\
    \             ^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu37kgha6.rs:21:21\n   |\n20 |                 match char.chars().next().unwrap()\
    \ {\n   |                       ---------------------------- this expression has\
    \ type `char`\n21 |                     Some(second_letter) => {\n   |       \
    \              ^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n\
    \   = note: expected type `char`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu37kgha6.rs:24:21\n   |\n20 |              \
    \   match char.chars().next().unwrap() {\n   |                       ----------------------------\
    \ this expression has type `char`\n...\n24 |                     None => char\
    \ = char.to_lowercase() + first_letter,\n   |                     ^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<_>`\n\nerror: aborting due to 5 previous errors\n\n\
    Some e"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut len = 0;\n    while let\
    \ Some(letter) = s.chars().any() {\n        if let Some(upper) = if let Some(up)\
    \ = letter.toUpper() {\n            Some(len)\n        } else {\n            None\n\
    \        }{\n            len += 1;\n            s = &s[..upper];\n        } else\
    \ {\n            s = &s[..letter];\n        }\n    }\n    String::from(&s[..len])\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp6lbm3j6u.rs:16:40\n     |\n16   |     while let Some(letter)\
    \ = s.chars().any() {\n     |                                        ^^^- supplied\
    \ 0 arguments\n     |                                        |\n     |       \
    \                                 expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6lbm3j6u.rs:16:15\n\
    \   |\n16 |     while let Some(letter) = s.chars().any() {\n   |             \
    \  ^^^^^^^^^^^^   --------------- this expression has type `bool`\n   |      \
    \         |\n   |               expected `bool`, found enum `Option`\n   |\n \
    \  = note: expected type `bool`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6lbm3j6u.rs:23:17\n   |\n14 |     let mut s\
    \ = s;\n   |                 - expected due to this value\n...\n23 |         \
    \    s = &s[..upper];\n   |                 ^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n23 |        \
    \     s = (&s[..upper]).to_string();\n   |                 +           +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6lbm3j6u.rs:25:17\n   |\n14 |\
    \     let mut s = s;\n   |                 - expected due to this value\n...\n\
    25 |             s = &s[..letter];\n   |                 ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n25 |             s = (&s[..letter]).to_string();\n   |                 +\
    \            +++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().all(|c| *c == c) {\n        solve_recursive(s)\n\
    \    } else {\n        solve_recursive(s.to_lowercase().unwrap())\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve_recursive` in this scope\n  -->\
    \ /tmp/tmpia87b3ir.rs:15:9\n   |\n15 |         solve_recursive(s)\n   |      \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `solve_recursive` in this scope\n  --> /tmp/tmpia87b3ir.rs:17:9\n   |\n17 |\
    \         solve_recursive(s.to_lowercase().unwrap())\n   |         ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpia87b3ir.rs:14:26\n   |\n14 |     if s.chars().all(|c| *c == c)\
    \ {\n   |                          ^^\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpia87b3ir.rs:17:42\n\
    \   |\n17 |         solve_recursive(s.to_lowercase().unwrap())\n   |         \
    \                                 ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| match c {\n        'a' => { 'A' as\
    \ char },\n        'B' => { 'b' as char },\n        'C' => { 'c' as char },\n\
    \        'D' => { 'd' as char },\n        'E' => { 'e' as char },\n        'F'\
    \ => { 'f' as char },\n        'G' => { 'g' as char },\n        'H' => { 'h' as\
    \ char },\n        'I' => { 'i' as char },\n        'J' => { 'j' as char },\n\
    \        'K' => { 'k' as char },\n        'L' => { 'l' as char },\n        'M'\
    \ => { 'm' as char },\n        'N' => { 'n' as char },\n        'O' => { 'o' as\
    \ char },\n        'P' => { 'p' as char },\n        'Q' => { 'q' as char },\n\
    \        'R' => { 'r' as char },\n        'S' => { 's' as char },\n        'T'\
    \ => { 't' as char },\n        'U' => { 'u' as char },\n        'V' => { 'v' as\
    \ char },\n        'W' => { 'w' as char },\n        'X' => { 'x' as char },\n\
    \        'Y' => { 'y' as char },\n        'Z' => { 'z' as char },\n        '@'\
    \ => { '@' as char },\n        '#' => { '#' as char },\n        _ => c,\n    }).collect::<String>().to_owned()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Asdf\"`,\n right: `\"aSdF\"`', /tmp/tmp0k7s01ri.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s1 = String::from(s);\n    let mut s2 = String::from(s);\n\
    \    while s1.len() != 0 {\n        let c = s1.chars().next().unwrap();\n    \
    \    match c {\n            'a' => s1.replace_range(0,1,'A'),\n            'A'\
    \ => s1.replace_range(0,1,'a'),\n            'b' => s1.replace_range(0,1,'b'),\n\
    \            'B' => s1.replace_range(0,1,'b'),\n            'c' => s1.replace_range(0,1,'C'),\n\
    \            'C' => s1.replace_range(0,1,'c'),\n            'd' => s1.replace_range(0,1,'D'),\n\
    \            'D' => s1.replace_range(0,1,'d'),\n            'e' => s1.replace_range(0,1,'E'),\n\
    \            'E' => s1.replace_range(0,1,'e'),\n            'f' => s1.replace_range(0,1,'F'),\n\
    \            'F' => s1.replace_range(0,1,'f'),\n            'g' => s1.replace_range(0,1,'G'),\n\
    \            'G' => s1.replace_range(0,1,'g'),\n            'h' => s1.replace_range(0,1,'H'),\n\
    \            'H' => s1.replace_range(0,1,'h'),\n            'i' => s1.replace_range(0,1,'I'),\n\
    \            'I' => s1.replace_range(0,1,'i'),\n            'j' => s1.replace_range(0,1,'J'),\n\
    \            'J' => s1.replace_range(0,1,'j'),\n            'k' => s1.replace_range(0,1,'K'),\n\
    \            'K' => s1.replace_range(0,1,'k'),\n            'l' => s1.replace_range(0,1,'L'),\n\
    \            'L' => s1.replace_range(0,1,'l'),\n            'm' => s1.replace_range(0,1,'M'),\n\
    \            'M' => s1.replace_range(0,1,'m'),\n            'n' => s1.replace_range(0,1,'N'),\n\
    \            'N' => s1.replace_range(0,1,'n'),\n            'o' => s1.replace_range(0,1,'O'),\n\
    \            'O' => s1.replace_range(0,1,'o'),\n            'p' => s1.replace_range(0,1,'P'),\n\
    \            'P' => s1.replace_range(0,1,'p'),\n            'q' => s1.replace_range(0,1,'Q'),\n\
    \            'Q' => s1.replace_range(0,1,'q'),\n            'r' => s1.replace_range(0,1,'R'),\n\
    \            'R' => s1.replace_range(0,1,'r'),\n            's' => s1.replace_range(0,1,'S'),\n\
    \            'S' => s1.replace_range(0,1,'s'),\n            't' => s1.replace_range(0,1,'T'),\n\
    \            'T' => s1.replace_range(0,1,'t'),\n            'u' => s1.replace_range(0,1,'U'),\n\
    \            'U' => s1.replace_range(0,1,'u'),\n            'v' => s1.replace_range(0,1,'V'),\n\
    \            'V' => \n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpif0jxyv3.rs:75:3\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n16 |     while s1.len() != 0 {\n   |          \
    \               - unclosed delimiter\n17 |         let c = s1.chars().next().unwrap();\n\
    18 |         match c {\n   |                 - this delimiter might not be properly\
    \ closed...\n...\n63 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n75 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpif0jxyv3.rs:63:1\n\
    \   |\n62 |             'V' => \n   |                 -- while parsing the `match`\
    \ arm starting here\n63 | }\n   | ^ expected expression\n\nerror[E0061]: this\
    \ function takes 2 arguments but 3 arguments were supplied\n    --> /tmp/tmpif0jxyv3.rs:19:23\n\
    \     |\n19   |             'a' => s1.replace_range(0,1,'A'),\n     |        \
    \               ^^^^^^^^^^^^^ - - --- supplied 3 arguments\n     |           \
    \            |\n     |                       expected 2 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 2 arguments\
    \ but 3 arguments were supplied\n    --> /tmp/tmpif0jxyv3.rs:20:23\n     |\n20\
    \   |             'A' => s1.replace_range(0,1,'a'),\n     |                  \
    \     ^^^^^^^^^^^^^ - - --- supplied 3 arguments\n     |                     \
    \  |\n     |                       expected 2 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 2 arguments but 3\
    \ arguments were supplied\n    --> /tmp/tmpif0jxyv3.rs:21:23\n     |\n21   | \
    \            'b' => s1.replace_range(0,1,'b'),\n     |                       ^^^^^^^^^^^^^\
    \ - - --- supplied 3 arguments\n     |                       |\n     |       \
    \                expected 2 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \    --> /tmp/tmpif0jxyv3.rs:22:23\n     |\n22   |             'B' => s1.replace_range(0,1,'b'),\n\
    \     |                       ^^^^^^^^^^^^^ - - --- supplied 3 argume"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return s;\n    }\n    \n\
    \    let mut result = s.clone();\n    let mut char = s.chars();\n    let mut i\
    \ = 0;\n    while let Some(c)  = char.next() {\n        let c = c.to_ascii_lowercase();\n\
    \        if char == Some(c.into()) {\n            result += c;\n            i\
    \ += 1;\n        } else {\n            let c = c.to_ascii_uppercase();\n     \
    \       if char == Some(c.into()) {\n                result += c;\n          \
    \      i += 1;\n            } else {\n                result += c;\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Chars<'_>`\n\
    \  --> /tmp/tmp9ijctes9.rs:23:17\n   |\n23 |         if char == Some(c.into())\
    \ {\n   |            ---- ^^ -------------- Option<_>\n   |            |\n   |\
    \            Chars<'_>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ijctes9.rs:24:23\n\
    \   |\n24 |             result += c;\n   |                       ^ expected `&str`,\
    \ found `char`\n\nerror[E0369]: binary operation `==` cannot be applied to type\
    \ `Chars<'_>`\n  --> /tmp/tmp9ijctes9.rs:28:21\n   |\n28 |             if char\
    \ == Some(c.into()) {\n   |                ---- ^^ -------------- Option<_>\n\
    \   |                |\n   |                Chars<'_>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9ijctes9.rs:29:27\n   |\n29 |                 result +=\
    \ c;\n   |                           ^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9ijctes9.rs:32:27\n   |\n32 |              \
    \   result += c;\n   |                           ^ expected `&str`, found `char`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().any(|c| c.is_letter()) {\n        solve2(s)\n\
    \    } else {\n        solve1(s)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve2` in this scope\n  --> /tmp/tmpuf3j6idj.rs:15:9\n\
    \   |\n15 |         solve2(s)\n   |         ^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `solve1` in this scope\n  --> /tmp/tmpuf3j6idj.rs:17:9\n\
    \   |\n17 |         solve1(s)\n   |         ^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `is_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpuf3j6idj.rs:14:28\n   |\n14 |     if s.chars().any(|c|\
    \ c.is_letter()) {\n   |                            ^^^^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut iter = s.chars();\n    let mut rev: Vec<u8> = Vec::new();\n\
    \n    for ch in iter {\n        let mut ch = ch.to_lowercase();\n        if ch\
    \ >= 'a' && ch <= 'z' {\n            ch = ch - 'a' + 'A';\n        }\n       \
    \ rev.push(ch);\n    }\n\n    if rev.is_empty() {\n        return String::from(\"\
    \\0\");\n    }\n\n    String::from_utf8(rev).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `>=` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpequulh59.rs:23:15\n   |\n23 |         if ch >= 'a' && ch <= 'z'\
    \ {\n   |            -- ^^ --- char\n   |            |\n   |            ToLowercase\n\
    \nerror[E0369]: binary operation `<=` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpequulh59.rs:23:28\n   |\n23 |         if ch >= 'a' && ch <= 'z'\
    \ {\n   |                         -- ^^ --- char\n   |                       \
    \  |\n   |                         ToLowercase\n\nerror[E0369]: cannot subtract\
    \ `char` from `ToLowercase`\n  --> /tmp/tmpequulh59.rs:24:21\n   |\n24 |     \
    \        ch = ch - 'a' + 'A';\n   |                  -- ^ --- char\n   |     \
    \             |\n   |                  ToLowercase\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpequulh59.rs:26:18\n   |\n26 |         rev.push(ch);\n \
    \  |                  ^^ expected `u8`, found struct `ToLowercase`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().iter().map(|c| {\n        if c.is_alphanumeric()\
    \ {\n            if c.to_ascii_lowercase() != c.to_ascii_uppercase() {\n     \
    \           c.to_ascii_uppercase()\n            } else {\n                c.to_ascii_lowercase()\n\
    \            }\n        } else {\n            c\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpb6h033jt.rs:14:15\n   |\n14 |     s.chars().iter().map(|c|\
    \ {\n   |               ^^^^ private field, not a method\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    use std::collections::HashSet;\n\n    let mut set =\
    \ HashSet::new();\n    for c in s.chars() {\n        set.insert(c.to_lowercase());\n\
    \    }\n    \n    let mut res = String::new();\n    for c in s.chars() {\n   \
    \     if let Some(i) = set.remove(c) {\n            res.push(i);\n           \
    \ set.insert(c.to_uppercase());\n        } else {\n            res.push(c);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `ToLowercase: Eq` is not satisfied\n   -->\
    \ /tmp/tmpaz11193i.rs:18:20\n    |\n18  |         set.insert(c.to_lowercase());\n\
    \    |             ------ ^^^^^^^^^^^^^^^^ the trait `Eq` is not implemented for\
    \ `ToLowercase`\n    |             |\n    |             required by a bound introduced\
    \ by this call\n    |\nnote: required by a bound in `HashSet::<T, S>::insert`\n\
    \nerror[E0277]: the trait bound `ToLowercase: Hash` is not satisfied\n   --> /tmp/tmpaz11193i.rs:18:20\n\
    \    |\n18  |         set.insert(c.to_lowercase());\n    |             ------\
    \ ^^^^^^^^^^^^^^^^ the trait `Hash` is not implemented for `ToLowercase`\n   \
    \ |             |\n    |             required by a bound introduced by this call\n\
    \    |\nnote: required by a bound in `HashSet::<T, S>::insert`\n\nerror[E0599]:\
    \ the method `remove` exists for struct `HashSet<ToLowercase>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpaz11193i.rs:23:30\n    |\n23  |  \
    \       if let Some(i) = set.remove(c) {\n    |                              ^^^^^^\
    \ method cannot be called on `HashSet<ToLowercase>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `ToLowercase: Eq`\n            `ToLowercase: Hash`\n\nerror[E0599]: the method\
    \ `insert` exists for struct `HashSet<ToLowercase>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmpaz11193i.rs:25:17\n    |\n25  |             set.insert(c.to_uppercase());\n\
    \    |                 ^^^^^^\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `ToLowercase: Eq`\n            `ToLowercase: Hash`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.len() == 0 {\n        return String::from(\"\"\
    )\n    }\n    let mut s = String::from(s);\n    let mut i = 0;\n    while i <\
    \ s.len() {\n        if s[i].is_alpha() {\n            let mut i = i + 1;\n  \
    \          while i < s.len() && s[i].is_alpha() {\n                s[i] = s.swap(i,\
    \ i + 1).to_uppercase();\n                i += 1;\n            }\n        }\n\
    \        i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5dqa3lj_.rs:20:12\n\
    \   |\n20 |         if s[i].is_alpha() {\n   |            ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5dqa3lj_.rs:22:34\n   |\n22 |             while i < s.len() &&\
    \ s[i].is_alpha() {\n   |                                  ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp5dqa3lj_.rs:23:26\n   |\n23 |          \
    \       s[i] = s.swap(i, i + 1).to_uppercase();\n   |                        \
    \  ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp5dqa3lj_.rs:23:17\n   |\n23 |         \
    \        s[i] = s.swap(i, i + 1).to_uppercase();\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    helper(s.chars().collect::<Vec<char>>())\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `helper` in this scope\n  --> /tmp/tmpc4fk6cs7.rs:14:5\n\
    \   |\n14 |     helper(s.chars().collect::<Vec<char>>())\n   |     ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return s;\n    }\n    \n\
    \    for c in s.chars() {\n        match c {\n            c @ c => s,\n      \
    \      _ => s.chars().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().map(|c|\
    \ {\n                if c >= 'a' && c <= 'z' {\n                    c += 'A' -\
    \ 'a';\n                } else {\n                    c += 'a' - 'A';\n      \
    \          }\n                \n                if c >= 'A' && c <= 'Z' {\n  \
    \                  c += 'a' - 'A';\n                } else {\n               \
    \     c += 'A' - 'a';\n                }\n                \n                c\n\
    \            }).collect::<Vec<_>>().collect::<String>().cloned().collect::<String>()\n\
    \        }\n    }\n    \n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0416]: identifier `c` is bound more than once in the same pattern\n\
    \  --> /tmp/tmpdwo0fo1y.rs:20:17\n   |\n20 |             c @ c => s,\n   |   \
    \              ^ used in a pattern more than once\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdwo0fo1y.rs:22:25\n   |\n22 |                 if c >= 'a'\
    \ && c <= 'z' {\n   |                         ^^^\n   |                      \
    \   |\n   |                         expected `&char`, found `char`\n   |     \
    \                    help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdwo0fo1y.rs:22:37\n   |\n22 |                 if c >= 'a'\
    \ && c <= 'z' {\n   |                                     ^^^\n   |          \
    \                           |\n   |                                     expected\
    \ `&char`, found `char`\n   |                                     help: consider\
    \ borrowing here: `&'z'`\n\nerror[E0369]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmpdwo0fo1y.rs:23:30\n   |\n23 |                     c += 'A' - 'a';\n\
    \   |                          --- ^ --- char\n   |                          |\n\
    \   |                          char\n\nerror[E0369]: cannot subtract `char` from\
    \ `char`\n  --> /tmp/tmpdwo0fo1y.rs:25:30\n   |\n25 |                     c +=\
    \ 'a' - 'A';\n   |                          --- ^ --- char\n   |             \
    \             |\n   |                          char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdwo0fo1y.rs:28:25\n   |\n28 |                 if c >= 'A'\
    \ && c <= 'Z' {\n   |                         ^^^\n   |                      \
    \   |\n   |                         expected `&char`, found `char`\n   |     \
    \                    help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdwo0fo1y.rs:28:37\n   |\n28 |                 if c >= 'A'\
    \ && c <= 'Z' {\n   |                                     ^^^\n   |          \
    \                           |\n   |                                     expected\
    \ `&char`, found `char`\n   |                                     help: consider\
    \ borrowing here: `&'Z'`\n\nerror[E0369]: cannot subtract `char` from `char`"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter(|&c| c.is_letter()).collect::<String>().to_owned().chars().fold(&s,\
    \ |s, &c| {\n        if let Some(next) = s[s.len() - 1] {\n            if let\
    \ Some(prev) = s[s.len() - 2] {\n                s.insert(s.len() - 2, prev)\n\
    \            } else {\n                s.insert(s.len() - 2, c)\n            }\n\
    \        } else {\n            s.push(c)\n        }\n        s\n    })\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmptjx7e1xz.rs:14:29\n   |\n14 |     s.chars().filter(|&c|\
    \ c.is_letter()).collect::<String>().to_owned().chars().fold(&s, |s, &c| {\n \
    \  |                             ^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptjx7e1xz.rs:14:86\n   |\n14 |     s.chars().filter(|&c|\
    \ c.is_letter()).collect::<String>().to_owned().chars().fold(&s, |s, &c| {\n \
    \  |                                                                         \
    \             ^^ expected struct `String`, found `&String`\n   |\nhelp: consider\
    \ removing the borrow\n   |\n14 -     s.chars().filter(|&c| c.is_letter()).collect::<String>().to_owned().chars().fold(&s,\
    \ |s, &c| {\n14 +     s.chars().filter(|&c| c.is_letter()).collect::<String>().to_owned().chars().fold(s,\
    \ |s, &c| {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmptjx7e1xz.rs:14:94\n\
    \   |\n14 |     s.chars().filter(|&c| c.is_letter()).collect::<String>().to_owned().chars().fold(&s,\
    \ |s, &c| {\n   |                                                            \
    \                                  ^--\n   |                                 \
    \                                                             ||\n   |       \
    \                                                                            \
    \           |expected due to this\n   |                                      \
    \                                                        expected `char`, found\
    \ reference\n   |                                                            \
    \                                  help: did you mean `c`: `&char`\n   |\n   =\
    \ note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptjx7e1xz.rs:15:29\n\
    \   |\n15 |         if let Some(next) = s[s.len() - 1] {\n   |               \
    \              ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement tra"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve_recursive(s.chars(), 0, s.len())\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve_recursive` in this scope\n  -->\
    \ /tmp/tmpyy8rzkte.rs:14:5\n   |\n14 |     solve_recursive(s.chars(), 0, s.len())\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars()\n        .filter(|&c| is_valid_char(c))\n\
    \        .map(|&c| if is_valid_case(c) then c.to_upper() else c.to_lower()).collect()\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmpmtmzm_cs.rs:16:39\n  \
    \ |\n16 |         .map(|&c| if is_valid_case(c) then c.to_upper() else c.to_lower()).collect()\n\
    \   |                   --                  ^^^^ expected `{`\n   |          \
    \         |\n   |                   this `if` expression has a condition, but\
    \ no block\n   |\nhelp: try placing this code inside a block\n   |\n16 |     \
    \    .map(|&c| if is_valid_case(c) { then } c.to_upper() else c.to_lower()).collect()\n\
    \   |                                       +      +\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve0(s)\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve0` in this scope\n  --> /tmp/tmpycyqy1ch.rs:14:5\n\
    \   |\n14 |     solve0(s)\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve(\"\", s)\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmppaalcx60.rs:14:5\n   |\n14 |     solve(\"\", s)\n   |     ^^^^^\
    \ --  - supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\n\
    note: function defined here\n  --> /tmp/tmppaalcx60.rs:13:4\n   |\n13 | fn solve(s:\
    \ String) -> String {\n   |    ^^^^^ ---------\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().rev().collect::<String>().to_owned()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fDsA\"`,\n right: `\"aSdF\"`', /tmp/tmp6r44agwb.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut v = s.clone();\n    if v.chars().any(|c| c.is_lowercase())\
    \ {\n        v.chars().rev().for_each(|c| c.to_uppercase());\n    } else {\n \
    \       v.chars().for_each(|c| c.to_lowercase());\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnm5mswpy.rs:16:38\n   |\n\
    16 |         v.chars().rev().for_each(|c| c.to_uppercase());\n   |           \
    \                           ^^^^^^^^^^^^^^^^ expected `()`, found struct `ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnm5mswpy.rs:18:32\n   |\n18 |\
    \         v.chars().for_each(|c| c.to_lowercase());\n   |                    \
    \            ^^^^^^^^^^^^^^^^ expected `()`, found struct `ToLowercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    \n    for &i in s.chars() {\n \
    \       if i.is_uppercase() {\n            s = s.to_uppercase();\n        } else\
    \ {\n            s = s.to_lowercase();\n        }\n    }\n    \n    s\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzu0ph_4q.rs:16:9\n   |\n\
    16 |     for &i in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut rev_s = s.chars().fold(String::new(), |mut\
    \ acc, x| {\n        let c = match x {\n            'a' => acc.to_uppercase(),\n\
    \            'b' => acc.to_lowercase(),\n            _ => acc,\n        };\n \
    \       acc + &c.to_string()\n    });\n    let mut chars = s.chars();\n    chars.for_each(|x|\
    \ {\n        if !rev_s.contains(x) {\n            rev_s += x.to_string();\n  \
    \      }\n    });\n    rev_s\n}\n\nfn main() {\n    let candidate = solve;\n \
    \   assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n \
    \   assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n \
    \   assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvgdpp_u.rs:25:22\n   |\n\
    25 |             rev_s += x.to_string();\n   |                      ^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&x.to_string()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        String::from(s)\n    } else\
    \ {\n        if s.chars().any(|c| c.is_ascii_lowercase()) {\n            let mut\
    \ s = String::from(s);\n            s.chars().for_each(|c| {\n               \
    \ match c.to_ascii_lowercase() {\n                    Some(c) => c = char::Uppercase(c),\n\
    \                    None => c = char::Lowercase(c)\n                }\n     \
    \       })\n        }\n        s\n    }\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz_gyutuq.rs:21:21\n   |\n\
    20 |                 match c.to_ascii_lowercase() {\n   |                    \
    \   ---------------------- this expression has type `char`\n21 |             \
    \        Some(c) => c = char::Uppercase(c),\n   |                     ^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpz_gyutuq.rs:22:21\n   |\n20 |                 match c.to_ascii_lowercase()\
    \ {\n   |                       ---------------------- this expression has type\
    \ `char`\n21 |                     Some(c) => c = char::Uppercase(c),\n22 |  \
    \                   None => c = char::Lowercase(c)\n   |                     ^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0599]: no associated item named\
    \ `Uppercase` found for type `char` in the current scope\n  --> /tmp/tmpz_gyutuq.rs:21:42\n\
    \   |\n21 |                     Some(c) => c = char::Uppercase(c),\n   |     \
    \                                     ^^^^^^^^^\n   |                        \
    \                  |\n   |                                          associated\
    \ item not found in `char`\n   |                                          help:\
    \ there is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]:\
    \ no associated item named `Lowercase` found for type `char` in the current scope\n\
    \  --> /tmp/tmpz_gyutuq.rs:22:39\n   |\n22 |                     None => c = char::Lowercase(c)\n\
    \   |                                       ^^^^^^^^^\n   |                  \
    \                     |\n   |                                       associated\
    \ item not found in `char`\n   |                                       help: there\
    \ is an associated function with a similar name: `is_lowercase`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut a = s.chars();\n    let mut b = s.chars();\n\
    \    \n    loop {\n        match a.pop() {\n            None => break,\n     \
    \       Some(c) => {\n                if c.is_letter() {\n                   \
    \ b = b.map(|x| if x.is_letter() || x.is_digit() {x.to_ascii_lowercase()} else\
    \ x.to_ascii_uppercase());\n                } else {\n                    b =\
    \ b.map(|x| x.to_ascii_uppercase());\n                }\n            }\n     \
    \   }\n    }\n\n    String::from(a.iter().chain(b).collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `x`\n  --> /tmp/tmpa0r91mxi.rs:22:98\n   |\n\
    22 |                     b = b.map(|x| if x.is_letter() || x.is_digit() {x.to_ascii_lowercase()}\
    \ else x.to_ascii_uppercase());\n   |                                        \
    \                                                          ^ expected `{`\n  \
    \ |\nhelp: try placing this code inside a block\n   |\n22 |                  \
    \   b = b.map(|x| if x.is_letter() || x.is_digit() {x.to_ascii_lowercase()} else\
    \ { x.to_ascii_uppercase() });\n   |                                         \
    \                                                         +                  \
    \      +\n\nerror[E0599]: no method named `pop` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpa0r91mxi.rs:18:17\n   |\n18 |         match a.pop()\
    \ {\n   |                 ^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa0r91mxi.rs:24:25\n   |\n15 |     let mut b\
    \ = s.chars();\n   |                 --------- expected due to this value\n...\n\
    24 |                     b = b.map(|x| x.to_ascii_uppercase());\n   |        \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found\
    \ struct `Map`\n   |\n   = note: expected struct `Chars<'_>`\n              found\
    \ struct `Map<Chars<'_>, [closure@/tmp/tmpa0r91mxi.rs:24:31: 24:57]>`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpa0r91mxi.rs:30:20\n   |\n30 |     String::from(a.iter().chain(b).collect::<String>())\n\
    \   |                    ^^^^ private field, not a method\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut letters = String::new();\n\n    for c in s.chars()\
    \ {\n        if let Some(l) = (c as u8).to_ascii_lowercase() {\n            letters.push_str(l);\n\
    \        } else {\n            letters.push_str(c);\n        }\n    }\n\n    if\
    \ letters.len() == 0 {\n        solve(s)\n    } else {\n        letters\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5_wxazzz.rs:17:16\n   |\n\
    17 |         if let Some(l) = (c as u8).to_ascii_lowercase() {\n   |         \
    \       ^^^^^^^   ------------------------------ this expression has type `u8`\n\
    \   |                |\n   |                expected `u8`, found enum `Option`\n\
    \   |\n   = note: expected type `u8`\n              found enum `Option<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5_wxazzz.rs:20:30\n   |\n20 |  \
    \           letters.push_str(c);\n   |                              ^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return String::from(\"\"\
    );\n    }\n    let mut res = s.clone();\n    let mut low = res.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count();\n    let mut high = res.chars().filter(|x| x\
    \ >= 'A' && x <= 'Z').count();\n    if low == 0 {\n        let mut cur = res.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count();\n        res.swap(0, cur);\n    }\n    if high\
    \ == 0 {\n        let mut cur = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n\
    \        res.swap(0, cur);\n    }\n    while low > 0 || high > 0 {\n        let\
    \ mut swap = if high > low {\n            res.swap(0, low - 1);\n            res.swap(low,\
    \ high - 1);\n            low = res.chars().filter(|x| x >= 'a' && x <= 'z').count();\n\
    \            high = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n  \
    \      }\n        else {\n            res.swap(0, high - 1);\n            res.swap(low,\
    \ high - 1);\n            low = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n\
    \            high = res.chars().filter(|x| x >= 'a' && x <= 'z').count();\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaf0zvqe7.rs:40:10\n   |\n\
    40 |         }\n   |          ^ help: add `;` here\n41 |     }\n   |     - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaf0zvqe7.rs:18:47\n \
    \  |\n18 |     let mut low = res.chars().filter(|x| x >= 'a' && x <= 'z').count();\n\
    \   |                                               ^^^\n   |                \
    \                               |\n   |                                      \
    \         expected `&char`, found `char`\n   |                               \
    \                help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaf0zvqe7.rs:18:59\n   |\n18 |     let mut low = res.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count();\n   |                                       \
    \                    ^^^\n   |                                               \
    \            |\n   |                                                         \
    \  expected `&char`, found `char`\n   |                                      \
    \                     help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaf0zvqe7.rs:19:48\n   |\n19 |     let mut high = res.chars().filter(|x|\
    \ x >= 'A' && x <= 'Z').count();\n   |                                       \
    \         ^^^\n   |                                                |\n   |   \
    \                                             expected `&char`, found `char`\n\
    \   |                                                help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaf0zvqe7.rs:19:60\n\
    \   |\n19 |     let mut high = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n\
    \   |                                                            ^^^\n   |   \
    \                                                         |\n   |            \
    \                                                expected `&char`, found `char`\n\
    \   |                                                            help: consider\
    \ borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaf0zvqe7.rs:21:51\n\
    \   |\n21 |         let"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut input = s.to_string();\n    let mut output\
    \ = String::from(\"\");\n    let mut flag = false;\n    for i in 0..input.len()\
    \ {\n        let c = input[i];\n        match c {\n            'a' => {\n    \
    \            output.push_str(&c.to_lowercase());\n                flag = true;\n\
    \            },\n            'b' => {\n                output.push_str(&c.to_uppercase());\n\
    \                flag = true;\n            },\n            _ => {\n          \
    \      if flag {\n                    output.push_str(&c.to_lowercase());\n  \
    \              } else {\n                    output.push_str(&c.to_uppercase());\n\
    \                }\n                flag = false;\n            }\n        }\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwb3cuf9m.rs:18:17\n\
    \   |\n18 |         let c = input[i];\n   |                 ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwb3cuf9m.rs:21:33\n\
    \   |\n21 |                 output.push_str(&c.to_lowercase());\n   |        \
    \                         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwb3cuf9m.rs:25:33\n   |\n25 |\
    \                 output.push_str(&c.to_uppercase());\n   |                  \
    \               ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwb3cuf9m.rs:30:37\n   |\n30 |\
    \                     output.push_str(&c.to_lowercase());\n   |              \
    \                       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwb3cuf9m.rs:32:37\n   |\n32 |\
    \                     output.push_str(&c.to_uppercase());\n   |              \
    \                       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return String::from(\"\"\
    );\n    }\n\n    let mut i = 0;\n\n    let mut s = s.to_string();\n    while i\
    \ < s.len() {\n        let c = s[i..].chars().collect::<Vec<_>>()[0];\n\n    \
    \    // if character is a letter\n        if c.is_ascii() {\n            if c.is_lowercase()\
    \ {\n                s[i] = c.to_uppercase();\n            } else {\n        \
    \        s[i] = c.to_lowercase();\n            }\n        } else {\n         \
    \   s[i] = c;\n        }\n\n        i += 1;\n    }\n\n    String::from(s)\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpczt0yxc7.rs:27:17\n\
    \   |\n27 |                 s[i] = c.to_uppercase();\n   |                 ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpczt0yxc7.rs:29:17\n   |\n29 |                 s[i] = c.to_lowercase();\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpczt0yxc7.rs:32:13\n   |\n32 |             s[i] = c;\n   |     \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.len() == 0 {\n        String::from(\"A\")\n  \
    \  } else {\n        let mut result = s.to_string();\n        if let Some(first)\
    \ = result.chars().next() {\n            match first {\n                'A' =>\
    \ result.chars().chain(|c| c.to_ascii_lowercase()).collect::<String>().clone(),\n\
    \                'a' => result.chars().chain(|c| c.to_ascii_uppercase()).collect::<String>().clone(),\n\
    \                _ => result,\n            }\n        } else {\n            result\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpofcgr7sy.rs:20:46\n\
    \   |\n20 |                 'A' => result.chars().chain(|c| c.to_ascii_lowercase()).collect::<String>().clone(),\n\
    \   |                                              ^ consider giving this closure\
    \ parameter a type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut i = 0;\n    for c in s.chars()\
    \ {\n        let c: char = c; // unwrap the char\n        if c.is_ascii_letter()\
    \ {\n            s = s.to_string().to_lowercase().chars().collect::<String>().join(\"\
    \") + c.to_string();\n        } else if !c.is_ascii_letter() {\n            s\
    \ = s.to_string().to_lowercase().chars().collect::<String>().join(\"\") + c;\n\
    \        }\n        i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpjjeqbz3t.rs:18:14\n   |\n18 |         if c.is_ascii_letter()\
    \ {\n   |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0599]: no method named `join` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpjjeqbz3t.rs:19:74\n   |\n\
    19 |             s = s.to_string().to_lowercase().chars().collect::<String>().join(\"\
    \") + c.to_string();\n   |                                                   \
    \                       ^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpjjeqbz3t.rs:20:22\n   |\n20 |         } else if !c.is_ascii_letter()\
    \ {\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `join` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpjjeqbz3t.rs:21:74\n\
    \   |\n21 |             s = s.to_string().to_lowercase().chars().collect::<String>().join(\"\
    \") + c;\n   |                                                               \
    \           ^^^^ method not found in `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|&c| match c {\n        'a'...'z' =>\
    \ c,\n        'A'...'Z' => c,\n        '0'...'9' => c,\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmptsvta4b2.rs:15:12\n\
    \   |\n15 |         'a'...'z' => c,\n   |            ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmptsvta4b2.rs:16:12\n\
    \   |\n16 |         'A'...'Z' => c,\n   |            ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = warning: this is accepted in the current edition\
    \ (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmptsvta4b2.rs:17:12\n\
    \   |\n17 |         '0'...'9' => c,\n   |            ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = warning: this is accepted in the current edition\
    \ (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptsvta4b2.rs:14:20\n   |\n14 |\
    \     s.chars().map(|&c| match c {\n   |                    ^--\n   |        \
    \            ||\n   |                    |expected due to this\n   |         \
    \           expected `char`, found reference\n   |                    help: did\
    \ you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror: aborting due to previous error; 3 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    for _ in 0..s.len() {\n       \
    \ if s.chars().any(|c| c.is_uppercase()) {\n            s = s.to_lowercase().chars().collect::<String>().to_string()\
    \ + s;\n        } else {\n            s = s.to_uppercase().chars().collect::<String>().to_string()\
    \ + s;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgkym6png.rs:17:76\n   |\n\
    17 |             s = s.to_lowercase().chars().collect::<String>().to_string()\
    \ + s;\n   |                                                                 \
    \           ^\n   |                                                          \
    \                  |\n   |                                                   \
    \                         expected `&str`, found struct `String`\n   |       \
    \                                                                     help: consider\
    \ borrowing here: `&s`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgkym6png.rs:19:76\n\
    \   |\n19 |             s = s.to_uppercase().chars().collect::<String>().to_string()\
    \ + s;\n   |                                                                 \
    \           ^\n   |                                                          \
    \                  |\n   |                                                   \
    \                         expected `&str`, found struct `String`\n   |       \
    \                                                                     help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().iter().filter_map(|c| match c {\n       \
    \ 'a' => (c as u8) - 0x41, // 'a' is 0x41, 'A' is 0x41, '#' is 0x23, '@' is 0x40\n\
    \        'A' => (c as u8) - 0x41, // 'A' is 0x41, 'a' is 0x41, '#' is 0x23, '@'\
    \ is 0x40\n        '#' => (c as u8) - 0x23, // '#' is 0x23, 'a' is 0x41, 'A' is\
    \ 0x41, '@' is 0x40\n        '@' => (c as u8) - 0x40, // '@' is 0x40, 'a' is 0x41,\
    \ 'A' is 0x41, '#' is 0x23\n        _ => c,\n    }).collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp7iqotxoz.rs:14:15\n   |\n14 |     s.chars().iter().filter_map(|c|\
    \ match c {\n   |               ^^^^ private field, not a method\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmp7iqotxoz.rs:19:14\n   |\n\
    14 |       s.chars().iter().filter_map(|c| match c {\n   |  _____________________________________-\n\
    15 | |         'a' => (c as u8) - 0x41, // 'a' is 0x41, 'A' is 0x41, '#' is 0x23,\
    \ '@' is 0x40\n   | |                ---------------- this is found to be of type\
    \ `u8`\n16 | |         'A' => (c as u8) - 0x41, // 'A' is 0x41, 'a' is 0x41, '#'\
    \ is 0x23, '@' is 0x40\n   | |                ---------------- this is found to\
    \ be of type `u8`\n17 | |         '#' => (c as u8) - 0x23, // '#' is 0x23, 'a'\
    \ is 0x41, 'A' is 0x41, '@' is 0x40\n   | |                ---------------- this\
    \ is found to be of type `u8`\n18 | |         '@' => (c as u8) - 0x40, // '@'\
    \ is 0x40, 'a' is 0x41, 'A' is 0x41, '#' is 0x23\n   | |                ----------------\
    \ this is found to be of type `u8`\n19 | |         _ => c,\n   | |           \
    \   ^ expected `u8`, found `char`\n20 | |     }).collect::<String>()\n   | |_____-\
    \ `match` arms have incompatible types\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve1(s.chars().collect(), s)\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve1` in this scope\n  --> /tmp/tmpl5syrk0k.rs:14:5\n\
    \   |\n14 |     solve1(s.chars().collect(), s)\n   |     ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::from(\"\");\n    for c in s.chars()\
    \ {\n        let upper = match c {\n            c => c as u32,\n            _\
    \ => 0,\n        };\n        let lower = match c {\n            c => c as u32,\n\
    \            _ => 0,\n        };\n        let tmp = match upper < lower {\n  \
    \          true => upper,\n            false => lower,\n        };\n        res\
    \ = res.push_str(String::from_str(&tmp.to_string()));\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpmg7zb68y.rs:28:36\n   |\n\
    28 |         res = res.push_str(String::from_str(&tmp.to_string()));\n   |   \
    \                                 ^^^^^^^^ function or associated item not found\
    \ in `String`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmg7zb68y.rs:28:15\n   |\n14 |     let mut res\
    \ = String::from(\"\");\n   |                   ---------------- expected due\
    \ to this value\n...\n28 |         res = res.push_str(String::from_str(&tmp.to_string()));\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmpmg7zb68y.rs:28:19\n   |\n28 |         res = res.push_str(String::from_str(&tmp.to_string()));\n\
    \   |               --- ^^^^^^^^ this call modifies `res` in-place\n   |     \
    \          |\n   |               you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().any(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\
    \ {\n        s.chars().collect().reverse()\n            .collect::<String>() +\
    \ s.chars().collect().collect();\n    } else {\n        s\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpcyo3iz3z.rs:15:19\n\
    \   |\n15 |         s.chars().collect().reverse()\n   |                   ^^^^^^^\
    \ cannot infer type for type parameter `B` declared on the associated function\
    \ `collect`\n   |\n   = note: type must be known at this point\nhelp: consider\
    \ specifying the type argument in the method call\n   |\n15 |         s.chars().collect::<B>().reverse()\n\
    \   |                          +++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcyo3iz3z.rs:14:76\n   |\n14 |       if s.chars().any(|c| c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase()) {\n   |  ____________________________________________________________________________^\n\
    15 | |         s.chars().collect().reverse()\n16 | |             .collect::<String>()\
    \ + s.chars().collect().collect();\n17 | |     } else {\n   | |_____^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0282, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars()\n        .map(|c|{\n            match c {\n\
    \                'a' => 'A',\n                'b' => 'B',\n                'c'\
    \ => 'C',\n                'd' => 'D',\n                'e' => 'E',\n        \
    \        'f' => 'F',\n                'g' => 'G',\n                'h' => 'H',\n\
    \                'i' => 'I',\n                'j' => 'J',\n                'k'\
    \ => 'K',\n                'l' => 'L',\n                'm' => 'M',\n        \
    \        'n' => 'N',\n                'o' => 'O',\n                'p' => 'P',\n\
    \                'q' => 'Q',\n                'r' => 'R',\n                's'\
    \ => 'S',\n                't' => 'T',\n                'u' => 'U',\n        \
    \        'v' => 'V',\n                'w' => 'W',\n                'x' => 'X',\n\
    \                'y' => 'Y',\n                'z' => 'Z',\n                _ =>\
    \ c,\n            }\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpro5_5qtj.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve_recursive(s.chars().cloned().collect())\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve_recursive` in this scope\n  -->\
    \ /tmp/tmpxt823jmf.rs:14:5\n   |\n14 |     solve_recursive(s.chars().cloned().collect())\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpxt823jmf.rs:14:31\n\
    \     |\n14   |     solve_recursive(s.chars().cloned().collect())\n     |    \
    \                           ^^^^^^ expected reference, found `char`\n     |\n\
    \     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpxt823jmf.rs:14:40\n   |\n14 |       solve_recursive(s.chars().cloned().collect())\n\
    \   |                                          ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        \"\"\n    } else {\n   \
    \     let mut s = s;\n        for c in s.chars() {\n            match c {\n  \
    \              'a' => {\n                    s = s.to_string().replace(\"A\".to_string(),\
    \ \"a\".to_string()).replace(\"a\".to_string(), \"A\".to_string());\n        \
    \        }\n                'b' => {\n                    s = s.to_string().replace(\"\
    B\".to_string(), \"b\".to_string()).replace(\"b\".to_string(), \"B\".to_string());\n\
    \                }\n                'c' => {\n                    s = s.to_string().replace(\"\
    C\".to_string(), \"c\".to_string()).replace(\"c\".to_string(), \"C\".to_string());\n\
    \                }\n                'd' => {\n                    s = s.to_string().replace(\"\
    D\".to_string(), \"d\".to_string()).replace(\"d\".to_string(), \"D\".to_string());\n\
    \                }\n                'e' => {\n                    s = s.to_string().replace(\"\
    E\".to_string(), \"e\".to_string()).replace(\"e\".to_string(), \"E\".to_string());\n\
    \                }\n                'f' => {\n                    s = s.to_string().replace(\"\
    F\".to_string(), \"f\".to_string()).replace(\"f\".to_string(), \"F\".to_string());\n\
    \                }\n                'g' => {\n                    s = s.to_string().replace(\"\
    G\".to_string(), \"g\".to_string()).replace(\"g\".to_string(), \"G\".to_string());\n\
    \                }\n                'h' => {\n                    s = s.to_string().replace(\"\
    H\".to_string(), \"h\".to_string()).replace(\"h\".to_string(), \"H\".to_string());\n\
    \                }\n                'i' => {\n                    s = s.to_string().replace(\"\
    I\".to_string(), \"i\".to_string()).replace(\"i\".to_string(), \"I\".to_string());\n\
    \                }\n                'j' => {\n                    s = s.to_string().replace(\"\
    J\".to_string(), \"j\".to_string()).replace(\"j\".to_string(), \"J\".to_string());\n\
    \                }\n                'k' => {\n                    s = s.to_string().replace(\"\
    K\".to_string(), \"k\".to_string()).replace(\"k\".to_string(), \"K\".to_string());\n\
    \                }\n                'l' => {\n                    s = s.to_string().replace(\"\
    L\".to_string(), \"l\".to_string()).replace(\"l\".to_string(), \"L\".to_string());\n\
    \                }\n                'm' => {\n                    s = s.to_string().replace(\"\
    M\".to_string(), \"m\".to_string()).replace(\"m\".to_string(), \"M\".to_string());\n\
    \                }\n                'n' => {\n                    s = s.to_string().replace(\"\
    N\".to_string(), \"n\".to_string()).replace(\"n\".to_string(), \"N\".to_string());\n\
    \                }\n                'o' => {\n                    s = s.to_string().replace(\"\
    O\".to_string(), \"o\".to_string()).replace(\"o\".to_string(), \"O\".to_string());\n\
    \                }\n                'p' => {\n                    s = s.to_string().replace(\"\
    P\".to_string(), \"p\".to_string()).\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzcpjb2l2.rs:79:3\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n16 |     } else {\n   |            - unclosed delimiter\n\
    17 |         let mut s = s;\n18 |         for c in s.chars() {\n   |         \
    \                   - unclosed delimiter\n19 |             match c {\n   |   \
    \                  - unclosed delimiter\n...\n65 |                 'p' => {\n\
    \   |                        - this delimiter might not be properly closed...\n\
    66 |                     s = s.to_string().replace(\"P\".to_string(), \"p\".to_string()).\n\
    67 | }\n   | - ...as it matches this but it has different indentation\n...\n79\
    \ | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpzcpjb2l2.rs:67:1\n\
    \   |\n67 | }\n   | ^\n\nerror: expected identifier, found keyword `fn`\n  -->\
    \ /tmp/tmpzcpjb2l2.rs:69:1\n   |\n69 | fn main() {\n   | ^^ expected identifier,\
    \ found keyword\n\nerror: expected one of `=>`, `@`, `if`, or `|`, found `main`\n\
    \  --> /tmp/tmpzcpjb2l2.rs:69:4\n   |\n69 | fn main() {\n   |    ^^^^ expected\
    \ one of `=>`, `@`, `if`, or `|`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzcpjb2l2.rs:15:9\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                        ------\
    \ expected `String` because of return type\n14 |     if s.is_empty() {\n15 | \
    \        \"\"\n   |         ^^- help: try using a conversion method: `.to_string()`\n\
    \   |         |\n   |         expected struct `String`, found `&str`\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `String`\n   --> /tmp/tmpzcpjb2l2.rs:21:39\n\
    \    |\n21  |                     s = s.to_string().replace(\"A\".to_string(),\
    \ \"a\".to_string()).replace(\"a\".to_string(), \"A\".to_string());\n    |   \
    \                                    ^^^^^^^ expected an `FnMut<(char,)>` closure,\
    \ found `String`\n    |\n    = help: the trait `FnMut<(char,)>` is not implemented\
    \ for `String`\n    = help: the following other types implement trait `Pattern<'a>`:\n\
    \              &'b String\n              &'b str\n              &'c &'b str\n\
    \    = note: required becaus"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = s.clone();\n    for i in res.chars()\
    \ {\n        if i.is_alphabetic() {\n            res.swap(i, i.to_uppercase());\n\
    \        } else {\n            res.swap(i, i.to_lowercase());\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp51nbdpg7.rs:17:17\n   |\n17 |             res.swap(i, i.to_uppercase());\n\
    \   |                 ^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `swap` found for struct `String` in the current scope\n  --> /tmp/tmp51nbdpg7.rs:19:17\n\
    \   |\n19 |             res.swap(i, i.to_lowercase());\n   |                 ^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    let mut reverse = s.to_string();\n    let mut\
    \ first_char = s.chars().take(1).unwrap();\n    let mut is_first_char = true;\n\
    \n    for c in reverse.chars() {\n        if !is_first_char {\n            reverse\
    \ = reverse + c.to_uppercase();\n        } else {\n            reverse = reverse\
    \ + c.to_lowercase();\n        }\n        is_first_char = !is_first_char;\n  \
    \  }\n    String::from(reverse)\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmpzvjtt6ow.rs:16:44\n   |\n16 |     let mut\
    \ first_char = s.chars().take(1).unwrap();\n   |                             \
    \               ^^^^^^ method not found in `std::iter::Take<Chars<'_>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzvjtt6ow.rs:21:33\n   |\n21 |             reverse\
    \ = reverse + c.to_uppercase();\n   |                                 ^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `ToUppercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzvjtt6ow.rs:23:33\n   |\n23 |             reverse = reverse + c.to_lowercase();\n\
    \   |                                 ^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ struct `ToLowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    let mut result = s.clone();\n    let mut i =\
    \ 1;\n    let mut j = s.len();\n    \n    while j > 0 {\n        while i < j {\n\
    \            \n            let char1 = s.chars().nth(i).unwrap();\n          \
    \  let char2 = s.chars().nth(i + 1).unwrap();\n            \n            if char1.is_upper()\
    \ {\n                if char2.is_lower() {\n                    let temp = char1;\n\
    \                    char1 = char2;\n                    char2 = temp;\n     \
    \           }\n                \n                i = i + 2;\n            } else\
    \ if char1.is_lower() {\n                if char2.is_upper() {\n             \
    \       let temp = char1;\n                    char1 = char2;\n              \
    \      char2 = temp;\n                }\n                \n                j =\
    \ j - 2;\n            } else {\n                i = i + 1;\n                j\
    \ = j - 1;\n            }\n        }\n        \n        i = 1;\n        j = s.len();\n\
    \    }\n    \n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpxddtmlxb.rs:25:22\n   |\n25 |             if char1.is_upper()\
    \ {\n   |                      ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `is_lower`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpxddtmlxb.rs:26:26\n\
    \   |\n26 |                 if char2.is_lower() {\n   |                      \
    \    ^^^^^^^^ help: there is an associated function with a similar name: `is_lowercase`\n\
    \nerror[E0599]: no method named `is_lower` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpxddtmlxb.rs:33:29\n   |\n33 |             } else if char1.is_lower()\
    \ {\n   |                             ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_lowercase`\n\nerror[E0599]: no method named `is_upper`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpxddtmlxb.rs:34:26\n\
    \   |\n34 |                 if char2.is_upper() {\n   |                      \
    \    ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = s.to_string();\n    for ch in s.chars()\
    \ {\n        match ch {\n            'A' as char => {\n                let chr\
    \ = ch.to_lowercase();\n                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_uppercase());\n\
    \            }\n            'a' as char => {\n                let chr = ch.to_uppercase();\n\
    \                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_lowercase());\n\
    \            }\n            '0' as char => {\n                let chr = ch.to_lowercase();\n\
    \                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_uppercase());\n\
    \            }\n            '1' as char => {\n                let chr = ch.to_uppercase();\n\
    \                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_lowercase());\n\
    \            }\n            _ => {\n                result.chars().skip(1).for_each(|c|\
    \ c.to_string());\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpqqzb8hqv.rs:17:17\n   |\n17 |             'A' as char =>\
    \ {\n   |                 ^^ expected one of `...`, `..=`, `..`, `=>`, `if`, or\
    \ `|`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    let mut chars = s.chars().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < chars.len() {\n        if chars[i].is_alphabetic()\
    \ {\n            if i > 0 {\n                chars[i - 1] = chars[i]\n       \
    \     }\n            chars[i] = chars[i].to_upper();\n        } else {\n     \
    \       chars[i] = chars[i].to_lower();\n        }\n        i += 1;\n    }\n \
    \   chars.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwnh8j51p.rs:22:33\n   |\n22 |             chars[i] = chars[i].to_upper();\n\
    \   |                                 ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpwnh8j51p.rs:24:33\n\
    \   |\n24 |             chars[i] = chars[i].to_lower();\n   |                \
    \                 ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    fn to_lower(c: char) -> char {\n        c.to_lowercase()\n\
    \    }\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if let Some(index) = s.find('a', i).ok() {\n            s[i] = to_lower(s[index]);\n\
    \            i += 1;\n        }\n        i += 1;\n    }\n    if s.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n        s.replace(s.chars().map(|c| to_lower(c)).collect::<String>(),\
    \ String::from(\"\"))\n    }\n    else {\n        s\n    }\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp7n1oba_y.rs:20:32\n     |\n20   |         if let Some(index)\
    \ = s.find('a', i).ok() {\n     |                                ^^^^ ---  - supplied\
    \ 2 arguments\n     |                                |\n     |               \
    \                 expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp7n1oba_y.rs:20:45\n   |\n20 |         if let Some(index)\
    \ = s.find('a', i).ok() {\n   |                                             ^^\
    \ help: there is an associated function with a similar name: `or`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7n1oba_y.rs:21:13\n\
    \   |\n21 |             s[i] = to_lower(s[index]);\n   |             ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `is_ascii_letter` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp7n1oba_y.rs:26:29\n   |\n26 |   \
    \  if s.chars().any(|c| !c.is_ascii_letter()) {\n   |                        \
    \     ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \   --> /tmp/tmp7n1oba_y.rs:27:11\n    |\n27  |         s.replace(s.chars().map(|c|\
    \ to_lower(c)).collect::<String>(), String::from(\"\"))\n    |           ^^^^^^^\
    \ expected an `FnMut<(char,)>` closure, found `String`\n    |\n    = help: the\
    \ trait `FnMut<(char,)>` is not implemented for `String`\n    = help: the following\
    \ other type"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    match s.chars() {\n        char::is_letter => {\n \
    \           let mut new = s.clone();\n            new.chars().for_each(|c| {\n\
    \                if c.is_lowercase() {\n                    new.swap(c, c.toupper());\n\
    \                } else {\n                    new.swap(c, c.tolowercase());\n\
    \                }\n            });\n            new\n        }\n        _ =>\
    \ s,\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `is_letter` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpfjm8wsur.rs:15:15\n   |\n15\
    \ |         char::is_letter => {\n   |               ^^^^^^^^^ function or associated\
    \ item not found in `char`\n\nerror[E0599]: no method named `swap` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpfjm8wsur.rs:19:25\n   |\n19 | \
    \                    new.swap(c, c.toupper());\n   |                         ^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `toupper` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpfjm8wsur.rs:19:35\n   |\n\
    19 |                     new.swap(c, c.toupper());\n   |                     \
    \              ^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_uppercase`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpfjm8wsur.rs:21:25\n   |\n21 |          \
    \           new.swap(c, c.tolowercase());\n   |                         ^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `tolowercase` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpfjm8wsur.rs:21:35\n   |\n21\
    \ |                     new.swap(c, c.tolowercase());\n   |                  \
    \                 ^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if !s.chars().any(|c| c.is_ascii_lowercase()) {\n \
    \       solve(s.chars().map(|c| c.to_ascii_lowercase()).collect::<String>().reverse())\n\
    \    } else {\n        solve(s.chars().map(|c| if c.is_ascii_uppercase() then\
    \ c.to_ascii_uppercase() else c).collect::<String>().reverse())\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmpbcwke8ul.rs:17:59\n  \
    \ |\n17 |         solve(s.chars().map(|c| if c.is_ascii_uppercase() then c.to_ascii_uppercase()\
    \ else c).collect::<String>().reverse())\n   |                               \
    \  --                        ^^^^ expected `{`\n   |                         \
    \        |\n   |                                 this `if` expression has a condition,\
    \ but no block\n   |\nhelp: try placing this code inside a block\n   |\n17 | \
    \        solve(s.chars().map(|c| if c.is_ascii_uppercase() { then } c.to_ascii_uppercase()\
    \ else c).collect::<String>().reverse())\n   |                               \
    \                            +      +\n\nerror: expected one of `.`, `;`, `?`,\
    \ `}`, or an operator, found `)`\n  --> /tmp/tmpbcwke8ul.rs:17:124\n   |\n17 |\
    \         solve(s.chars().map(|c| if c.is_ascii_uppercase() then c.to_ascii_uppercase()\
    \ else c).collect::<String>().reverse())\n   |                               \
    \                                                                            \
    \                 ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpbcwke8ul.rs:15:77\n   |\n15 |         solve(s.chars().map(|c| c.to_ascii_lowercase()).collect::<String>().reverse())\n\
    \   |                                                                        \
    \     ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut str = String::new();\n    for &c in s.chars()\
    \ {\n        let c = c.to_string();\n        if c.is_letter() {\n            str.push_str(c.to_uppercase());\n\
    \        } else {\n            str.push_str(c.to_lowercase());\n        }\n  \
    \  }\n    str\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmwp50hvy.rs:15:9\n   |\n\
    15 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return s\n    }\n    \n\
    \    let mut result = String::from(\"\");\n    \n    let mut i = 1;\n    \n  \
    \  for c in s.chars() {\n        if c.is_uppercase() {\n            result.append(c.to_lowercase());\n\
    \        } else {\n            result.append(c.to_uppercase());\n        }\n \
    \       \n        i += 1;\n    }\n    \n    result.reverse_from_beginning();\n\
    \    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp617sjd1n.rs:24:20\n   |\n24 |             result.append(c.to_lowercase());\n\
    \   |                    ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp617sjd1n.rs:26:20\n   |\n26 |             result.append(c.to_uppercase());\n\
    \   |                    ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `reverse_from_beginning` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp617sjd1n.rs:32:12\n   |\n32 |     result.reverse_from_beginning();\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res: String = \"\".to_string();\n    for c\
    \ in s.chars() {\n        if c.is_lowercase() {\n            res.insert(0, c.to_uppercase());\n\
    \        } else {\n            res.insert(0, c.to_lowercase());\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy21fj0m3.rs:17:27\n   |\n\
    17 |             res.insert(0, c.to_uppercase());\n   |                      \
    \     ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy21fj0m3.rs:19:27\n   |\n19 |             res.insert(0,\
    \ c.to_lowercase());\n   |                           ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `ToLowercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter(|c| !c.is_ascii_uppercase())\n   \
    \     .map(|c| if c.is_ascii_lowercase() {\n            c.to_ascii_uppercase().to_string()\n\
    \        } else {\n            c.to_ascii_lowercase().to_string()\n        })\n\
    \        .collect::<Vec<_>>()\n        .join(\"\").to_string()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"SF\"`,\n right: `\"aSdF\"`', /tmp/tmp19730t_1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| {\n        if c.is_ascii() {\n  \
    \          if c.to_ascii_uppercase() == c {\n                c.to_ascii_lowercase()\n\
    \            } else {\n                c.to_ascii_uppercase()\n            }\n\
    \        } else {\n            c\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpad0n01ao.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    String::from(s.chars().collect::<Vec<_>>().iter().rev().collect())\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpw_njqptn.rs:14:5\n\
    \   |\n14 |     String::from(s.chars().collect::<Vec<_>>().iter().rev().collect())\n\
    \   |     ^^^^^^^^^^^^ cannot infer type for type parameter `T` declared on the\
    \ trait `From`\n   |\n   = note: multiple `impl`s satisfying `String: From<_>`\
    \ found in the following crates: `alloc`, `core`:\n           - impl From<Box<str>>\
    \ for String;\n           - impl From<char> for String;\n           - impl<'a>\
    \ From<Cow<'a, str>> for String;\n           - impl<> From<&String> for String;\n\
    \           and 3 more\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n14 |     String::from(s.chars().collect::<Vec<_>>().iter().rev().collect::<B>())\n\
    \   |                                                                    +++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0283`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().all(|c| c.is_ascii_letter()) {\n     \
    \   let mut newstring = \"\";\n        for char in s {\n            if char >=\
    \ 'A' && char <= 'Z' {\n                let new_value = char.to_string().to_ascii_uppercase();\n\
    \                newstring.push_str(&new_value);\n            } else {\n     \
    \           newstring.push_str(&char.to_ascii_lowercase());\n            }\n \
    \       }\n        return newstring;\n    }\n    return s.chars().fold(s, |s,\
    \ c| s + c.to_ascii_lowercase());\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmphph5mr5r.rs:14:28\n   |\n14 |     if s.chars().all(|c|\
    \ c.is_ascii_letter()) {\n   |                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmphph5mr5r.rs:16:21\n   |\n16 |   \
    \      for char in s {\n   |                     ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no method named\
    \ `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmphph5mr5r.rs:19:27\n\
    \   |\n19 |                 newstring.push_str(&new_value);\n   |            \
    \               ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method\
    \ named `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmphph5mr5r.rs:21:27\n\
    \   |\n21 |                 newstring.push_str(&char.to_ascii_lowercase());\n\
    \   |                           ^^^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphph5mr5r.rs:24:16\n   |\n13 | fn solve(s: String)\
    \ -> String {\n   |                        ------ expected `String` because of\
    \ return type\n...\n24 |         return newstring;\n   |                ^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                |\n\
    \   |                expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphph5mr5r.rs:26:41\n   |\n26 |     return s.chars().fold(s,\
    \ |s, c| s + c.to_ascii_lowercase());\n   |                                  \
    \       ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    if s.chars().any(|c|\
    \ c.is_ascii()) {\n        s.append(s.chars().map(|c| match c {\n            c\
    \ if c.is_ascii() => c.to_ascii_lowercase(),\n            c if c.is_ascii() =>\
    \ c.to_ascii_uppercase(),\n            _ => c,\n        }).collect());\n    }\
    \ else {\n        s.append(s);\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp67_h5g_p.rs:16:11\n   |\n16 |         s.append(s.chars().map(|c|\
    \ match c {\n   |           ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp67_h5g_p.rs:22:11\n   |\n22 |         s.append(s);\n   |           ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    let mut res = s.clone();\n    \n    for &ch in\
    \ s.chars() {\n        let mut cased_ch = ch.to_lowercase();\n        \n     \
    \   if cased_ch == ch {\n            res = res.chars().filter(|c| c != ch).collect();\n\
    \        }\n        else if cased_ch == ch.to_uppercase() {\n            res =\
    \ res.chars().filter(|c| c != ch).collect();\n            res = res.chars().map(|c|\
    \ c.to_uppercase()).collect();\n        }\n        else {\n            res = res.chars().filter(|c|\
    \ c != ch).collect();\n            res = res.chars().map(|c| c.to_lowercase()).collect();\n\
    \        }\n    }\n    \n    return res\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuhsshrdu.rs:17:9\n   |\n\
    17 |     for &ch in s.chars() {\n   |         ^^^    --------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `ch`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: a value of type `String` cannot be built from an iterator over elements\
    \ of type `ToUppercase`\n    --> /tmp/tmpuhsshrdu.rs:25:57\n     |\n25   |   \
    \          res = res.chars().map(|c| c.to_uppercase()).collect();\n     |    \
    \                                                     ^^^^^^^ value of type `String`\
    \ cannot be built from `std::iter::Iterator<Item=ToUppercase>`\n     |\n     =\
    \ help: the trait `FromIterator<ToUppercase>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0277]: a value of type `String` cannot be built from an iterator over\
    \ elements of type `ToLowercase`\n    --> /tmp/tmpuhsshrdu.rs:29:57\n     |\n\
    29   |             res = res.chars().map(|c| c.to_lowercase()).collect();\n  \
    \   |                                                         ^^^^^^^ value of\
    \ type `String` cannot be built from `std::iter::Iterator<Item=ToLowercase>`\n\
    \     |\n     = help: the trait `FromIterator<ToLowercase>` is not implemented\
    \ for `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n     "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() { return String::new(); }\n    let\
    \ mut s = s;\n    \n    // Reverse all letters\n    while !s.is_empty() {\n  \
    \      match s.chars().next().unwrap() {\n            'a' => {\n             \
    \   s = s.chars().filter(|c| c != 'a').map(|c| 'A' + c).collect();\n         \
    \   }\n            'A' => {\n                s = s.chars().filter(|c| c != 'A').map(|c|\
    \ 'a' + c).collect();\n            }\n            c => s = s + c.to_string(),\n\
    \        }\n    }\n    return s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpw5ynh1j5.rs:21:44\n\
    \   |\n21 |                 s = s.chars().filter(|c| c != 'a').map(|c| 'A' + c).collect();\n\
    \   |                                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpw5ynh1j5.rs:21:64\n   |\n21 |   \
    \              s = s.chars().filter(|c| c != 'a').map(|c| 'A' + c).collect();\n\
    \   |                                                            --- ^ - char\n\
    \   |                                                            |\n   |     \
    \                                                       char\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpw5ynh1j5.rs:24:44\n   |\n24\
    \ |                 s = s.chars().filter(|c| c != 'A').map(|c| 'a' + c).collect();\n\
    \   |                                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpw5ynh1j5.rs:24:64\n   |\n24 |   \
    \              s = s.chars().filter(|c| c != 'A').map(|c| 'a' + c).collect();\n\
    \   |                                                            --- ^ - char\n\
    \   |                                                            |\n   |     \
    \                                                       char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw5ynh1j5.rs:26:26\n   |\n26 |             c\
    \ => s = s + c.to_string(),\n   |                          ^^^^^^^^^^^^^\n   |\
    \                          |\n   |                          expected `&str`, found\
    \ struct `String`\n   |                          help: consider borrowing here:\
    \ `&c.to_string()`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    for c in s.chars() {\n        if\
    \ c.is_ascii() {\n            match c.to_ascii_lowercase() {\n               \
    \ Some(x) => (c as char).reverse(),\n                None => c,\n            }\n\
    \        } else if c.is_digit() {\n            match c.to_digit() {\n        \
    \        Some(x) => (c as char).reverse(),\n                None => c,\n     \
    \       }\n        } else {\n            c.reverse();\n        }\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyf8l498t.rs:18:17\n   |\n\
    17 |             match c.to_ascii_lowercase() {\n   |                   ----------------------\
    \ this expression has type `char`\n18 |                 Some(x) => (c as char).reverse(),\n\
    \   |                 ^^^^^^^ expected `char`, found enum `Option`\n   |\n   =\
    \ note: expected type `char`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyf8l498t.rs:19:17\n   |\n17 |             match\
    \ c.to_ascii_lowercase() {\n   |                   ---------------------- this\
    \ expression has type `char`\n18 |                 Some(x) => (c as char).reverse(),\n\
    19 |                 None => c,\n   |                 ^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<_>`\n\nerror[E0599]: no method named `reverse` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpyf8l498t.rs:18:40\n   |\n18 |          \
    \       Some(x) => (c as char).reverse(),\n   |                              \
    \          ^^^^^^^ method not found in `char`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpyf8l498t.rs:21:21\n\
    \    |\n21  |         } else if c.is_digit() {\n    |                     ^^^^^^^^-\
    \ supplied 0 arguments\n    |                     |\n    |                   \
    \  expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpyf8l498t.rs:22:21\n\
    \    |\n22  |             match c.to_digit() {\n    |                     ^^^^^^^^-\
    \ supplied 0 arguments\n    |                     |\n    |                   \
    \  expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `reverse` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpyf8l498t.rs:23:40\n   |\n23 |                 Some(x) => (c as char).reverse(),\n\
    \   |                                        ^^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `reverse` found for type `char` in the "
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    loop {\n        let mut it = s.chars();\n\
    \        match it.next() {\n            Some('\\0') => s,\n            _ => break,\n\
    \        }\n        let mut first = it.next().unwrap();\n        if let Some(other)\
    \ = it.next() {\n            let mut other_first = other.next().unwrap();\n  \
    \          if let Some(other_other) = it.next() {\n                let mut other_second_first\
    \ = other_other.next().unwrap();\n                match other_second_first {\n\
    \                    Some('\\0') => {\n                        s = s.chars().rev().collect();\n\
    \                    }\n                    _ => (),\n                };\n   \
    \             match other_first {\n                    Some('\\0') => {\n    \
    \                    s = s.chars().rev().collect();\n                    }\n \
    \                   _ => (),\n                };\n                match other_second\
    \ {\n                    Some('\\0') => {\n                        s = s.chars().rev().collect();\n\
    \                    }\n                    _ => (),\n                };\n   \
    \             match other {\n                    Some('\\0') => {\n          \
    \              s = s.chars().rev().collect();\n                    }\n       \
    \             _ => (),\n                };\n                match first {\n  \
    \                  Some('\\0') => {\n                        s = s.chars().rev().collect();\n\
    \                    }\n                    _ => (),\n                };\n   \
    \         } else {\n                match first {\n                    Some('\\\
    0') => {\n                        s = s.chars().rev().collect();\n           \
    \         }\n                    _ => (),\n                };\n              \
    \  match other_first {\n                    Some('\\0') => {\n               \
    \         s = s.chars().rev().collect();\n                    }\n            \
    \        _ => (),\n                };\n            }\n        } else {\n     \
    \       match first {\n                Some('\\0') => {\n                    s\
    \ = s.chars().rev().collect();\n                }\n                _ => (),\n\
    \            }\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `other_second` in this scope\n  --> /tmp/tmpwg2sjo4f.rs:38:23\n\
    \   |\n38 |                 match other_second {\n   |                       ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg2sjo4f.rs:17:9\n\
    \   |\n17 | /         match it.next() {\n18 | |             Some('\\0') => s,\n\
    19 | |             _ => break,\n20 | |         }\n   | |         ^- help: consider\
    \ using a semicolon here\n   | |_________|\n   |           expected `()`, found\
    \ struct `String`\n\nerror[E0599]: no method named `next` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpwg2sjo4f.rs:23:41\n   |\n23 |          \
    \   let mut other_first = other.next().unwrap();\n   |                       \
    \                  ^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `next` found for type `char` in the current scope\n  --> /tmp/tmpwg2sjo4f.rs:25:58\n\
    \   |\n25 |                 let mut other_second_first = other_other.next().unwrap();\n\
    \   |                                                          ^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg2sjo4f.rs:45:21\n\
    \   |\n44 |                 match other {\n   |                       ----- this\
    \ expression has type `char`\n45 |                     Some('\\0') => {\n   |\
    \                     ^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n\
    \   = note: expected type `char`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwg2sjo4f.rs:51:21\n   |\n50 |              \
    \   match first {\n   |                       ----- this expression has type `char`\n\
    51 |                     Some('\\0') => {\n   |                     ^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwg2sjo4f.rs:58:21\n   |\n57 |                 match first {\n   |  \
    \                     ----- this expression has type `char`\n58 |            \
    \         Some('\\0') => {\n   |                     ^^^^^^^^^^ expected `char`,\
    \ found enu"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut result =\
    \ String::from(s);\n    s.chars().for_each(|c| {\n        let mut ch = c;\n  \
    \      if *ch >= 'A' && *ch <= 'Z' {\n            *ch = *ch - 'A' + 'a';\n   \
    \     } else if *ch >= 'a' && *ch <= 'z' {\n            *ch = *ch - 'a' + 'A';\n\
    \        } else {\n            *ch = *ch;\n        }\n        result += *ch;\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:18:12\n\
    \   |\n18 |         if *ch >= 'A' && *ch <= 'Z' {\n   |            ^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:18:26\n   |\n\
    18 |         if *ch >= 'A' && *ch <= 'Z' {\n   |                          ^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:19:13\n\
    \   |\n19 |             *ch = *ch - 'A' + 'a';\n   |             ^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:19:19\n   |\n\
    19 |             *ch = *ch - 'A' + 'a';\n   |                   ^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:20:19\n   |\n\
    20 |         } else if *ch >= 'a' && *ch <= 'z' {\n   |                   ^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:20:33\n\
    \   |\n20 |         } else if *ch >= 'a' && *ch <= 'z' {\n   |               \
    \                  ^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n \
    \ --> /tmp/tmpqwzknl8q.rs:21:13\n   |\n21 |             *ch = *ch - 'a' + 'A';\n\
    \   |             ^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  -->\
    \ /tmp/tmpqwzknl8q.rs:21:19\n   |\n21 |             *ch = *ch - 'a' + 'A';\n \
    \  |                   ^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpqwzknl8q.rs:23:13\n   |\n23 |             *ch = *ch;\n   |    \
    \         ^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:23:19\n\
    \   |\n23 |             *ch = *ch;\n   |                   ^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpqwzknl8q.rs:25:19\n   |\n\
    25 |         result += *ch;\n   |                   ^^^\n\nerror: aborting due\
    \ to 11 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    // use regex to find all words in s\n    let mut matches:\
    \ Vec<String> = regex::Regex::new(r\"[a-z]+\").unwrap().find_iter(&s).collect();\n\
    \n    // rev the words\n    for &str in matches {\n        let mut reverse = str;\n\
    \        reverse.chars().for_each(|c| match c {\n            c if c.is_alphanumeric()\
    \ => {\n                c.to_ascii_lowercase().swap()\n            }\n       \
    \     _ => (),\n        })\n    }\n\n    // concat all matches\n    matches.into_iter().filter(|&s|\
    \ !s.is_empty()).collect().join()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \  --> /tmp/tmpm_l1u_dc.rs:15:36\n   |\n15 |     let mut matches: Vec<String>\
    \ = regex::Regex::new(r\"[a-z]+\").unwrap().find_iter(&s).collect();\n   |   \
    \                                 ^^^^^ use of undeclared crate or module `regex`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm_l1u_dc.rs:18:9\n   |\n18 | \
    \    for &str in matches {\n   |         ^^^^    ------- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `str`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut str = s.to_string();\n    let mut len = str.len();\n\
    \    while len > 0 {\n        let mut len = len;\n        while len > 0 {\n  \
    \          let c = str[len - 1];\n            if c.is_alpha() {\n            \
    \    str[len - 1] = c.to_uppercase();\n                break;\n            } else\
    \ if c.is_digit() {\n                str[len - 1] = c.to_digit().unwrap();\n \
    \               break;\n            }\n            len -= 1;\n        }\n    }\n\
    \    str\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy6lzzb34.rs:19:21\n\
    \   |\n19 |             let c = str[len - 1];\n   |                     ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy6lzzb34.rs:21:17\n   |\n21 |                 str[len - 1] = c.to_uppercase();\n\
    \   |                 ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy6lzzb34.rs:24:17\n\
    \   |\n24 |                 str[len - 1] = c.to_digit().unwrap();\n   |      \
    \           ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Rang"
  stdout: ''
  timestamp: 1659978359
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s: String = s.to_string();\n    for ch in s.chars()\
    \ {\n        let c = if ch.is_lowercase() {\n            ch.to_uppercase()\n \
    \       } else {\n            ch.to_lowercase()\n        };\n        s = s.replace(c,\
    \ \"#\").to_string();\n    }\n    s.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpgq56n55f.rs:19:13\n\
    \   |\n16 |           let c = if ch.is_lowercase() {\n   |  _________________-\n\
    17 | |             ch.to_uppercase()\n   | |             ----------------- expected\
    \ because of this\n18 | |         } else {\n19 | |             ch.to_lowercase()\n\
    \   | |             ^^^^^^^^^^^^^^^^^ expected struct `ToUppercase`, found struct\
    \ `ToLowercase`\n20 | |         };\n   | |_________- `if` and `else` have incompatible\
    \ types\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::from(\"\");\n    for &c in s.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            res.push_str(&c.to_ascii_lowercase());\n\
    \        } else {\n            res.push_str(&c.to_ascii_uppercase());\n      \
    \  }\n    }\n    if res.is_empty() {\n        res = s;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqmh7pnbi.rs:15:9\n   |\n\
    15 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = s.clone();\n    if result.is_empty()\
    \ {\n        result = \"#\";\n    }\n    let mut counter = 0;\n    let mut i =\
    \ 0;\n    let mut length = result.len();\n    let mut letters = false;\n    loop\
    \ {\n        if i == length {\n            break;\n        }\n        if let Some(letter)\
    \ = result.chars().nth(i).unwrap() {\n            counter += 1;\n            if\
    \ counter == 2 {\n                result.push_str(&(letter.to_ascii_lowercase()));\n\
    \            } else {\n                result.push_str(&(letter.to_ascii_uppercase()));\n\
    \            }\n            i += 1;\n            length = result.len();\n    \
    \    } else {\n            i += 1;\n            length = result.len();\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_r5ryg17.rs:16:18\n   |\n\
    14 |     let mut result = s.clone();\n   |                      --------- expected\
    \ due to this value\n15 |     if result.is_empty() {\n16 |         result = \"\
    #\";\n   |                  ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                  |\n   |                  expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_r5ryg17.rs:26:16\n\
    \   |\n26 |         if let Some(letter) = result.chars().nth(i).unwrap() {\n \
    \  |                ^^^^^^^^^^^^   ------------------------------ this expression\
    \ has type `char`\n   |                |\n   |                expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: -1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().any(|c| c.is_ascii()) {\n        solve(s.to_ascii_lowercase())\n\
    \    } else {\n        solve(s.to_ascii_uppercase())\n    }\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978365
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut new_s = String::new();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < s.len() {\n        let c: Char = s[i];\n  \
    \      if c.is_letter() {\n            if s.len() > i {\n                if s[i]\
    \ == s[i+1] {\n                    new_s.push_str(&s[i..i]);\n               \
    \ } else {\n                    new_s.push_str(&s[i..i+1]);\n                }\n\
    \            }\n            i += 1;\n        } else {\n            new_s.push_str(&s[i]);\n\
    \            i += 1;\n        }\n    }\n    new_s.push_str(&s[..i]);\n    new_s\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmp2vx_nmvb.rs:18:16\n\
    \   |\n18 |         let c: Char = s[i];\n   |                ^^^^ help: a builtin\
    \ type with a similar name exists (notice the capitalization): `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2vx_nmvb.rs:18:23\n\
    \   |\n18 |         let c: Char = s[i];\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2vx_nmvb.rs:21:20\n   |\n21 |                 if s[i] == s[i+1]\
    \ {\n   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2vx_nmvb.rs:21:28\n\
    \   |\n21 |                 if s[i] == s[i+1] {\n   |                        \
    \    ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n            "
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars();\n    s.reverse();\n    s.filter(|&c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').map(|c| c.to_ascii_lowercase().to_string())\n\
    \        .collect::<String>().iter()\n        .join(\"\").to_string()\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp1ilnshla.rs:15:7\n   |\n15 |     s.reverse();\n\
    \   |       ^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method\
    \ named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp1ilnshla.rs:17:30\n\
    \   |\n17 |         .collect::<String>().iter()\n   |                        \
    \      ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n17 |         .collect::<String>().chars()\n   |  \
    \                            ~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().for_each(|c| {\n        if c.is_alpha() {\n\
    \            c.to_ascii_lowercase().to_ascii_uppercase();\n        } else {\n\
    \            c\n        }\n    })\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_alpha` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp2tw6jtxw.rs:15:14\n   |\n15 |         if c.is_alpha() {\n\
    \   |              ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_alphabetic`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2tw6jtxw.rs:18:13\n\
    \   |\n15 | /         if c.is_alpha() {\n16 | |             c.to_ascii_lowercase().to_ascii_uppercase();\n\
    17 | |         } else {\n18 | |             c\n   | |             ^ expected `()`,\
    \ found `char`\n19 | |         }\n   | |_________- expected this to be `()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2tw6jtxw.rs:14:5\n   |\n13 |   fn\
    \ solve(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n14 | /     s.chars().for_each(|c| {\n15 | |\
    \         if c.is_alpha() {\n16 | |             c.to_ascii_lowercase().to_ascii_uppercase();\n\
    17 | |         } else {\n18 | |             c\n19 | |         }\n20 | |     })\n\
    \   | |______^ expected struct `String`, found `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::from(s);\n    if res.chars().any(|c|\
    \ *c < 'a' || *c > 'z') {\n        res.chars().rev().collect();\n    } else {\n\
    \        res.chars().collect();\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpcy60yrh8.rs:15:28\n\
    \   |\n15 |     if res.chars().any(|c| *c < 'a' || *c > 'z') {\n   |         \
    \                   ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n \
    \ --> /tmp/tmpcy60yrh8.rs:15:40\n   |\n15 |     if res.chars().any(|c| *c < 'a'\
    \ || *c > 'z') {\n   |                                        ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        String::from(\"AaBbCcDd\"\
    )\n    } else {\n        let mut res = String::from(\"\");\n        for &c in\
    \ s.chars() {\n            match c {\n                'a' | 'b' | 'c' => {\n \
    \                   res += String::from(\"CcDdEeFfGgHh\");\n                },\n\
    \                'd' | 'e' | 'f' => {\n                    res += String::from(\"\
    EeFfGgHhIiJj\");\n                },\n                'g' | 'h' | 'i' => {\n \
    \                   res += String::from(\"HhIiJjKkLl\");\n                },\n\
    \                'j' | 'k' | 'l' => {\n                    res += String::from(\"\
    IiJjKkLlMm\");\n                },\n                'm' | 'l' | 'n' => {\n   \
    \                 res += String::from(\"LlMmNnOoPpQq\");\n                },\n\
    \                'o' | 'p' | 'q' => {\n                    res += String::from(\"\
    PpQqRrSsTt\");\n                },\n                'r' | 's' | 't' => {\n   \
    \                 res += String::from(\"RsTtUuVvWwXxYy\");\n                },\n\
    \                'u' | 'v' | 'w' => {\n                    res += String::from(\"\
    VvWwXxYyZz\");\n                },\n                'w' | 'x' | 'y' => {\n   \
    \                 res += String::from(\"WxYyZz\");\n                },\n     \
    \           'y' | 'z' | _ => {\n                    res += String::from(\"Zz\"\
    );\n                }\n            };\n        }\n        res += String::from(\"\
    AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\");\n        res.chars().rev().collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyx9yeq6b.rs:18:13\n   |\n\
    18 |         for &c in s.chars() {\n   |             ^^    --------- this expression\
    \ has type `Option<char>`\n   |             |\n   |             expected `char`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx9yeq6b.rs:21:28\n  \
    \ |\n21 |                     res += String::from(\"CcDdEeFfGgHh\");\n   |   \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                 \
    \           |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&String::from(\"\
    CcDdEeFfGgHh\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx9yeq6b.rs:24:28\n\
    \   |\n24 |                     res += String::from(\"EeFfGgHhIiJj\");\n   | \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |               \
    \             |\n   |                            expected `&str`, found struct\
    \ `String`\n   |                            help: consider borrowing here: `&String::from(\"\
    EeFfGgHhIiJj\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx9yeq6b.rs:27:28\n\
    \   |\n27 |                     res += String::from(\"HhIiJjKkLl\");\n   |   \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                   \
    \         |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&String::from(\"\
    HhIiJjKkLl\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx9yeq6b.rs:30:28\n\
    \   |\n30 |                     res += String::from(\"IiJjKkLlMm\");\n   |   \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                   \
    \         |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&String::from(\"\
    IiJjKkLlMm\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx9yeq6b.rs:33:28\n\
    \   |\n33 |                     res += Str"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_letter\
    \ = false;\n    for i in s.chars() {\n        if i.is_lowercase() {\n        \
    \    prev_letter = false;\n            if prev_letter == false {\n           \
    \     result.push_str(\"A\");\n            }\n            prev_letter = true;\n\
    \            result.push_str(i.get_lowercase());\n        } else {\n         \
    \   prev_letter = false;\n            if prev_letter == false {\n            \
    \    result.push_str(\"a\");\n            }\n            prev_letter = true;\n\
    \            result.push_str(i.get_uppercase());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_lowercase` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpk8tv9xdm.rs:23:31\n   |\n23 |             result.push_str(i.get_lowercase());\n\
    \   |                               ^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_lowercase`\n\nerror[E0599]: no method named\
    \ `get_uppercase` found for type `char` in the current scope\n  --> /tmp/tmpk8tv9xdm.rs:30:31\n\
    \   |\n30 |             result.push_str(i.get_uppercase());\n   |            \
    \                   ^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_uppercase`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if !is_letter(&s[i]) {\n            swap(i, i+1);\n        }\n  \
    \      i += 1;\n    }\n    s.clone()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpgiqjr8wk.rs:17:13\n\
    \   |\n17 |         if !is_letter(&s[i]) {\n   |             ^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `swap` in this scope\n \
    \ --> /tmp/tmpgiqjr8wk.rs:18:13\n   |\n18 |             swap(i, i+1);\n   |  \
    \           ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgiqjr8wk.rs:17:24\n\
    \   |\n17 |         if !is_letter(&s[i]) {\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter(|&c| c == 'a' || c == 'A' || c ==\
    \ 'b' || c == 'B' || c == 'c' || c == 'C').for_each(|&c| {\n        if (c == 'a'\
    \ || c == 'A') c = 'A';\n        if (c == 'b' || c == 'B') c = 'B';\n        if\
    \ (c == 'c' || c == 'C') c = 'C';\n    })\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `c`\n  --> /tmp/tmpbkmi9j2h.rs:15:35\n   |\n\
    15 |         if (c == 'a' || c == 'A') c = 'A';\n   |         --             \
    \           ^ expected `{`\n   |         |\n   |         this `if` expression\
    \ has a condition, but no block\n   |\nhelp: try placing this code inside a block\n\
    \   |\n15 |         if (c == 'a' || c == 'A') { c = 'A' };\n   |             \
    \                      +         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbkmi9j2h.rs:14:107\n\
    \   |\n14 |     s.chars().filter(|&c| c == 'a' || c == 'A' || c == 'b' || c ==\
    \ 'B' || c == 'c' || c == 'C').for_each(|&c| {\n   |                         \
    \                                                                            \
    \      ^--\n   |                                                             \
    \                                              ||\n   |                      \
    \                                                                            \
    \         |expected due to this\n   |                                        \
    \                                                                   expected `char`,\
    \ found reference\n   |                                                      \
    \                                                     help: did you mean `c`:\
    \ `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbkmi9j2h.rs:14:5\n   |\n\
    13 |   fn solve(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n14 | /     s.chars().filter(|&c| c == 'a' ||\
    \ c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C').for_each(|&c| {\n\
    15 | |         if (c == 'a' || c == 'A') c = 'A';\n16 | |         if (c == 'b'\
    \ || c == 'B') c = 'B';\n17 | |         if (c == 'c' || c == 'C') c = 'C';\n18\
    \ | |     })\n   | |______^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut s = s;\n    while let Some(c)\
    \ = s.chars().next() {\n        let c = c as char;\n        if c.is_ascii_lowercase()\
    \ {\n            s = s.into_lowercase();\n        } else if c.is_ascii_uppercase()\
    \ {\n            s = s.into_uppercase();\n        } else {\n            s = c;\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpjf1vel71.rs:19:19\n   |\n19 |          \
    \   s = s.into_lowercase();\n   |                   ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `into_uppercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpjf1vel71.rs:21:19\n   |\n21 |             s = s.into_uppercase();\n\
    \   |                   ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjf1vel71.rs:23:17\n\
    \   |\n15 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n23 |             s = c;\n   |                 ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                 |\n   |                 expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut len = s.len();\n    while\
    \ len > 0 {\n        if s.is_ascii_lowercase(0) {\n            s = s.into_lowercase();\n\
    \        } else if s.is_ascii_uppercase(0) {\n            s = s.into_uppercase();\n\
    \        } else {\n            break;\n        }\n        len -= 1;\n    }\n \
    \   s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpuzqib1oi.rs:17:14\n   |\n17 |         if\
    \ s.is_ascii_lowercase(0) {\n   |              ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `into_lowercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpuzqib1oi.rs:18:19\n   |\n18 |             s = s.into_lowercase();\n\
    \   |                   ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_ascii_uppercase`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpuzqib1oi.rs:19:21\n\
    \   |\n19 |         } else if s.is_ascii_uppercase(0) {\n   |                \
    \     ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_uppercase`\n\nerror[E0599]: no method named `into_uppercase`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpuzqib1oi.rs:20:19\n\
    \   |\n20 |             s = s.into_uppercase();\n   |                   ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| match c {\n        c @ _ => c,\n\
    \        '#' | '$' => {\n            if s.len() == 0 {\n                c\n  \
    \          } else {\n                if c.to_string().is_lowercase() {\n     \
    \               s.chars().map(|c| match c {\n                        'a' => {\n\
    \                            c\n                        }\n                  \
    \      'A' => {\n                            c\n                        }\n  \
    \                      '#' | '$' => {\n                            if s.len()\
    \ == 0 {\n                                c\n                            } else\
    \ {\n                                if c.to_string().is_lowercase() {\n     \
    \                               s.chars().map(|c| match c {\n                \
    \                        'a' => {\n                                          \
    \  c\n                                        }\n                            \
    \            'A' => {\n                                            c\n       \
    \                                 }\n                                        _\
    \ => c,\n                                    }).collect()\n                  \
    \              } else {\n                                    s.chars().map(|c|\
    \ match c {\n                                        'a' => {\n              \
    \                              c\n                                        }\n\
    \                                        'A' => {\n                          \
    \                  c\n                                        }\n            \
    \                            _ => c,\n                                    }).collect()\n\
    \                                }\n                            }\n          \
    \              }\n                        _ => c,\n                    }).collect()\n\
    \                } else {\n                    s.chars().map(|c| match c {\n \
    \                       'a' => {\n                            c\n            \
    \            }\n                        'A' => {\n                           \
    \ c\n                        }\n                        '#' | '$' => {\n     \
    \                       if s.len() == 0 {\n                                c\n\
    \                            } else {\n                                if c.to_string().is_lowercase()\
    \ {\n                                    s.chars().map(|c| match c {\n       \
    \                                 'a' => {\n                                 \
    \           c\n                                        }\n                   \
    \                     'A' => {\n                                            c\n\
    \                                        }\n                                 \
    \       _ => c,\n                                    }).collect()\n          \
    \                      } else {\n                                    s.chars().map(|c|\
    \ match c {\n                                        'a' => {\n              \
    \                              c\n                                        }\n\
    \                                        'A' => {\n                          \
    \                  c\n                                        }\n            \
    \                            _ => c,\n                                    }).collect()\n\
    \                                }\n                            }\n          \
    \              }\n                        _ => c,\n                    }).collect()\n\
    \                }\n            }\n        }\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpquextyk4.rs:20:34\n   |\n20 |          \
    \       if c.to_string().is_lowercase() {\n   |                              \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_lowercase` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpquextyk4.rs:32:50\n   |\n32 | ...             \
    \      if c.to_string().is_lowercase() {\n   |                               \
    \         ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror[E0599]: no method named `is_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpquextyk4.rs:69:50\n   |\n69 | ...\
    \                   if c.to_string().is_lowercase() {\n   |                  \
    \                      ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut newString = \"\";\n    for ch in s {\n    \
    \    if let Some(letter) = match ch {\n            Some(c) => c,\n           \
    \ None => return newString,\n            _ => return newString,\n        }\n \
    \       if let Some(lowerLetter) = letter.to() {\n            let newLowerLetter\
    \ = if lowerLetter == 'A' { 'B' } else { lowerLetter };\n            newString\
    \ = newString.to_string() + newLowerLetter + newString;\n        } else {\n  \
    \          newString = newString.to_string() + letter + newString;\n        }\n\
    \    }\n    newString\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `if`\n  --> /tmp/tmp2_9fkjj9.rs:21:9\n\
    \   |\n16 |         if let Some(letter) = match ch {\n   |         -- this `if`\
    \ expression has a condition, but no block\n...\n21 |         if let Some(lowerLetter)\
    \ = letter.to() {\n   |         ^^ expected `{`\n   |\nhelp: try placing this\
    \ code inside a block\n   |\n21 ~         { if let Some(lowerLetter) = letter.to()\
    \ {\n22 |             let newLowerLetter = if lowerLetter == 'A' { 'B' } else\
    \ { lowerLetter };\n23 |             newString = newString.to_string() + newLowerLetter\
    \ + newString;\n24 |         } else {\n25 |             newString = newString.to_string()\
    \ + letter + newString;\n26 ~         } }\n   |\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmp2_9fkjj9.rs:15:15\n   |\n15 |     for ch in s {\n\
    \   |               ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2_9fkjj9.rs:28:5\n   |\n13 | fn\
    \ solve(s: String) -> String {\n   |                        ------ expected `String`\
    \ because of return type\n...\n28 |     newString\n   |     ^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |     |\n   |     expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut new_s = s;\n    \n    for x in s.chars() {\n\
    \        let char = x.to_ascii_lowercase();\n        if char.len() != 1 || char.chars().first()\
    \ != 'a' || char.chars().last().unwrap() != 'a' {\n            new_s = new_s.to_string();\n\
    \        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n \
    \   assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n \
    \   assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n \
    \   assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4ocfxyr5.rs:18:17\n   |\n18 |         if char.len() !=\
    \ 1 || char.chars().first() != 'a' || char.chars().last().unwrap() != 'a' {\n\
    \   |                 ^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmp4ocfxyr5.rs:18:36\n\
    \   |\n18 |         if char.len() != 1 || char.chars().first() != 'a' || char.chars().last().unwrap()\
    \ != 'a' {\n   |                                    ^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `chars` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp4ocfxyr5.rs:18:67\n   |\n18 |         if char.len()\
    \ != 1 || char.chars().first() != 'a' || char.chars().last().unwrap() != 'a' {\n\
    \   |                                                                   ^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s1 = s.to_lowercase();\n    let mut s2 = s.to_lowercase();\n\
    \n    for i in s.chars().enumerate() {\n        if s1.contains(i.0) {\n      \
    \      s2.insert(i.0, i.1);\n        } else {\n            s2.insert(i.0, i.0);\n\
    \        }\n    }\n\n    s2.into()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `usize`\n    -->\
    \ /tmp/tmpkyfc39sl.rs:18:24\n     |\n18   |         if s1.contains(i.0) {\n  \
    \   |               -------- ^^^ expected an `FnMut<(char,)>` closure, found `usize`\n\
    \     |               |\n     |               required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `FnMut<(char,)>` is not implemented\
    \ for `usize`\n     = help: the following other types implement trait `Pattern<'a>`:\n\
    \               &'b String\n               &'b [char; N]\n               &'b [char]\n\
    \               &'b str\n               &'c &'b str\n               [char; N]\n\
    \               char\n               pattern::MultiCharEqPattern<C>\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `usize`\n\
    note: required by a bound in `core::str::<impl str>::contains`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkyfc39sl.rs:21:28\n   |\n21 |             s2.insert(i.0,\
    \ i.0);\n   |                            ^^^ expected `char`, found `usize`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().cloned().for_each(|c|\n\
    \        if c.is_ascii() {\n            if c >= 'a' && c <= 'z' {\n          \
    \      c.to_ascii_lowercase();\n            } else if c >= 'A' && c <= 'Z' {\n\
    \                c.to_ascii_uppercase();\n            } else {\n             \
    \   c = c.to_ascii_lowercase();\n            }\n        } else {\n           \
    \ c = c.to_ascii_lowercase();\n        }\n    );\n    String::from(s)\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpkkbwfape.rs:15:15\n     |\n15   |     s.chars().cloned().for_each(|c|\n\
    \     |               ^^^^^^ expected reference, found `char`\n     |\n     =\
    \ note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `for_each` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpkkbwfape.rs:15:24\n   |\n15 |       s.chars().cloned().for_each(|c|\n\
    \   |                          ^^^^^^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut reversed = s.clone();\n    let mut result =\
    \ String::new();\n    for i in s.chars() {\n        if i.is_ascii_lowercase()\
    \ {\n            reversed.to_lowercase();\n        } else if i.is_ascii_uppercase()\
    \ {\n            reversed.to_uppercase();\n        } else {\n            result\
    \ = result.push_str(&i);\n        }\n    }\n    result.reverse();\n    result\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5esngyl2.rs:22:38\n   |\n\
    22 |             result = result.push_str(&i);\n   |                         \
    \             ^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5esngyl2.rs:22:22\n   |\n15 |     let mut result = String::new();\n\
    \   |                      ------------- expected due to this value\n...\n22 |\
    \             result = result.push_str(&i);\n   |                      ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmp5esngyl2.rs:22:29\n   |\n22 |         \
    \    result = result.push_str(&i);\n   |                      ------ ^^^^^^^^\
    \ this call modifies `result` in-place\n   |                      |\n   |    \
    \                  you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp5esngyl2.rs:25:12\n   |\n25 |     result.reverse();\n   |      \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| match c {\n        'a' | 'A' => c\
    \ as char,\n        'b' | 'B' => c as char,\n        'c' | 'C' => c as char,\n\
    \        _ => c,\n    }).collect::<String>().reverse().into_iter().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp187_rxk9.rs:19:28\n   |\n19 |     }).collect::<String>().reverse().into_iter().collect::<String>()\n\
    \   |                            ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        s\n    } else {\n      \
    \  let mut new_s = s;\n        new_s.reverse();\n        if new_s.is_lowercase()\
    \ {\n            new_s.to_ascii_lowercase().reverse();\n        } else if new_s.is_uppercase()\
    \ {\n            new_s.to_ascii_uppercase().reverse();\n        } else {\n   \
    \         new_s\n        }\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpt_zbcyip.rs:18:15\n   |\n18 |         new_s.reverse();\n\
    \   |               ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `is_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpt_zbcyip.rs:19:18\n   |\n19 | \
    \        if new_s.is_lowercase() {\n   |                  ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpt_zbcyip.rs:20:40\n   |\n20 |             new_s.to_ascii_lowercase().reverse();\n\
    \   |                                        ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt_zbcyip.rs:19:33\n   |\n19 |           if new_s.is_lowercase()\
    \ {\n   |  _________________________________^\n20 | |             new_s.to_ascii_lowercase().reverse();\n\
    21 | |         } else if new_s.is_uppercase() {\n   | |_________^ expected struct\
    \ `String`, found `()`\n\nerror[E0599]: no method named `is_uppercase` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpt_zbcyip.rs:21:25\n   |\n\
    21 |         } else if new_s.is_uppercase() {\n   |                         ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpt_zbcyip.rs:22:40\n   |\n22 |             new_s.to_ascii_uppercase().reverse();\n\
    \   |                                        ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt_zbcyip.rs:21:40\n   |\n21 |           } else if new_s.is_uppercase()\
    \ {\n   |  ________________________________________^\n22 | |             new_s.to_ascii_uppercase().reverse();\n\
    23 | |         } else {\n   | |_________^ expected struct `String`, found `()`\n\
    \nerror: aborting"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.to_string();\n    if s.chars().any(|c|\
    \ !c.is_letter()) {\n        std::str::from_utf8(&s).unwrap().to_uppercase();\n\
    \    } else {\n        std::str::from_utf8(&s).unwrap().to_lowercase();\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpyxw16b6w.rs:15:29\n   |\n15 |     if s.chars().any(|c|\
    \ !c.is_letter()) {\n   |                             ^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyxw16b6w.rs:16:29\n\
    \   |\n16 |         std::str::from_utf8(&s).unwrap().to_uppercase();\n   |   \
    \                          ^^ expected slice `[u8]`, found struct `String`\n \
    \  |\n   = note: expected reference `&[u8]`\n              found reference `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyxw16b6w.rs:15:42\n   |\n15 |\
    \       if s.chars().any(|c| !c.is_letter()) {\n   |  __________________________________________^\n\
    16 | |         std::str::from_utf8(&s).unwrap().to_uppercase();\n   | |      \
    \                                                  - help: remove this semicolon\n\
    17 | |     } else {\n   | |_____^ expected struct `String`, found `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyxw16b6w.rs:18:29\n   |\n18 |         std::str::from_utf8(&s).unwrap().to_lowercase();\n\
    \   |                             ^^ expected slice `[u8]`, found struct `String`\n\
    \   |\n   = note: expected reference `&[u8]`\n              found reference `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyxw16b6w.rs:17:12\n   |\n17 |\
    \       } else {\n   |  ____________^\n18 | |         std::str::from_utf8(&s).unwrap().to_lowercase();\n\
    \   | |                                                        - help: remove\
    \ this semicolon\n19 | |     }\n   | |_____^ expected struct `String`, found `()`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::from(s);\n\n    for c in s.chars()\
    \ {\n        match c {\n            'a' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_lowercase())).chain(Some(b => b.to_ascii_uppercase()))\n     \
    \               .chain(Some(b => b.to_ascii_lowercase())).collect();\n       \
    \     }\n            'A' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_uppercase())).chain(Some(b => b.to_ascii_lowercase()))\n     \
    \               .chain(Some(b => b.to_ascii_uppercase())).collect();\n       \
    \     }\n            'b' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_lowercase())).chain(Some(b => b.to_ascii_uppercase()))\n     \
    \               .chain(Some(b => b.to_ascii_lowercase())).collect();\n       \
    \     }\n            'B' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_uppercase())).chain(Some(b => b.to_ascii_lowercase()))\n     \
    \               .chain(Some(b => b.to_ascii_uppercase())).collect();\n       \
    \     }\n            '#' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_lowercase())).chain(Some(b => b.to_ascii_uppercase()))\n     \
    \               .chain(Some(b => b.to_ascii_lowercase())).collect();\n       \
    \     }\n            '@' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_uppercase())).chain(Some(b => b.to_ascii_lowercase()))\n     \
    \               .chain(Some(b => b.to_ascii_uppercase())).collect();\n       \
    \     }\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `=>`\n  --> /tmp/tmp4w38etkn.rs:19:48\n   |\n19 |                 res\
    \ = res.chars().chain(Some(b => b.to_ascii_lowercase())).chain(Some(b => b.to_ascii_uppercase()))\n\
    \   |                                                ^^ expected one of 8 possible\
    \ tokens\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().count() > 0 {\n        Solution::iter(s)\n\
    \    } else {\n        Solution::reverse_iter(s)\n    }\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Solution`\n  -->\
    \ /tmp/tmph_khfwwb.rs:15:9\n   |\n15 |         Solution::iter(s)\n   |       \
    \  ^^^^^^^^ use of undeclared type `Solution`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Solution`\n  --> /tmp/tmph_khfwwb.rs:17:9\n   |\n17\
    \ |         Solution::reverse_iter(s)\n   |         ^^^^^^^^ use of undeclared\
    \ type `Solution`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().any(|x| !x.is_ascii()) {\n        solve_reverse(s);\n\
    \    } else {\n        solve_reverse(s.to_ascii_lowercase());\n    }\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve_reverse` in this scope\n  -->\
    \ /tmp/tmpajzvq09e.rs:15:9\n   |\n15 |         solve_reverse(s);\n   |       \
    \  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `solve_reverse` in this scope\n  --> /tmp/tmpajzvq09e.rs:17:9\n   |\n17 |  \
    \       solve_reverse(s.to_ascii_lowercase());\n   |         ^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpajzvq09e.rs:14:41\n\
    \   |\n14 |       if s.chars().any(|x| !x.is_ascii()) {\n   |  _________________________________________^\n\
    15 | |         solve_reverse(s);\n16 | |     } else {\n   | |_____^ expected struct\
    \ `String`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpajzvq09e.rs:16:12\n\
    \   |\n16 |       } else {\n   |  ____________^\n17 | |         solve_reverse(s.to_ascii_lowercase());\n\
    18 | |     }\n   | |_____^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s: Vec<_> = s.chars().collect();\n    s.reverse();\n\
    \    let mut new_s = String::new();\n    for c in s {\n        if c.is_lowercase()\
    \ {\n            new_s.push_str(c.to_string().to_uppercase());\n        } else\
    \ {\n            new_s.push_str(c.to_string().to_lowercase());\n        }\n  \
    \  }\n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_ku7itw.rs:19:28\n   |\n\
    19 |             new_s.push_str(c.to_string().to_uppercase());\n   |         \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                       \
    \     |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&c.to_string().to_uppercase()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd_ku7itw.rs:21:28\n   |\n21 |\
    \             new_s.push_str(c.to_string().to_lowercase());\n   |            \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                          \
    \  |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&c.to_string().to_lowercase()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() { return String::new(); }\n\n    let\
    \ mut s: String = s;\n    for c in s.chars() {\n        if let Some(upper) = c.to_ascii_uppercase()\
    \ {\n            s.replace(c.to_ascii_lowercase(), upper);\n        }\n      \
    \  if let Some(low) = c.to_ascii_lowercase() {\n            s.replace(c.to_ascii_uppercase(),\
    \ low);\n        }\n    }\n\n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoqu3ywvw.rs:18:16\n   |\n\
    18 |         if let Some(upper) = c.to_ascii_uppercase() {\n   |             \
    \   ^^^^^^^^^^^   ---------------------- this expression has type `char`\n   |\
    \                |\n   |                expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoqu3ywvw.rs:21:16\n   |\n21 |\
    \         if let Some(low) = c.to_ascii_lowercase() {\n   |                ^^^^^^^^^\
    \   ---------------------- this expression has type `char`\n   |             \
    \   |\n   |                expected `char`, found enum `Option`\n   |\n   = note:\
    \ expected type `char`\n              found enum `Option<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        \"\".to_string();\n    }\
    \ else {\n        let mut s = s;\n        let mut i = 0;\n        while !s.is_empty()\
    \ {\n            let mut c = s[i];\n            if c == 'A' {\n              \
    \  if i == 0 {\n                    s = String::from(\"cA\");\n              \
    \      break;\n                }\n                c += 'a' - 'A';\n          \
    \  } else if c == 'a' {\n                if i == 0 {\n                    s =\
    \ String::from(\"Ca\");\n                    break;\n                }\n     \
    \           c += 'A' - 'a';\n            }\n            s[i] = c;\n          \
    \  i += 1;\n        }\n        s + &s[i..].to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpidoz7d4i.rs:14:21\n   |\n\
    14 |       if s.is_empty() {\n   |  _____________________^\n15 | |         \"\"\
    .to_string();\n   | |                       - help: remove this semicolon\n16\
    \ | |     } else {\n   | |_____^ expected struct `String`, found `()`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpidoz7d4i.rs:20:25\n\
    \   |\n20 |             let mut c = s[i];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpidoz7d4i.rs:26:26\n\
    \   |\n26 |                 c += 'a' - 'A';\n   |                      --- ^ ---\
    \ char\n   |                      |\n   |                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpidoz7d4i.rs:32:26\n   |\n\
    32 |                 c += 'A' - 'a';\n   |                      --- ^ --- char\n\
    \   |                      |\n   |                      char\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpidoz7d4i.rs:34:13\n\
    \   |\n34 |             s[i] = c;\n   |             ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::o"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for ch in s.chars()\
    \ {\n        if ch.is_ascii_letter() {\n            result.push((ch as u8).to_ascii_uppercase().to_string());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpdx28ignk.rs:16:15\n   |\n16 |         if ch.is_ascii_letter()\
    \ {\n   |               ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdx28ignk.rs:17:25\n\
    \   |\n17 |             result.push((ch as u8).to_ascii_uppercase().to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.to_lowercase();\n    if s.chars().any(|c|\
    \ !c.is_ascii_lowercase()) {\n        s = s.to_uppercase();\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"asdf\"`,\n right: `\"aSdF\"`', /tmp/tmpwjzv30c1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve_internal(s).to_string()\n}\n\nfn main() {\n \
    \   let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve_internal` in this scope\n  -->\
    \ /tmp/tmp7ldc3zin.rs:14:5\n   |\n14 |     solve_internal(s).to_string()\n   |\
    \     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return s;\n    }\n    \n\
    \    let mut s = s;\n    \n    // step 1: loop through each character, try to\
    \ reverse it\n    for c in s.chars() {\n        \n        // step 2: if the char\
    \ not letter move to the next one\n        if !c.is_letter() {\n            \n\
    \            // step 3: if we are at the end, return the empty string\n      \
    \      if s.len() == 0 {\n                return String::new();\n            }\n\
    \            \n            // step 4: move to the next char\n            s = &s[1..];\n\
    \            \n            // step 5: move to the next char\n            c = &s[1..];\n\
    \        }\n        \n        // step 6: reverse the char\n        s = s.chars().filter(|c|\
    \ c.is_letter()).map(|c| c.to_ascii_lowercase()).collect::<String>() + s;\n  \
    \      \n        // step 7: move to the next char\n        c = &s[1..];\n    }\n\
    \    \n    // step 8: return the resulted string\n    s\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpc040uef2.rs:24:15\n   |\n24 |         if !c.is_letter()\
    \ {\n   |               ^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc040uef2.rs:32:17\n   |\n18 |     let mut s\
    \ = s;\n   |                 - expected due to this value\n...\n32 |         \
    \    s = &s[1..];\n   |                 ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n32 |             s\
    \ = (&s[1..]).to_string();\n   |                 +       +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc040uef2.rs:35:17\n   |\n21 |     for c in s.chars()\
    \ {\n   |         - expected due to the type of this binding\n...\n35 |      \
    \       c = &s[1..];\n   |                 ^^^^^^^ expected `char`, found `&str`\n\
    \nerror[E0599]: no method named `is_letter` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpc040uef2.rs:39:36\n   |\n39 |         s = s.chars().filter(|c|\
    \ c.is_letter()).map(|c| c.to_ascii_lowercase()).collect::<String>() + s;\n  \
    \ |                                    ^^^^^^^^^ method not found in `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc040uef2.rs:39:103\n   |\n39 |\
    \         s = s.chars().filter(|c| c.is_letter()).map(|c| c.to_ascii_lowercase()).collect::<String>()\
    \ + s;\n   |                                                                 \
    \                                      ^\n   |                               \
    \                                                                        |\n \
    \  |                                                                         \
    \                              expected `&str`, found struct `String`\n   |  \
    \                                                                            \
    \                         help: consider borrowing here: `&s`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc040uef2.rs:42:13\n   |\n21 |     for c in s.chars()\
    \ {\n   |         - expected due to the type of this binding\n...\n42 |      \
    \   c = &s[1..];\n   |             ^^^^^"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| {\n        match c {\n          \
    \  c if c.is_letter() => c.to_uppercase(),\n            c if c.is_digit() => c.to_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect::<String>() + s.chars().filter(|c|\
    \ !c.is_letter()).collect::<String>() + s.chars().filter(|c| !c.is_digit()).collect::<String>()\
    \ + s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpcjcfpl9n.rs:16:20\n   |\n16 |             c if\
    \ c.is_letter() => c.to_uppercase(),\n   |                    ^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmpcjcfpl9n.rs:17:20\n    |\n17  |             c\
    \ if c.is_digit() => c.to_lowercase(),\n    |                    ^^^^^^^^- supplied\
    \ 0 arguments\n    |                    |\n    |                    expected 1\
    \ argument\n    |\nnote: associated function defined here\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpcjcfpl9n.rs:17:34\n   |\n15 | /\
    \         match c {\n16 | |             c if c.is_letter() => c.to_uppercase(),\n\
    \   | |                                   ---------------- this is found to be\
    \ of type `ToUppercase`\n17 | |             c if c.is_digit() => c.to_lowercase(),\n\
    \   | |                                  ^^^^^^^^^^^^^^^^ expected struct `ToUppercase`,\
    \ found struct `ToLowercase`\n18 | |             _ => c,\n19 | |         }\n \
    \  | |_________- `match` arms have incompatible types\n\nerror[E0599]: no method\
    \ named `is_letter` found for reference `&char` in the current scope\n  --> /tmp/tmpcjcfpl9n.rs:20:54\n\
    \   |\n20 |     }).collect::<String>() + s.chars().filter(|c| !c.is_letter()).collect::<String>()\
    \ + s.chars().filter(|c| !c.is_digit()).collect::<Str...\n   |               \
    \                                       ^^^^^^^^^ method not found in `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcjcfpl9n.rs:20:30\n   |\n20 |\
    \     }).collect::<String>() + s.chars().filter(|c| !c.is_letter()).collect::<String>()\
    \ + s.chars().filter(|c| !c.is_digit()).collect::<Str...\n   |               \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                              |\n   |                              expected `&str`,\
    \ found struct `String`\n   |                              help: consider borrowing\
    \ here: `&s.chars().filter(|c| !c.is_letter()).collect::<String>()`\n\nerror[E"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::from(\"a\");\n    let mut lower\
    \ = String::from(\"z\");\n    let mut upper = String::from(\"A\");\n\n    for\
    \ i in s.chars() {\n        match i {\n            'A' | 'a' => { res += &upper;\
    \ upper = String::from(\"A\");},\n            'B' | 'b' => { res += &lower; lower\
    \ = String::from(\"B\"); },\n            'C' | 'c' => { res += &upper; upper =\
    \ String::from(\"C\");},\n            'D' | 'd' => { res += &lower; lower = String::from(\"\
    D\"); },\n            'E' | 'e' => { res += &upper; upper = String::from(\"E\"\
    );},\n            'F' | 'f' => { res += &lower; lower = String::from(\"F\"); },\n\
    \            'G' | 'g' => { res += &upper; upper = String::from(\"G\");},\n  \
    \          'H' | 'h' => { res += &lower; lower = String::from(\"H\"); },\n   \
    \         'I' | 'i' => { res += &upper; upper = String::from(\"I\");},\n     \
    \       'J' | 'j' => { res += &lower; lower = String::from(\"J\"); },\n      \
    \      'K' | 'k' => { res += &upper; upper = String::from(\"K\");},\n        \
    \    'L' | 'l' => { res += &lower; lower = String::from(\"L\"); },\n         \
    \   'M' | 'm' => { res += &upper; upper = String::from(\"M\");},\n           \
    \ 'N' | 'n' => { res += &lower; lower = String::from(\"N\"); },\n            'O'\
    \ | 'o' => { res += &upper; upper = String::from(\"O\");},\n            'P' |\
    \ 'p' => { res += &lower; lower = String::from(\"P\"); },\n            'Q' | 'q'\
    \ => { res += &upper; upper = String::from(\"Q\");},\n            'R' | 'r' =>\
    \ { res += &lower; lower = String::from(\"R\"); },\n            'S' | 's' => {\
    \ res += &upper; upper = String::from(\"S\");},\n            'T' | 't' => { res\
    \ += &lower; lower = String::from(\"T\"); },\n            'U' | 'u' => { res +=\
    \ &upper; upper = String::from(\"U\");},\n            'V' | 'v' => { res += &lower;\
    \ lower = String::from(\"V\"); },\n            'W' | 'w' => \n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3__tx8y1.rs:55:3\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n18 |     for i in s.chars() {\n   |           \
    \             - unclosed delimiter\n19 |         match i {\n   |             \
    \    - this delimiter might not be properly closed...\n...\n43 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n55 | }\n   |   ^\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmp3__tx8y1.rs:43:1\n   |\n\
    42 |             'W' | 'w' => \n   |                       -- while parsing the\
    \ `match` arm starting here\n43 | }\n   | ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3__tx8y1.rs:18:5\n   |\n13 |   fn solve(s: String)\
    \ -> String {\n   |                          ------ expected `String` because\
    \ of return type\n...\n18 | /     for i in s.chars() {\n19 | |         match i\
    \ {\n20 | |             'A' | 'a' => { res += &upper; upper = String::from(\"\
    A\");},\n21 | |             'B' | 'b' => { res += &lower; lower = String::from(\"\
    B\"); },\n...  |\n54 | |     assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n55 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.replace(s.chars().filter_map(|c| {\n\
    \        let is_letter = c.is_letter();\n        if is_letter {\n            if\
    \ c.is_lowercase() {\n                Some(c.to_uppercase().to_string())\n   \
    \         } else {\n                Some(c.to_lowercase().to_string())\n     \
    \       }\n        } else {\n            None\n        }\n    }).collect::<Vec<String>>()).to_string();\n\
    \    \n    if s.is_empty() {\n        String::new()\n    } else {\n        s\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpkhui45ks.rs:15:27\n   |\n15 |         let is_letter\
    \ = c.is_letter();\n   |                           ^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0061]: this function takes 2 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmpkhui45ks.rs:14:19\n    |\n14  |       let mut s = s.replace(s.chars().filter_map(|c|\
    \ {\n    |  ___________________^^^^^^^_-\n    | |                   |\n    | |\
    \                   expected 2 arguments\n15  | |         let is_letter = c.is_letter();\n\
    16  | |         if is_letter {\n17  | |             if c.is_lowercase() {\n...\
    \   |\n24  | |         }\n25  | |     }).collect::<Vec<String>>()).to_string();\n\
    \    | |_______________________________- supplied 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| if is_alpha_lower(c) then c.to_string().to_lowercase()\
    \ else c.to_string()).collect::<String>().to_owned()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmp3fezm90i.rs:14:44\n  \
    \ |\n14 |     s.chars().map(|c| if is_alpha_lower(c) then c.to_string().to_lowercase()\
    \ else c.to_string()).collect::<String>().to_owned()\n   |                   \
    \    --                   ^^^^ expected `{`\n   |                       |\n  \
    \ |                       this `if` expression has a condition, but no block\n\
    \   |\nhelp: try placing this code inside a block\n   |\n14 |     s.chars().map(|c|\
    \ if is_alpha_lower(c) { then } c.to_string().to_lowercase() else c.to_string()).collect::<String>().to_owned()\n\
    \   |                                            +      +\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().fold(\"1234\".to_string(), |mut c, x| {\n\
    \        if c.is_empty() {\n            c = x.to_string();\n        } else {\n\
    \            c = c.chars().fold(x.to_string(), |mut d, y| {\n                if\
    \ d.is_empty() {\n                    d = y.to_string();\n                } else\
    \ {\n                    if let Some(c) = d.chars().next() {\n               \
    \         d += c.to_ascii_lowercase().to_string();\n                    } else\
    \ {\n                        d += y.to_string();\n                    }\n    \
    \            }\n                d\n            });\n        }\n        c\n   \
    \ })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppuql2jjl.rs:23:30\n   |\n\
    23 |                         d += c.to_ascii_lowercase().to_string();\n   |  \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |        \
    \                      |\n   |                              expected `&str`, found\
    \ struct `String`\n   |                              help: consider borrowing\
    \ here: `&c.to_ascii_lowercase().to_string()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppuql2jjl.rs:25:30\n   |\n25 |                         d += y.to_string();\n\
    \   |                              ^^^^^^^^^^^^^\n   |                       \
    \       |\n   |                              expected `&str`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&y.to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars()\n        .filter(|c| is_letter(c))\n    \
    \    .fold(\n            |s, c| {\n                let mut s = c.to_lowercase();\n\
    \                if *s != c {\n                    s = c.to_uppercase();\n   \
    \             }\n                s\n            },\n            &s.to_string(),\n\
    \        )\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpiymrz5x0.rs:15:21\n\
    \   |\n15 |         .filter(|c| is_letter(c))\n   |                     ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: expected a `Fn<(_, char)>` closure,\
    \ found `String`\n    --> /tmp/tmpiymrz5x0.rs:24:13\n     |\n16   |         .fold(\n\
    \     |          ---- required by a bound introduced by this call\n...\n24   |\
    \             &s.to_string(),\n     |             ^^^^^^^^^^^^^^ expected an `Fn<(_,\
    \ char)>` closure, found `String`\n     |\n     = help: the trait `Fn<(_, char)>`\
    \ is not implemented for `String`\n     = note: required because of the requirements\
    \ on the impl of `FnMut<(_, char)>` for `&String`\nnote: required by a bound in\
    \ `fold`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| if c < 'a' || (c > 'z' && c < 'A')\
    \ || (c > 'Z') || (c < '0' && c > '9') {\n        String::from(c).to_string().to_uppercase()\n\
    \    } else {\n        String::from(c).to_string().to_lowercase()\n    }).collect::<String>()\
    \ + s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_e2f68o.rs:18:30\n   |\n\
    18 |     }).collect::<String>() + s\n   |                              ^\n   |\
    \                              |\n   |                              expected `&str`,\
    \ found struct `String`\n   |                              help: consider borrowing\
    \ here: `&s`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = s.clone();\n    let mut counter = String::new();\n\
    \    for (i, c) in s.chars().enumerate() {\n        counter.push_str(&(c.to_lowercase()));\n\
    \        if i != 0 {\n            res.push_str(&(c.to_uppercase()));\n       \
    \ }\n    }\n    res.push_str(&counter);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9t1weln0.rs:17:26\n   |\n\
    17 |         counter.push_str(&(c.to_lowercase()));\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9t1weln0.rs:19:26\n   |\n19 |\
    \             res.push_str(&(c.to_uppercase()));\n   |                       \
    \   ^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.to_lowercase();\n    let mut res = s.clone();\n\
    \n    if res.len() == 0 {\n        String::from(\"nothing\")\n    } else if res.chars().any(|c|\
    \ match c {\n        'a' => true,\n        'z' => true,\n        'A' => true,\n\
    \        'Z' => true,\n        _ => false,\n    }) {\n        let mut res_copy\
    \ = res.clone();\n        res_copy.reverse();\n        res = String::from(res_copy);\n\
    \    }\n    return res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2x23ar3f.rs:18:9\n   |\n\
    17 | /     if res.len() == 0 {\n18 | |         String::from(\"nothing\")\n   |\
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n19 |\
    \ |     } else if res.chars().any(|c| match c {\n20 | |         'a' => true,\n\
    ...  |\n28 | |         res = String::from(res_copy);\n29 | |     }\n   | |_____-\
    \ expected this to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n\
    18 |         String::from(\"nothing\");\n   |                                +\n\
    help: consider using a semicolon here\n   |\n29 |     };\n   |      +\nhelp: you\
    \ might have meant to return this value\n   |\n18 |         return String::from(\"\
    nothing\");\n   |         ++++++                        +\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp2x23ar3f.rs:27:18\n   |\n27 |         res_copy.reverse();\n   |    \
    \              ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if let Ok(mut s) = s.chars() {\n        while let Some(mut\
    \ c) = s.next() {\n            if c.is_ascii_lowercase() {\n                c.to_ascii_uppercase();\n\
    \            } else {\n                c.to_ascii_lowercase();\n            }\n\
    \        }\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ceyew03.rs:14:12\n   |\n\
    14 |     if let Ok(mut s) = s.chars() {\n   |            ^^^^^^^^^   ---------\
    \ this expression has type `Chars<'_>`\n   |            |\n   |            expected\
    \ struct `Chars`, found enum `Result`\n   |\n   = note: expected struct `Chars<'_>`\n\
    \                found enum `Result<_, _>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    match s {\n        s => s.to_string()\n     \
    \       .chars()\n            .filter_map(|x| if x.is_a< char> { x.to_string()\
    \ + x.to_string().to_lowercase() } else { x })\n            .collect::<Vec<_>>()\n\
    \            .iter()\n            .fold(\"\".to_string(), |mut acc, char| match\
    \ char {\n                c if c.is_a< char> => {\n                    let mut\
    \ res = acc;\n                    res.push_str(&mut c.to_lowercase());\n     \
    \               res\n                },\n                c => {\n            \
    \        let mut res = acc;\n                    res.push_str(&mut c);\n     \
    \               res\n                }\n            })\n            .to_string(),\n\
    \        None => s.to_string()\n            .chars()\n            .map(|x| if\
    \ x.is_a< char> { x.to_string() + x.to_string().to_lowercase() } else { x })\n\
    \            .collect::<Vec<_>>()\n            .iter()\n            .fold(\"\"\
    .to_string(), |mut acc, char| match char {\n                c if c.is_a< char>\
    \ => {\n                    let mut res = acc;\n                    res.push_str(&mut\
    \ c.to_lowercase());\n                    res\n                },\n          \
    \      c => {\n                    let mut res = acc;\n                    res.push_str(&mut\
    \ c);\n                    res\n                }\n            })\n          \
    \  .to_string(),\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpouiokb8h.rs:18:38\n\
    \   |\n16 |         s => s.to_string()\n   |           -- while parsing the `match`\
    \ arm starting here\n17 |             .chars()\n18 |             .filter_map(|x|\
    \ if x.is_a< char> { x.to_string() + x.to_string().to_lowercase() } else { x })\n\
    \   |                                      ^     ^\n   |\n   = help: use `::<...>`\
    \ instead of `<...>` to specify lifetime, type, or const arguments\n   = help:\
    \ or use `(...)` if you meant to specify fn arguments\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut chars = s.chars();\n    chars.next().unwrap();\n\
    \    if chars.next() != Some('a'){\n        chars.next().unwrap();\n    }\n  \
    \  let mut result = String::new();\n    let mut cur = chars.next().unwrap();\n\
    \    loop {\n        if cur == Some('a') {\n            if chars.next() == Some('z')\
    \ {\n                cur = chars.next().unwrap();\n            }\n           \
    \ else\n                cur = chars.next().unwrap();\n        }\n        else\
    \ if cur == Some('z') {\n            if chars.next() == Some('a') { \n       \
    \         cur = chars.next().unwrap();\n            }\n            else\n    \
    \            cur = chars.next().unwrap();\n        }\n        else \n        \
    \    result.push(*cur);\n        cur = chars.next().unwrap();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `cur`\n  --> /tmp/tmpcijshh69.rs:27:17\n   |\n\
    27 |                 cur = chars.next().unwrap();\n   |                 ^^^ expected\
    \ `{`\n   |\nhelp: try placing this code inside a block\n   |\n27 |          \
    \       { cur = chars.next().unwrap(); }\n   |                 +             \
    \                 +\n\nerror: expected `{`, found `cur`\n  --> /tmp/tmpcijshh69.rs:34:17\n\
    \   |\n34 |                 cur = chars.next().unwrap();\n   |               \
    \  ^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n\
    34 |                 { cur = chars.next().unwrap(); }\n   |                 +\
    \                              +\n\nerror: expected `{`, found `result`\n  -->\
    \ /tmp/tmpcijshh69.rs:37:13\n   |\n37 |             result.push(*cur);\n   | \
    \            ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n\
    \   |\n37 |             { result.push(*cur); }\n   |             +           \
    \         +\n\nwarning: unreachable expression\n  --> /tmp/tmpcijshh69.rs:40:5\n\
    \   |\n21 | /     loop {\n22 | |         if cur == Some('a') {\n23 | |       \
    \      if chars.next() == Some('z') {\n24 | |                 cur = chars.next().unwrap();\n\
    ...  |\n38 | |         cur = chars.next().unwrap();\n39 | |     }\n   | |_____-\
    \ any code following this expression is unreachable\n40 |       result\n   | \
    \      ^^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() { return String::new(); }\n    let\
    \ mut str = String::new();\n    for ch in s {\n        let cap = match ch {\n\
    \            'a' => false,\n            'A' => false,\n            '#' => true,\n\
    \            _ => false,\n        };\n        if cap {\n            str = str.chars().filter_map(|c|\
    \ if c == 'A' { 'a' } else { c }).collect();\n        } else {\n            str\
    \ = str.chars().filter_map(|c| if c == 'a' { 'A' } else { c }).collect();\n  \
    \      }\n    }\n    str\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpyl3ue7hs.rs:16:15\n\
    \   |\n16 |     for ch in s {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyl3ue7hs.rs:24:60\n   |\n24 |             str = str.chars().filter_map(|c|\
    \ if c == 'A' { 'a' } else { c }).collect();\n   |                           \
    \                                 ^^^ expected enum `Option`, found `char`\n \
    \  |\n   = note: expected enum `Option<_>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n24 |             str = str.chars().filter_map(|c|\
    \ if c == 'A' { Some('a') } else { c }).collect();\n   |                     \
    \                                       +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyl3ue7hs.rs:24:73\n   |\n24 |             str = str.chars().filter_map(|c|\
    \ if c == 'A' { 'a' } else { c }).collect();\n   |                           \
    \                                              ^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `char`\nhelp: try wrapping the expression in `Some`\n   |\n24 |            \
    \ str = str.chars().filter_map(|c| if c == 'A' { 'a' } else { Some(c) }).collect();\n\
    \   |                                                                        \
    \ +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyl3ue7hs.rs:26:60\n\
    \   |\n26 |             str = str.chars().filter_map(|c| if c == 'a' { 'A' } else\
    \ { c }).collect();\n   |                                                    \
    \        ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum\
    \ `Option<_>`\n              found type `char`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n26 |             str = str.chars().filter_map(|c| if c == 'a'\
    \ { Some('A') } else { c }).collect();\n   |                                 \
    \                         "
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    match s.chars() {\n        // reverse the case of the\
    \ letter if there is one\n        char::is_letter => (s.to_string().chars().enumerate().filter_map(|(i,\
    \ _)| {\n            Some((\n                match i {\n                    //\
    \ reverse the case of the letter if there is one\n                    0 => Some(s.chars().nth(i).unwrap().to_ascii_lowercase()),\n\
    \                    n => Some(s.chars().nth(i).unwrap().to_ascii_uppercase()),\n\
    \                    _ => None,\n                }\n            ))\n        }).collect()).join(\"\
    \"),\n\n        _ => s,\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around function argument\n  --> /tmp/tmpdkjdgw13.rs:17:18\n\
    \   |\n17 |               Some((\n   |  __________________^\n18 | |          \
    \       match i {\n   | |________________^\n...\n23 |                   }\n  \
    \ |  __________________^\n24 | |             ))\n   | |_____________^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n17 ~             Some(match i {\n18 |                     // reverse the\
    \ case of the letter if there is one\n19 |                     0 => Some(s.chars().nth(i).unwrap().to_ascii_lowercase()),\n\
    20 |                     n => Some(s.chars().nth(i).unwrap().to_ascii_uppercase()),\n\
    21 |                     _ => None,\n22 ~                 })\n   |\n\nerror[E0599]:\
    \ no function or associated item named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdkjdgw13.rs:16:15\n   |\n16 |         char::is_letter\
    \ => (s.to_string().chars().enumerate().filter_map(|(i, _)| {\n   |          \
    \     ^^^^^^^^^ function or associated item not found in `char`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut chars = s.chars();\n\
    \    chars.reverse();\n    s = chars.collect();\n    String::from(s)\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpoxd2i46b.rs:16:11\n   |\n16 |     chars.reverse();\n\
    \   |           ^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    // Fn returns String\n    let mut new_s = s;\n\n  \
    \  let mut i = 0;\n\n    while i < new_s.len() {\n        if new_s[i..].chars().any(|&x|\
    \ x >= 'A' && x <= 'Z') {\n            new_s = new_s.to_string().to_lowercase();\n\
    \            i += 1;\n            continue;\n        }\n        if new_s[i..].chars().any(|&x|\
    \ x >= 'a' && x <= 'z') {\n            new_s = new_s.to_string().to_uppercase();\n\
    \            i += 1;\n            continue;\n        }\n        i += 1;\n    }\n\
    \n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdvkouxoo.rs:20:36\n   |\n\
    20 |         if new_s[i..].chars().any(|&x| x >= 'A' && x <= 'Z') {\n   |    \
    \                                ^--\n   |                                   \
    \ ||\n   |                                    |expected due to this\n   |    \
    \                                expected `char`, found reference\n   |      \
    \                              help: did you mean `x`: `&char`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdvkouxoo.rs:25:36\n   |\n25 |         if new_s[i..].chars().any(|&x|\
    \ x >= 'a' && x <= 'z') {\n   |                                    ^--\n   | \
    \                                   ||\n   |                                 \
    \   |expected due to this\n   |                                    expected `char`,\
    \ found reference\n   |                                    help: did you mean\
    \ `x`: `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if !s.is_empty() && s.chars().all(|c| c.is_letter())\
    \ {\n        let mut reversed_s = s.chars().enumerate().rev().map(|(i, char)|\
    \ {\n            if i % 2 == 0 {\n                char.to_upper().to_string()\n\
    \            } else {\n                char.to_lowercase().to_string()\n     \
    \       }\n        }).collect();\n        reversed_s.insert(0, s.chars().collect());\n\
    \        reversed_s.insert(0, s.chars().count());\n        return String::from(reversed_s);\n\
    \    } else {\n        return s.chars().collect();\n    }\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpqxbnkx8c.rs:14:45\n   |\n14 |     if !s.is_empty()\
    \ && s.chars().all(|c| c.is_letter()) {\n   |                                \
    \             ^^^^^^^^^ method not found in `char`\n\nerror[E0277]: the trait\
    \ bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpqxbnkx8c.rs:15:52\n\
    \     |\n15   |         let mut reversed_s = s.chars().enumerate().rev().map(|(i,\
    \ char)| {\n     |                                                    ^^^ the\
    \ trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     =\
    \ help: the following other types implement trait `ExactSizeIterator`:\n     \
    \          &mut I\n               Args\n               ArgsOs\n              \
    \ ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n           \
    \    ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0599]: the method `map` exists for struct `Rev<Enumerate<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpqxbnkx8c.rs:15:58\n \
    \  |\n15 |           let mut reversed_s = s.chars().enumerate().rev().map(|(i,\
    \ char)| {\n   |                                                            ^^^\
    \ method cannot be called on `Rev<Enumerate<Chars<'_>>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `Enumerate<Chars<'_>>: DoubleEndedIterator`\n           which is required\
    \ by `Rev<Enumerate<Chars<'_>>>: Iterator`\n           `Rev<Enumerate<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Rev<Enumerate<Chars<'_>>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().fold(String::new(), |result, c| match c {\n\
    \        Some('a'..='z') => result.push_str(c.to_string()),\n        Some('A'..='Z')\
    \ => result.push_str(c.to_string() + c.to_string()),\n        Some(_) => result.push_str(c.to_string()),\n\
    \        None => result.push_str(c.to_string()),\n    })\n}\n\nfn main() {\n \
    \   let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsegxehb7.rs:15:9\n   |\n\
    14 |     s.chars().fold(String::new(), |result, c| match c {\n   |           \
    \                                          - this expression has type `char`\n\
    15 |         Some('a'..='z') => result.push_str(c.to_string()),\n   |        \
    \ ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsegxehb7.rs:16:9\n   |\n14 |     s.chars().fold(String::new(),\
    \ |result, c| match c {\n   |                                                \
    \     - this expression has type `char`\n15 |         Some('a'..='z') => result.push_str(c.to_string()),\n\
    16 |         Some('A'..='Z') => result.push_str(c.to_string() + c.to_string()),\n\
    \   |         ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   =\
    \ note: expected type `char`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsegxehb7.rs:17:9\n   |\n14 |     s.chars().fold(String::new(),\
    \ |result, c| match c {\n   |                                                \
    \     - this expression has type `char`\n...\n17 |         Some(_) => result.push_str(c.to_string()),\n\
    \   |         ^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsegxehb7.rs:18:9\n   |\n14 |     s.chars().fold(String::new(),\
    \ |result, c| match c {\n   |                                                \
    \     - this expression has type `char`\n...\n18 |         None => result.push_str(c.to_string()),\n\
    \   |         ^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsegxehb7.rs:15:44\n   |\n15 |         Some('a'..='z') =>\
    \ result.push_str(c.to_string()),\n   |                                      \
    \      ^^^^^^^^^^^^^\n   |                                            |\n   |\
    \                                            expected `"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    match s.chars().count(|c| is_letter(c.to_ascii_lowercase())\
    \ || is_letter(c.to_ascii_uppercase())) {\n        0 => s,\n        _ => reverse(s),\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmprwt0msko.rs:14:31\n\
    \   |\n14 |     match s.chars().count(|c| is_letter(c.to_ascii_lowercase()) ||\
    \ is_letter(c.to_ascii_uppercase())) {\n   |                               ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in\
    \ this scope\n  --> /tmp/tmprwt0msko.rs:14:68\n   |\n14 |     match s.chars().count(|c|\
    \ is_letter(c.to_ascii_lowercase()) || is_letter(c.to_ascii_uppercase())) {\n\
    \   |                                                                    ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `reverse` in this\
    \ scope\n  --> /tmp/tmprwt0msko.rs:16:14\n   |\n16 |         _ => reverse(s),\n\
    \   |              ^^^^^^^ not found in this scope\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprwt0msko.rs:14:21\n\
    \    |\n14  |     match s.chars().count(|c| is_letter(c.to_ascii_lowercase())\
    \ || is_letter(c.to_ascii_uppercase())) {\n    |                     ^^^^^ --------------------------------------------------------------------------\
    \ supplied 1 argument\n    |                     |\n    |                    \
    \ expected 0 arguments\n    |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0425.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve(s0, s.chars()).to_owned()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `s0` in this scope\n  --> /tmp/tmp8qeqf7e1.rs:14:11\n\
    \   |\n14 |     solve(s0, s.chars()).to_owned()\n   |           ^^ help: a local\
    \ variable with a similar name exists: `s`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n  --> /tmp/tmp8qeqf7e1.rs:14:5\n \
    \  |\n14 |     solve(s0, s.chars()).to_owned()\n   |     ^^^^^ --  --------- supplied\
    \ 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote: function\
    \ defined here\n  --> /tmp/tmp8qeqf7e1.rs:13:4\n   |\n13 | fn solve(s: String)\
    \ -> String {\n   |    ^^^^^ ---------\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        String::new()\n    } else\
    \ {\n        let mut s = String::from(*s);\n        for i in 0..s.len() {\n  \
    \          if s[i].is_ascii_letter() {\n                if s.starts_with(s.chars().skip(i).rev().collect::<String>())\
    \ {\n                    s = s.replace(i+1, i+1, s[i].to_ascii_lowercase());\n\
    \                } else {\n                    s = s.replace(i+1, i+1, s[i].to_ascii_uppercase());\n\
    \                }\n            } else {\n                s = s.replace(i+1, i+1,\
    \ s[i]);\n            }\n        }\n        \n        s\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpa40sg2ip.rs:17:34\n    |\n17  |         let mut s = String::from(*s);\n\
    \    |                     ------------ ^^ doesn't have a size known at compile-time\n\
    \    |                     |\n    |                     required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `from`\n\nerror[E0277]: the trait bound `String:\
    \ From<str>` is not satisfied\n  --> /tmp/tmpa40sg2ip.rs:17:21\n   |\n17 |   \
    \      let mut s = String::from(*s);\n   |                     ^^^^^^^^^^^^ the\
    \ trait `From<str>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpa40sg2ip.rs:19:16\n   |\n19 |  \
    \           if s[i].is_ascii_letter() {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is\
    \ not satisfied\n    --> /tmp/tmpa40sg2ip.rs:20:52\n     |\n20   |           \
    \      if s.starts_with(s.chars().skip(i).rev().collect::<String>()) {\n     |\
    \                                                    ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    // return s if s is empty\n    if s.is_empty() {\n\
    \        return s;\n    }\n\n    // count how many letters in s\n    let mut letter_count:\
    \ usize = 0;\n    for c in s.chars() {\n        if c.is_ascii() {\n          \
    \  letter_count += 1;\n        }\n    }\n\n    // create string with new length\n\
    \    let mut result = String::with_capacity(s.len() * letter_count + s.len());\n\
    \n    // copy the s\n    result.extend(s.chars());\n\n    // reverse every letters\n\
    \    for c in result.chars() {\n        if c.is_ascii() {\n            let mut\
    \ s = c.to_ascii_lowercase();\n            if s.is_ascii() {\n               \
    \ s = s.to_ascii_uppercase();\n            }\n            c.replace(s);\n    \
    \    }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `replace` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgb47evg8.rs:40:15\n   |\n40 |             c.replace(s);\n\
    \   |               ^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter(|c| c.is_ascii_lowercase()).map(|c|\
    \ c.to_ascii_lowercase()).collect()\n        .join().chars().filter(|c| c.is_ascii_uppercase()).map(|c|\
    \ c.to_ascii_uppercase()).collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp6mcq8y1r.rs:14:82\n\
    \   |\n14 |     s.chars().filter(|c| c.is_ascii_lowercase()).map(|c| c.to_ascii_lowercase()).collect()\n\
    \   |                                                                        \
    \          ^^^^^^^ cannot infer type for type parameter `B` declared on the associated\
    \ function `collect`\n   |\n   = note: type must be known at this point\nhelp:\
    \ consider specifying the type argument in the method call\n   |\n14 |     s.chars().filter(|c|\
    \ c.is_ascii_lowercase()).map(|c| c.to_ascii_lowercase()).collect::<B>()\n   |\
    \                                                                            \
    \             +++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    s.chars().enumerate().fold(String::from(\"?\"\
    ), |mut acc, (idx, ch)| {\n        let (mut x, mut y) = (acc, \"?\");\n      \
    \  let char = s.chars().nth(idx);\n        if let Some(is_letter) = char.ascii_lowercase()\
    \ {\n            x =  &mut ch.to_ascii_uppercase();\n        }\n        if let\
    \ Some(is_letter) = char.ascii_uppercase() {\n            y = &mut ch.to_ascii_lowercase();\n\
    \        }\n        acc\n    });\n    \n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ascii_lowercase` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpci_1l61n.rs:18:39\n   |\n18 |         if\
    \ let Some(is_letter) = char.ascii_lowercase() {\n   |                       \
    \                ^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpci_1l61n.rs:19:18\n   |\n16 |         let (mut\
    \ x, mut y) = (acc, \"?\");\n   |              ----- expected due to the type\
    \ of this binding\n...\n19 |             x =  &mut ch.to_ascii_uppercase();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&mut char`\n   |\nhelp: try using a conversion method\n   |\n19 |   \
    \          x =  (&mut ch.to_ascii_uppercase()).to_string();\n   |            \
    \      +                            +++++++++++++\n\nerror[E0599]: no method named\
    \ `ascii_uppercase` found for enum `Option` in the current scope\n  --> /tmp/tmpci_1l61n.rs:21:39\n\
    \   |\n21 |         if let Some(is_letter) = char.ascii_uppercase() {\n   |  \
    \                                     ^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpci_1l61n.rs:22:17\n   |\n16 |\
    \         let (mut x, mut y) = (acc, \"?\");\n   |                     ----- expected\
    \ due to the type of this binding\n...\n22 |             y = &mut ch.to_ascii_lowercase();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note:      expected reference `&str`\n           found mutable reference\
    \ `&mut char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpci_1l61n.rs:13:24\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n25 |     });\n   |\
    \       - help: remove this semicolon\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.len() == 0 {\n        String::from(\"\")\n   \
    \ } else {\n        let mut rev = s.chars().collect::<Vec<char>>();\n        rev.rev();\n\
    \        rev.join(\"\").to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmpgltgn_5j.rs:18:13\n\
    \    |\n18  |           rev.rev();\n    |               ^^^ `Vec<char>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>:\
    \ Iterator`\n            `[char]: Iterator`\n            which is required by\
    \ `&mut [char]: Iterator`\n\nerror[E0599]: the method `join` exists for struct\
    \ `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmpgltgn_5j.rs:19:13\n\
    \   |\n19 |         rev.join(\"\").to_string()\n   |             ^^^^ method cannot\
    \ be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let len = s.len();\n\
    \    for i in 0..len {\n        let char = s[i]; // char here is String, not char.char()\n\
    \        if char.is_ascii_lowercase() {\n            res.push_str(&s[len - i -\
    \ 1].to_ascii_lowercase());\n        } else {\n            res.push_str(&s[len\
    \ - i - 1].to_ascii_uppercase());\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuqz2ehpv.rs:17:20\n\
    \   |\n17 |         let char = s[i]; // char here is String, not char.char()\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuqz2ehpv.rs:19:27\n\
    \   |\n19 |             res.push_str(&s[len - i - 1].to_ascii_lowercase());\n\
    \   |                           ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuqz2ehpv.rs:21:27\n   |\n21 |             res.push_str(&s[len -\
    \ i - 1].to_ascii_uppercase());\n   |                           ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    while !s.is_empty() {\n       \
    \ if s.is_alphanumeric() {\n            s = s.to_lowercase().to_uppercase();\n\
    \        }\n        else{\n            s = s.to_lowercase();\n        }\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_alphanumeric` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp54_g1tih.rs:16:14\n   |\n16 |         if\
    \ s.is_alphanumeric() {\n   |              ^^^^^^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return String::from(\"1\"\
    );\n    }\n    let mut result = String::new();\n    for i in 0..s.len() {\n  \
    \      match s[i].to_ascii_lowercase() {\n            Some('a') => result.append(&'A'\
    \ - 'a'),\n            Some('z') => result.append(&'Z' - 'z'),\n            Some(c)\
    \ => result.append(&c - 'a'),\n            None => result.append(&s[i] - 'a'),\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnt3bpho4.rs:19:15\n\
    \   |\n19 |         match s[i].to_ascii_lowercase() {\n   |               ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpnt3bpho4.rs:20:33\n   |\n20 |          \
    \   Some('a') => result.append(&'A' - 'a'),\n   |                            \
    \     ^^^^^^ method not found in `String`\n\nerror[E0369]: cannot subtract `char`\
    \ from `&char`\n  --> /tmp/tmpnt3bpho4.rs:20:45\n   |\n20 |             Some('a')\
    \ => result.append(&'A' - 'a'),\n   |                                        ----\
    \ ^ --- char\n   |                                        |\n   |            \
    \                            &char\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpnt3bpho4.rs:21:33\n\
    \   |\n21 |             Some('z') => result.append(&'Z' - 'z'),\n   |        \
    \                         ^^^^^^ method not found in `String`\n\nerror[E0369]:\
    \ cannot subtract `char` from `&char`\n  --> /tmp/tmpnt3bpho4.rs:21:45\n   |\n\
    21 |             Some('z') => result.append(&'Z' - 'z'),\n   |               \
    \                         ---- ^ --- char\n   |                              \
    \          |\n   |                                        &char\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpnt3bpho4.rs:22:31\n   |\n22 |             Some(c) => result.append(&c\
    \ - 'a'),\n   |                               ^^^^^^ method not found in `String`\n\
    \nerror[E0"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut i = 0;\n    loop {\n  \
    \      if s[i].is_ascii() {\n            let j = (i + 1) % (s.len() - 1);\n  \
    \          s[i] = s[s.len() - j];\n            s[i] = s[i].to_upper();\n     \
    \       i += 1;\n        } else {\n            i += 1;\n        }\n        if\
    \ i >= s.len() {\n            break;\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp9_y5us0h.rs:17:12\n   |\n17 |         if s[i].is_ascii() {\n   |   \
    \         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9_y5us0h.rs:19:13\n   |\n19 |             s[i] = s[s.len() - j];\n\
    \   |             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9_y5us0h.rs:19:20\n   |\n19 |             s[i] = s[s.len() - j];\n\
    \   |                    ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    \n    let mut res = String::new();\n    for e in s.chars()\
    \ {\n        let ch = match e.to_lowercase() {\n            \"a\" => e.to_uppercase(),\n\
    \            \"b\" => e.to_lowercase(),\n            \"c\" => e.to_uppercase(),\n\
    \            \"d\" => e.to_lowercase(),\n            _ => e,\n        };\n   \
    \     res.push_str(&ch);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjs93p9pb.rs:18:13\n   |\n\
    17 |         let ch = match e.to_lowercase() {\n   |                        ----------------\
    \ this expression has type `ToLowercase`\n18 |             \"a\" => e.to_uppercase(),\n\
    \   |             ^^^ expected struct `ToLowercase`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjs93p9pb.rs:19:13\n   |\n17 |         let ch\
    \ = match e.to_lowercase() {\n   |                        ---------------- this\
    \ expression has type `ToLowercase`\n18 |             \"a\" => e.to_uppercase(),\n\
    19 |             \"b\" => e.to_lowercase(),\n   |             ^^^ expected struct\
    \ `ToLowercase`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjs93p9pb.rs:20:13\n\
    \   |\n17 |         let ch = match e.to_lowercase() {\n   |                  \
    \      ---------------- this expression has type `ToLowercase`\n...\n20 |    \
    \         \"c\" => e.to_uppercase(),\n   |             ^^^ expected struct `ToLowercase`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjs93p9pb.rs:21:13\n\
    \   |\n17 |         let ch = match e.to_lowercase() {\n   |                  \
    \      ---------------- this expression has type `ToLowercase`\n...\n21 |    \
    \         \"d\" => e.to_lowercase(),\n   |             ^^^ expected struct `ToLowercase`,\
    \ found `&str`\n\nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpjs93p9pb.rs:19:20\n\
    \   |\n17 |           let ch = match e.to_lowercase() {\n   |  __________________-\n\
    18 | |             \"a\" => e.to_uppercase(),\n   | |                    ----------------\
    \ this is found to be of type `ToUppercase`\n19 | |             \"b\" => e.to_lowercase(),\n\
    \   | |                    ^^^^^^^^^^^^^^^^ expected struct `ToUppercase`, found\
    \ struct `ToLowercase`\n20 | |             \"c\" => e.to_uppercase(),\n21 | |\
    \             \"d\" => e.to_lowercase(),\n22 | |             _ => e,\n23 | | \
    \        };\n   | |_________- `match` arms have incompatible types\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    loop {\n        if s.is_empty()\
    \ {\n            return s;\n        }\n        if s.chars().any(|c| c != 'a' &&\
    \ c != 'A' && c != '#' && c != '$') {\n            return s;\n        }\n    \
    \    let len = s.len();\n        s.chars().cloned()\n            .enumerate()\n\
    \            .for_each(|(i, c)| {\n                if *c.is_uppercase() {\n  \
    \                  s.swap(i, len - i - 1);\n                }\n            });\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpmc_553hw.rs:23:19\n     |\n23   |         s.chars().cloned()\n\
    \     |                   ^^^^^^ expected reference, found `char`\n     |\n  \
    \   = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `enumerate`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpmc_553hw.rs:24:14\n   |\n24 |               .enumerate()\n   |\
    \                ^^^^^^^^^ method cannot be called on `Cloned<Chars<'_>>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n          \
    \ which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpmc_553hw.rs:27:23\n   |\n27 |                     s.swap(i,\
    \ len - i - 1);\n   |                       ^^^^ method not found in `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.len() == 0 {\n        return s;\n    }\n    let\
    \ mut result = String::new();\n    for i in s.chars() {\n        if i.is_ascii_lowercase()\
    \ {\n            result.push_str(i.to_uppercase());\n        } else {\n      \
    \      result.push_str(i.to_lowercase());\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpry8_2b7s.rs:20:29\n   |\n\
    20 |             result.push_str(i.to_uppercase());\n   |                    \
    \         ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToUppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpry8_2b7s.rs:22:29\n   |\n22 |             result.push_str(i.to_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `ToLowercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if !s.is_ascii() {\n        String::from_utf8(s.to_utf8()).unwrap().into()\n\
    \    } else {\n        let mut s = String::new();\n        iterate_string_by_char_case(s,\
    \ |c| {\n            match c {\n                'A' | 'a' => return 'B',\n   \
    \             'B' | 'b' => return 'A',\n                'C' | 'c' => return 'a',\n\
    \                'a' | 'A' => return 'b',\n                'b' | 'B' => return\
    \ 'C',\n                'C' | 'c' => return 'A',\n                'd' | 'D' =>\
    \ return 'D',\n                'D' | 'd' => return 'd',\n                'e' |\
    \ 'E' => return 'E',\n                'E' | 'e' => return 'e',\n             \
    \   'f' | 'F' => return 'F',\n                'F' | 'f' => return 'f',\n     \
    \           'G' | 'g' => return 'G',\n                'G' | 'g' => return 'g',\n\
    \                'h' | 'H' => return 'H',\n                'H' | 'h' => return\
    \ 'h',\n                'i' | 'I' => return 'I',\n                'I' | 'i' =>\
    \ return 'i',\n                'j' | 'J' => return 'J',\n                'J' |\
    \ 'j' => return 'j',\n                'k' | 'K' => return 'K',\n             \
    \   'K' | 'k' => return 'k',\n                'l' | 'L' => return 'L',\n     \
    \           'L' | 'l' => return 'l',\n                'm' | 'M' => return 'M',\n\
    \                'M' | 'm' => return 'm',\n                'n' | 'N' => return\
    \ 'N',\n                'N' | 'n' => return 'n',\n                'o' | 'O' =>\
    \ return 'O',\n                'O' | 'o' => return 'o',\n                'p' |\
    \ 'P' => return 'P',\n                'P' | 'p' => return 'p',\n             \
    \   'q' | 'Q' => return 'Q',\n                'Q' | 'q' => return 'q',\n     \
    \           'r' | 'R' => return 'R',\n                'R' | 'r' => return 'r',\n\
    \                's' | 'S' => return 'S',\n                'S' | 's' => return\
    \ 's',\n                't' | 'T' => return 'T',\n                'T' | 't' =>\
    \ return 't',\n                'u' | 'U' => return 'U',\n                'U' |\
    \ 'u' => return 'u',\n                'v' | 'V' => return 'V',\n             \
    \   'V' | 'v' => return 'v',\n                'w' | 'W' => return 'W',\n     \
    \           'W' | 'w' => return 'w',\n                'x' | 'X' => return 'X',\n\
    \                'X' | 'x' => return 'x',\n\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4xtqjli0.rs:81:3\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n16 |     } else {\n   |            - unclosed delimiter\n\
    17 |         let mut s = String::new();\n18 |         iterate_string_by_char_case(s,\
    \ |c| {\n   |                                    -       - unclosed delimiter\n\
    \   |                                    |\n   |                             \
    \       unclosed delimiter\n19 |             match c {\n   |                 \
    \    - this delimiter might not be properly closed...\n...\n69 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n81 | }\n   |   ^\n\n\
    error[E0425]: cannot find function `iterate_string_by_char_case` in this scope\n\
    \  --> /tmp/tmp4xtqjli0.rs:18:9\n   |\n18 |         iterate_string_by_char_case(s,\
    \ |c| {\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `to_utf8` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4xtqjli0.rs:15:29\n   |\n15 |         String::from_utf8(s.to_utf8()).unwrap().into()\n\
    \   |                             ^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars()\n        .map(|c| if c.is_letter() {\n  \
    \          (c.to_lowercase(), c.to_uppercase())\n        } else {\n          \
    \  (c, c)\n        })\n        .fold(String::new(), |mut s, (c, u)| {\n      \
    \      if let (Some(c), Some(u)) = (c, u) {\n                let mut s = String::from(s);\n\
    \                let mut i = s.len();\n                s.insert((i >> 1).saturating_add(i),\
    \ c);\n                s.insert((i >> 1).saturating_add(i + 1), u);\n        \
    \        s\n            } else {\n                s\n            }\n        });\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpg8_tobpo.rs:15:23\n   |\n15 |         .map(|c|\
    \ if c.is_letter() {\n   |                       ^^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpg8_tobpo.rs:18:13\n\
    \   |\n15 |           .map(|c| if c.is_letter() {\n   |  __________________-\n\
    16 | |             (c.to_lowercase(), c.to_uppercase())\n   | |             ------------------------------------\
    \ expected because of this\n17 | |         } else {\n18 | |             (c, c)\n\
    \   | |             ^^^^^^ expected struct `ToLowercase`, found `char`\n19 | |\
    \         })\n   | |_________- `if` and `else` have incompatible types\n   |\n\
    \   = note: expected tuple `(ToLowercase, ToUppercase)`\n              found tuple\
    \ `(char, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg8_tobpo.rs:13:24\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n30 |         });\n\
    \   |           - help: remove this semicolon\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::from(\"0\");\n    let mut t =\
    \ s.chars();\n    for c in t {\n        if c.is_lowercase() {\n            res.push_str(c.to_uppercase());\n\
    \        } else if c.is_uppercase() {\n            res.push_str(c.to_lowercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    res.trim_left_until(1);\n\
    \    return res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb4mz1yia.rs:18:26\n   |\n\
    18 |             res.push_str(c.to_uppercase());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToUppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb4mz1yia.rs:20:26\n   |\n20 |             res.push_str(c.to_lowercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `ToLowercase`\n\nerror[E0599]: no method named `trim_left_until` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpb4mz1yia.rs:25:9\n   |\n25 |  \
    \   res.trim_left_until(1);\n   |         ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `trim_left`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars()\n        .filter(|c| c != b'@')\n       \
    \ .map(|c| if c == b'A' {\n            b'Z'\n        } else {\n            b'a'\n\
    \        })\n        .collect()\n        .to_string()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj1pv28s6.rs:15:26\n   |\n\
    15 |         .filter(|c| c != b'@')\n   |                          ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0277]: can't compare `&char` with `u8`\n  --> /tmp/tmpj1pv28s6.rs:15:23\n\
    \   |\n15 |         .filter(|c| c != b'@')\n   |                       ^^ no implementation\
    \ for `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj1pv28s6.rs:16:26\n   |\n16 |  \
    \       .map(|c| if c == b'A' {\n   |                          ^^^^ expected `char`,\
    \ found `u8`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().map(|c| if c.is_alphanumeric() {\n      \
    \  c.to_ascii_lowercase()\n    } else {\n        c.to_ascii_uppercase()\n    }).chain(s.chars()).collect::<Vec<_>>().map(|s|\
    \ s.to_string()).collect()\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmpug7fh7fa.rs:18:45\n\
    \    |\n18  |       }).chain(s.chars()).collect::<Vec<_>>().map(|s| s.to_string()).collect()\n\
    \    |                                               ^^^ `Vec<char>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>:\
    \ Iterator`\n            `[char]: Iterator`\n            which is required by\
    \ `&mut [char]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if let Some(iter) = s.chars().filter_map(|c| {\n  \
    \      match c {\n            c if c >= 'a' && c <= 'z' => Some((c - 'a' + 10).to_string()),\n\
    \            c if c >= 'A' && c <= 'Z' => Some((c - 'A' + 10).to_string()),\n\
    \            _ => None,\n        }\n    }) {\n        s.reverse();\n        iter\n\
    \    } else {\n        s.reverse();\n        String::from(\"\")\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp0gs8f6ww.rs:16:50\n\
    \   |\n16 |             c if c >= 'a' && c <= 'z' => Some((c - 'a' + 10).to_string()),\n\
    \   |                                                - ^ --- char\n   |      \
    \                                          |\n   |                           \
    \                     char\n\nerror[E0369]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmp0gs8f6ww.rs:17:50\n   |\n17 |             c if c >= 'A' && c <=\
    \ 'Z' => Some((c - 'A' + 10).to_string()),\n   |                             \
    \                   - ^ --- char\n   |                                       \
    \         |\n   |                                                char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0gs8f6ww.rs:14:12\n   |\n14 |        if let\
    \ Some(iter) = s.chars().filter_map(|c| {\n   |   ____________^^^^^^^^^^___-____________________-\n\
    \   |  |____________|____________|\n   | ||            |\n   | ||            expected\
    \ struct `FilterMap`, found enum `Option`\n15 | ||         match c {\n16 | ||\
    \             c if c >= 'a' && c <= 'z' => Some((c - 'a' + 10).to_string()),\n\
    17 | ||             c if c >= 'A' && c <= 'Z' => Some((c - 'A' + 10).to_string()),\n\
    18 | ||             _ => None,\n19 | ||         }\n20 | ||     }) {\n   | ||_____--\
    \ this expression has type `FilterMap<Chars<'_>, [closure@/tmp/tmp0gs8f6ww.rs:14:46:\
    \ 20:6]>`\n   |  |_____|\n   |        the expected closure\n   |\n   = note: expected\
    \ struct `FilterMap<Chars<'_>, [closure@/tmp/tmp0gs8f6ww.rs:14:46: 20:6]>`\n \
    \               found enum `Option<_>`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp0gs8f6ww.rs:21:11\n\
    \   |\n21 |         s.reverse();\n   |           ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp0gs8f6ww.rs:24:11\n\
    \   |\n24 |         s.reverse();\n   |           ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    \n    for c in s.chars().filter(|c|\
    \ c.is_ascii()) {\n        match c.to_ascii_lowercase() {\n            Some(c)\
    \ => s.insert(c, s.len() - c.len() as i32),\n            None => ()\n        }\n\
    \    }\n\n    if s.chars().count() != 0 {\n        s\n    } else {\n        String::from(s.to_ascii_lowercase().unwrap())\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdtkqstw.rs:18:13\n   |\n\
    17 |         match c.to_ascii_lowercase() {\n   |               ----------------------\
    \ this expression has type `char`\n18 |             Some(c) => s.insert(c, s.len()\
    \ - c.len() as i32),\n   |             ^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgdtkqstw.rs:19:13\n   |\n17 |\
    \         match c.to_ascii_lowercase() {\n   |               ----------------------\
    \ this expression has type `char`\n18 |             Some(c) => s.insert(c, s.len()\
    \ - c.len() as i32),\n19 |             None => ()\n   |             ^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<_>`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmpgdtkqstw.rs:18:48\n   |\n18\
    \ |             Some(c) => s.insert(c, s.len() - c.len() as i32),\n   |      \
    \                                          ^^^ method not found in `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgdtkqstw.rs:18:36\n   |\n18 |  \
    \           Some(c) => s.insert(c, s.len() - c.len() as i32),\n   |          \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\
    \nerror[E0599]: no method named `unwrap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpgdtkqstw.rs:26:45\n   |\n26 |         String::from(s.to_ascii_lowercase().unwrap())\n\
    \   |                                             ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n\n    for i in 0..s.len() {\n     \
    \   let char = s.chars().nth(i).unwrap();\n\n        if char.is_ascii_lowercase()\
    \ {\n            if i >= s.len() - 1 {\n                return s;\n          \
    \  }\n\n            let next = s.chars().nth(i + 1).unwrap();\n\n            if\
    \ next.is_ascii_uppercase() {\n                s = s.chars().collect();\n    \
    \        }\n\n            let next = s.chars().nth(i + 2).unwrap();\n\n      \
    \      if next.is_ascii_lowercase() {\n                s = s.chars().collect();\n\
    \            }\n        }\n\n        let c = s.chars().nth(i).unwrap();\n\n  \
    \      if c.is_ascii_uppercase() {\n            if i >= s.len() - 2 {\n      \
    \          return s;\n            }\n\n            let next = s.chars().nth(i\
    \ + 1).unwrap();\n\n            if next.is_ascii_lowercase() {\n             \
    \   s = s.chars().collect();\n            }\n\n            let next = s.chars().nth(i\
    \ + 2).unwrap();\n\n            if next.is_ascii_uppercase() {\n             \
    \   s = s.chars().collect();\n            }\n        }\n    }\n\n    s.into_owned()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp6vcl8wkk.rs:58:7\n   |\n58 |     s.into_owned()\n\
    \   |       ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter(|c| c.is_ascii_lowercase()).fold(String::new(),\
    \ |mut result, c| {\n        match c {\n            'a' => {\n               \
    \ result.push_str(&c.to_ascii_lowercase());\n                result.push_str(&c.to_ascii_uppercase());\n\
    \            },\n            'A' => {\n                result.push_str(&c.to_ascii_uppercase());\n\
    \                result.push_str(&c.to_ascii_lowercase());\n            },\n \
    \           _ => result.push_str(&c),\n        }\n        result\n    }).to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmghbfqgj.rs:17:33\n   |\n\
    17 |                 result.push_str(&c.to_ascii_lowercase());\n   |         \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmghbfqgj.rs:18:33\n   |\n18 |\
    \                 result.push_str(&c.to_ascii_uppercase());\n   |            \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n \
    \  |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmghbfqgj.rs:21:33\n   |\n21 |\
    \                 result.push_str(&c.to_ascii_uppercase());\n   |            \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n \
    \  |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmghbfqgj.rs:22:33\n   |\n22 |\
    \                 result.push_str(&c.to_ascii_lowercase());\n   |            \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n \
    \  |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmghbfqgj.rs:24:34\n   |\n24 |\
    \             _ => result.push_str(&c),\n   |                                \
    \  ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve(s.chars(), s.len())\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpg_xlima4.rs:14:5\n   |\n14 |     solve(s.chars(), s.len())\n  \
    \ |     ^^^^^ ---------  ------- supplied 2 arguments\n   |     |\n   |     expected\
    \ 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpg_xlima4.rs:13:4\n\
    \   |\n13 | fn solve(s: String) -> String {\n   |    ^^^^^ ---------\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve1(s, s.chars().chain(s.chars().enumerate().filter(|(_,\
    \ c)| c != '#'))).to_string()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve1` in this scope\n  --> /tmp/tmpavqcyqve.rs:14:5\n\
    \   |\n14 |     solve1(s, s.chars().chain(s.chars().enumerate().filter(|(_, c)|\
    \ c != '#'))).to_string()\n   |     ^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpavqcyqve.rs:14:71\n   |\n14\
    \ |     solve1(s, s.chars().chain(s.chars().enumerate().filter(|(_, c)| c != '#'))).to_string()\n\
    \   |                                                                       ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0271]: type mismatch resolving `<Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpavqcyqve.rs:14:60: 14:77]> as IntoIterator>::Item == char`\n\
    \   --> /tmp/tmpavqcyqve.rs:14:25\n    |\n14  |     solve1(s, s.chars().chain(s.chars().enumerate().filter(|(_,\
    \ c)| c != '#'))).to_string()\n    |                         ^^^^^ expected `char`,\
    \ found tuple\n    |\n    = note: expected type `char`\n              found tuple\
    \ `(usize, char)`\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0277, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    s.chars().filter_map(move |c|{\n        match *c {\n\
    \            'A'..='Z' => Some(c.to_string().to_upper()),\n            'a'..='z'\
    \ => Some(c.to_string().to_lower()),\n            _ => None,\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpzxryn11d.rs:15:15\n\
    \   |\n15 |         match *c {\n   |               ^^\n\nerror[E0599]: no method\
    \ named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpzxryn11d.rs:16:45\n\
    \   |\n16 |             'A'..='Z' => Some(c.to_string().to_upper()),\n   |   \
    \                                          ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpzxryn11d.rs:17:45\n\
    \   |\n17 |             'a'..='z' => Some(c.to_string().to_lower()),\n   |   \
    \                                          ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = s.clone();\n    let mut c = s.chars();\n\
    \    c.sort();\n\n    if c.is_empty() {\n        return res;\n    }\n\n    let\
    \ mut start = Some(c.next().unwrap());\n    let mut end = Some(c.next().unwrap());\n\
    \    while !start.is_none() && !end.is_none() {\n        let c = start.unwrap();\n\
    \        let e = end.unwrap();\n\n        let mut new_s = \"\";\n\n        if\
    \ c.is_uppercase() {\n            new_s.append(&c.to_lowercase());\n        }\
    \ else {\n            new_s.append(&c.to_uppercase());\n        }\n\n        if\
    \ e.is_uppercase() {\n            new_s.append(&e.to_lowercase());\n        }\
    \ else {\n            new_s.append(&e.to_uppercase());\n        }\n\n        res\
    \ = new_s + res;\n        start = Some(c.next().unwrap());\n        end = Some(c.next().unwrap());\n\
    \    }\n\n    res.to_string()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpl0dt9bsb.rs:16:7\n   |\n16 |     c.sort();\n   |      \
    \ ^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `is_empty`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmpl0dt9bsb.rs:18:10\n\
    \   |\n18 |     if c.is_empty() {\n   |          ^^^^^^^^ method not found in\
    \ `Chars<'_>`\n\nerror[E0599]: no method named `append` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpl0dt9bsb.rs:31:19\n   |\n31 |          \
    \   new_s.append(&c.to_lowercase());\n   |                   ^^^^^^ method not\
    \ found in `&str`\n\nerror[E0599]: no method named `append` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpl0dt9bsb.rs:33:19\n   |\n33 |   \
    \          new_s.append(&c.to_uppercase());\n   |                   ^^^^^^ method\
    \ not found in `&str`\n\nerror[E0599]: no method named `append` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpl0dt9bsb.rs:37:19\n   |\n37 |   \
    \          new_s.append(&e.to_lowercase());\n   |                   ^^^^^^ method\
    \ not found in `&str`\n\nerror[E0599]: no method named `append` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpl0dt9bsb.rs:39:19\n   |\n39 |   \
    \          new_s.append(&e.to_uppercase());\n   |                   ^^^^^^ method\
    \ not found in `&str`\n\nerror[E0369]: cannot add `String` to `&str`\n  --> /tmp/tmpl0dt9bsb.rs:42:21\n\
    \   |\n42 |         res = new_s + res;\n   |               ----- ^ --- String\n\
    \   |               |     |\n   |               |     `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |               &str\n   |\nhelp: create an owned\
    \ `String` on the left and add a borrow on the right\n   |\n42 |         res =\
    \ new_s.to_owned() + &res;\n   |                    +++++++++++   +\n\nerror[E0599]:\
    \ no method named `next` found for type `char` in the current scope\n  --> /tmp/tmpl0dt9bsb.rs:43:24\n\
    \   |\n43 |         start = Some(c.next().unwrap());\n   |                   \
    \     ^^^^ method not found in `char`\n\nerror[E0599]: no method named `next`\
    \ found for t"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    solve2(s, String::new())\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve2` in this scope\n  --> /tmp/tmp_mp3m5xc.rs:14:5\n\
    \   |\n14 |     solve2(s, String::new())\n   |     ^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return s.to_owned();\n \
    \   }\n\n    let mut s = String::from(s);\n\n    for letter in s.chars() {\n \
    \       if let Some(c) = match letter {\n            c if c.is_lowercase() ||\
    \ c.is_uppercase() => c.to_uppercase(),\n            c if c.is_uppercase() ||\
    \ c.is_lowercase() => c.to_lowercase(),\n            _ => letter,\n        };\n\
    \        s = s.replace(&letter, \"\");\n    }\n\n    return s.to_owned();\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `;`\n  --> /tmp/tmphulbyyn7.rs:25:10\n   |\n\
    21 |         if let Some(c) = match letter {\n   |         -- this `if` expression\
    \ has a condition, but no block\n...\n25 |         };\n   |          ^ expected\
    \ `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.chars().any(|c| c.is_lowercase()) {\n        s.chars()\n\
    \            .map(|c| if c.is_lowercase() {\n                c\n            }\
    \ else {\n                c.to_uppercase().to_string()\n            })\n     \
    \       .collect()\n    } else {\n        s.chars()\n            .map(|c| if c.is_lowercase()\
    \ {\n                c\n            } else {\n                c\n            })\n\
    \            .collect()\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpuipkou43.rs:19:17\n\
    \   |\n16 |               .map(|c| if c.is_lowercase() {\n   |  ______________________-\n\
    17 | |                 c\n   | |                 - expected because of this\n\
    18 | |             } else {\n19 | |                 c.to_uppercase().to_string()\n\
    \   | |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n20 | |             })\n   | |_____________- `if` and `else` have incompatible\
    \ types\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s;\n    for c in s.chars() {\n        if\
    \ c.is_uppercase() {\n            s = s.to_string().to_lowercase().chars().collect::<String>().join(\"\
    \") + c;\n        } else {\n            s = s.to_string().to_uppercase().chars().collect::<String>().join(\"\
    \") + c;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `join` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfzulye9l.rs:17:74\n   |\n17 |             s = s.to_string().to_lowercase().chars().collect::<String>().join(\"\
    \") + c;\n   |                                                               \
    \           ^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `join` found for struct `String` in the current scope\n  --> /tmp/tmpfzulye9l.rs:19:74\n\
    \   |\n19 |             s = s.to_string().to_uppercase().chars().collect::<String>().join(\"\
    \") + c;\n   |                                                               \
    \           ^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.len() == 0 {\n        return String::from(s);\n\
    \    }\n    if s.chars().all(|c| c.is_letter()) {\n        String::from(s.chars().map(|c|\
    \ if c.is_lower() { c.to_upper() } else { c.to_lower() }).collect::<String>())\n\
    \    } else {\n        String::from(s.chars().map(|c| c.to_ascii_lowercase()).collect::<String>())\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp2y9g4gls.rs:17:28\n   |\n17 |     if s.chars().all(|c|\
    \ c.is_letter()) {\n   |                            ^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_lower` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp2y9g4gls.rs:18:45\n   |\n18 |         String::from(s.chars().map(|c|\
    \ if c.is_lower() { c.to_upper() } else { c.to_lower() }).collect::<String>())\n\
    \   |                                             ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_lowercase`\n\nerror[E0599]: no method named\
    \ `to_upper` found for type `char` in the current scope\n  --> /tmp/tmp2y9g4gls.rs:18:60\n\
    \   |\n18 |         String::from(s.chars().map(|c| if c.is_lower() { c.to_upper()\
    \ } else { c.to_lower() }).collect::<String>())\n   |                        \
    \                                    ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp2y9g4gls.rs:18:82\n\
    \   |\n18 |         String::from(s.chars().map(|c| if c.is_lower() { c.to_upper()\
    \ } else { c.to_lower() }).collect::<String>())\n   |                        \
    \                                                          ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_lowercase`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    check(s.chars().filter(|c| isalpha(c)).fold(s, |acc,\
    \ c| {\n        if c.is_uppercase() {\n            acc.to_string() + c.to_string()\
    \ + acc.to_string()\n        } else {\n            acc + c.to_string() + acc\n\
    \        }\n    }))\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check` in this scope\n  --> /tmp/tmp8e4exd3j.rs:14:5\n\
    \   |\n14 |     check(s.chars().filter(|c| isalpha(c)).fold(s, |acc, c| {\n  \
    \ |     ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `isalpha`\
    \ in this scope\n  --> /tmp/tmp8e4exd3j.rs:14:32\n   |\n14 |     check(s.chars().filter(|c|\
    \ isalpha(c)).fold(s, |acc, c| {\n   |                                ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut reversed = 0;\n    for i in s.chars() {\n \
    \       match i {\n            'a' => reversed = !reversed,\n            'A' =>\
    \ reversed = !reversed,\n            'b' => reversed = !reversed,\n          \
    \  'B' => reversed = !reversed,\n            'c' => reversed = !reversed,\n  \
    \          'C' => reversed = !reversed,\n            _ => (),\n        }\n   \
    \ }\n    if reversed == 0 {\n        s\n    } else {\n        s.chars().cloned()\n\
    \            .map(|c| {\n                match c {\n                    'a' |\
    \ 'A' => c as u32,\n                    'b' | 'B' => c as u32,\n             \
    \       'c' | 'C' => c as u32,\n                    _ => c,\n                }\n\
    \            })\n            .collect()\n            .cloned()\n            .join(\"\
    \")\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp8jt0uqa5.rs:29:19\n     |\n29   |         s.chars().cloned()\n\
    \     |                   ^^^^^^ expected reference, found `char`\n     |\n  \
    \   = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `map` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmp8jt0uqa5.rs:30:14\n   |\n30 |               .map(|c| {\n   |       \
    \         ^^^ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Chars<'_> as Iterator>::Item = &_`\n           which is required\
    \ by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n\
    \           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmp8jt0uqa5.rs:35:26\n   |\n\
    31 | /                 match c {\n32 | |                     'a' | 'A' => c as\
    \ u32,\n   | |                                  -------- this is found to be of\
    \ type `u32`\n33 | |                     'b' | 'B' => c as u32,\n   | |      \
    \                            -------- this is found to be of type `u32`\n34 |\
    \ |                     'c' | 'C' => c as u32,\n   | |                       \
    \           -------- this is found to be of type `u32`\n35 | |               \
    \      _ => c,\n   | |                          ^ expected `u32`, found `char`\n\
    36 | |                 }\n   | |_________________- `match` arms have incompatible\
    \ types\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659978360
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    if s.is_empty() {\n        String::new()\n    } else\
    \ if is_letter(s) {\n        s.reverse();\n    } else if s.chars().all(|&c| !is_letter(c))\
    \ {\n        s.reverse();\n    }\n    s\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpp_wzxxqv.rs:16:15\n\
    \   |\n16 |     } else if is_letter(s) {\n   |               ^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n\
    \  --> /tmp/tmpp_wzxxqv.rs:18:35\n   |\n18 |     } else if s.chars().all(|&c|\
    \ !is_letter(c)) {\n   |                                   ^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp_wzxxqv.rs:15:9\n\
    \   |\n14 | /     if s.is_empty() {\n15 | |         String::new()\n   | |    \
    \     ^^^^^^^^^^^^^ expected `()`, found struct `String`\n16 | |     } else if\
    \ is_letter(s) {\n17 | |         s.reverse();\n18 | |     } else if s.chars().all(|&c|\
    \ !is_letter(c)) {\n19 | |         s.reverse();\n20 | |     }\n   | |_____- expected\
    \ this to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n15 |   \
    \      String::new();\n   |                      +\nhelp: consider using a semicolon\
    \ here\n   |\n20 |     };\n   |      +\nhelp: you might have meant to return this\
    \ value\n   |\n15 |         return String::new();\n   |         ++++++       \
    \       +\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpp_wzxxqv.rs:17:11\n   |\n17 |         s.reverse();\n\
    \   |           ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp_wzxxqv.rs:18:30\n\
    \   |\n18 |     } else if s.chars().all(|&c| !is_letter(c)) {\n   |          \
    \                    ^--\n   |                              ||\n   |         \
    \                     |expected due to this\n   |                            \
    \  expected `char`, found reference\n   |                              help: did\
    \ you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpp_wzxxqv.rs:19:11\n   |\n19 |         s.reverse();\n\
    \   |           ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerro"
  stdout: ''
  timestamp: 1659978360
