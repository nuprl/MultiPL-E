language: rs
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    if arr.len() == 1 {\n        return vec![0];\n    }\n\n\
    \    let mut mut index = arr.len() - 1;\n    let mut smalest_value = arr[0];\n\
    \n    while index >= 0 && arr[index] % 2 == 0 {\n        smalest_value = arr[index];\n\
    \        index -= 1;\n    }\n\n    let mut node = smalest_value;\n    let mut\
    \ count = 0;\n\n    while index >= 0 && arr[index] % 2 != 0 {\n        node =\
    \ arr[index];\n        index -= 1;\n        count += 1;\n    }\n\n    if count\
    \ > 0 {\n        vec![node, index]\n    } else {\n        vec![]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmprlti0oaa.rs:34:13\n\
    \   |\n34 |     let mut mut index = arr.len() - 1;\n   |             ^^^ help:\
    \ remove the additional `mut`s\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprlti0oaa.rs:52:20\n\
    \   |\n52 |         vec![node, index]\n   |                    ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n52 |         vec![node,\
    \ index.try_into().unwrap()]\n   |                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    debug_assert!(arr.len() <= 10000);\n\
    \    let mut lowest_value = 0;\n    let mut index_of_smallest_even_value = 0;\n\
    \    for node in arr.iter() {\n        if node.is_even() {\n            if node.value\
    \ < lowest_value {\n                lowest_value = node.value;\n             \
    \   index_of_smallest_even_value = node\n                    .index()\n      \
    \              .expect(\"Failed to get the index of the smallest even value\"\
    );\n            }\n        }\n    }\n    if lowest_value == 0 {\n        return\
    \ vec![];\n    }\n    return vec![lowest_value, index_of_smallest_even_value];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp4933_zya.rs:31:17\n   |\n31 |         if node.is_even()\
    \ {\n   |                 ^^^^^^^ method not found in `&isize`\n\nerror[E0609]:\
    \ no field `value` on type `&isize`\n  --> /tmp/tmp4933_zya.rs:32:21\n   |\n32\
    \ |             if node.value < lowest_value {\n   |                     ^^^^^\n\
    \nerror[E0609]: no field `value` on type `&isize`\n  --> /tmp/tmp4933_zya.rs:33:37\n\
    \   |\n33 |                 lowest_value = node.value;\n   |                 \
    \                    ^^^^^\n\nerror[E0599]: no method named `index` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmp4933_zya.rs:35:22\n \
    \  |\n35 |                     .index()\n   |                      ^^^^^ method\
    \ not found in `&isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // Your code here\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_x6zkli9.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut v = vec![];\n\n    let\
    \ mut index = 0;\n    let mut smalest_value = 0;\n\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            smalest_value = i;\n            index =\
    \ i;\n        }\n    }\n\n    v.push(smalest_value);\n    v.push(index);\n   \
    \ v\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph8mpa8jg.rs:34:29\n   |\n\
    30 |     let mut smalest_value = 0;\n   |                             - expected\
    \ due to this value\n...\n34 |             smalest_value = i;\n   |          \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |             smalest_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph8mpa8jg.rs:35:21\n\
    \   |\n29 |     let mut index = 0;\n   |                     - expected due to\
    \ this value\n...\n35 |             index = i;\n   |                     ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             index = *i;\n   |                     +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().zip(0..).enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(_, v)| (v, i)).min().unwrap_or([])\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpgdtsrc_g.rs:27:91\n\
    \   |\n27 |     arr.iter().cloned().zip(0..).enumerate().filter(|(i, _)| i % 2\
    \ == 0).map(|(_, v)| (v, i)).min().unwrap_or([])\n   |                       \
    \                                                                    ^ help: a\
    \ local variable with a similar name exists: `v`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgdtsrc_g.rs:27:111\n   |\n27 |     arr.iter().cloned().zip(0..).enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(_, v)| (v, i)).min().unwrap_or([])\n   |             \
    \                                                                            \
    \                      ^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                                                                        \
    \                                       |\n   |                              \
    \                                                                            \
    \     expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n               found array `[_; 0]`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens = arr.iter().filter(|&x|\
    \ x.is_even());\n    if evens.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_even = evens.min_by_key(|&x| x.0);\n    let mut min_idx = evens.index(&min_even).unwrap();\n\
    \    let mut evens = evens.clone();\n    evens.remove(min_even);\n    let mut\
    \ smaller_vec: Vec<(isize, isize)> = vec![];\n    for (even, idx) in evens.iter().enumerate()\
    \ {\n        if idx == min_idx {\n            min_even = even;\n            smaller_vec.push((min_even,\
    \ idx));\n        }\n    }\n    smaller_vec\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpcuy_s_cp.rs:27:46\n   |\n27 |     let mut evens\
    \ = arr.iter().filter(|&x| x.is_even());\n   |                               \
    \               ^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method\
    \ named `is_empty` found for struct `Filter` in the current scope\n  --> /tmp/tmpcuy_s_cp.rs:28:14\n\
    \   |\n28 |     if evens.is_empty() {\n   |              ^^^^^^^^ method not found\
    \ in `Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpcuy_s_cp.rs:27:39:\
    \ 27:55]>`\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpcuy_s_cp.rs:31:48\n\
    \   |\n31 |     let mut min_even = evens.min_by_key(|&x| x.0);\n   |         \
    \                                       ^\n\nerror[E0599]: no method named `index`\
    \ found for struct `Filter` in the current scope\n  --> /tmp/tmpcuy_s_cp.rs:32:29\n\
    \   |\n32 |     let mut min_idx = evens.index(&min_even).unwrap();\n   |     \
    \                        ^^^^^ method not found in `Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpcuy_s_cp.rs:27:39: 27:55]>`\n\nerror[E0599]: no method\
    \ named `remove` found for struct `Filter` in the current scope\n  --> /tmp/tmpcuy_s_cp.rs:34:11\n\
    \   |\n34 |     evens.remove(min_even);\n   |           ^^^^^^ method not found\
    \ in `Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpcuy_s_cp.rs:27:39:\
    \ 27:55]>`\n\nerror[E0599]: no method named `iter` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpcuy_s_cp.rs:36:30\n   |\n36 |     for (even,\
    \ idx) in evens.iter().enumerate() {\n   |                              ^^^^ private\
    \ field, not a method\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcuy_s_cp.rs:39:31\n\
    \   |\n39 |             smaller_vec.push((min_even, idx));\n   |             \
    \                  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected type `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcuy_s_cp.rs:42:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- ex"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // write your code here\n    let\
    \ mut even_values = vec![];\n    let mut min_value = arr.iter().min().unwrap();\n\
    \    for n in arr.iter() {\n        if n % 2 == 0 {\n            even_values.push(n);\n\
    \            if n == min_value {\n                min_value = n - 1;\n       \
    \     }\n        }\n    }\n    min_value\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvrkbg9fc.rs:34:29\n   |\n\
    29 |     let mut min_value = arr.iter().min().unwrap();\n   |                \
    \         ------------------------- expected due to this value\n...\n34 |    \
    \             min_value = n - 1;\n   |                             ^^^^^\n   |\
    \                             |\n   |                             expected `&isize`,\
    \ found `isize`\n   |                             help: consider borrowing here:\
    \ `&(n - 1)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrkbg9fc.rs:38:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n38\
    \ |     min_value\n   |     ^^^^^^^^^ expected struct `Vec`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found reference `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n\n    let mut even_values = vec![];\n    let mut min_even_value\
    \ = arr.iter().min().unwrap();\n\n    for &mut value in &mut arr {\n        if\
    \ *value % 2 == 0 {\n            even_values.push(*value);\n        }\n    }\n\
    \n    even_values.sort_by(|a, b| a.cmp(b));\n    min_even_value = *even_values.iter().skip(1).next().unwrap();\n\
    \n    let mut min_index = even_values.iter().skip(1).count();\n\n    for &mut\
    \ value in &mut arr {\n        if *value % 2 == 0 {\n            *value = *value\
    \ / 2;\n            *value -= *min_even_value;\n            *value += min_index;\n\
    \            *value /= 2;\n            *value *= 2;\n            *value += min_index;\n\
    \n            if *value % 2 == 0 {\n                min_even_value = *value;\n\
    \                min_index += 1;\n            }\n        }\n    }\n\n    vec![*min_even_value]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:35:12\n\
    \   |\n35 |         if *value % 2 == 0 {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:36:30\n   |\n\
    36 |             even_values.push(*value);\n   |                             \
    \ ^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:46:12\n\
    \   |\n46 |         if *value % 2 == 0 {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:47:13\n   |\n\
    47 |             *value = *value / 2;\n   |             ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:47:22\n   |\n\
    47 |             *value = *value / 2;\n   |                      ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:48:13\n   |\n\
    48 |             *value -= *min_even_value;\n   |             ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:49:13\n   |\n\
    49 |             *value += min_index;\n   |             ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:50:13\n   |\n\
    50 |             *value /= 2;\n   |             ^^^^^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:51:13\n   |\n51 |        \
    \     *value *= 2;\n   |             ^^^^^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:52:13\n   |\n52 |             *value\
    \ += min_index;\n   |             ^^^^^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:54:16\n   |\n54 |             if\
    \ *value % 2 == 0 {\n   |                ^^^^^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp1z16ntg_.rs:55:34\n   |\n55 |        \
    \         min_even_value = *value;\n   |                                  ^^^^^^\n\
    \nerror: aborting due to 12 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ Vec::new();\n    }\n    let mut min_val = *arr.iter().min().unwrap();\n    let\
    \ mut min_idx = 0;\n    for idx in arr.iter().rev() {\n        let v = *idx;\n\
    \        if v < min_val {\n            min_val = v;\n            min_idx = *idx;\n\
    \        }\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 0]`,\n right: `[2, 1]`', /tmp/tmpcw9uhbl2.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sorted().collect();\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpx39_r82h.rs:27:25\n   |\n27 |     arr.iter().cloned().sorted().collect();\n\
    \   |                         ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx39_r82h.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // write your code here\n    let\
    \ mut even_values = arr.iter().filter(|x| x % 2 == 0).collect::<Vec<_>>();\n \
    \   even_values\n        .iter()\n        .enumerate()\n        .min_by_key(|(_,\
    \ value)| value)\n        .unwrap()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp83bzah9p.rs:28:51\n\
    \   |\n28 |     let mut even_values = arr.iter().filter(|x| x % 2 == 0).collect::<Vec<_>>();\n\
    \   |                                                 - ^ - {integer}\n   |  \
    \                                               |\n   |                      \
    \                           &&isize\n   |\nhelp: `%` can be used on `isize`, you\
    \ can dereference `x`\n   |\n28 |     let mut even_values = arr.iter().filter(|x|\
    \ *x % 2 == 0).collect::<Vec<_>>();\n   |                                    \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83bzah9p.rs:29:5\n\
    \   |\n26 |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                \
    \                ---------- expected `Vec<isize>` because of return type\n...\n\
    29 | /     even_values\n30 | |         .iter()\n31 | |         .enumerate()\n\
    32 | |         .min_by_key(|(_, value)| value)\n33 | |         .unwrap()\n   |\
    \ |_________________^ expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n               found tuple `(usize, &&isize)`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = Vec::new();\n\
    \    let mut node = 0;\n    let mut smallest_even_value = arr[0];\n    let mut\
    \ smallest_even_index_idx = 0;\n    for x in arr.iter().rev() {\n        if x.is_even()\
    \ {\n            if smallest_even_value < x {\n                smallest_even_value\
    \ = x;\n                smallest_even_index_idx = node;\n            }\n     \
    \       vec.push(smallest_even_value);\n            node++;\n        } else {\n\
    \            vec.push(x);\n        }\n    }\n    vec\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmppeb_lfoy.rs:38:17\n\
    \   |\n38 |             node++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n38 |             { let tmp = node; node\
    \ += 1; tmp };\n   |             +++++++++++     ~~~~~~~~~~~~~~~~~~\n38 -    \
    \         node++;\n38 +             node += 1;\n   | \n\nerror[E0599]: no method\
    \ named `is_even` found for reference `&isize` in the current scope\n  --> /tmp/tmppeb_lfoy.rs:32:14\n\
    \   |\n32 |         if x.is_even() {\n   |              ^^^^^^^ method not found\
    \ in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppeb_lfoy.rs:33:38\n\
    \   |\n33 |             if smallest_even_value < x {\n   |                   \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |             if smallest_even_value < *x {\n   |     \
    \                                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppeb_lfoy.rs:34:39\n\
    \   |\n29 |     let mut smallest_even_value = arr[0];\n   |                  \
    \                 ------ expected due to this value\n...\n34 |               \
    \  smallest_even_value = x;\n   |                                       ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |                 smallest_even_value = *x;\n   |                         \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppeb_lfoy.rs:40:22\n\
    \   |\n40 |             vec.push(x);\n   |                      ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n40 |  \
    \           vec.push(*x);\n   |                      +\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = vec![];\n\
    \    arr.iter().cloned().sort_by_key(|x| {\n        if x.is_even() {\n       \
    \     x.clone()\n        } else {\n            x.checked_mul(2).unwrap()\n   \
    \     }\n    }).fold(vec, |mut vec, node| {\n        vec\n            .iter()\n\
    \            .filter(|&x| x.is_even())\n            .fold(vec, |mut vec, &node|\
    \ {\n                vec.push(node);\n                vec\n            })\n  \
    \  });\n    vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpdwhp0j9s.rs:28:25\n   |\n28 |     arr.iter().cloned().sort_by_key(|x|\
    \ {\n   |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = isize::MIN;\n    let mut min_index = isize::MIN;\n\
    \    let mut max_index = isize::MAX;\n    for i in arr.iter() {\n        let j\
    \ = i + 1;\n        while j < arr.len() {\n            if arr[j] % 2 == 0 {\n\
    \                if smallest_even_value > arr[j] {\n                    smallest_even_value\
    \ = arr[j];\n                    smallest_even_index = j;\n                }\n\
    \                if min_index > j {\n                    min_index = j;\n    \
    \            }\n                if max_index < j {\n                    max_index\
    \ = j;\n                }\n                break;\n            }\n           \
    \ j += 1;\n        }\n    }\n    vec![smallest_even_index, min_index, max_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwgrxsaam.rs:33:19\n   |\n\
    33 |         while j < arr.len() {\n   |                   ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n33 |         while j < arr.len().try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwgrxsaam.rs:34:16\n\
    \   |\n34 |             if arr[j] % 2 == 0 {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpwgrxsaam.rs:35:42\n   |\n35 |  \
    \               if smallest_even_value > arr[j] {\n   |                      \
    \                    ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwgrxsaam.rs:36:43\n\
    \   |\n36 |                     smallest_even_value = arr[j];\n   |          \
    \                                 ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = 0;\n \
    \   let mut smallest_index = 0;\n    let mut counter = 0;\n    let mut result\
    \ = vec![];\n    for v in arr.iter() {\n        if v % 2 == 0 {\n            smallest_value\
    \ = v;\n            smallest_index = counter;\n        }\n        counter += 1;\n\
    \    }\n    let mut counter2 = 0;\n    for v in arr.iter() {\n        if smallest_value\
    \ == v && smallest_index == counter2 {\n            result.push(v);\n        \
    \    break;\n        }\n        counter2 += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmzco5emi.rs:33:30\n   |\n\
    27 |     let mut smallest_value = 0;\n   |                              - expected\
    \ due to this value\n...\n33 |             smallest_value = v;\n   |         \
    \                     ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n33 |             smallest_value = *v;\n   |\
    \                              +\n\nerror[E0277]: can't compare `isize` with `&isize`\n\
    \  --> /tmp/tmpmzco5emi.rs:40:27\n   |\n40 |         if smallest_value == v &&\
    \ smallest_index == counter2 {\n   |                           ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmzco5emi.rs:46:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n46 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = Vec::new();\n\
    \    let mut smallest_index = Vec::new();\n    for i in arr {\n        if i.is_even()\
    \ {\n            even_values.push(i);\n        }\n        if i==0 {\n        \
    \    smallest_index.push(i);\n        }\n    }\n    if even_values.is_empty()\
    \ {\n        return smallest_index;\n    }\n    let mut smallest_even_value =\
    \ even_values[0];\n    let mut smallest_index = smallest_index[0];\n    for i\
    \ in even_values {\n        if i == smallest_even_value {\n            smallest_index\
    \ = smallest_index + 1;\n        }\n        else {\n            smallest_even_value\
    \ = i;\n            smallest_index = smallest_index+1;\n        }\n    }\n   \
    \ smallest_index.push(smallest_index[0]);\n    return smallest_index;\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp9qkhf7s6.rs:30:14\n   |\n30 |         if i.is_even() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `push` found for type `isize` in the current scope\n  --> /tmp/tmp9qkhf7s6.rs:51:20\n\
    \   |\n51 |     smallest_index.push(smallest_index[0]);\n   |                \
    \    ^^^^ method not found in `isize`\n\nerror[E0608]: cannot index into a value\
    \ of type `isize`\n  --> /tmp/tmp9qkhf7s6.rs:51:25\n   |\n51 |     smallest_index.push(smallest_index[0]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9qkhf7s6.rs:52:12\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n52 |     return smallest_index;\n   |            ^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = vec![std::isize::MAX;\
    \ arr.len()];\n    let mut result: Vec<isize> = vec![std::isize::MAX; arr.len()];\n\
    \n    for i in 0..arr.len() {\n        let mut tmp = vec![i];\n        let mut\
    \ j = 0;\n        while j < arr.len() {\n            if arr[j] % 2 != 0 {\n  \
    \              tmp[j] = arr[j];\n                break;\n            }\n     \
    \       j += 1\n        }\n        if j == arr.len() {\n            if j == 1\
    \ {\n                result[i] = arr[0];\n            } else {\n             \
    \   result[i] = tmp[0];\n            }\n        } else {\n            result[i]\
    \ = tmp[0];\n        }\n        for &v in &tmp {\n            if v < min[i - 1]\
    \ { // min[i] == arr[i]\n                min[i] = v;\n            }\n        }\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaiz98l0g.rs:35:26\n   |\n\
    35 |                 tmp[j] = arr[j];\n   |                 ------   ^^^^^^ expected\
    \ `usize`, found `isize`\n   |                 |\n   |                 expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaiz98l0g.rs:44:29\n\
    \   |\n44 |                 result[i] = tmp[0];\n   |                 ---------\
    \   ^^^^^^ expected `isize`, found `usize`\n   |                 |\n   |     \
    \            expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaiz98l0g.rs:47:25\n   |\n47 |             result[i] = tmp[0];\n\
    \   |             ---------   ^^^^^^ expected `isize`, found `usize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaiz98l0g.rs:50:20\n   |\n50 |             if\
    \ v < min[i - 1] { // min[i] == arr[i]\n   |                    ^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n50 |             if v <\
    \ min[i - 1].try_into().unwrap() { // min[i] == arr[i]\n   |                 \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaiz98l0g.rs:51:26\n\
    \   |\n51 |                 min[i] = v;\n   |                 ------   ^ expected\
    \ `isize`, found `usize`\n   |                 |\n   |                 expected\
    \ due to the type of this binding\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    let mut min_value = even_values[0];\n    let mut min_idx = 0;\n  \
    \  for i in even_values {\n        if i < min_value {\n            min_value =\
    \ i;\n            min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmpd1wwykyu.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_index: usize = 0;\n    for &mut node in arr.iter_mut()\
    \ {\n        if node.value % 2 == 0 {\n            node.value += 1;\n        \
    \    if node.value > smalest_value {\n                smalest_value = node.value;\n\
    \                smalest_index = 0;\n            }\n        }\n    }\n    if smalest_value\
    \ == 0 || smalest_index == 0 {\n        return vec![];\n    }\n    arr.iter_mut().filter(|&mut\
    \ node| node.value == smalest_value).cloned().collect().swap(0, 1).collect();\n\
    \    let mut index = 0;\n    for i in &arr[index..] {\n        if i % 2 == 0 {\n\
    \            index += 1;\n        }\n    }\n    vec![smalest_value, smalest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp4a6vk2n6.rs:30:17\n   |\n30 |         if node.value % 2 == 0 {\n\
    \   |                 ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp4a6vk2n6.rs:31:18\n   |\n31 |           \
    \  node.value += 1;\n   |                  ^^^^^\n\nerror[E0610]: `isize` is a\
    \ primitive type and therefore doesn't have fields\n  --> /tmp/tmp4a6vk2n6.rs:32:21\n\
    \   |\n32 |             if node.value > smalest_value {\n   |                \
    \     ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp4a6vk2n6.rs:33:38\n   |\n33 |                 smalest_value\
    \ = node.value;\n   |                                      ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4a6vk2n6.rs:41:28\n   |\n41 |     arr.iter_mut().filter(|&mut\
    \ node| node.value == smalest_value).cloned().collect().swap(0, 1).collect();\n\
    \   |                            ^^^^^-----\n   |                            |\
    \    |\n   |                            |    expected due to this\n   |      \
    \                      types differ in mutability\n   |                      \
    \      help: did you mean `node`: `&&&mut isize`\n   |\n   = note:      expected\
    \ reference `&&mut isize`\n           found mutable reference `&mut _`\n\nerror[E0271]:\
    \ type mismatch resolving `<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp4a6vk2n6.rs:41:27:\
    \ 41:66]> as Iterator>::Item == &_`\n    --> /tmp/tmp4a6vk2n6.rs:41:68\n     |\n\
    41   |     arr.iter_mut().filter(|&mut node| node.value == smalest_value).cloned().collect().swap(0,\
    \ 1).collect();\n     |                                                      \
    \              ^^^^^^ types differ in mutability\n     |\n     = note:      expected\
    \ reference `&_`\n             found mutable reference `&mut isize`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Filter<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp4a6vk2n6.rs:41:27:\
    \ 41:66]>>`, but its trait bounds were not satisfi"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    let mut min_value: isize = 0;\n    let mut min_value_index:\
    \ usize = 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n           \
    \ if even_values.iter().none() {\n                min_value = i;\n           \
    \ } else {\n                if i < min_value {\n                    min_value\
    \ = i;\n                }\n            }\n            even_values.push(i);\n \
    \       } else {\n            if even_values.iter().none() {\n               \
    \ min_value = i;\n            }\n        }\n    }\n    if even_values.iter().any()\
    \ {\n        min_value_index = even_values.iter().min().unwrap();\n    }\n   \
    \ if min_value_index == 0 {\n        return vec![];\n    }\n    return vec![min_value,\
    \ min_value_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `none` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpmy9mzcla.rs:32:35\n   |\n32 |          \
    \   if even_values.iter().none() {\n   |                                   ^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmy9mzcla.rs:33:29\n   |\n28 |     let mut min_value: isize\
    \ = 0;\n   |                        ----- expected due to this type\n...\n33 |\
    \                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmy9mzcla.rs:35:24\n   |\n35 |              \
    \   if i < min_value {\n   |                        ^^^^^^^^^\n   |          \
    \              |\n   |                        expected `&isize`, found `isize`\n\
    \   |                        help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmy9mzcla.rs:36:33\n   |\n28 |     let mut min_value:\
    \ isize = 0;\n   |                        ----- expected due to this type\n...\n\
    36 |                     min_value = i;\n   |                                \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n36 |                     min_value = *i;\n   |                        \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmy9mzcla.rs:39:30\n\
    \   |\n39 |             even_values.push(i);\n   |                           \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n39 |             even_values.push(*i);\n   |                 \
    \             +\n\nerror[E0599]: no method named `none` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpmy9mzcla.rs:41:35\n   |\n41 |          \
    \   if even_values.iter().none() {\n   |                                   ^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmy9mzcla.rs:42:29\n   |\n28 |     "
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = arr.to_vec();\n\
    \    let mut smallest_value: isize = 0;\n    let mut smallest_index: usize = 0;\n\
    \    let mut smallest_index: usize = 0;\n    let mut even_value_count: usize =\
    \ 0;\n    let mut index_of_smallest_value: usize = 0;\n    let mut index_of_smallest_value:\
    \ usize = 0;\n    let mut index_of_next_smallest_value: usize = 0;\n\n    for\
    \ i in vec.iter() {\n        if i % 2 == 0 {\n            even_value_count = even_value_count\
    \ + 1;\n            if even_value_count == 1 {\n                smallest_value\
    \ = i;\n                index_of_smallest_value = i;\n                index_of_next_smallest_value\
    \ = i + 1;\n            }\n            if even_value_count == 2 {\n          \
    \      smallest_index = i;\n            }\n        } else {\n            if even_value_count\
    \ == 0 {\n                smallest_value = i;\n                index_of_smallest_value\
    \ = i;\n                index_of_next_smallest_value = i + 1;\n            }\n\
    \            if even_value_count >= 2 {\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_value_count == 0 {\n        return\
    \ vec;\n    }\n    let mut vec2 = vec;\n    vec2[index_of_smallest_value] = vec2[index_of_next_smallest_value];\n\
    \    if even_value_count == 2 {\n        vec2[index_of_next_smallest_value] =\
    \ vec2[index_of_next_smallest_value + 1];\n    }\n    return vec2;\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2cl0gvj9.rs:40:34\n   |\n\
    28 |     let mut smallest_value: isize = 0;\n   |                            \
    \ ----- expected due to this type\n...\n40 |                 smallest_value =\
    \ i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2cl0gvj9.rs:41:43\n   |\n33 |     let mut index_of_smallest_value:\
    \ usize = 0;\n   |                                      ----- expected due to\
    \ this type\n...\n41 |                 index_of_smallest_value = i;\n   |    \
    \                                       ^ expected `usize`, found `&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2cl0gvj9.rs:42:48\n   |\n34 |  \
    \   let mut index_of_next_smallest_value: usize = 0;\n   |                   \
    \                        ----- expected due to this type\n...\n42 |          \
    \       index_of_next_smallest_value = i + 1;\n   |                          \
    \                      ^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2cl0gvj9.rs:45:34\n   |\n30 |     let mut smallest_index:\
    \ usize = 0;\n   |                             ----- expected due to this type\n\
    ...\n45 |                 smallest_index = i;\n   |                          \
    \        ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2cl0gvj9.rs:49:34\n   |\n28 |     let mut smallest_value: isize\
    \ = 0;\n   |                             ----- expected due to this type\n...\n\
    49 |                 smallest_value = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n49 |                 smallest_value = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cl0gvj9.rs:50:43\n\
    \   |\n33 |     let mut index_of_smallest_value: usize = 0;\n   |            \
    \                          ----- expected due to this type\n...\n50 |  "
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // write your code here\n    if\
    \ arr.len() == 0 {\n        return vec![];\n    }\n    let mut min_value = arr[0];\n\
    \    let mut min_index = 0;\n    for i in arr {\n        if i % 2 != 0 {\n   \
    \         break;\n        }\n        if min_value < i {\n            min_value\
    \ = i;\n            min_index = i;\n        }\n    }\n    return vec![min_value,\
    \ min_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 0]`,\n right: `[2, 1]`', /tmp/tmpyrq7qf38.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), 10000, \"\
    the length of input array should be less than 10000\");\n    let mut smalest_value\
    \ = isize::MIN;\n    let mut smallest_index = 0;\n    for i in arr.iter().cloned()\
    \ {\n        match smalest_value {\n            0 => smalest_value = *i,\n   \
    \         v => if v == *i {\n                if i < smallest_index {\n       \
    \             smallest_index = i;\n                }\n                smalest_value\
    \ = *i;\n            }\n        }\n    }\n    if smalest_value == isize::MIN {\n\
    \        Vec::new()\n    } else {\n        vec![smalest_value, smallest_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpy7gsmlpm.rs:32:34\n\
    \   |\n32 |             0 => smalest_value = *i,\n   |                       \
    \           ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpy7gsmlpm.rs:33:26\n\
    \   |\n33 |             v => if v == *i {\n   |                          ^^\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpy7gsmlpm.rs:37:33\n\
    \   |\n37 |                 smalest_value = *i;\n   |                        \
    \         ^^\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut mut min_index = 0;\n    let mut min_value = arr[0];\n\
    \    for i in 0..arr.len() {\n        if min_value == arr[i] {\n            min_index\
    \ = i;\n            min_value = arr[i];\n        }\n    }\n    let mut result\
    \ = vec![min_value];\n    if min_index == 0 {\n        return result;\n    }\n\
    \    let mut min_index = 0;\n    let mut min_value = arr[0];\n    for i in 0..arr.len()\
    \ {\n        if min_value == arr[i] {\n            min_index = i;\n          \
    \  min_value = arr[i];\n        }\n    }\n    for i in 0..arr.len() {\n      \
    \  if i != min_index {\n            result.append(min_value);\n        }\n   \
    \ }\n    return result;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmp0zgr_jk6.rs:30:13\n\
    \   |\n30 |     let mut mut min_index = 0;\n   |             ^^^ help: remove\
    \ the additional `mut`s\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0zgr_jk6.rs:52:27\n\
    \   |\n52 |             result.append(min_value);\n   |                      \
    \     ^^^^^^^^^ expected `&mut Vec<isize>`, found `isize`\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<isize>`\n                           found type `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_index = 0;\n    let\
    \ mut smalest_value = arr[0];\n    for i in arr.iter().rev() {\n        if i &\
    \ 1 == 0 {\n            smalest_value = i;\n            min_index = 1;\n     \
    \   } else {\n            if smalest_value < i {\n                smalest_value\
    \ = i;\n                min_index = 0;\n            }\n        }\n    }\n    vec![smalest_value,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc0sw9b1m.rs:31:29\n   |\n\
    28 |     let mut smalest_value = arr[0];\n   |                             ------\
    \ expected due to this value\n...\n31 |             smalest_value = i;\n   | \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |             smalest_value = *i;\n   | \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc0sw9b1m.rs:34:32\n\
    \   |\n34 |             if smalest_value < i {\n   |                         \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |             if smalest_value < *i {\n   |           \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc0sw9b1m.rs:35:33\n\
    \   |\n28 |     let mut smalest_value = arr[0];\n   |                        \
    \     ------ expected due to this value\n...\n35 |                 smalest_value\
    \ = i;\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 smalest_value\
    \ = *i;\n   |                                 +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // Your code here\n    let mut\
    \ v = vec![];\n    for i in arr.iter() {\n        if i % 2 == 0 {\n          \
    \  if v[v.len() - 1].0 > i {\n                v.push(i);\n            } else {\n\
    \                let idx = v.len() - 1;\n                while idx != 0 {\n  \
    \                  if v[idx].0 > i {\n                        let temp = v[idx\
    \ + 1];\n                        v.remove(v[idx + 1]);\n                     \
    \   v[idx] = temp;\n                    } else if v[idx].0 == i {\n          \
    \              break;\n                    }\n                    idx -= 1;\n\
    \                }\n                v.push(i);\n            }\n        }\n   \
    \ }\n    v\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpnaigm524.rs:31:16\n\
    \   |\n28 |     let mut v = vec![];\n   |         ----- consider giving `v` the\
    \ explicit type `Vec<T>`, with the type parameters specified\n...\n31 |      \
    \       if v[v.len() - 1].0 > i {\n   |                ^^^^^^^^^^^^^^ cannot infer\
    \ type\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_index: usize = 0;\n\n    for i in 0..arr.len() {\n \
    \       if arr[i] % 2 == 0 {\n            smalest_value = arr[i];\n          \
    \  smalest_index = i;\n        }\n    }\n\n    smalest_index\n        .unwrap_or(0)\n\
    \        .into_iter()\n        .cloned()\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp2hfn8jpe.rs:38:10\n   |\n38 |         .unwrap_or(0)\n\
    \   |          ^^^^^^^^^ method not found in `usize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut index = 0isize;\n    let\
    \ mut result = vec![];\n\n    for node in arr.iter() {\n        if node % 2 ==\
    \ 0 {\n            result.push((node as isize)+index);\n        }\n        index\
    \ += 1;\n    }\n\n    result.sort_by(|a, b| a.cmp(b));\n\n    let mut smallest\
    \ = result[0];\n    let mut i = 0;\n    for node in result {\n        if node\
    \ == smallest {\n            i += 1;\n        } else {\n            break;\n \
    \       }\n    }\n\n    vec![smallest as isize, i]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp_c4nyi24.rs:32:25\n\
    \   |\n32 |             result.push((node as isize)+index);\n   |            \
    \             ^----^^^^^^^^^^\n   |                         ||\n   |         \
    \                |help: dereference the expression: `*node`\n   |            \
    \             cannot cast `&isize` as `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr.iter().min();\n\
    \    let mut min_val_index = -1;\n    let mut even_value_index = 0;\n    for &v\
    \ in arr {\n        if v % 2 == 0 {\n            min_val = v;\n            min_val_index\
    \ = 0;\n            even_value_index += 1;\n        }\n        if min_val_index\
    \ == -1 || min_val_index > even_value_index {\n            min_val_index = even_value_index;\n\
    \            min_val = v;\n        }\n    }\n    if min_val_index == -1 || min_val_index\
    \ == arr.len() {\n        return vec![];\n    }\n    vec![min_val, min_val_index].into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxg7yrdx5.rs:30:9\n   |\n\
    30 |     for &v in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `v`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: cannot mod `Option<&isize>`\
    \ by `{integer}`\n  --> /tmp/tmpxg7yrdx5.rs:31:14\n   |\n31 |         if v % 2\
    \ == 0 {\n   |              ^ no implementation for `Option<&isize> % {integer}`\n\
    \   |\n   = help: the trait `Rem<{integer}>` is not implemented for `Option<&isize>`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpxg7yrdx5.rs:28:29\n\
    \   |\n28 |     let mut min_val_index = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpxg7yrdx5.rs:36:29\n\
    \   |\n36 |         if min_val_index == -1 || min_val_index > even_value_index\
    \ {\n   |                             ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpxg7yrdx5.rs:41:25\n   |\n41 |     if min_val_index\
    \ == -1 || min_val_index == arr.len() {\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 "
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min = arr[0];\n    let mut min_index = 0;\n    let\
    \ mut min_even_index = 0;\n    for index in 1..arr.len() {\n        let value\
    \ = arr[index];\n        if value < min {\n            min = value;\n        \
    \    min_index = index;\n            if value % 2 == 0 {\n                min_even_index\
    \ = index;\n            }\n        }\n    }\n    let mut even_index = min_even_index;\n\
    \    let mut even_value = arr[even_index];\n    if even_index == min_index {\n\
    \        // There are no even values\n        return vec![];\n    }\n    let mut\
    \ new_arr = vec![];\n    for index in min_index..arr.len() {\n        let value\
    \ = arr[index];\n        if value % 2 == 0 {\n            new_arr.push(even_value);\n\
    \            even_value = 0;\n            even_index = index;\n        } else\
    \ {\n            even_value = value;\n        }\n    }\n    new_arr.push(even_value);\n\
    \    new_arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 1]`', /tmp/tmpn8__s9q9.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() > 0);\n    let\
    \ mut smalest_value = arr[0];\n    let mut smallest_index = 0;\n    let mut index_of_smallest_value\
    \ = 0;\n    for val in arr.iter().rev() {\n        if val % 2 == 0 && val < smalest_value\
    \ {\n            smalest_value = val;\n            index_of_smallest_value = smallest_index;\n\
    \        }\n        smallest_index += 1;\n    }\n    let mut rev = arr.iter().rev();\n\
    \    rev.nth(index_of_smallest_value).unwrap();\n    rev\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp73l73cja.rs:32:34\n   |\n\
    32 |         if val % 2 == 0 && val < smalest_value {\n   |                  \
    \                ^^^^^^^^^^^^^\n   |                                  |\n   |\
    \                                  expected `&isize`, found `isize`\n   |    \
    \                              help: consider borrowing here: `&smalest_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp73l73cja.rs:33:29\n   |\n28 |\
    \     let mut smalest_value = arr[0];\n   |                             ------\
    \ expected due to this value\n...\n33 |             smalest_value = val;\n   |\
    \                             ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n33 |             smalest_value = *val;\n\
    \   |                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73l73cja.rs:40:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n40\
    \ |     rev\n   |     ^^^ expected struct `Vec`, found struct `Rev`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n              found struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr.iter().min();\n\
    \    let mut smallest_index = 0;\n    let mut count = 0;\n\n    for i in arr.iter().enumerate()\
    \ {\n        if i[1].0 % 2 == 0 {\n            if i[1].0 > smallest_value {\n\
    \                smallest_value = i[1].0;\n                smallest_index = count;\n\
    \            }\n            count += 1;\n        }\n    }\n\n    if smallest_value\
    \ == 0 {\n        return Vec::new();\n    }\n\n    vec![smallest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(usize, &isize)`\n  -->\
    \ /tmp/tmpmos1gv0d.rs:32:12\n   |\n32 |         if i[1].0 % 2 == 0 {\n   |   \
    \         ^^^^ help: to access tuple elements, use: `i.1`\n\nerror[E0608]: cannot\
    \ index into a value of type `(usize, &isize)`\n  --> /tmp/tmpmos1gv0d.rs:33:16\n\
    \   |\n33 |             if i[1].0 > smallest_value {\n   |                ^^^^\
    \ help: to access tuple elements, use: `i.1`\n\nerror[E0608]: cannot index into\
    \ a value of type `(usize, &isize)`\n  --> /tmp/tmpmos1gv0d.rs:34:34\n   |\n34\
    \ |                 smallest_value = i[1].0;\n   |                           \
    \       ^^^^ help: to access tuple elements, use: `i.1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmos1gv0d.rs:41:26\n   |\n41 |     if smallest_value ==\
    \ 0 {\n   |                          ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<&isize>`\n              found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmos1gv0d.rs:45:10\n   |\n45 |\
    \     vec![smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut v = vec![];\n    let mut\
    \ smallest_even_value = arr[0];\n    let mut smallest_index = 0;\n    for &i in\
    \ arr {\n        if i / 2 == 0 {\n            v.push(i);\n            if smallest_even_value\
    \ < i {\n                smallest_even_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    v.push(smallest_even_value);\n  \
    \  v.push(smallest_index);\n    v\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7hj47xe4.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() >= 1);\n    let\
    \ mut smalest_value = arr[0];\n    let mut smalest_index = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            smalest_value = i;\n            smalest_index\
    \ = arr.len() - i - 1;\n            break;\n        }\n    }\n    vec![smalest_value,\
    \ smalest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcvo27oqc.rs:32:29\n   |\n\
    28 |     let mut smalest_value = arr[0];\n   |                             ------\
    \ expected due to this value\n...\n32 |             smalest_value = i;\n   | \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n32 |             smalest_value = *i;\n   | \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvo27oqc.rs:33:41\n\
    \   |\n33 |             smalest_index = arr.len() - i - 1;\n   |             \
    \                            ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `&isize` from `usize`\n  --> /tmp/tmpcvo27oqc.rs:33:39\n   |\n\
    33 |             smalest_index = arr.len() - i - 1;\n   |                    \
    \                   ^ no implementation for `usize - &isize`\n   |\n   = help:\
    \ the trait `Sub<&isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcvo27oqc.rs:37:25\n   |\n37 |     vec![smalest_value, smalest_index]\n\
    \   |                         ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |     vec![smalest_value, smalest_index.try_into().unwrap()]\n\
    \   |                                      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_index = std::cmp::min(0, arr.len());\n    for (index, &v) in arr.iter().enumerate()\
    \ {\n        if *v < min_val {\n            min_val = *v;\n            min_index\
    \ = index;\n        }\n    }\n    if min_val < arr.len() {\n        vec![min_val,\
    \ min_index]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpu1_glrti.rs:30:12\n\
    \   |\n30 |         if *v < min_val {\n   |            ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpu1_glrti.rs:31:23\n   |\n31 |\
    \             min_val = *v;\n   |                       ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu1_glrti.rs:35:18\n   |\n35 |     if min_val < arr.len()\
    \ {\n   |                  ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n35 |     if min_val < arr.len().try_into().unwrap() {\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu1_glrti.rs:36:23\n   |\n36 |         vec![min_val, min_index]\n\
    \   |                       ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n36 |         vec![min_val, min_index.try_into().unwrap()]\n\
    \   |                                ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::i32::MAX;\n\
    \    let mut min_index = 0;\n    let mut smalest_value = std::i32::MAX;\n    let\
    \ mut counter = 0;\n    for el in arr.iter() {\n        if el % 2 == 0 {\n   \
    \         smalest_value = el;\n            counter = 1;\n            min = el;\n\
    \            min_index = 0;\n        }\n        if el < min {\n            counter\
    \ = 0;\n            min = el;\n            min_index = 0;\n        }\n       \
    \ if counter == 0 && el == min {\n            min_index = min_index + 1;\n   \
    \     }\n    }\n    let mut v = vec![std::i32::MAX; min_index];\n    v.copy(&mut\
    \ 0, min_index, min_index + 1);\n    v\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp64yqpi7d.rs:33:29\n   |\n\
    29 |     let mut smalest_value = std::i32::MAX;\n   |                        \
    \     ------------- expected due to this value\n...\n33 |             smalest_value\
    \ = el;\n   |                             ^^ expected `i32`, found `&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp64yqpi7d.rs:35:19\n   |\n27 |  \
    \   let mut min = std::i32::MAX;\n   |                   ------------- expected\
    \ due to this value\n...\n35 |             min = el;\n   |                   ^^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64yqpi7d.rs:38:17\n\
    \   |\n38 |         if el < min {\n   |                 ^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64yqpi7d.rs:40:19\n\
    \   |\n27 |     let mut min = std::i32::MAX;\n   |                   -------------\
    \ expected due to this value\n...\n40 |             min = el;\n   |          \
    \         ^^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp64yqpi7d.rs:43:34\n   |\n43 |         if counter == 0 && el ==\
    \ min {\n   |                                  ^^^ expected `isize`, found `i32`\n\
    \nerror[E0277]: can't compare `&isize` with `i32`\n  --> /tmp/tmp64yqpi7d.rs:43:31\n\
    \   |\n43 |         if counter == 0 && el == min {\n   |                     \
    \          ^^ no implementation for `&isize == i32`\n   |\n   = help: the trait\
    \ `PartialEq<i32>` is not implemented for `&isize`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n\
    \             i128\n             i16\n             i32\n             i64\n   \
    \          i8\n             isize\n           and 6 others\n\nerror[E0599]: no\
    \ method named `copy` found for struct `Vec<i32>` in the current scope\n  -->\
    \ /tmp/tmp64yqpi7d.rs:48:7\n   |\n48 |     v.copy(&mut 0, min_index, min_index\
    \ + 1);\n   |       ^^^^ method not found in `Vec<i32>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp64yqpi7d.rs:49:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- "
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = -1;\n    let mut even_value_count = arr.iter().filter(|&x|\
    \ x.is_even()).count();\n    if even_value_count == 0 {\n        return vec![];\n\
    \    }\n    for i in 0..arr.len() {\n        if arr[i].is_even() && (arr[i] <\
    \ smallest_value) {\n            smallest_value = arr[i];\n            smallest_index\
    \ = i;\n        }\n    }\n    let mut index = smallest_index;\n    let mut value\
    \ = smallest_value;\n    for i in 1..arr.len() {\n        if arr[i] == value {\n\
    \            i += 1;\n            if i == smallest_index {\n                index\
    \ += 1;\n                value = arr[index];\n            }\n        }\n    }\n\
    \    let mut result = vec![];\n    result.resize(index + 1.);\n    result[index]\
    \ = value;\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpusn_y_6k.rs:29:57\n   |\n29 |     let mut even_value_count\
    \ = arr.iter().filter(|&x| x.is_even()).count();\n   |                       \
    \                                  ^^^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `is_even` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpusn_y_6k.rs:34:19\n   |\n34 |         if arr[i].is_even() && (arr[i]\
    \ < smallest_value) {\n   |                   ^^^^^^^ method not found in `isize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpusn_y_6k.rs:28:30\n\
    \   |\n28 |     let mut smallest_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ cannot add `{float}` to `usize`\n  --> /tmp/tmpusn_y_6k.rs:51:25\n   |\n51 |\
    \     result.resize(index + 1.);\n   |                         ^ no implementation\
    \ for `usize + {float}`\n   |\n   = help: the trait `Add<{float}>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0061]: this function takes 2 arguments but 1 argument was\
    \ supplied\n    --> /tmp/tmpusn_y_6k.rs:51:12\n     |\n51   |     result.resize(index\
    \ + 1.);\n     |            ^^^^^^ ---------- supplied 1 argument\n     |    \
    \        |\n     |            expected 2 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, "
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_val = arr[0];\n\
    \    let mut min_even_idx = 0;\n\n    // find minimum value and its index\n  \
    \  for i in arr {\n        if i % 2 == 0 {\n            if min_even_val == i {\n\
    \                min_even_val += 2;\n                min_even_idx = i;\n     \
    \       } else {\n                min_even_val = i;\n                min_even_idx\
    \ = i;\n            }\n        }\n    }\n\n    // return min value\n    let mut\
    \ ret_vec = Vec::new();\n    ret_vec.push(min_even_val);\n    ret_vec.push(min_even_idx);\n\
    \    return ret_vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmp5qq2g0ik.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_index: usize = 0;\n    let mut current_index: usize\
    \ = 0;\n\n    for i in arr {\n        if i % 2 == 0 {\n            smalest_value\
    \ = i;\n            smalest_index = current_index;\n        }\n\n        current_index\
    \ += 1;\n    }\n\n    if smalest_value == 0 {\n        return Vec::new();\n  \
    \  }\n\n    if smalest_index == arr.len() {\n        vec![]\n    } else {\n  \
    \      let mut indexes: Vec<usize> = Vec::new();\n        for i in arr.iter().rev()\
    \ {\n            if i % 2 == 0 {\n                indexes.push(i);\n         \
    \   }\n        }\n        indexes.sort_by_key(|index| index % 2 != 0);\n     \
    \   indexes.reverse();\n        indexes.get(smalest_index)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jf1y0mb.rs:50:30\n   |\n\
    50 |                 indexes.push(i);\n   |                              ^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8jf1y0mb.rs:55:9\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n55\
    \ |         indexes.get(smalest_index)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found enum `Option<&usize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // sort by even value to get smallest\
    \ even value\n    // since we sort by even value, the first one should be the\
    \ smallest even value\n    arr.sort_by(|a, b| if a % 2 == b % 2 { a } else { b\
    \ })\n\n    // find the index of the smallest even value\n    let mut smalest_value\
    \ = 0;\n    let mut smallest_index = 0;\n    for i in 0..arr.len() {\n       \
    \ if arr[i] % 2 == 0 {\n            if smalest_value == 0 {\n                smalest_value\
    \ = arr[i];\n                smallest_index = i;\n            } else {\n     \
    \           if arr[i] < smalest_value {\n                    smalest_value = arr[i];\n\
    \                    smallest_index = i;\n                }\n            }\n \
    \       }\n    }\n\n    let mut vec = Vec::new();\n    vec.push(smalest_value);\n\
    \    vec.push(smallest_index);\n\n    return vec;\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpidnmh8xm.rs:29:59\n\
    \   |\n29 |     arr.sort_by(|a, b| if a % 2 == b % 2 { a } else { b })\n   | \
    \                                                          ^ help: add `;` here\n\
    ...\n32 |     let mut smalest_value = 0;\n   |     --- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpidnmh8xm.rs:29:44\n   |\n29 |     arr.sort_by(|a,\
    \ b| if a % 2 == b % 2 { a } else { b })\n   |                               \
    \             ^ expected enum `std::cmp::Ordering`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpidnmh8xm.rs:29:55\n   |\n29 |     arr.sort_by(|a,\
    \ b| if a % 2 == b % 2 { a } else { b })\n   |                               \
    \                        ^ expected enum `std::cmp::Ordering`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpidnmh8xm.rs:50:14\n   |\n50 |\
    \     vec.push(smallest_index);\n   |              ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n50 |     vec.push(smallest_index.try_into().unwrap());\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert_eq!(*arr.len(), 10000);\n\
    \    let mut even = vec![0; arr.len()];\n    let mut index = vec![0; arr.len()];\n\
    \    let mut max_even = -1;\n    let mut max_index = -1;\n    for e in arr {\n\
    \        if e % 2 == 0 {\n            even[e as usize] = e;\n            index[e\
    \ as usize] = even[e as usize];\n        }\n        if e < max_even {\n      \
    \      max_even = e;\n            max_index = index;\n        }\n    }\n    if\
    \ even[max_even] == -1 {\n        return vec![];\n    }\n    let mut i = 0;\n\
    \    for e in even {\n        if e == max_even {\n            return vec![i..(max_index[e\
    \ as usize] + 1)];\n        }\n        i += 1;\n    }\n    vec![i]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmps1udf513.rs:27:16\n\
    \   |\n27 |     assert_eq!(*arr.len(), 10000);\n   |                ^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps1udf513.rs:39:25\n   |\n31 |\
    \     let mut max_index = -1;\n   |                         -- expected due to\
    \ this value\n...\n39 |             max_index = index;\n   |                 \
    \        ^^^^^ expected integer, found struct `Vec`\n   |\n   = note: expected\
    \ type `{integer}`\n            found struct `Vec<isize>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps1udf513.rs:42:8\n\
    \   |\n42 |     if even[max_even] == -1 {\n   |        ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0608]: cannot index into a value of\
    \ type `{integer}`\n  --> /tmp/tmps1udf513.rs:48:29\n   |\n48 |             return\
    \ vec![i..(max_index[e as usize] + 1)];\n   |                             ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps1udf513.rs:48:25\n   |\n48 |\
    \             return vec![i..(max_index[e as usize] + 1)];\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected type `isize`\n            found struct `std::ops::Range<{integer}>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0608, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_value: isize = 1;\n    let mut smallest_index:\
    \ isize = 0;\n    for node in\n        arr.iter().cloned().filter(|&x| x >= 0\
    \ && x < arr.len()).iter().cloned().cloned()\n    {\n        if smallest_value\
    \ == 0 {\n            if node < smallest_value {\n                smallest_value\
    \ = node;\n                smallest_index = 0;\n            }\n        }\n   \
    \     if node == smallest_value {\n            smallest_index += 1;\n        }\n\
    \    }\n    smallest_index\n        .into_iter()\n        .cloned()\n        .filter(|&x|\
    \ x % 2 == 0)\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt5hy8u7.rs:33:55\n   |\n\
    33 |         arr.iter().cloned().filter(|&x| x >= 0 && x < arr.len()).iter().cloned().cloned()\n\
    \   |                                                       ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n33 |         arr.iter().cloned().filter(|&x|\
    \ x >= 0 && x < arr.len().try_into().unwrap()).iter().cloned().cloned()\n   |\
    \                                                                ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `iter` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpqt5hy8u7.rs:33:66\n   |\n33 |         arr.iter().cloned().filter(|&x|\
    \ x >= 0 && x < arr.len()).iter().cloned().cloned()\n   |                    \
    \                                              ^^^^ private field, not a method\n\
    \nerror[E0599]: `isize` is not an iterator\n  --> /tmp/tmpqt5hy8u7.rs:46:10\n\
    \   |\n46 |         .into_iter()\n   |          ^^^^^^^^^ `isize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `isize:\
    \ Iterator`\n           which is required by `isize: IntoIterator`\n         \
    \  `&isize: Iterator`\n           which is required by `&isize: IntoIterator`\n\
    \           `&mut isize: Iterator`\n           which is required by `&mut isize:\
    \ IntoIterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_index = arr.iter().min_by_key(|&x|\
    \ *x).unwrap();\n    let mut smalest_value = min_index;\n    while arr.iter().any(|&x|\
    \ *x == 0) {\n        smalest_value = min_index;\n        min_index = min_index\
    \ / 2;\n    }\n    let mut ret = {0};\n    ret.push(smalest_value);\n    ret.push(min_index);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpgucxj0lr.rs:29:31\n\
    \   |\n29 |     while arr.iter().any(|&x| *x == 0) {\n   |                   \
    \            ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgucxj0lr.rs:31:21\n\
    \   |\n27 |     let mut min_index = arr.iter().min_by_key(|&x| *x).unwrap();\n\
    \   |                         --------------------------------------- expected\
    \ due to this value\n...\n31 |         min_index = min_index / 2;\n   |      \
    \               ^^^^^^^^^^^^^\n   |                     |\n   |              \
    \       expected `&isize`, found `isize`\n   |                     help: consider\
    \ borrowing here: `&(min_index / 2)`\n\nerror[E0599]: no method named `push` found\
    \ for type `{integer}` in the current scope\n  --> /tmp/tmpgucxj0lr.rs:34:9\n\
    \   |\n34 |     ret.push(smalest_value);\n   |         ^^^^ method not found in\
    \ `{integer}`\n\nerror[E0599]: no method named `push` found for type `{integer}`\
    \ in the current scope\n  --> /tmp/tmpgucxj0lr.rs:35:9\n   |\n35 |     ret.push(min_index);\n\
    \   |         ^^^^ method not found in `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgucxj0lr.rs:36:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n36 |     ret\n   |     ^^^ expected struct `Vec`,\
    \ found integer\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `{integer}`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // Write your code here.\n    let\
    \ mut smalest_value = i32::MIN;\n    let mut smalest_index = 0;\n    let mut smallest_value_index\
    \ = i32::MAX;\n    let mut smallest_value_value = i32::MIN;\n\n    let mut even_values\
    \ = arr\n        .iter()\n        .filter(|&x| x % 2 == 0)\n        .cloned()\n\
    \        .collect::<Vec<isize>>();\n\n    for index, _v in arr.iter().cloned().enumerate()\
    \ {\n        if even_values.contains(&index * 2) {\n            smallest_value_index\
    \ = index;\n            smallest_value_value = index;\n            smalest_index\
    \ = index;\n            smalest_value = index;\n            even_values.remove(index);\n\
    \        }\n    }\n\n    vec![smalest_value, smalest_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmpmzho3v6w.rs:39:14\n   |\n\
    39 |     for index, _v in arr.iter().cloned().enumerate() {\n   |            \
    \  ^\n   |\nhelp: try adding parentheses to match on a tuple\n   |\n39 |     for\
    \ (index, _v) in arr.iter().cloned().enumerate() {\n   |         +         +\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().enumerate().filter(|(_,\
    \ v)| *v % 2 == 0).map(|(_, v)| *v).min()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xlq9uu_.rs:27:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n27 |     arr.iter().enumerate().filter(|(_,\
    \ v)| *v % 2 == 0).map(|(_, v)| *v).min()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found enum `Option<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n    }\n\n    let mut smallest_even = even_values.iter().min();\n\n\
    \    let mut smallest_index = even_values.iter().nth(|x| *x == *smallest_even).unwrap();\n\
    \n    if even_values.len() == 0 {\n        return vec![];\n    }\n\n    for i\
    \ in even_values {\n        if smallest_even % 2 == 0 {\n            smallest_even\
    \ /= 2;\n        }\n\n        if *i == *smallest_even {\n            smallest_index\
    \ = i;\n        }\n    }\n\n    vec![smallest_even, smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp_a9bh0lx.rs:36:54\n\
    \   |\n36 |     let mut smallest_index = even_values.iter().nth(|x| *x == *smallest_even).unwrap();\n\
    \   |                                                      ^ consider giving this\
    \ closure parameter a type\n   |\n   = note: type must be known at this point\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp_a9bh0lx.rs:36:63\n\
    \   |\n36 |     let mut smallest_index = even_values.iter().nth(|x| *x == *smallest_even).unwrap();\n\
    \   |                                                               ^^^^^^^^^^^^^^\n\
    \nerror[E0369]: cannot mod `Option<&isize>` by `{integer}`\n  --> /tmp/tmp_a9bh0lx.rs:43:26\n\
    \   |\n43 |         if smallest_even % 2 == 0 {\n   |            -------------\
    \ ^ - {integer}\n   |            |\n   |            Option<&isize>\n\nerror[E0368]:\
    \ binary assignment operation `/=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmp_a9bh0lx.rs:44:13\n   |\n44 |             smallest_even /= 2;\n\
    \   |             -------------^^^^^\n   |             |\n   |             cannot\
    \ use `/=` on type `Option<&isize>`\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp_a9bh0lx.rs:47:12\n   |\n47 |         if *i == *smallest_even {\n\
    \   |            ^^\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp_a9bh0lx.rs:47:18\n   |\n47 |         if *i == *smallest_even {\n\
    \   |                  ^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_a9bh0lx.rs:48:30\n   |\n36 |     let mut smallest_index = even_values.iter().nth(|x|\
    \ *x == *smallest_even).unwrap();\n   |                              ---------------------------------------------------------\
    \ expected due to this value\n...\n48 |             smallest_index = i;\n   |\
    \                              ^\n   |                              |\n   |  \
    \                            expected `&isize`, found `isize`\n   |          \
    \                    help: consider borrowing here: `&i`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_a9bh0lx.rs:52:10\n   |\n52 |     vec![smallest_even"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_value = arr.iter().filter(|&n|\
    \ n % 2 == 0).next();\n    let mut smalest_value = even_value;\n    let mut smalest_index:\
    \ isize = 0;\n    for (i, &n) in arr.iter().enumerate() {\n        if n % 2 ==\
    \ 0 {\n            if smalest_value != n {\n                smalest_value = n;\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    if smalest_value\
    \ == EvenValue {\n        vec![smalest_value, smalest_index]\n    } else {\n \
    \       vec![smalest_value]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `EvenValue` in this scope\n  --> /tmp/tmptkl3z6hz.rs:38:25\n\
    \   |\n38 |     if smalest_value == EvenValue {\n   |                        \
    \ ^^^^^^^^^ help: a local variable with a similar name exists: `even_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptkl3z6hz.rs:32:33\n   |\n32 |  \
    \           if smalest_value != n {\n   |                                 ^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptkl3z6hz.rs:33:33\n\
    \   |\n28 |     let mut smalest_value = even_value;\n   |                    \
    \         ---------- expected due to this value\n...\n33 |                 smalest_value\
    \ = n;\n   |                                 ^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<&isize>`\n              found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptkl3z6hz.rs:34:33\n   |\n29 |\
    \     let mut smalest_index: isize = 0;\n   |                            -----\
    \ expected due to this type\n...\n34 |                 smalest_index = i;\n  \
    \ |                                 ^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptkl3z6hz.rs:39:14\n   |\n39 |         vec![smalest_value,\
    \ smalest_index]\n   |              ^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptkl3z6hz.rs:41:14\n   |\n41 |\
    \         vec![smalest_value]\n   |              ^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = vec![];\n\
    \    let mut smallest_value: isize = std::i32::MAX;\n    let mut smallest_index:\
    \ usize = 0;\n    let mut even_value_index: usize = 0;\n\n    for v in arr.iter()\
    \ {\n        if v % 2 == 0 {\n            even_value_index += 1;\n        } else\
    \ {\n            if even_value_index > 0 {\n                smallest_value = std::i32::MAX;\n\
    \                smallest_index = even_value_index - 1;\n                even_value_index\
    \ = 0;\n            }\n            if smallest_value > v {\n                smallest_value\
    \ = v;\n                smallest_index = v;\n            }\n        }\n    }\n\
    \    if even_value_index > 0 {\n        smallest_value = std::i32::MAX;\n    \
    \    smallest_index = even_value_index - 1;\n    }\n\n    vec.push(smallest_value);\n\
    \    vec.push(smallest_index);\n\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgzvo3wlp.rs:28:37\n   |\n\
    28 |     let mut smallest_value: isize = std::i32::MAX;\n   |                \
    \             -----   ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |      \
    \                       |\n   |                             expected due to this\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n28 |     let mut smallest_value: isize = std::i32::MAX.try_into().unwrap();\n\
    \   |                                                  ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgzvo3wlp.rs:37:34\n   |\n28 |  \
    \   let mut smallest_value: isize = std::i32::MAX;\n   |                     \
    \        ----- expected due to this type\n...\n37 |                 smallest_value\
    \ = std::i32::MAX;\n   |                                  ^^^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgzvo3wlp.rs:41:33\n\
    \   |\n41 |             if smallest_value > v {\n   |                        \
    \         ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n41 |             if smallest_value > *v {\n   |          \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgzvo3wlp.rs:42:34\n\
    \   |\n28 |     let mut smallest_value: isize = std::i32::MAX;\n   |         \
    \                    ----- expected due to this type\n...\n42 |              \
    \   smallest_value = v;\n   |                                  ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n42 |  \
    \               smallest_value = *v;\n   |                                  +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgzvo3wlp.rs:43:34\n   |\n29 |\
    \     let mut smallest_index: usize = 0;\n   |                             -----\
    \ expected due to this type\n...\n43 |                 smallest_index = v;\n \
    \  |                                  ^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgzvo3wlp.rs:48:26\n   |\n28 |     let mut smallest_value:\
    \ isize = std::i32::M"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut mut_arr = arr.to_mut();\n\
    \    mut_arr.sort_unstable();\n    let mut first_index = -1;\n    let mut mut_first_index\
    \ = first_index;\n    while mut_arr.len() > 1 {\n        let mut mut_arr2 = mut_arr.to_mut();\n\
    \        mut_arr2.sort();\n        if mut_arr[0] % 2 == 0 {\n            mut_first_index\
    \ = mut_arr.len();\n        }\n        let mut_first_index = mut_first_index +\
    \ 1;\n        mut_arr.drain(..mut_arr.len() - 1);\n        if mut_arr.len() ==\
    \ 0 {\n            break;\n        }\n        if mut_arr[0] % 2 != 0 {\n     \
    \       first_index = mut_first_index;\n            break;\n        }\n      \
    \  mut_arr.drain(..mut_arr.len() - 1);\n    }\n    if mut_arr.len() == 0 || mut_arr[0]\
    \ != 0 {\n        return vec![];\n    }\n    mut_arr.get(mut_first_index).unwrap()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_mut` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmperikep7c.rs:27:27\n   |\n27 |     let mut mut_arr\
    \ = arr.to_mut();\n   |                           ^^^^^^ help: there is an associated\
    \ function with a similar name: `align_to_mut`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut idx: usize = 1;\n    let\
    \ mut smalest_value = arr[0];\n    while idx < arr.len() {\n        if arr[idx]\
    \ % 2 == 0 {\n            smalest_value = arr[idx];\n            idx = idx;\n\
    \        } else {\n            idx += 1;\n        }\n    }\n    if arr.len() ==\
    \ 0 {\n        return vec![];\n    }\n    let mut arr = vec![];\n    if smalest_value\
    \ % 2 == 0 {\n        arr.push(smalest_value);\n    }\n    arr.push(idx);\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy8rjbzby.rs:44:14\n   |\n\
    44 |     arr.push(idx);\n   |              ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n44 |     arr.push(idx.try_into().unwrap());\n   | \
    \                ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), 10000);\n\
    \    let mut largest = vec![isize::MAX];\n    let mut index = 0;\n    let mut\
    \ smallest_index = 0;\n    for i in arr {\n        if i < largest[0] {\n     \
    \       largest[0] = i;\n            smallest_index = 0;\n        }\n        if\
    \ i == largest[0] {\n            largest[0] += 1;\n        }\n        if i ==\
    \ smallest_index {\n            if largest[0] != i {\n                smallest_index\
    \ += 1;\n            }\n        }\n    }\n    let mut ret: Vec<isize> = vec![];\n\
    \    ret[0] = largest[0];\n    if smallest_index == 0 {\n        return ret;\n\
    \    }\n    for i in arr {\n        if i < ret[0] {\n            ret[0] = i;\n\
    \        }\n    }\n    for i in &arr[smallest_index..] {\n        if i != ret[0]\
    \ {\n            return ret;\n        }\n    }\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmp44kc5frb.rs:55:15\n   |\n55 |     for i in &arr[smallest_index..]\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `RangeFrom<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \             <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_value_count = 0usize;\n\
    \    let mut smallest_index = 0usize;\n    let mut smallest_value = arr[0];\n\
    \    for &item in arr {\n        if item % 2 == 0 {\n            even_value_count\
    \ = even_value_count + 1usize;\n            if smallest_value > item {\n     \
    \           smallest_value = item;\n                smallest_index = smallest_index\
    \ + 1usize;\n            }\n        }\n    }\n\n    if even_value_count < 2 {\n\
    \        vec![]\n    } else if even_value_count == 2 {\n        if smallest_index\
    \ == 0usize || smallest_index == 1usize {\n            return vec![]\n       \
    \ }\n    } else {\n        let mut index = smallest_index;\n        let mut value\
    \ = smallest_value;\n        while index != 0usize && value % 2 == 0 {\n     \
    \       value /= 2;\n            index = index - 1usize;\n        }\n        if\
    \ index == 0usize {\n            return vec![]\n        } else if index == 1usize\
    \ {\n            return vec![smallest_value]\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmq2ekj9l.rs:30:9\n   |\n\
    30 |     for &item in arr {\n   |         ^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `item`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0317]:\
    \ `if` may be missing an `else` clause\n  --> /tmp/tmpmq2ekj9l.rs:43:9\n   |\n\
    43 | /         if smallest_index == 0usize || smallest_index == 1usize {\n44 |\
    \ |             return vec![]\n   | |             ------------- found here\n45\
    \ | |         }\n   | |_________^ expected `()`, found struct `Vec`\n   |\n  \
    \ = note: expected unit type `()`\n                 found struct `Vec<isize>`\n\
    \   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider\
    \ adding an `else` block that evaluates to the expected type\n\nerror[E0317]:\
    \ `if` may be missing an `else` clause\n  --> /tmp/tmpmq2ekj9l.rs:55:16\n   |\n\
    55 |           } else if index == 1usize {\n   |  ________________^\n56 | |  \
    \           return vec![smallest_value]\n   | |             ---------------------------\
    \ found here\n57 | |         }\n   | |_________^ expected `()`, found struct `Vec`\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<isize>`\n\
    \   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider\
    \ adding an `else` block that evaluates to the expected type\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0317.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort().cloned().take(arr.len())\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp14ujef9p.rs:27:16\n\
    \   |\n27 |     arr.sort().cloned().take(arr.len())\n   |                ^^^^^^\
    \ `()` is not an iterator\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `(): Iterator`\n           which is required by `&mut\
    \ (): Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n\n    let mut min_index = 0usize;\n    let mut min_val = arr[0];\n\
    \    let mut current_index = 0usize;\n\n    for &n in arr {\n        if n % 2\
    \ == 0 {\n            min_val = n;\n            current_index = min_index;\n \
    \       }\n        if n == min_val {\n            current_index += 1;\n      \
    \      min_index = current_index;\n        }\n    }\n\n    return vec![min_val,\
    \ min_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptfvvrbj7.rs:35:9\n   |\n\
    35 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptfvvrbj7.rs:46:26\n   |\n46 |     return vec![min_val, min_index];\n\
    \   |                          ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n46 |     return vec![min_val, min_index.try_into().unwrap()];\n\
    \   |                                   ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_idx = isize::MAX;\n\
    \    let mut smallest_value = isize::MAX;\n    for &node in arr {\n        smallest_value\
    \ = min_idx if node < smallest_value {\n            smallest_value = node;\n \
    \           min_ind = min_idx;\n        }\n        if node % 2 == 0 && node <\
    \ smallest_value {\n            min_idx = node;\n        }\n    }\n    if min_idx\
    \ == isize::MAX {\n        vec![]\n    } else {\n        vec![(smallest_value,\
    \ min_idx)]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmprny37u5f.rs:30:34\n   |\n30 |         smallest_value\
    \ = min_idx if node < smallest_value {\n   |                                 \
    \ ^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprny37u5f.rs:29:9\n   |\n29 |     for &node in arr {\n   |         ^^^^^\
    \    --- this expression has type `Option<isize>`\n   |         |\n   |      \
    \   expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `node`\n   |\n   = note:   expected type `isize`\n    \
    \       found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprny37u5f.rs:41:14\n\
    \   |\n41 |         vec![(smallest_value, min_idx)]\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(isize, isize)`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = vec![arr.iter().min().unwrap()];\n\
    \    let mut min = vec![(&arr[min[0]]).unwrap()];\n    let mut min = vec![(&arr[min[0]]).unwrap()];\n\
    \n    for index in min.iter().skip(1) {\n        let mut current_min = vec![index.clone()];\n\
    \        if arr.len() > 2 {\n            for index in min.iter().skip(2) {\n \
    \               let mut current_min = vec![index.clone()];\n                let\
    \ mut current_min_index = index;\n                while arr.len() > 2 {\n    \
    \                let mut min = vec![(&arr[index]).unwrap()];\n               \
    \     let mut index = index;\n                    if min[0] == 0 && min[1] ==\
    \ 0 {\n                        break;\n                    }\n               \
    \     min.iter().for_each(|&i| {\n                        if i % 2 == 0 {\n  \
    \                          current_min.push(index);\n                        \
    \    current_min_index += 2;\n                        }\n                    });\n\
    \                }\n                current_min = vec![current_min.iter().min().unwrap()];\n\
    \                current_min = vec![(&arr[current_min[0]]).unwrap()];\n      \
    \          current_min = vec![(&arr[current_min[0]]).unwrap()];\n            \
    \    current_min_index += 1;\n                if current_min_index == index {\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     min = vec![current_min.clone(), current_min_index];\n    }\n    vec![(&arr[min[0]]).unwrap(),\
    \ min[1]]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `current_min_index` in this scope\n  -->\
    \ /tmp/tmppsi1xq58.rs:59:41\n   |\n59 |         min = vec![current_min.clone(),\
    \ current_min_index];\n   |                                         ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmppsi1xq58.rs:28:26\n   |\n28 |     let mut min = vec![(&arr[min[0]]).unwrap()];\n\
    \   |                          ^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppsi1xq58.rs:50:31\n\
    \   |\n50 |                 current_min = vec![current_min.iter().min().unwrap()];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cyclic\
    \ type of infinite size\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // write your code here\n    let\
    \ mut min = arr[0];\n    let mut index = 0;\n    for i in arr {\n        if i\
    \ % 2 == 0 {\n            min = i;\n        }\n        if i == min {\n       \
    \     index += 1;\n        }\n    }\n    vec![min, index].into_iter().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmpbda9jtmn.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = arr[0];\n    let\
    \ mut min_index = 0;\n\n    for e in arr {\n        if e == min {\n          \
    \  min_index += 1;\n        }\n        if e < min {\n            min = e;\n  \
    \          min_index = 0;\n        }\n    }\n    vec![min, min_index]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 0]`,\n right: `[2, 1]`', /tmp/tmput890_2o.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_index = 0;\n    for value in arr {\n        if value\
    \ % 2 == 0 {\n            if smalest_value == 0 {\n                smalest_value\
    \ = value;\n                smalest_index = arr.iter().position(|n| *n % 2 ==\
    \ 0).unwrap();\n            } else if *smalest_value < *value {\n            \
    \    smalest_value = value;\n                smalest_index = arr.iter().position(|n|\
    \ *n % 2 == 0).unwrap();\n            }\n        }\n    }\n    smalest_index\n\
    \        .clone()\n        .into_iter()\n        .collect::<Vec<_>>()\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpcsuarq96.rs:34:23\n\
    \   |\n34 |             } else if *smalest_value < *value {\n   |            \
    \           ^^^^^^^^^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpcsuarq96.rs:34:40\n   |\n34 |             } else if *smalest_value\
    \ < *value {\n   |                                        ^^^^^^\n\nerror[E0599]:\
    \ `usize` is not an iterator\n  --> /tmp/tmpcsuarq96.rs:42:10\n   |\n42 |    \
    \     .into_iter()\n   |          ^^^^^^^^^ `usize` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `usize:\
    \ Iterator`\n           which is required by `usize: IntoIterator`\n         \
    \  `&usize: Iterator`\n           which is required by `&usize: IntoIterator`\n\
    \           `&mut usize: Iterator`\n           which is required by `&mut usize:\
    \ IntoIterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert_eq!(1, arr.len());\n   \
    \ let mut smallest_even_node: isize = 0;\n    let mut smallest_even_node_and_index:\
    \ Vec<isize> = Vec::new();\n    let mut smallest_index: usize = 0;\n    for e\
    \ in arr.iter() {\n        if smallest_even_node == 0 || e % smallest_even_node\
    \ == 0 {\n            if smallest_even_node == 0 {\n                smallest_even_node\
    \ = e;\n                smallest_even_node_and_index.push(e);\n            } else\
    \ {\n                if e < smallest_even_node {\n                    smallest_even_node\
    \ = e;\n                    smallest_even_node_and_index.push(e);\n          \
    \      }\n            }\n        } else {\n            smallest_index = 0;\n \
    \           if e < smallest_even_node {\n                if smallest_index < smallest_even_node_and_index.len()\
    \ {\n                    smallest_index = smallest_even_node_and_index.len();\n\
    \                    smallest_even_node = e;\n                    smallest_even_node_and_index.push(e);\n\
    \                }\n            }\n        }\n    }\n    if smallest_even_node\
    \ == 0 {\n        return Vec::new();\n    }\n    if smallest_even_node_and_index.len()\
    \ == 1 {\n        return smallest_even_node_and_index.clone();\n    }\n    if\
    \ smallest_index != 0 {\n        let mut i = smallest_index;\n        while i\
    \ != 0 {\n            smallest_index = smallest_even_node_and_index[i as usize];\n\
    \            i = (i + 1) % smallest_index;\n        }\n        return smallest_even_node_and_index.clone();\n\
    \    }\n    return Vec::new();\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxstreho_.rs:34:38\n   |\n\
    28 |     let mut smallest_even_node: isize = 0;\n   |                        \
    \         ----- expected due to this type\n...\n34 |                 smallest_even_node\
    \ = e;\n   |                                      ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_even_node\
    \ = *e;\n   |                                      +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxstreho_.rs:35:51\n   |\n35 |                 smallest_even_node_and_index.push(e);\n\
    \   |                                                   ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |        \
    \         smallest_even_node_and_index.push(*e);\n   |                       \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxstreho_.rs:37:24\n\
    \   |\n37 |                 if e < smallest_even_node {\n   |                \
    \        ^^^^^^^^^^^^^^^^^^\n   |                        |\n   |             \
    \           expected `&isize`, found `isize`\n   |                        help:\
    \ consider borrowing here: `&smallest_even_node`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxstreho_.rs:38:42\n   |\n28 |     let mut smallest_even_node: isize\
    \ = 0;\n   |                                 ----- expected due to this type\n\
    ...\n38 |                     smallest_even_node = e;\n   |                  \
    \                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n38 |                     smallest_even_node\
    \ = *e;\n   |                                          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxstreho_.rs:39:55\n   |\n39 |                     smallest_even_node_and_index.push(e);\n\
    \   |                                                       ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n39 |  \
    \                   smallest_even_node_and_index.push(*e);\n   |             \
    \                                          +\n\nerror"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    let mut counter\
    \ = Vec::new();\n    let mut result = Vec::new();\n    for (index, element) in\
    \ arr.iter().enumerate() {\n        if counter > 0 && element % 2 == 0 {\n   \
    \         result.push(counter.min());\n            counter.clear();\n        }\n\
    \        counter.push(element);\n    }\n    if counter > 0 {\n        result.push(counter.min());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6qvqvajj.rs:31:22\n   |\n\
    31 |         if counter > 0 && element % 2 == 0 {\n   |                      ^\
    \ expected struct `Vec`, found integer\n   |\n   = note: expected struct `Vec<_>`\n\
    \                found type `{integer}`\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmp6qvqvajj.rs:32:33\n \
    \   |\n32  |             result.push(counter.min());\n    |                  \
    \               ^^^- supplied 0 arguments\n    |                             \
    \    |\n    |                                 expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6qvqvajj.rs:37:18\n\
    \   |\n37 |     if counter > 0 {\n   |                  ^ expected struct `Vec`,\
    \ found integer\n   |\n   = note: expected struct `Vec<&isize>`\n            \
    \    found type `{integer}`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmp6qvqvajj.rs:38:29\n    |\n38  |  \
    \       result.push(counter.min());\n    |                             ^^^- supplied\
    \ 0 arguments\n    |                             |\n    |                    \
    \         expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6qvqvajj.rs:40:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n40 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Vec<&isize>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min_val = arr.iter().min();\n    let mut min_idx\
    \ = 0;\n    for idx in 0..arr.len() {\n        if arr[idx] < min_val {\n     \
    \       min_val = arr[idx];\n            min_idx = idx;\n        }\n    }\n  \
    \  return vec![(min_val, min_idx)];\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfzktxb05.rs:33:23\n   |\n\
    33 |         if arr[idx] < min_val {\n   |                       ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfzktxb05.rs:34:23\n   |\n30 |     let mut min_val = arr.iter().min();\n\
    \   |                       ---------------- expected due to this value\n...\n\
    34 |             min_val = arr[idx];\n   |                       ^^^^^^^^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfzktxb05.rs:38:17\n\
    \   |\n38 |     return vec![(min_val, min_idx)];\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(Option<&isize>, usize)`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_values = [isize::MIN,\
    \ isize::MAX];\n    let mut min_value_index = isize::MIN;\n    for ele in arr\
    \ {\n        if min_values[ele] < min_values[min_value_index] {\n            min_values[min_value_index]\
    \ = ele;\n            min_value_index = ele;\n        }\n    }\n    if min_value_index\
    \ == isize::MIN || min_value_index == isize::MAX {\n        return vec![];\n \
    \   }\n    let mut ans = vec![min_value_index];\n    for i in min_values.iter().rev()\
    \ {\n        if min_values[i] != i {\n            ans.push(i);\n            break;\n\
    \        }\n    }\n    return ans;\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa8bx6_ag.rs:30:12\n\
    \   |\n30 |         if min_values[ele] < min_values[min_value_index] {\n   | \
    \           ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `[isize]`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa8bx6_ag.rs:30:30\n\
    \   |\n30 |         if min_values[ele] < min_values[min_value_index] {\n   | \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[isize]`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpa8bx6_ag.rs:31:13\n   |\n31 |             min_values[min_value_index]\
    \ = ele;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[isize]`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpa8bx6_ag.rs:40:12\n   |\n40 |         if min_values[i]\
    \ != i {\n   |            ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa8bx6_ag.rs:41:22\n\
    \   |\n41 |             ans.pu"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values: Vec<isize>\
    \ = vec![];\n    let mut even_values_index: Vec<isize> = vec![];\n    let mut\
    \ smallest_value = arr.iter().min().unwrap();\n\n    let mut smallest_index =\
    \ 0;\n\n    for i in arr.iter() {\n        if i.is_even() {\n            even_values.push(i);\n\
    \            even_values_index.push(i);\n            if even_values.len() > 1\
    \ {\n                if even_values[0] == i {\n                    smallest_value\
    \ = i;\n                    smallest_index = even_values_index.iter().min().unwrap();\n\
    \                } else {\n                    smallest_value = even_values[0];\n\
    \                    smallest_index = even_values_index[0];\n                }\n\
    \            }\n        }\n    }\n\n    even_values_index.iter().cloned().filter(|&index|\
    \ index == smallest_index).cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpppw8p1wj.rs:34:14\n   |\n34 |         if i.is_even()\
    \ {\n   |              ^^^^^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpppw8p1wj.rs:35:30\n   |\n35 |             even_values.push(i);\n\
    \   |                              ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n35 |             even_values.push(*i);\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpppw8p1wj.rs:36:36\n   |\n36 |             even_values_index.push(i);\n\
    \   |                                    ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n36 |             even_values_index.push(*i);\n\
    \   |                                    +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpppw8p1wj.rs:38:38\n   |\n38 |                 if even_values[0]\
    \ == i {\n   |                                      ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |        \
    \         if even_values[0] == *i {\n   |                                    \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpppw8p1wj.rs:40:38\n   |\n\
    31 |     let mut smallest_index = 0;\n   |                              - expected\
    \ due to this value\n...\n40 |                     smallest_index = even_values_index.iter().min().unwrap();\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n40 |                     smallest_index = *even_values_index.iter().min().unwrap();\n\
    \   |                                      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpppw8p1wj.rs:42:38\n   |\n29 |     let mut smallest_value = arr.iter().min().unwrap();\n\
    \   |                              ------------------------- expected due to this\
    \ value\n...\n42 |                     smallest_value = even_values[0];\n   |\
    \                                      ^^^^^^^"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort_unstable_by_key(|x| x\
    \ % 2)\n        .into_iter()\n        .take(arr.len() / 2)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp12yrpvcj.rs:28:10\n\
    \   |\n28 |         .into_iter()\n   |          ^^^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `(): IntoIterator`\n           `&():\
    \ Iterator`\n           which is required by `&(): IntoIterator`\n           `&mut\
    \ (): Iterator`\n           which is required by `&mut (): IntoIterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.to_vec();\n \
    \   let mut sorted_arr: Vec<isize> = vec![-1isize; arr.len()];\n    let mut smallest_value:\
    \ isize = 0;\n    let mut smallest_index: isize = 0;\n\n    for i in arr.iter().rev()\
    \ {\n        if i != 0 {\n            smallest_value = i;\n            smallest_index\
    \ = i;\n        }\n    }\n\n    for i in arr.iter() {\n        if smallest_value\
    \ + i == smallest_value {\n            sorted_arr[i] = i;\n        }\n    }\n\
    \    let mut index: isize = 0;\n    let mut value: isize = 0;\n\n    for i in\
    \ sorted_arr.iter().rev() {\n        if *i == 0 {\n            if *i == 0 || !(index\
    \ > 0 && *index == 0) {\n                value = i;\n                index = i;\n\
    \            }\n        }\n    }\n    vec![value, index]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwidxqs81.rs:33:14\n\
    \   |\n33 |         if i != 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwidxqs81.rs:34:30\n\
    \   |\n29 |     let mut smallest_value: isize = 0;\n   |                     \
    \        ----- expected due to this type\n...\n34 |             smallest_value\
    \ = i;\n   |                              ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |             smallest_value\
    \ = *i;\n   |                              +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwidxqs81.rs:35:30\n   |\n30 |     let mut smallest_index: isize\
    \ = 0;\n   |                             ----- expected due to this type\n...\n\
    35 |             smallest_index = i;\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             smallest_index = *i;\n   |                              +\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpwidxqs81.rs:41:13\n\
    \   |\n41 |             sorted_arr[i] = i;\n   |             ^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpwidxqs81.rs:49:42\n   |\n\
    49 |             if *i == 0 || !(index > 0 && *index == 0) {\n   |           \
    \                               ^^^^^^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwidxqs81.rs:50:2"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.to_owned();\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut smallest_even_val\
    \ = arr.iter().filter(|n| n % 2 == 0).min(|a, b| a.partial_cmp(&b).unwrap()).unwrap();\n\
    \    let mut smallest_even_val_index = -1;\n    for i in arr.iter() {\n      \
    \  if i == smallest_even_val {\n            smallest_even_val_index = i;\n   \
    \     }\n    }\n    vec![smallest_even_val, smallest_even_val_index]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpoz5clorp.rs:31:57\n\
    \   |\n31 |     let mut smallest_even_val = arr.iter().filter(|n| n % 2 == 0).min(|a,\
    \ b| a.partial_cmp(&b).unwrap()).unwrap();\n   |                             \
    \                          - ^ - {integer}\n   |                             \
    \                          |\n   |                                           \
    \            &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `n`\n   |\n31 |     let mut smallest_even_val = arr.iter().filter(|n| *n % 2\
    \ == 0).min(|a, b| a.partial_cmp(&b).unwrap()).unwrap();\n   |               \
    \                                        +\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n    --> /tmp/tmpoz5clorp.rs:31:67\n\
    \     |\n31   |     let mut smallest_even_val = arr.iter().filter(|n| n % 2 ==\
    \ 0).min(|a, b| a.partial_cmp(&b).unwrap()).unwrap();\n     |                \
    \                                                   ^^^ ---------------------------------\
    \ supplied 1 argument\n     |                                                \
    \                   |\n     |                                                \
    \                   expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz5clorp.rs:35:39\n  \
    \ |\n32 |     let mut smallest_even_val_index = -1;\n   |                    \
    \                   -- expected due to this value\n...\n35 |             smallest_even_val_index\
    \ = i;\n   |                                       ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |             smallest_even_val_index\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoz5clorp.rs:38:10\n   |\n38 |     vec![smallest_even_val,\
    \ smallest_even_val_index]\n   |          ^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \   vec![*smallest_even_val, smallest_even_val_index]\n   |          +\n\nerror:\
    \ aborting due to 4 pr"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut ans = Vec::new();\n   \
    \ let mut min_even_value: isize = 0;\n    let mut min_index: isize = 0;\n\n  \
    \  for node in arr.iter() {\n        if node % 2 == 0 {\n            ans.push(node);\n\
    \            if node < min_even_value.clone() {\n                min_even_value\
    \ = node;\n                min_index = 0;\n            }\n        } else {\n \
    \           if node < min_even_value.clone() {\n                min_even_value\
    \ = node;\n                min_index = 1;\n            }\n        }\n    }\n \
    \   if ans.is_empty() {\n        return Vec::new();\n    } else {\n        ans[min_index\
    \ as usize]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx5vdzwau.rs:34:23\n   |\n\
    34 |             if node < min_even_value.clone() {\n   |                    \
    \   ^^^^^^^^^^^^^^^^^^^^^^\n   |                       |\n   |               \
    \        expected `&isize`, found `isize`\n   |                       help: consider\
    \ borrowing here: `&min_even_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx5vdzwau.rs:35:34\n\
    \   |\n28 |     let mut min_even_value: isize = 0;\n   |                     \
    \        ----- expected due to this type\n...\n35 |                 min_even_value\
    \ = node;\n   |                                  ^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |        \
    \         min_even_value = *node;\n   |                                  +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpx5vdzwau.rs:39:23\n   |\n39 |  \
    \           if node < min_even_value.clone() {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                       |\n   |                       expected `&isize`, found\
    \ `isize`\n   |                       help: consider borrowing here: `&min_even_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx5vdzwau.rs:40:34\n   |\n28 |\
    \     let mut min_even_value: isize = 0;\n   |                             -----\
    \ expected due to this type\n...\n40 |                 min_even_value = node;\n\
    \   |                                  ^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |                 min_even_value\
    \ = *node;\n   |                                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx5vdzwau.rs:48:9\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n48 |         ans[min_index as usize]\n   |    \
    \     ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&isize`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n           found reference `&isize`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explai"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut index_set = Vec::new();\n\
    \n    for i in arr {\n        if i % 2 == 0 {\n            let mut smallest_odd\
    \ = i;\n            let mut index_i = 0;\n\n            for j in arr {\n     \
    \           if j % 2 == 0 {\n                    if smallest_odd < j {\n     \
    \                   smallest_odd = j;\n                    }\n\n             \
    \       if index_i < (&index_set).len() {\n                        if i != j {\n\
    \                            index_i = &index_set[index_i];\n                \
    \            index_set[index_i] += 1;\n                        }\n           \
    \         } else {\n                        index_set.append(i);\n           \
    \             index_i = arr.len();\n                    }\n                }\n\
    \            }\n            index_set.append(index_i);\n        }\n    }\n\n \
    \   index_set\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptr3g40ai.rs:42:39\n   |\n\
    32 |             let mut index_i = 0;\n   |                               - expected\
    \ due to this value\n...\n42 |                             index_i = &index_set[index_i];\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found reference\n   |\n   = note:   expected type `usize`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n42 -             \
    \                index_i = &index_set[index_i];\n42 +                        \
    \     index_i = index_set[index_i];\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptr3g40ai.rs:46:42\n   |\n46 |                         index_set.append(i);\n\
    \   |                                          ^ expected `&mut Vec<_>`, found\
    \ `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n       \
    \                    found type `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptr3g40ai.rs:51:30\n   |\n51 |             index_set.append(index_i);\n\
    \   |                              ^^^^^^^ expected `&mut Vec<_>`, found `usize`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \          found type `usize`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // write your code here\n    let\
    \ mut index_of_min_value = -1;\n    let mut smallest_value = arr[0];\n    let\
    \ mut index_of_min_value = 0;\n    for i in 1..arr.len() {\n        let value\
    \ = arr[i];\n        if value < smallest_value {\n            smallest_value =\
    \ value;\n            index_of_min_value = i;\n        }\n        if value ==\
    \ smallest_value {\n            index_of_min_value += 1;\n        }\n    }\n\n\
    \    let result = vec![smallest_value, index_of_min_value];\n    \n    \n    \n\
    \    return result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvs7qajck.rs:42:39\n   |\n\
    42 |     let result = vec![smallest_value, index_of_min_value];\n   |        \
    \                               ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n\n    let mut smallest_even_value = arr.iter().min().unwrap();\n\
    \    let mut smallest_index = 0;\n\n    for node in\n        arr.iter_mut()\n\
    \            .filter(|v| v % 2 == 0)\n            .enumerate()\n            .map(|(i,\
    \ v)| {\n                if smallest_even_value == v {\n                    smallest_even_value\
    \ = v;\n                    smallest_index = i;\n                    return true;\n\
    \                }\n                false\n            })\n    {\n        if *node\
    \ {\n            smallest_index = i;\n        }\n    }\n\n    vec![smallest_even_value;\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpnsvay65_.rs:48:30\n\
    \   |\n48 |             smallest_index = i;\n   |                            \
    \  ^ not found in this scope\n\nerror[E0369]: cannot mod `&&mut isize` by `{integer}`\n\
    \  --> /tmp/tmpnsvay65_.rs:36:27\n   |\n36 |             .filter(|v| v % 2 ==\
    \ 0)\n   |                         - ^ - {integer}\n   |                     \
    \    |\n   |                         &&mut isize\n\nerror[E0614]: type `bool`\
    \ cannot be dereferenced\n  --> /tmp/tmpnsvay65_.rs:47:12\n   |\n47 |        \
    \ if *node {\n   |            ^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsvay65_.rs:52:10\n\
    \   |\n52 |     vec![smallest_even_value; smallest_index]\n   |          ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n52 |     vec![*smallest_even_value; smallest_index]\n   |          +\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0425, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n   \
    \ let mut min = isize::MAX;\n    let mut min_index = isize::MAX;\n    for &val\
    \ in arr {\n        if val % 2 == 0 {\n            if val < min {\n          \
    \      min = val;\n                min_index = arr.index((val));\n           \
    \ }\n        }\n    }\n    vec.push(min);\n    vec.push(min_index);\n    vec\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmptdmj5tyl.rs:34:39\n\
    \   |\n34 |                 min_index = arr.index((val));\n   |              \
    \                         ^   ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n34 -                 min_index\
    \ = arr.index((val));\n34 +                 min_index = arr.index(val);\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmptdmj5tyl.rs:30:9\n   |\n30\
    \ |     for &val in arr {\n   |         ^^^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `val`\n   |\n   = note: \
    \  expected type `isize`\n           found reference `&_`\n\nerror[E0599]: no\
    \ method named `index` found for struct `Vec<isize>` in the current scope\n  -->\
    \ /tmp/tmptdmj5tyl.rs:34:33\n   |\n34 |                 min_index = arr.index((val));\n\
    \   |                                 ^^^^^ method not found in `Vec<isize>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = *arr;\n    let\
    \ mut min_idx = -1;\n    let mut num_even_values = 0;\n    let mut num_even_values_idx\
    \ = 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n            num_even_values\
    \ += 1;\n            if min_val < i {\n                min_val = i;\n        \
    \        min_idx = i;\n            }\n        }\n    }\n    // If no even values\
    \ were found\n    if num_even_values == 0 {\n        return vec![];\n    }\n \
    \   for i in arr.iter() {\n        if i % 2 == 0 {\n            num_even_values_idx\
    \ += 1;\n            if min_val < i {\n                min_val = i;\n        \
    \        min_idx = i;\n            }\n        }\n    }\n    if num_even_values\
    \ > 1 {\n        let mut smalest_val = min_val;\n        let mut smalest_idx =\
    \ min_idx;\n        for i in arr.iter() {\n            if i % 2 == 0 {\n     \
    \           if smalest_val < i {\n                    smalest_val = i;\n     \
    \               smalest_idx = i;\n                }\n            }\n        }\n\
    \        return vec![smalest_val, smalest_idx];\n    }\n    return vec![];\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpnjdqhaze.rs:27:9\n   |\n27 |     let mut min_val\
    \ = *arr;\n   |         ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ all local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnjdqhaze.rs:34:26\n\
    \   |\n34 |             if min_val < i {\n   |                          ^ expected\
    \ slice `[isize]`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnjdqhaze.rs:35:27\n\
    \   |\n27 |     let mut min_val = *arr;\n   |                       ---- expected\
    \ due to this value\n...\n35 |                 min_val = i;\n   |            \
    \               ^ expected slice `[isize]`, found `&isize`\n\nerror[E0277]: the\
    \ size for values of type `[isize]` cannot be known at compilation time\n  -->\
    \ /tmp/tmpnjdqhaze.rs:35:17\n   |\n35 |                 min_val = i;\n   |   \
    \              ^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[isize]`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnjdqhaze.rs:36:27\n   |\n28 |     let mut min_idx = -1;\n\
    \   |                       -- expected due to this value\n...\n36 |         \
    \        min_idx = i;\n   |                           ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |        \
    \         min_idx = *i;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnjdqhaze.rs:47:26\n   |\n47 |             if min_val <\
    \ i {\n   |                          ^ expected slice `[isize]`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnjdqhaze.rs:48:27\n   |\n27 |\
    \     let mut min_val = *arr;\n   |                       ---- expected due to\
    \ this value\n...\n48 |                 min_val = i;\n   |                   \
    \        ^ expected slice `[i"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_so_far = i32::MAX;\n\
    \    let mut min = i32::MAX;\n    for i in arr.iter() {\n        if i % 2 == 0\
    \ {\n            if i < min_so_far {\n                min_so_far = i;\n      \
    \          min = i;\n            }\n        }\n    }\n    if min_so_far == i32::MAX\
    \ {\n        Vec::new()\n    } else {\n        let mut index = arr.len();\n  \
    \      for i in 0..arr.len() {\n            if arr[i] == min {\n             \
    \   index = i;\n            }\n        }\n        vec![min_so_far, index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5bwkhdnm.rs:31:20\n   |\n\
    31 |             if i < min_so_far {\n   |                    ^^^^^^^^^^ expected\
    \ `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5bwkhdnm.rs:32:30\n\
    \   |\n27 |     let mut min_so_far = i32::MAX;\n   |                         \
    \ -------- expected due to this value\n...\n32 |                 min_so_far =\
    \ i;\n   |                              ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5bwkhdnm.rs:33:23\n   |\n28 |     let mut min\
    \ = i32::MAX;\n   |                   -------- expected due to this value\n...\n\
    33 |                 min = i;\n   |                       ^ expected `i32`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5bwkhdnm.rs:42:26\n\
    \   |\n42 |             if arr[i] == min {\n   |                          ^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n42 |             if arr[i]\
    \ == min.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5bwkhdnm.rs:46:14\n   |\n46 |\
    \         vec![min_so_far, index]\n   |              ^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n46 |         vec![min_so_far.try_into().unwrap(),\
    \ index]\n   |                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = Vec::with_capacity(arr.len());\n\
    \    let mut small_index = 0;\n    for i in arr.iter() {\n        if i & 1 !=\
    \ 0 {\n            even_values.push(i);\n        } else {\n            if even_values.len()\
    \ == 0 {\n                return vec![];\n            }\n            small_index\
    \ = even_values.iter().map(|&i|i).min_by_key(|&i|i).unwrap();\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ smallest_value = even_values[small_index];\n    let mut smallest_index = small_index;\n\
    \    for i in even_values.iter() {\n        if i != smallest_value {\n       \
    \     smallest_value = i;\n            smallest_index = small_index;\n       \
    \ }\n    }\n    return vec![smallest_value, smallest_index];\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdjem5th2.rs:36:27\n   |\n\
    28 |     let mut small_index = 0;\n   |                           - expected due\
    \ to this value\n...\n36 |             small_index = even_values.iter().map(|&i|i).min_by_key(|&i|i).unwrap();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n36 |             small_index = *even_values.iter().map(|&i|i).min_by_key(|&i|i).unwrap();\n\
    \   |                           +\n\nerror[E0277]: can't compare `&isize` with\
    \ `isize`\n  --> /tmp/tmpdjem5th2.rs:45:14\n   |\n45 |         if i != smallest_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<&isize>`\
    \ for `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdjem5th2.rs:50:17\n\
    \   |\n50 |     return vec![smallest_value, smallest_index];\n   |           \
    \      ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n50 |     return vec![*smallest_value, smallest_index];\n \
    \  |                 +\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut pluck_vec = Vec::new();\n\
    \    let mut even_values = Vec::new();\n    let mut min_value = arr[0] as isize;\n\
    \    let mut min_value_index = 0;\n    let mut current_value = 0;\n    for i in\
    \ 0..arr.len() {\n        if arr[i] % 2 != 0 {\n            even_values.push(arr[i]);\n\
    \        } else {\n            if arr[i] < min_value {\n                min_value\
    \ = arr[i];\n                min_value_index = i;\n            }\n        }\n\
    \    }\n\n    if even_values.len() == 1 {\n        pluck_vec.push(min_value);\n\
    \    } else {\n        let mut index = min_value_index;\n        loop {\n    \
    \        if even_values[index] < min_value {\n                index = index +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        pluck_vec.push(min_value);\n        pluck_vec.push(min_value_index);\n\
    \    }\n    pluck_vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5b78ghml.rs:55:24\n   |\n\
    55 |         pluck_vec.push(min_value_index);\n   |                        ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n55 |         pluck_vec.push(min_value_index.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = i32::MAX;\n    let\
    \ mut min_idx: i32 = 0;\n    for (idx, v) in arr.iter().enumerate() {\n      \
    \  if v % 2 == 0 {\n            min = i32::MAX;\n            min_idx = 0;\n  \
    \      }\n        if v < min {\n            min = v;\n            min_idx = idx;\n\
    \        }\n    }\n    let mut ans = Vec::new();\n    ans.push(min);\n    ans.push(min_idx);\n\
    \    ans\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9kxcp25f.rs:34:16\n   |\n\
    34 |         if v < min {\n   |                ^^^ expected `&isize`, found `i32`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9kxcp25f.rs:35:19\n   |\n27 |\
    \     let mut min = i32::MAX;\n   |                   -------- expected due to\
    \ this value\n...\n35 |             min = v;\n   |                   ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9kxcp25f.rs:36:23\n\
    \   |\n28 |     let mut min_idx: i32 = 0;\n   |                      --- expected\
    \ due to this type\n...\n36 |             min_idx = idx;\n   |               \
    \        ^^^ expected `i32`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9kxcp25f.rs:42:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n42 |     ans\n   |     ^^^ expected `isize`, found `i32`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<i32>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut smallest_value = 0;\n    let mut smallest_index: usize = 0;\n    for ele\
    \ in arr {\n        if ele % 2 == 0 {\n            if ele < smallest_value {\n\
    \                smallest_value = ele;\n                smallest_index = ele;\n\
    \            }\n        }\n    }\n    result.push(smallest_value);\n    result.push(smallest_index);\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprq44w4mm.rs:34:34\n   |\n\
    29 |     let mut smallest_index: usize = 0;\n   |                            \
    \ ----- expected due to this type\n...\n34 |                 smallest_index =\
    \ ele;\n   |                                  ^^^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprq44w4mm.rs:39:17\n   |\n39 |\
    \     result.push(smallest_index);\n   |                 ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n39 |     result.push(smallest_index.try_into().unwrap());\n\
    \   |                               ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr2 = vec![0; arr.len()];\n\
    \    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            arr2[i]\
    \ = arr[i];\n        }\n    }\n    arr2\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 0]`,\n right: `[2, 1]`', /tmp/tmpop5qgaen.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even = vec![String::new();\
    \ arr.len()];\n    let mut smallest_even_index = vec![String::new(); arr.len()];\n\
    \n    let mut even_values = vec![0; arr.len()];\n    let mut even_values_index\
    \ = vec![0; arr.len()];\n\n    // Find the smallest even values.\n    for i in\
    \ 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            even_values[i] = arr[i];\n\
    \            even_values_index[i] = i;\n        } else {\n            // If we\
    \ find the smallest even value we only need to check it once.\n            if\
    \ even_values[i] == 0 {\n                even_values[i] = arr[i];\n          \
    \      even_values_index[i] = i;\n            } else {\n                // We\
    \ found an even value less than the current smallest even value,\n           \
    \     // so we update smallest even values with the smallest even value and\n\
    \                // the index of the smallest even value.\n                if\
    \ even_values[i] > even_values[smallest_even_index[i]] {\n                   \
    \ smallest_even[i] = even_values[smallest_even_index[i]].to_string();\n      \
    \              smallest_even_index[i] = even_values_index[smallest_even_index[i]];\n\
    \                }\n            }\n        }\n    }\n\n    // If there are no\
    \ even values, return an empty vector.\n    if even_values.iter().count() == 0\
    \ {\n        return vec![];\n    }\n\n    // If there are, let's return the smallest\
    \ even value and the index of the smallest even value.\n    vec![(smallest_even[even_values_index[even_values.iter().min(|a,\
    \ b| a * b % 2 == 0)].clone()), even_values.iter().min(|a, b| a * b % 2 == 0).clone()]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `)`\n  --> /tmp/tmpmr4ypqiv.rs:61:24\n\
    \   |\n61 |     vec![(smallest_even[even_values_index[even_values.iter().min(|a,\
    \ b| a * b % 2 == 0)].clone()), even_values.iter().min(|a, b| a * b % ...\n  \
    \ |          -             ^ unclosed delimiter                              \
    \                       ^ mismatched closing delimiter\n   |          |\n   |\
    \          closing delimiter possibly meant for this\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `String`\n  --> /tmp/tmpmr4ypqiv.rs:47:37\n \
    \  |\n47 |                 if even_values[i] > even_values[smallest_even_index[i]]\
    \ {\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `Index<String>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `String`\n  --> /tmp/tmpmr4ypqiv.rs:48:40\n\
    \   |\n48 |                     smallest_even[i] = even_values[smallest_even_index[i]].to_string();\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `Index<String>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[usize]` cannot be indexed by `String`\n  --> /tmp/tmpmr4ypqiv.rs:49:46\n\
    \   |\n49 |                     smallest_even_index[i] = even_values_index[smallest_even_index[i]];\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[usize]>` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `Index<String>` for `Vec<usize>`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpmr4ypqiv.rs:61:62\n "
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_index = 1;\n    let\
    \ mut min_value = arr[0];\n    let mut max_value = -1;\n    let mut min_node =\
    \ 0;\n    let mut max_node = 0;\n\n    for index in 0..arr.len() {\n        let\
    \ v = arr[index];\n\n        if v > max_value {\n            max_value = v;\n\
    \            max_node = index;\n        }\n\n        if v < min_value {\n    \
    \        min_value = v;\n            min_node = index;\n        }\n\n        if\
    \ v % 2 == 0 {\n            if min_value > max_value {\n                max_value\
    \ = v;\n                max_node = index;\n            }\n        } else {\n \
    \           if min_value < max_value {\n                min_value = v;\n     \
    \           min_node = index;\n            }\n        }\n    }\n\n    if min_value\
    \ < max_value {\n        return vec![min_value, min_node];\n    }\n\n    return\
    \ vec![max_value, max_node];\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ejamhru.rs:60:32\n   |\n\
    60 |         return vec![min_value, min_node];\n   |                         \
    \       ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    60 |         return vec![min_value, min_node.try_into().unwrap()];\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ejamhru.rs:63:28\n   |\n63 |     return vec![max_value,\
    \ max_node];\n   |                            ^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n63 |     return vec![max_value, max_node.try_into().unwrap()];\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n   \
    \ let mut sorted_arr = arr.iter().cloned().sorted();\n    while sorted_arr.len()\
    \ > 0 {\n        if sorted_arr.len() == 1 {\n            return vec![];\n    \
    \    }\n        let mut even = sorted_arr[0];\n        let mut index = sorted_arr.iter().position(|x|\
    \ *x%2 == 0).unwrap();\n        let mut found = false;\n        for (i, val) in\
    \ sorted_arr.iter().enumerate() {\n            if val % 2 == 0 {\n           \
    \     even = val;\n                index = i;\n                found = true;\n\
    \                break;\n            }\n        }\n        if !found {\n     \
    \       return vec![];\n        }\n        res.push(even);\n        sorted_arr.drain(index..);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpmr6ha6wf.rs:28:46\n   |\n28 |     let mut sorted_arr\
    \ = arr.iter().cloned().sorted();\n   |                                      \
    \        ^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val: isize = 0;\n \
    \   let mut min_idx: usize = 0;\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            match i {\n                0 => return vec![],\n          \
    \      x if x < min_val => min_val = x,\n                x if x > min_val => {\n\
    \                    if x < min_idx {\n                        min_idx = x;\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           if min_val == i {\n                return vec![];\n            }\n\
    \        }\n    }\n    return vec![min_val, min_idx];\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplfqs2eau.rs:33:26\n   |\n\
    33 |                 x if x < min_val => min_val = x,\n   |                  \
    \        ^^^^^^^\n   |                          |\n   |                      \
    \    expected `&isize`, found `isize`\n   |                          help: consider\
    \ borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfqs2eau.rs:33:47\n\
    \   |\n27 |     let mut min_val: isize = 0;\n   |                      ----- expected\
    \ due to this type\n...\n33 |                 x if x < min_val => min_val = x,\n\
    \   |                                               ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         x if x < min_val => min_val = *x,\n   |                            \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfqs2eau.rs:34:26\n\
    \   |\n34 |                 x if x > min_val => {\n   |                      \
    \    ^^^^^^^\n   |                          |\n   |                          expected\
    \ `&isize`, found `isize`\n   |                          help: consider borrowing\
    \ here: `&min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfqs2eau.rs:35:28\n\
    \   |\n35 |                     if x < min_idx {\n   |                       \
    \     ^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplfqs2eau.rs:36:35\n   |\n28 |     let mut min_idx: usize = 0;\n\
    \   |                      ----- expected due to this type\n...\n36 |        \
    \                 min_idx = x;\n   |                                   ^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfqs2eau.rs:41:27\n\
    \   |\n41 |             if min_val == i {\n   |                           ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    41 |             if min_val == *i {\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplfqs2eau.rs:46:26\n   |\n46 |     return vec![min_val,\
    \ min_idx];\n   |                          ^^^^^^^ expected `isize`, found `usize`\n\
    \  "
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut even_value = true;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        } else {\n            even_value = false;\n     \
    \   }\n    }\n\n    if even_value\n        && min_value\n        .clone()\n  \
    \      .checked_mul(min_value).is_zero()\n    {\n        vec![]\n    } else {\n\
    \        vec![min_value, min_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmp2kv9n3cz.rs:42:33\n   |\n42 |         .checked_mul(min_value).is_zero()\n\
    \   |                                 ^^^^^^^ method not found in `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2kv9n3cz.rs:46:25\n   |\n46 |\
    \         vec![min_value, min_idx]\n   |                         ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n46 |         vec![min_value,\
    \ min_idx.try_into().unwrap()]\n   |                                ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n\n    let mut current_min: isize = 0;\n    let mut index: usize\
    \ = 0;\n    let mut smalest_value: isize = 0;\n\n    for val in arr.iter() {\n\
    \        if val % 2 == 0 {\n            smalest_value = val;\n            if val\
    \ < current_min {\n                current_min = val;\n            }\n       \
    \ } else {\n            if current_min != 0 && val == 0 {\n                index\
    \ = index as usize + 1;\n            }\n            current_min = val as isize;\n\
    \        }\n    }\n\n    if current_min != 0 && index == 0 {\n        index =\
    \ index as usize + 1;\n    }\n\n    if current_min == 0 {\n        return vec![];\n\
    \    }\n\n    if index == 0 {\n        return vec![smalest_value];\n    }\n\n\
    \    let mut ret = vec![smalest_value, index];\n    let mut j: usize = smalest_value;\n\
    \n    for _ in 0..(index - 1) {\n        let mut i = j;\n        if i % 2 == 0\
    \ {\n            i += 1;\n        }\n        ret = vec![i, ret[0]];\n        j\
    \ += 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwmd1r6s_.rs:37:29\n   |\n\
    33 |     let mut smalest_value: isize = 0;\n   |                            -----\
    \ expected due to this type\n...\n37 |             smalest_value = val;\n   |\
    \                             ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n37 |             smalest_value = *val;\n\
    \   |                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmd1r6s_.rs:38:22\n\
    \   |\n38 |             if val < current_min {\n   |                      ^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&current_min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwmd1r6s_.rs:39:31\n   |\n31 |\
    \     let mut current_min: isize = 0;\n   |                          ----- expected\
    \ due to this type\n...\n39 |                 current_min = val;\n   |       \
    \                        ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n39 |                 current_min = *val;\n \
    \  |                               +\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpwmd1r6s_.rs:42:40\n   |\n42 |             if current_min\
    \ != 0 && val == 0 {\n   |                                        ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwmd1r6s_.rs:61:39\n   |\n61 |     let mut ret = vec![smalest_value,\
    \ index];\n   |                                       ^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmd1r6s_.rs:62:24\n\
    \   |\n62 |     let mut j: usize = smalest_value;\n   |                ----- \
    \  ^^^^^^^^^^^^^ expected `us"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() > 0);\n\n   \
    \ let mut smalest_value = -1;\n    let mut smalest_index = -1;\n\n    for &node\
    \ in arr.iter().rev() {\n        if node % 2 == 0 {\n            if smalest_value\
    \ < 0 {\n                smalest_value = node;\n            } else {\n       \
    \         smalest_index = node;\n            }\n        }\n    }\n    if smalest_index\
    \ >= 0 {\n        let mut temp_index = smalest_index;\n        let mut temp_val\
    \ = smalest_value;\n        let mut temp_node = smalest_index;\n\n        while\
    \ temp_val != 0 && temp_val != temp_node {\n            temp_index--;\n      \
    \      temp_node = temp_index;\n            temp_val = temp_node;\n        }\n\
    \n        vec![temp_val, temp_index]\n    } else {\n        vec![]\n    }\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3dh_hhp_.rs:47:25\n\
    \   |\n47 |             temp_index--;\n   |                         ^ expected\
    \ expression\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() <= 10000);\n\
    \    let mut evens: Vec<isize> = Vec::new();\n    for i in arr {\n        if i\
    \ % 2 == 0 {\n            evens.push(i);\n        }\n    }\n    let mut smallest_value\
    \ = evens[0];\n    let mut smallest_index = 0;\n    for i in evens.iter() {\n\
    \        if i == smallest_value {\n            smallest_index = i;\n        }\n\
    \        if i == i + 1 {\n            smallest_value = i;\n        }\n    }\n\
    \    if smallest_value == 0 {\n        Vec::new()\n    } else {\n        vec![smallest_value,\
    \ smallest_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpbdp9pwmu.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbdp9pwmu.rs:38:30\n   |\n35 |     let mut smallest_index = 0;\n   |\
    \                              - expected due to this value\n...\n38 |       \
    \      smallest_index = i;\n   |                              ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbdp9pwmu.rs:41:30\n   |\n34 |     let mut smallest_value\
    \ = evens[0];\n   |                              -------- expected due to this\
    \ value\n...\n41 |             smallest_value = i;\n   |                     \
    \         ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n41 |             smallest_value = *i;\n   |              \
    \                +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  -->\
    \ /tmp/tmpbdp9pwmu.rs:40:14\n   |\n40 |         if i == i + 1 {\n   |        \
    \      ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut min_even: isize = 0;\n    for i in arr.iter() {\n        if i % 2\
    \ == 0 {\n            evens.push(i);\n            if i == min_even {\n       \
    \         min_even = i;\n            }\n        }\n    }\n    if evens.len() ==\
    \ 0 {\n        return vec![];\n    }\n    min_even %= evens.len();\n    let mut\
    \ smallest_even_val: isize = 0;\n    let mut smallest_even_val_index = 0;\n  \
    \  for i in evens.iter() {\n        if i == min_even {\n            smallest_even_val_index\
    \ += 1;\n            if smallest_even_val_index > 1 {\n                break;\n\
    \            }\n            smallest_even_val = i;\n        }\n    }\n    vec![smallest_even_val,\
    \ smallest_even_val_index]\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5n9aeyf4.rs:31:24\n   |\n\
    31 |             evens.push(i);\n   |                        ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           evens.push(*i);\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5n9aeyf4.rs:33:28\n   |\n28 |     let mut min_even: isize\
    \ = 0;\n   |                       ----- expected due to this type\n...\n33 |\
    \                 min_even = i;\n   |                            ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_even = *i;\n   |                            +\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmp5n9aeyf4.rs:32:18\n   |\n\
    32 |             if i == min_even {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5n9aeyf4.rs:40:17\n   |\n40 |     min_even %= evens.len();\n   |   \
    \              ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ mod-assign `isize` by `usize``\n  --> /tmp/tmp5n9aeyf4.rs:40:14\n   |\n40 |\
    \     min_even %= evens.len();\n   |              ^^ no implementation for `isize\
    \ %= usize`\n   |\n   = help: the trait `RemAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `RemAssign<Rhs>`:\n\
    \             <f32 as RemAssign<&f32>>\n             <f32 as RemAssign>\n    \
    \         <f64 as RemAssign<&f64>>\n             <f64 as RemAssign>\n        \
    \     <i128 as RemAssign<&i128>>\n             <i128 as RemAssign>\n         \
    \    <i16 as RemAssign<&i16>>\n             <i16 as RemAssign>\n           and\
    \ 20 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp5n9aeyf4."
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    let mut index\
    \ = 0;\n    let mut smallest = arr[0];\n    while index < arr.len() {\n      \
    \  if smallest & 1 == 0 {\n            index = index;\n            break;\n  \
    \      } else {\n            smallest = *index;\n            index += 1;\n   \
    \     }\n    }\n    let mut result = Vec::new();\n    result.push(smallest);\n\
    \    result.push(index);\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpg5bmah32.rs:35:24\n\
    \   |\n35 |             smallest = *index;\n   |                        ^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg5bmah32.rs:41:17\n   |\n41 |\
    \     result.push(index);\n   |                 ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n41 |     result.push(index.try_into().unwrap());\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values: Vec<isize>\
    \ = vec![];\n    for value in arr {\n        if value % 2 == 0 {\n           \
    \ even_values.push(value);\n        }\n    }\n    let mut largest_even_value =\
    \ even_values.iter().max().unwrap();\n    let mut largest_even_index_value = even_values.iter().skip(1).take(even_values.iter().count()\
    \ - 1).max().unwrap();\n    let mut smallest_index_value = even_values.iter().skip(1).last().unwrap();\n\
    \    let mut smallest_even_index_value = even_values.iter().skip(1).take(even_values.iter().count()\
    \ - 1).last().unwrap();\n    while largest_even_value_value != even_values.iter().max().unwrap()\
    \ {\n        largest_even_value_value += 2;\n        if largest_even_index_value\
    \ == even_values.iter().skip(1).take(even_values.iter().count() - 1).max().unwrap()\
    \ {\n            largest_even_index_value += 2;\n        }\n        if smallest_even_index_value\
    \ == even_values.iter().skip(1).last().unwrap() {\n            smallest_even_index_value\
    \ += 2;\n        }\n        if smallest_index_value == even_values.iter().skip(1).last().unwrap()\
    \ {\n            smallest_index_value += 2;\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    return vec![smallest_even_index_value,\
    \ smallest_index_value];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `largest_even_value_value` in this scope\n\
    \  --> /tmp/tmpv6216chf.rs:37:11\n   |\n37 |     while largest_even_value_value\
    \ != even_values.iter().max().unwrap() {\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `largest_even_index_value`\n\
    \nerror[E0425]: cannot find value `largest_even_value_value` in this scope\n \
    \ --> /tmp/tmpv6216chf.rs:38:9\n   |\n38 |         largest_even_value_value +=\
    \ 2;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `largest_even_index_value`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&isize`\n  --> /tmp/tmpv6216chf.rs:40:13\n \
    \  |\n40 |             largest_even_index_value += 2;\n   |             ------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&isize`\n   |\n\
    help: `+=` can be used on `isize`, you can dereference `largest_even_index_value`\n\
    \   |\n40 |             *largest_even_index_value += 2;\n   |             +\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&isize`\n\
    \  --> /tmp/tmpv6216chf.rs:43:13\n   |\n43 |             smallest_even_index_value\
    \ += 2;\n   |             -------------------------^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&isize`\n   |\nhelp: `+=` can be used\
    \ on `isize`, you can dereference `smallest_even_index_value`\n   |\n43 |    \
    \         *smallest_even_index_value += 2;\n   |             +\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&isize`\n  --> /tmp/tmpv6216chf.rs:46:13\n\
    \   |\n46 |             smallest_index_value += 2;\n   |             --------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&isize`\n   |\n\
    help: `+=` can be used on `isize`, you can dereference `smallest_index_value`\n\
    \   |\n46 |             *smallest_index_value += 2;\n   |             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv6216chf.rs:52:17\n   |\n52 |     return vec![smallest_even_index_value,\
    \ smallest_index_value];\n   |       "
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_value = 0isize;\n\
    \    let mut smallest_index = 0isize;\n    for i in arr.iter() {\n        if i\
    \ % 2isize == even_value\n            || i == 0isize\n            || i == arr.last().unwrap()\n\
    \        {\n            smallest_index = i;\n            even_value = i;\n   \
    \     }\n    }\n    let mut smallest_value = 0isize;\n    for i in arr.iter()\
    \ {\n        if i % 2isize == smallest_value {\n            return vec![i];\n\
    \        }\n    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpw3q8kz2y.rs:31:18\n\
    \   |\n31 |             || i == 0isize\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw3q8kz2y.rs:34:30\n   |\n28 |     let mut smallest_index = 0isize;\n\
    \   |                              ------ expected due to this value\n...\n34\
    \ |             smallest_index = i;\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |             smallest_index = *i;\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpw3q8kz2y.rs:35:26\n   |\n27 |  \
    \   let mut even_value = 0isize;\n   |                          ------ expected\
    \ due to this value\n...\n35 |             even_value = i;\n   |             \
    \             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |             even_value = *i;\n   |                  \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3q8kz2y.rs:41:25\n\
    \   |\n41 |             return vec![i];\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    41 |             return vec![*i];\n   |                         +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min = arr[0] as isize;\n    let mut index = arr[0]\
    \ as isize;\n    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n      \
    \      if min == i {\n                index = i;\n            } else {\n     \
    \           min = i;\n                index = i;\n            }\n        } else\
    \ {\n            break;\n        }\n    }\n    vec![min, index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv1g3lj8p.rs:34:23\n   |\n\
    34 |             if min == i {\n   |                       ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |  \
    \           if min == *i {\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv1g3lj8p.rs:35:25\n   |\n31 |     let mut index = arr[0]\
    \ as isize;\n   |                     --------------- expected due to this value\n\
    ...\n35 |                 index = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 index = *i;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv1g3lj8p.rs:37:23\n   |\n30 |     let mut min\
    \ = arr[0] as isize;\n   |                   --------------- expected due to this\
    \ value\n...\n37 |                 min = i;\n   |                       ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    37 |                 min = *i;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv1g3lj8p.rs:38:25\n   |\n31 |     let mut index\
    \ = arr[0] as isize;\n   |                     --------------- expected due to\
    \ this value\n...\n38 |                 index = i;\n   |                     \
    \    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n38 |                 index = *i;\n   |                       \
    \  +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter()\n        .enumerate()\n\
    \        .map(|(idx, elem)| {\n            if elem % 2 == 0 {\n              \
    \  Some(elem)\n            } else {\n                None\n            }\n   \
    \     })\n        .min_by_key(|e| e.unwrap())\n        .map(|e| e.0)\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `Option<&isize>`\n  --> /tmp/tmprmhgrgrm.rs:37:20\n\
    \   |\n37 |         .map(|e| e.0)\n   |                    ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        vec![]\n\
    \    } else {\n        arr.sort_by(|a, b| {\n            if b % 2 == 0 {\n   \
    \             a\n            } else {\n                b\n            }\n    \
    \    });\n        let smallest_value = arr[0];\n        let mut smallest_index\
    \ = 0;\n        for index in 0..arr.len() {\n            if arr[index] % 2 ==\
    \ 0 {\n                if smallest_value < arr[index] {\n                    smallest_value\
    \ = arr[index];\n                    smallest_index = index;\n               \
    \ }\n            }\n        }\n        vec![smallest_value, smallest_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo2g01y60.rs:32:17\n   |\n\
    32 |                 a\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo2g01y60.rs:34:17\n\
    \   |\n34 |                 b\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo2g01y60.rs:47:30\n\
    \   |\n47 |         vec![smallest_value, smallest_index]\n   |               \
    \               ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n47 |         vec![smallest_value, smallest_index.try_into().unwrap()]\n\
    \   |                                            ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() > 0);\n    let\
    \ mut result = vec![];\n    let mut min_val = arr[0];\n    let mut min_val_pos\
    \ = 0;\n    let mut min_val_neg_ind = -1;\n    let mut max_val = 0;\n    let mut\
    \ max_val_neg_ind = -1;\n    let mut min_pos_count = 0;\n    let mut max_pos_count\
    \ = 0;\n    for (idx, val) in arr.iter().enumerate() {\n        if val < 0 {\n\
    \            let val_neg_ind = idx as isize;\n            if val_neg_ind == min_val_neg_ind\
    \ {\n                if val < min_val {\n                    min_val = val;\n\
    \                    min_val_neg_ind = val_neg_ind;\n                }\n     \
    \       } else {\n                if val < max_val {\n                    max_val\
    \ = val;\n                    max_val_neg_ind = val_neg_ind;\n               \
    \ }\n            }\n        } else {\n            if val == min_val {\n      \
    \          min_pos_count = 1;\n            } else {\n                min_pos_count\
    \ += 1;\n            }\n        }\n        if val > max_val {\n            max_val\
    \ = val;\n            max_val_neg_ind = idx;\n        }\n    }\n    if min_val\
    \ == max_val {\n        result.push(min_val);\n    } else {\n        if min_pos_count\
    \ == max_pos_count {\n            result.push(min_val);\n        } else {\n  \
    \          result.push(min_val);\n            result.push(max_val);\n        }\n\
    \    }\n    if result.len() > 1 {\n        result.sort();\n        result.sort();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcf6an502.rs:37:18\n   |\n\
    37 |         if val < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcf6an502.rs:40:26\n   |\n40 |                 if val < min_val {\n \
    \  |                          ^^^^^^^\n   |                          |\n   | \
    \                         expected `&isize`, found `isize`\n   |             \
    \             help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcf6an502.rs:41:31\n   |\n29 |     let mut min_val = arr[0];\n\
    \   |                       ------ expected due to this value\n...\n41 |     \
    \                min_val = val;\n   |                               ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    41 |                     min_val = *val;\n   |                               +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcf6an502.rs:45:26\n   |\n45 |\
    \                 if val < max_val {\n   |                          ^^^^^^^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found integer\n   |                          help: consider borrowing here:\
    \ `&max_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcf6an502.rs:46:31\n\
    \   |\n32 |     let mut max_val = 0;\n   |                       - expected due\
    \ to this value\n...\n46 |                     max_val = val;\n   |          \
    \                     ^^^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n46 |                     max_val = *val;\n \
    \  |                               +\n\nerror[E0277]: can't compare `&isize` with\
    \ `isize`\n  --> /tmp/tmpcf6an502.rs:51:20\n   |\n51 |             if val == min_val\
    \ {\n   |                    ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_index = 0;\n\n    // The for-loop below runs for all the\
    \ values in the array\n    for index in 1..arr.len() {\n        let even_count\
    \ = arr[index] % 2;\n        // The conditional below checks if the smallest even\
    \ value has been reached\n        // or if the smallest index is still being considered\n\
    \        if even_count == 0 || index == arr.len() {\n            smallest_even_value\
    \ += 1;\n            smallest_index = index;\n        }\n    }\n\n    let mut\
    \ arr2 = vec![smallest_even_value; smallest_index + 1];\n    arr2[0] = 0;\n\n\
    \    for _ in 0..(arr.len() - 1) {\n        if arr2[arr2.len() - 1] > arr2[0]\
    \ {\n            arr2[arr2.len() - 1] = arr2[0];\n        }\n        arr2[0] +=\
    \ 1;\n    }\n\n    arr2\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `arr2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp1iquhwhu.rs:46:18\n   |\n46 |             arr2[arr2.len()\
    \ - 1] = arr2[0];\n   |             -----^^^^^^^^^^-----\n   |             | \
    \   |\n   |             |    immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp1iquhwhu.rs:46:18\n  \
    \ |\n46 |             arr2[arr2.len() - 1] = arr2[0];\n   |                  ^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp1iquhwhu.rs:46:13\n   |\n\
    46 |             arr2[arr2.len() - 1] = arr2[0];\n   |             ^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    // find the minimum even number\n    let mut min_even =\
    \ 0;\n    let mut min_idx = -1;\n    for i in arr.iter() {\n        if i.0 % 2\
    \ == 0 {\n            if min_even < i {\n                min_even = i;\n     \
    \           min_idx = i;\n            }\n        }\n    }\n    // pick a node\n\
    \    let mut idx = 0;\n    if min_even > 0 {\n        // pick the smallest even\
    \ node\n        if min_even % 2 == 0 {\n            idx = min_even / 2;\n    \
    \    }\n        else {\n            idx = min_even / 2 + 1;\n        }\n    }\n\
    \    // return the picked node and its index\n    vec![min_even/2, idx]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmp4p44aufz.rs:34:14\n\
    \   |\n34 |         if i.0 % 2 == 0 {\n   |              ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4p44aufz.rs:36:28\n   |\n31 |     let mut min_even = 0;\n\
    \   |                        - expected due to this value\n...\n36 |         \
    \        min_even = i;\n   |                            ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |        \
    \         min_even = *i;\n   |                            +\n\nerror[E0277]: can't\
    \ compare `isize` with `&isize`\n  --> /tmp/tmp4p44aufz.rs:35:25\n   |\n35 | \
    \            if min_even < i {\n   |                         ^ no implementation\
    \ for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4p44aufz.rs:37:27\n   |\n32 |     let mut min_idx = -1;\n   |      \
    \                 -- expected due to this value\n...\n37 |                 min_idx\
    \ = i;\n   |                           ^ expected integer, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n37 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0609.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values: Vec<isize>\
    \ = vec![];\n    let mut smallest_value: isize = 0;\n    let mut smallest_index\
    \ = 0;\n\n    for ele in arr.iter().cloned() {\n        if ele % 2 == 0 {\n  \
    \          even_values.push(ele);\n            if smallest_value < ele {\n   \
    \             smallest_value = ele;\n                smallest_index = 0;\n   \
    \         }\n        }\n    }\n\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n\n    if even_values[0] % 2 == 0 {\n        return vec![isize\
    \ {\n            value: smallest_value,\n            index: smallest_index,\n\
    \        }];\n    }\n\n    let mut mut smallest_value_index = 0;\n    let mut\
    \ mut mut_el = 0;\n    for &mut ele in even_values.iter_mut() {\n        if ele\
    \ % 2 == 0 {\n            if mut_el < ele {\n                mut_el = ele;\n \
    \               smallest_value_index = mut_el - 1;\n            }\n        }\n\
    \    }\n\n    return vec![isize {\n        value: smallest_value,\n        index:\
    \ smallest_value_index,\n    }];\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmpv0ae4gk1.rs:52:13\n\
    \   |\n52 |     let mut mut smallest_value_index = 0;\n   |             ^^^ help:\
    \ remove the additional `mut`s\n\nerror: `mut` on a binding may not be repeated\n\
    \  --> /tmp/tmpv0ae4gk1.rs:53:13\n   |\n53 |     let mut mut mut_el = 0;\n   |\
    \             ^^^ help: remove the additional `mut`s\n\nerror[E0574]: expected\
    \ struct, variant or union type, found builtin type `isize`\n  --> /tmp/tmpv0ae4gk1.rs:46:21\n\
    \   |\n46 |         return vec![isize {\n   |                     ^^^^^ not a\
    \ struct, variant or union type\n\nerror[E0574]: expected struct, variant or union\
    \ type, found builtin type `isize`\n  --> /tmp/tmpv0ae4gk1.rs:63:17\n   |\n63\
    \ |     return vec![isize {\n   |                 ^^^^^ not a struct, variant\
    \ or union type\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0574`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut mut smallest_value: isize\
    \ = 0;\n    let mut smallest_index: isize = 0;\n    for i in arr.iter_mut() {\n\
    \        *i = *i + 1;\n        if *i %2 == 0 {\n            if *i < (smallest_value\
    \ || smallest_index) {\n                smallest_value = *i;\n               \
    \ smallest_index = i;\n            }\n        }\n    }\n    smallest_index\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmpxcnpsjoy.rs:27:13\n\
    \   |\n27 |     let mut mut smallest_value: isize = 0;\n   |             ^^^ help:\
    \ remove the additional `mut`s\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxcnpsjoy.rs:32:22\n\
    \   |\n32 |             if *i < (smallest_value || smallest_index) {\n   |   \
    \                   ^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxcnpsjoy.rs:32:40\n   |\n32 |             if\
    \ *i < (smallest_value || smallest_index) {\n   |                            \
    \            ^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxcnpsjoy.rs:32:21\n   |\n32 |             if *i < (smallest_value\
    \ || smallest_index) {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxcnpsjoy.rs:34:34\n\
    \   |\n28 |     let mut smallest_index: isize = 0;\n   |                     \
    \        ----- expected due to this type\n...\n34 |                 smallest_index\
    \ = i;\n   |                                  ^ expected `isize`, found `&mut\
    \ isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |          \
    \       smallest_index = *i;\n   |                                  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxcnpsjoy.rs:38:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n38 |     smallest_index\n   |     ^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut sorted_vec: Vec<isize>\
    \ = vec![];\n    for node in arr.iter().cloned() {\n        if node % 2 == 0 {\n\
    \            sorted_vec.push(node);\n        }\n    }\n    if arr.len() > 0 &&\
    \ sorted_vec.len() > 0 {\n        sorted_vec\n    } else {\n        vec![]\n \
    \   }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[2, 1]`', /tmp/tmpwtl318b3.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min_val = arr[0];\n    let mut min_idx = arr.iter().position(|x|\
    \ *x % 2 == 0).unwrap();\n    for i in arr.iter() {\n        if *i % 2 == 0 {\n\
    \            min_val = *i;\n            min_idx = i;\n        }\n    }\n    return\
    \ vec![min_val, min_idx];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcw3l15ty.rs:35:23\n   |\n\
    31 |     let mut min_idx = arr.iter().position(|x| *x % 2 == 0).unwrap();\n  \
    \ |                       --------------------------------------------- expected\
    \ due to this value\n...\n35 |             min_idx = i;\n   |                \
    \       ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcw3l15ty.rs:38:26\n   |\n38 |     return vec![min_val, min_idx];\n\
    \   |                          ^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n38 |     return vec![min_val, min_idx.try_into().unwrap()];\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    let mut smalest_value\
    \ = arr[0];\n    let mut smalest_index = 0;\n    for val in arr.iter().rev() {\n\
    \        if val % 2 == 0 {\n            smalest_value = val;\n            smalest_index\
    \ = arr.len() - arr.iter().rposition(|&x| *x == val).unwrap() - 1;\n         \
    \   break;\n        }\n    }\n    return vec![smalest_value, smalest_index];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbijogr2.rs:32:29\n   |\n\
    28 |     let mut smalest_value = arr[0];\n   |                             ------\
    \ expected due to this value\n...\n32 |             smalest_value = val;\n   |\
    \                             ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n32 |             smalest_value = *val;\n\
    \   |                             +\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpcbijogr2.rs:33:67\n   |\n33 |             smalest_index = arr.len()\
    \ - arr.iter().rposition(|&x| *x == val).unwrap() - 1;\n   |                 \
    \                                                  ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcbijogr2.rs:37:32\n   |\n37 |     return vec![smalest_value,\
    \ smalest_index];\n   |                                ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n37 |     return vec![smalest_value,\
    \ smalest_index.try_into().unwrap()];\n   |                                  \
    \           ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest: isize = 0;\n\
    \    let mut index: isize = 0;\n    let mut min_even_val: isize = 0;\n    let\
    \ mut vec: Vec<isize> = Vec::new();\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            if smallest * 2 < min_even_val {\n                smallest\
    \ = i;\n                min_even_val = min_even_val + arr[i];\n            }\n\
    \            if smallest != i {\n                index = i;\n            }\n \
    \       }\n    }\n    vec.push(min_even_val);\n    vec.push(index);\n    vec\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxflfdk6l.rs:34:28\n   |\n\
    27 |     let mut smallest: isize = 0;\n   |                       ----- expected\
    \ due to this type\n...\n34 |                 smallest = i;\n   |            \
    \                ^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxflfdk6l.rs:37:28\n   |\n37 |             if smallest !=\
    \ i {\n   |                            ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n37 |             if smallest != i.try_into().unwrap() {\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxflfdk6l.rs:38:25\n   |\n28 |     let mut index: isize\
    \ = 0;\n   |                    ----- expected due to this type\n...\n38 |   \
    \              index = i;\n   |                         ^ expected `isize`, found\
    \ `usize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = Vec::<isize>::new();\n\
    \    let mut smallest_value;\n\n    for value in arr {\n        if value % 2 ==\
    \ 0 {\n            even_values.push(value);\n        }\n        if even_values.is_empty()\
    \ {\n            smallest_value = value;\n        }\n        if value < smallest_value\
    \ {\n            smallest_value = value;\n        }\n    }\n\n    if even_values.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut smallest_index = -1;\n\n   \
    \ for value in even_values {\n        if value == smallest_value {\n         \
    \   smallest_index = even_values.iter().position(|x| x == value);\n        }\n\
    \    }\n\n    if smallest_index == -1 {\n        return vec![];\n    }\n\n   \
    \ vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp6w16njj6.rs:50:64\n\
    \   |\n50 |             smallest_index = even_values.iter().position(|x| x ==\
    \ value);\n   |                                                              \
    \  ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6w16njj6.rs:50:30\n   |\n46 |     let mut smallest_index = -1;\n   |\
    \                              -- expected due to this value\n...\n50 |      \
    \       smallest_index = even_values.iter().position(|x| x == value);\n   |  \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut min_value: isize = 0;\n    let mut min_idx: Option<usize> = None;\n\
    \    let mut min_even_idx = 0;\n    let mut even_value: Vec<isize> = Vec::new();\n\
    \n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value.is_none()\
    \ {\n                min_value = i;\n                min_idx = Some(i);\n    \
    \        } else {\n                if i < min_value {\n                    min_value\
    \ = i;\n                    min_idx = Some(i);\n                }\n          \
    \  }\n        } else {\n            if min_value.is_none() {\n               \
    \ min_even_idx = i;\n            } else {\n                even_value.push(i);\n\
    \                if min_even_idx >= min_value {\n                    if min_even_idx\
    \ < i {\n                        min_even_idx = i;\n                    }\n  \
    \              }\n            }\n        }\n    }\n    result\n        .extend_from_slice(even_value.iter().cloned());\n\
    \    min_idx\n        .map(|_| result.iter().cloned().nth(min_even_idx).unwrap())\n\
    \        .unwrap_or(vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkgei37vy.rs:33:9\n   |\n\
    33 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `is_none` found for type `isize` in the current scope\n  --> /tmp/tmpkgei37vy.rs:35:26\n\
    \   |\n35 |             if min_value.is_none() {\n   |                       \
    \   ^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkgei37vy.rs:37:32\n   |\n37 |                 min_idx = Some(i);\n \
    \  |                                ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n37 |                 min_idx = Some(i.try_into().unwrap());\n\
    \   |                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkgei37vy.rs:41:36\n   |\n41 |                     min_idx\
    \ = Some(i);\n   |                                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n41 |                     min_idx = Some(i.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `is_none` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpkgei37vy.rs:45:26\n   |\n45 |             if min_value.is_none() {\n\
    \   |                          ^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkgei37vy.rs:58:28\n   |\n58 |         .extend_from_slice(even_value.iter().cloned());\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[isize]`,\
    \ found struct `Cloned`\n   |\n   = note: expected reference `&[isize]`\n    \
    \             found struct `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkgei37vy.rs:60:45\n   |\n60 "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() <= 10000);\n\
    \    assert!(arr.iter().all(|&x| x >= 0));\n\n    let mut even_values: Vec<isize>\
    \ = Vec::with_capacity(arr.len());\n    let mut max_index: isize = 0;\n    for\
    \ (index, item) in arr.iter().enumerate() {\n        if item % 2 == 0 {\n    \
    \        even_values.push(item);\n            max_index = index;\n        }\n\
    \    }\n\n    if even_values.len() == 0 {\n        vec![]\n    } else {\n    \
    \    let mut min_value = even_values[0];\n        let mut min_value = even_values[0];\n\
    \        let mut min_value_index = 0;\n        for value in even_values {\n  \
    \          if value >= min_value {\n                min_value = value;\n     \
    \           min_value_index = index;\n            }\n        }\n        let mut\
    \ result = vec![];\n        result.append(min_value);\n        result.push(min_value_index);\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `index` in this scope\n  --> /tmp/tmpkfibhwvu.rs:48:35\n\
    \   |\n48 |                 min_value_index = index;\n   |                   \
    \                ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkfibhwvu.rs:34:30\n   |\n34 |             even_values.push(item);\n\
    \   |                              ^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n34 |             even_values.push(*item);\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkfibhwvu.rs:35:25\n   |\n31 |     let mut max_index: isize = 0;\n  \
    \ |                        ----- expected due to this type\n...\n35 |        \
    \     max_index = index;\n   |                         ^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkfibhwvu.rs:52:23\n\
    \   |\n52 |         result.append(min_value);\n   |                       ^^^^^^^^^\
    \ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().min_by_key(|&el| {\n\
    \        if el % 2 == 0 {\n            el\n        } else {\n            0\n \
    \       }\n    }).map(|el| {\n        if el % 2 == 0 {\n            el\n     \
    \   } else {\n            el + 1\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpanvje32v.rs:31:13\n\
    \   |\n28 | /         if el % 2 == 0 {\n29 | |             el\n   | |        \
    \     -- expected because of this\n30 | |         } else {\n31 | |           \
    \  0\n   | |             ^ expected `&isize`, found integer\n32 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n\nerror[E0308]: `if`\
    \ and `else` have incompatible types\n  --> /tmp/tmpanvje32v.rs:37:13\n   |\n\
    34 | /         if el % 2 == 0 {\n35 | |             el\n   | |             --\
    \ expected because of this\n36 | |         } else {\n37 | |             el + 1\n\
    \   | |             ^^^^^^ expected `&isize`, found `isize`\n38 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut result: Vec<isize> = vec![];\n    let mut smallest_even_value\
    \ = arr.iter().min().unwrap();\n    let mut smallest_even_index = -1;\n    let\
    \ mut smallest_even_indexes: Vec<isize> = vec![];\n    let mut prev_even_value\
    \ = smallest_even_value;\n    let mut prev_even_index = -1;\n    let mut prev_even_indexes:\
    \ Vec<isize> = vec![];\n\n    for element in arr {\n        if element % 2 ==\
    \ 0 {\n            if element < prev_even_value{\n                smallest_even_index\
    \ += 1;\n                smallest_even_indexes.push(smallest_even_index);\n  \
    \          }\n\n            if element < smallest_even_value {\n             \
    \   smallest_even_value = element;\n                smallest_even_index = smallest_even_indexes.iter().max().unwrap();\n\
    \            }\n\n            prev_even_value = element;\n            prev_even_index\
    \ = smallest_even_index;\n\n        } else {\n            if element < prev_even_value\
    \ {\n                smallest_even_index += 1;\n                smallest_even_indexes.push(smallest_even_index);\n\
    \            }\n\n            if element < smallest_even_value {\n           \
    \     smallest_even_value = element;\n                smallest_even_index = smallest_even_indexes.iter().max().unwrap();\n\
    \            }\n            prev_even_value = element;\n            prev_even_index\
    \ = smallest_even_index;\n        }\n    }\n\n    smallest_even_indexes.push(smallest_even_index);\n\
    \    smallest_even_indexes.push(smallest_even_index);\n    result.append(smallest_even_index);\n\
    \    result.append(prev_even_index);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9c7tajra.rs:40:26\n   |\n\
    40 |             if element < prev_even_value{\n   |                         \
    \ ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n40 |             if element < *prev_even_value{\n   |    \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c7tajra.rs:45:26\n\
    \   |\n45 |             if element < smallest_even_value {\n   |             \
    \             ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n45 |             if element < *smallest_even_value\
    \ {\n   |                          +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9c7tajra.rs:46:39\n   |\n31 |     let mut smallest_even_value = arr.iter().min().unwrap();\n\
    \   |                                   ------------------------- expected due\
    \ to this value\n...\n46 |                 smallest_even_value = element;\n  \
    \ |                                       ^^^^^^^\n   |                      \
    \                 |\n   |                                       expected `&isize`,\
    \ found `isize`\n   |                                       help: consider borrowing\
    \ here: `&element`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c7tajra.rs:47:39\n\
    \   |\n32 |     let mut smallest_even_index = -1;\n   |                      \
    \             -- expected due to this value\n...\n47 |                 smallest_even_index\
    \ = smallest_even_indexes.iter().max().unwrap();\n   |                       \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n47 |  \
    \               smallest_even_index = *smallest_even_indexes.iter().max().unwrap();\n\
    \   |                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9c7tajra.rs:50:31\n   |\n34 |     let mut prev_even_value = smallest_even_value;\n\
    \   |                               ------------------- expected due to this value\n\
    ...\n50 |             prev_even_value = element;\n   |         "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value: Vec<isize>\
    \ = vec![];\n    let mut min_index: Vec<isize> = vec![];\n    for i in arr {\n\
    \        if i.is_even() {\n            if min_even_value.is_empty() {\n      \
    \          min_even_value.push(i);\n            } else {\n                let\
    \ mut i = 0;\n                while i < min_even_value.len() && min_even_value[i]\
    \ < i {\n                    i += 1;\n                }\n                if min_even_value[i]\
    \ > i {\n                    min_even_value[i] = i;\n                }\n     \
    \       }\n            if min_index.is_empty() {\n                min_index.push(i);\n\
    \            }\n        } else {\n            min_index.push(i);\n        }\n\
    \    }\n    if min_even_value.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = vec![];\n    for i in min_even_value.iter() {\n       \
    \ min_value.push(i);\n    }\n    let mut min_value_index = 0;\n    for i in min_even_value.iter()\
    \ {\n        if min_value_index == min_value.len() {\n            loop {\n   \
    \             min_value_index += 1;\n                if min_value_index == min_value.len()\
    \ {\n                    break;\n                }\n            }\n        }\n\
    \    }\n    for i in min_value.iter() {\n        min_value_index = i;\n    }\n\
    \    let mut min = vec![min_value_index];\n    for i in min_index.iter() {\n \
    \       min = vec![min.last().unwrap() + 1, i];\n    }\n    min\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpjqp9oxif.rs:30:14\n   |\n30 |         if i.is_even() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjqp9oxif.rs:35:71\n   |\n35 |                 while i <\
    \ min_even_value.len() && min_even_value[i] < i {\n   |                      \
    \                                                 ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |                 while i < min_even_value.len()\
    \ && min_even_value[i] < i.try_into().unwrap() {\n   |                       \
    \                                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjqp9oxif.rs:38:40\n   |\n38 |              \
    \   if min_even_value[i] > i {\n   |                                        ^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n38 |           \
    \      if min_even_value[i] > i.try_into().unwrap() {\n   |                  \
    \                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjqp9oxif.rs:39:41\n   |\n39 |                     min_even_value[i]\
    \ = i;\n   |                     -----------------   ^ expected `isize`, found\
    \ `usize`\n   |                     |\n   |                     expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjqp9oxif.rs:68:27\n\
    \   |\n56 |     let mut min_value_index = 0;\n   |                           \
    \    - expected due to this value\n...\n68 |         min_value_index = i;\n  \
    \ |                           ^ expected `usize`, found `&&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjqp9oxif.rs:72:45\n   |\n72 |         min =\
    \ vec![min.last().unwrap() + 1, i];\n   |                                    \
    \         ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjqp9oxif.rs:74:5\n   |\n26 | fn pluck(arr: V"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = std::i32::MIN;\n\
    \    let mut smallest_index = 0;\n    let mut even_value_counter = 0;\n    let\
    \ mut index = 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n       \
    \     even_value_counter += 1;\n        }\n        smallest_value = std::i32::MAX;\n\
    \        if i < smallest_value {\n            smallest_index = index;\n      \
    \      smallest_value = i;\n        }\n        if even_value_counter > 1 {\n \
    \           smallest_index = index;\n            smallest_value = i;\n       \
    \ }\n        index += 1;\n    }\n    if even_value_counter == 0 {\n        return\
    \ vec![];\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbm_1u2nc.rs:36:16\n   |\n\
    36 |         if i < smallest_value {\n   |                ^^^^^^^^^^^^^^ expected\
    \ `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbm_1u2nc.rs:38:30\n\
    \   |\n27 |     let mut smallest_value = std::i32::MIN;\n   |                \
    \              ------------- expected due to this value\n...\n38 |           \
    \  smallest_value = i;\n   |                              ^ expected `i32`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbm_1u2nc.rs:42:30\n\
    \   |\n27 |     let mut smallest_value = std::i32::MIN;\n   |                \
    \              ------------- expected due to this value\n...\n42 |           \
    \  smallest_value = i;\n   |                              ^ expected `i32`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbm_1u2nc.rs:49:10\n\
    \   |\n49 |     vec![smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n49 |     vec![smallest_value.try_into().unwrap(),\
    \ smallest_index]\n   |                        ++++++++++++++++++++\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min_value: isize = 0;\n    let mut min_node_index:\
    \ usize = 0;\n    for i in arr {\n        if i % 2 == 0 {\n            min_value\
    \ = i;\n            min_node_index = i;\n        }\n    }\n    let mut new_vec:\
    \ Vec<isize> = vec![min_value, min_node_index];\n    for i in arr {\n        if\
    \ i == min_value && i % 2 == 0 {\n            new_vec.push(i);\n        }\n  \
    \  }\n    if new_vec.is_empty() {\n        return vec![];\n    }\n    return new_vec;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk087153e.rs:35:30\n   |\n\
    31 |     let mut min_node_index: usize = 0;\n   |                            \
    \ ----- expected due to this type\n...\n35 |             min_node_index = i;\n\
    \   |                              ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk087153e.rs:38:51\n   |\n38 |     let mut new_vec:\
    \ Vec<isize> = vec![min_value, min_node_index];\n   |                        \
    \                           ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n38 |     let mut new_vec: Vec<isize> = vec![min_value,\
    \ min_node_index.try_into().unwrap()];\n   |                                 \
    \                                ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut pluck_result: Vec<isize>\
    \ = vec![];\n    let mut pluck_node: isize = 0;\n    for i in arr {\n        if\
    \ i % 2 == 0 {\n            pluck_result = vec![pluck_node];\n            pluck_node\
    \ = i;\n        } else {\n            pluck_result.push(pluck_node);\n       \
    \ }\n    }\n    pluck_result\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[2, 1]`', /tmp/tmp5lwk8uqn.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut mut min_value = arr[0]\
    \ as usize;\n    let mut min_index = 0;\n\n    for val in arr.iter().cloned()\
    \ {\n        if val % 2 == 0 {\n            min_value = val;\n            min_index\
    \ = arr.iter().position(|x| x == val);\n        }\n    }\n\n    return vec![min_value,\
    \ min_index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmpczwfpk54.rs:27:13\n\
    \   |\n27 |     let mut mut min_value = arr[0] as usize;\n   |             ^^^\
    \ help: remove the additional `mut`s\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpczwfpk54.rs:32:25\n   |\n27 |     let mut mut min_value = arr[0] as\
    \ usize;\n   |                             --------------- expected due to this\
    \ value\n...\n32 |             min_value = val;\n   |                        \
    \ ^^^ expected `usize`, found `isize`\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpczwfpk54.rs:33:51\n   |\n33 |             min_index\
    \ = arr.iter().position(|x| x == val);\n   |                                 \
    \                  ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpczwfpk54.rs:33:25\n   |\n28 |\
    \     let mut min_index = 0;\n   |                         - expected due to this\
    \ value\n...\n33 |             min_index = arr.iter().position(|x| x == val);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczwfpk54.rs:37:17\n\
    \   |\n37 |     return vec![min_value, min_index];\n   |                 ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n37 |     return\
    \ vec![min_value.try_into().unwrap(), min_index];\n   |                      \
    \    ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = arr[0];\n    let mut smallest_value_index\
    \ = arr[0];\n    let mut index_of_smallest_even_value = arr.len();\n    for i\
    \ in arr.iter() {\n        if i % 2 == 0 {\n            if smallest_even_value\
    \ < i {\n                smallest_even_value = i;\n                index_of_smallest_even_value\
    \ = i;\n            } else {\n                if index_of_smallest_even_value\
    \ < i {\n                    smallest_value_index = i;\n                    index_of_smallest_even_value\
    \ = i;\n                }\n            }\n        }\n    }\n    vec![smallest_even_value,\n\
    \         smallest_value_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3sy7ftca.rs:35:38\n   |\n\
    35 |             if smallest_even_value < i {\n   |                          \
    \            ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |             if smallest_even_value < *i {\n   |     \
    \                                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3sy7ftca.rs:36:39\n\
    \   |\n30 |     let mut smallest_even_value = arr[0];\n   |                  \
    \                 ------ expected due to this value\n...\n36 |               \
    \  smallest_even_value = i;\n   |                                       ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    36 |                 smallest_even_value = *i;\n   |                         \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3sy7ftca.rs:37:48\n\
    \   |\n32 |     let mut index_of_smallest_even_value = arr.len();\n   |      \
    \                                      --------- expected due to this value\n\
    ...\n37 |                 index_of_smallest_even_value = i;\n   |            \
    \                                    ^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3sy7ftca.rs:39:51\n   |\n39 |              \
    \   if index_of_smallest_even_value < i {\n   |                              \
    \                     ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3sy7ftca.rs:40:44\n   |\n31 |     let mut smallest_value_index\
    \ = arr[0];\n   |                                    ------ expected due to this\
    \ value\n...\n40 |                     smallest_value_index = i;\n   |       \
    \                                     ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n40 |                     smallest_value_index\
    \ = *i;\n   |                                            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3sy7ftca.rs:41:52\n   |\n32 |     let mut index_of_smallest_even_value\
    \ = arr.len();\n   |                                            --------- expected\
    \ due "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() { return vec![];\
    \ }\n    let mut min_even_value = arr.iter().min();\n    let mut min_even_index:\
    \ Option<usize> = None;\n    let mut even_values_count: usize = 0;\n    for &v\
    \ in arr.iter() {\n        if v % 2 == 0 {\n            min_even_value_count =\
    \ min_even_value;\n            min_even_index = Some(arr.iter().position(|n| *n\
    \ == min_even_value));\n            if min_even_index.is_none() {\n          \
    \      even_values_count = 1;\n            } else {\n                even_values_count\
    \ += 1;\n            }\n        }\n    }\n    vec![min_even_index, min_even_value_count]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `min_even_value_count` in this scope\n\
    \  --> /tmp/tmpap7i578i.rs:33:13\n   |\n33 |             min_even_value_count\
    \ = min_even_value;\n   |             ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `even_values_count`\n\nerror[E0425]: cannot find\
    \ value `min_even_value_count` in this scope\n  --> /tmp/tmpap7i578i.rs:42:26\n\
    \   |\n42 |     vec![min_even_index, min_even_value_count]\n   |             \
    \             ^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `even_values_count`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap7i578i.rs:34:65\n\
    \   |\n34 |             min_even_index = Some(arr.iter().position(|n| *n == min_even_value));\n\
    \   |                                                                 ^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpap7i578i.rs:34:35\n   |\n34 |             min_even_index = Some(arr.iter().position(|n|\
    \ *n == min_even_value));\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpap7i578i.rs:42:10\n   |\n42 |     vec![min_even_index, min_even_value_count]\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<usize>`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_val: isize = 0;\n\
    \    let mut smalest_ind: usize = 0;\n    for i in arr.iter().cloned() {\n   \
    \     if i % 2 == 0 {\n            smalest_val = i;\n            smalest_ind =\
    \ i;\n        }\n    }\n    let mut smalest_vec: Vec<isize> = vec![];\n    if\
    \ smalest_val == 0 {\n        return vec![];\n    }\n    for i in 1..arr.len()\
    \ {\n        if arr[i] == smalest_val {\n            smalest_vec.push(smalest_val);\n\
    \        }\n    }\n    if smalest_vec.len() == 0 {\n        return vec![];\n \
    \   }\n    if smalest_vec.len() == 1 {\n        return vec![i];\n    }\n    for\
    \ i in 1..smalest_vec.len() {\n        if smalest_vec[i] - smalest_vec[i - 1]\
    \ < 0 {\n            return vec![i];\n        }\n    }\n    smalest_vec\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp2_jgdnuf.rs:48:21\n\
    \   |\n48 |         return vec![i];\n   |                     ^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_jgdnuf.rs:32:27\n \
    \  |\n28 |     let mut smalest_ind: usize = 0;\n   |                         \
    \ ----- expected due to this type\n...\n32 |             smalest_ind = i;\n  \
    \ |                           ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2_jgdnuf.rs:52:25\n   |\n52 |             return\
    \ vec![i];\n   |                         ^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n52 |             return vec![i.try_into().unwrap()];\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n\n    let mut min_val = min_node(arr);\n    let mut mut_arr\
    \ = arr;\n    while !mut_arr.is_empty() {\n        if mut_arr.len() < arr.len()\
    \ {\n            mut_arr.remove(0);\n        } else {\n            mut_arr.remove(0);\n\
    \        }\n        if mut_arr.len() < arr.len() {\n            mut_arr.remove(0);\n\
    \        }\n        if mut_arr.len() < arr.len() {\n            mut_arr.remove(0);\n\
    \        }\n        if mut_arr.len() < arr.len() {\n            mut_arr.remove(0);\n\
    \        }\n        if mut_arr.len() < arr.len() {\n            mut_arr.remove(0);\n\
    \        }\n        if mut_arr.len() < arr.len() {\n            mut_arr.remove(0);\n\
    \        }\n    }\n\n    let mut res = vec![];\n    for val in arr {\n       \
    \ if val == min_val {\n            res.push((val as usize - min_val) as usize);\n\
    \            break;\n        }\n    }\n\n    return res;\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min_node` in this scope\n  --> /tmp/tmpvas4tpdy.rs:31:23\n\
    \   |\n31 |     let mut min_val = min_node(arr);\n   |                       ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvas4tpdy.rs:59:38\n\
    \   |\n59 |             res.push((val as usize - min_val) as usize);\n   |   \
    \                                   ^^^^^^^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpvas4tpdy.rs:59:36\n\
    \   |\n59 |             res.push((val as usize - min_val) as usize);\n   |   \
    \                                 ^ no implementation for `usize - isize`\n  \
    \ |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvas4tpdy.rs:64:12\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n64 |     return res;\n   |            ^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    let mut smaller_than_even_value_index:\
    \ Option<isize> = None;\n    let mut smaller_than_even_value = vec![0isize];\n\
    \    for i in 0..arr.len() {\n        if i % 2 == 0 && smaller_than_even_value_index.is_none()\
    \ {\n            smaller_than_even_value_index =  Some(i);\n            smaller_than_even_value\
    \ = vec![0isize];\n        }\n        if arr[i] < smaller_than_even_value[0] {\n\
    \            smaller_than_even_value[0] = arr[i];\n            smaller_than_even_value_index.take();\n\
    \        }\n    }\n    smaller_than_even_value_index.take()\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp38r46tjm.rs:32:51\n   |\n\
    32 |             smaller_than_even_value_index =  Some(i);\n   |             \
    \                                      ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n32 |             smaller_than_even_value_index =  Some(i.try_into().unwrap());\n\
    \   |                                                    ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp38r46tjm.rs:40:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n40 |     smaller_than_even_value_index.take()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ enum `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut mut_arr = arr.to_owned();\n\
    \    let mut index = 0;\n    let mut smalest_value = 0;\n\n    for node in mut_arr.iter_mut()\
    \ {\n        if node % 2 == 0 {\n            smalest_value = node;\n         \
    \   index = index;\n        }\n    }\n\n    smalest_value.clone_from_slice(&mut_arr[index..]);\n\
    \n    vec![smalest_value, index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmphrgjkcjs.rs:32:17\n\
    \   |\n32 |         if node % 2 == 0 {\n   |            ---- ^ - {integer}\n \
    \  |            |\n   |            &mut isize\n   |\nhelp: `%` can be used on\
    \ `isize`, you can dereference `node`\n   |\n32 |         if *node % 2 == 0 {\n\
    \   |            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphrgjkcjs.rs:33:29\n\
    \   |\n29 |     let mut smalest_value = 0;\n   |                             -\
    \ expected due to this value\n...\n33 |             smalest_value = node;\n  \
    \ |                             ^^^^ expected integer, found `&mut isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n33 |             smalest_value\
    \ = *node;\n   |                             +\n\nerror[E0599]: no method named\
    \ `clone_from_slice` found for type `{integer}` in the current scope\n  --> /tmp/tmphrgjkcjs.rs:38:19\n\
    \   |\n38 |     smalest_value.clone_from_slice(&mut_arr[index..]);\n   |     \
    \              ^^^^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphrgjkcjs.rs:40:25\n   |\n40 |     vec![smalest_value,\
    \ index]\n   |                         ^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n40 |     vec![smalest_value, index.try_into().unwrap()]\n\
    \   |                              ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n\n    let mut largest: isize = 0;\n    let mut smallest: isize\
    \ = 0;\n\n    for &i in arr {\n        if i % 2 == 0 {\n            if largest\
    \ < i {\n                largest = i;\n            }\n        } else {\n     \
    \       if smallest > i {\n                smallest = i;\n            }\n    \
    \    }\n    }\n\n    if smallest != 0 {\n        let mut ret = vec![smallest,\
    \ 0];\n        let mut i = 1isize;\n        while i < arr.len() {\n          \
    \  if arr[i] % 2 == 0 {\n                ret[0] = arr[i];\n                break;\n\
    \            }\n            i += 1;\n        }\n        std::mem::swap(ret.0,\
    \ ret[1]);\n        return ret\n    } else {\n        vec![]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzorpfgst.rs:34:9\n   |\n\
    34 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzorpfgst.rs:49:19\n   |\n49 |         while i < arr.len() {\n \
    \  |                   ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n49 |         while i < arr.len().try_into().unwrap() {\n   |    \
    \                        ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzorpfgst.rs:50:16\n   |\n50 |  \
    \           if arr[i] % 2 == 0 {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzorpfgst.rs:51:26\n   |\n51 |            \
    \     ret[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0609]: no field `0` on type `Vec<isize>`\n\
    \  --> /tmp/tmpzorpfgst.rs:56:28\n   |\n56 |         std::mem::swap(ret.0, ret[1]);\n\
    \   |                            ^ unknown field\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzorpfgst.rs:56:31\n   |\n56 |         std::mem::swap(ret.0, ret[1]);\n\
    \   |                               ^^^^^^\n   |                             \
    \  |\n   |        "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().rev().filter().sorted().take().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpomilnr1q.rs:27:22\n    |\n27  |     arr.iter().rev().filter().sorted().take().collect()\n\
    \    |                      ^^^^^^- supplied 0 arguments\n    |              \
    \        |\n    |                      expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0599]: no method named `sorted` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmpomilnr1q.rs:27:31\n   |\n27 | \
    \    arr.iter().rev().filter().sorted().take().collect()\n   |               \
    \                ^^^^^^ method not found in `Filter<Rev<std::slice::Iter<'_, isize>>,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), 10000);\n\
    \    arr.iter().cloned().filter(|&x| x % 2 == 0).min_by(|a, b| a.cmp(b)).unwrap()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf9r2yzis.rs:28:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n27 |     assert_eq!(arr.len(),\
    \ 10000);\n28 |     arr.iter().cloned().filter(|&x| x % 2 == 0).min_by(|a, b|\
    \ a.cmp(b)).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut index = 0;\n    let mut\
    \ smalest_value = 0;\n    let mut smalest_node = 0;\n    for &i in arr {\n   \
    \     if i / 2 == smalest_value {\n            smalest_node = i;\n        } else\
    \ {\n            smalest_value = i;\n        }\n        if index == 0 {\n    \
    \        index = i;\n        }\n        index /= 2;\n    }\n    return vec![smalest_node,\
    \ index];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu52978tb.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), 10000, \"\
    input array must be exactly 10000 elements long\");\n\n    // sort the list in-place\
    \ to speed up the next step\n    // use std::cmp::min to avoid a lot of if statements\n\
    \    // https://doc.rust-lang.org/std/cmp/trait.Min.html\n    // https://doc.rust-lang.org/std/cmp/trait.Ord.html\n\
    \    arr.sort_unstable_by_key(|x| x.0 as isize);\n\n    let mut i = 0;\n    let\
    \ mut smalest_value = arr[0];\n    let mut smalest_index = i;\n    let mut current_value\
    \ = 0;\n\n    for val in arr.iter().cloned() {\n        if val % 2 == 0 {\n  \
    \          smalest_value = val;\n            smalest_index = i;\n            current_value\
    \ = val;\n        }\n\n        i += 1;\n    }\n\n    if current_value == 0 {\n\
    \        return vec![];\n    }\n\n    let mut indexes = vec![];\n\n    while smalest_index\
    \ != smalest_index {\n        if smalest_value == arr[0] {\n            indexes.push(smalest_index);\n\
    \        }\n\n        smalest_index += 1;\n    }\n\n    indexes.push(smalest_index);\n\
    \n    indexes\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpz4ybl3uf.rs:33:36\n\
    \   |\n33 |     arr.sort_unstable_by_key(|x| x.0 as isize);\n   |            \
    \                        ^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_index: isize = 0;\n    let mut max_value: isize = 0;\n\
    \    let mut max_index: isize = 0;\n\n    for i in arr.iter() {\n        if i\
    \ % 2 == 0 {\n            if smalest_value > i {\n                smalest_value\
    \ = i;\n                smalest_index = i;\n            }\n        } else {\n\
    \            if smalest_value < i {\n                smalest_value = i;\n    \
    \            smalest_index = i;\n            }\n        }\n\n        if max_value\
    \ < i {\n            max_value = i;\n            max_index = i;\n        }\n \
    \   }\n\n    if max_index == 0 {\n        return vec![];\n    } else {\n     \
    \   return vec![smalest_value, max_index];\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvfd_ed1.rs:34:32\n   |\n\
    34 |             if smalest_value > i {\n   |                                ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n34 |             if smalest_value > *i {\n   |                        \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvfd_ed1.rs:35:33\n\
    \   |\n27 |     let mut smalest_value: isize = 0;\n   |                      \
    \      ----- expected due to this type\n...\n35 |                 smalest_value\
    \ = i;\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 smalest_value\
    \ = *i;\n   |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwvfd_ed1.rs:36:33\n   |\n28 |     let mut smalest_index: isize\
    \ = 0;\n   |                            ----- expected due to this type\n...\n\
    36 |                 smalest_index = i;\n   |                                \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n36 |                 smalest_index = *i;\n   |                        \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvfd_ed1.rs:39:32\n\
    \   |\n39 |             if smalest_value < i {\n   |                         \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n39 |             if smalest_value < *i {\n   |           \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvfd_ed1.rs:40:33\n\
    \   |\n27 |     let mut smalest_value: isize = 0;\n   |                      \
    \      ----- expected due to this type\n...\n40 |                 smalest_value\
    \ = i;\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |                 smalest_value\
    \ = *i;\n   |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwvfd_ed1.rs:41:33\n   |\n28 |     let mut smalest_index: isize\
    \ = 0;\n   |                            ----- expected due to"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().enumerate().filter_map(|(index,\
    \ element)| {\n        if element % 2 == 0 {\n            Some(element)\n    \
    \    } else {\n            None\n        }\n    }).map(|(node, value)| {\n   \
    \     vec![value, index]\n    })\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `index` in this scope\n  --> /tmp/tmphs12yk5i.rs:34:21\n\
    \   |\n34 |         vec![value, index]\n   |                     ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphs12yk5i.rs:33:13\n\
    \   |\n33 |     }).map(|(node, value)| {\n   |             ^^^^^^^^^^^^-\n   |\
    \             |           |\n   |             |           expected due to this\n\
    \   |             expected `isize`, found tuple\n   |\n   = note: expected type\
    \ `isize`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphs12yk5i.rs:27:5\n   |\n26 |   fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                ---------- expected `Vec<isize>` because\
    \ of return type\n27 | /     arr.iter().enumerate().filter_map(|(index, element)|\
    \ {\n28 | |         if element % 2 == 0 {\n29 | |             Some(element)\n\
    30 | |         } else {\n...  |\n34 | |         vec![value, index]\n35 | |   \
    \  })\n   | |______^ expected struct `Vec`, found struct `Map`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Map<FilterMap<Enumerate<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmphs12yk5i.rs:27:39: 33:6]>, [closure@/tmp/tmphs12yk5i.rs:33:12:\
    \ 35:6]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = -1;\n    for &mut x in arr.iter_mut() {\n        *x = *x %\
    \ 2;\n        if *x == 0 && min_val > x {\n            min_val = x;\n        \
    \    min_idx = x;\n        }\n    }\n    let mut mut_arr = arr.as_mut_slice();\n\
    \    mut_arr[min_idx].unwrap();\n    mut_arr\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpz2uy0brw.rs:30:9\n\
    \   |\n30 |         *x = *x % 2;\n   |         ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpz2uy0brw.rs:30:14\n   |\n30 |        \
    \ *x = *x % 2;\n   |              ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpz2uy0brw.rs:31:12\n   |\n31 |         if *x == 0 && min_val > x\
    \ {\n   |            ^^\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpz2uy0brw.rs:37:5\n   |\n37 |     mut_arr[min_idx].unwrap();\n\
    \   |     ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `[isize]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz2uy0brw.rs:38:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n38 |     mut_arr\n   |  \
    \   ^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |     |\n  \
    \ |     expected struct `Vec`, found `&mut [isize]`\n   |\n   = note:        \
    \ expected struct `Vec<isize>`\n           found mutable reference `&mut [isize]`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // Write your code here.\n    let\
    \ mut smallest_even_value = vec![];\n    let mut smallest_index = vec![];\n  \
    \  for i in arr.iter() {\n        if i % 2 == 0 {\n            if smallest_even_value.len()\
    \ == 0 {\n                smallest_even_value.push(i);\n                smallest_index.push(i);\n\
    \            } else {\n                smallest_even_value = vec![];\n       \
    \         smallest_index = vec![];\n                break;\n            }\n  \
    \      }\n    }\n    if arr.len() > 0 && smallest_even_value.len() == 0 {\n  \
    \      smallest_even_value = vec![];\n        smallest_index = vec![];\n    }\n\
    \    smallest_even_value\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc0yh9cd2.rs:46:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n46 |     smallest_even_value\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.into_iter().filter(|&x| x %\
    \ 2 == 0).min().cloned().collect()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<isize>` is not an iterator\n   --> /tmp/tmprd42x26g.rs:27:51\n\
    \    |\n27  |       arr.into_iter().filter(|&x| x % 2 == 0).min().cloned().collect()\n\
    \    |                                                     ^^^^^^ `Option<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<isize>: Iterator`\n            which is required by `&mut\
    \ Option<isize>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() > 0, \"Invalid\
    \ input\");\n    assert!(arr.len() <= 10000, \"Invalid input\");\n    if arr.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    let mut vec: Vec<isize> = vec![];\n\
    \    let mut smallest_value: isize = 0;\n    let mut smallest_index = 0;\n   \
    \ let mut smallest_even_value = false;\n\n    for i in arr.iter().cloned() {\n\
    \        if smallest_even_value\n            && smallest_value > i\n         \
    \   && !smallest_value\n            .checked_sub(i).is_ok()\n        {\n     \
    \       continue;\n        }\n        if !smallest_even_value\n            &&\
    \ (smallest_value > i || smallest_value < i)\n        {\n            smallest_even_value\
    \ = true;\n            smallest_value = i;\n        }\n        if !smallest_value\n\
    \            .checked_sub(i % 2)\n            .unwrap()\n            .checked_add(1)\n\
    \            .unwrap()\n            .is_ok()\n        {\n            continue;\n\
    \        }\n        vec.push(i);\n        if smallest_value == i {\n         \
    \   smallest_index = vec.len();\n        }\n    }\n    vec\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp5t9ocitm.rs:42:29\n   |\n42 |             .checked_sub(i).is_ok()\n\
    \   |                             ^^^^^ method not found in `Option<isize>`\n\n\
    error[E0599]: no method named `is_ok` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp5t9ocitm.rs:57:14\n   |\n57 |             .is_ok()\n   |      \
    \        ^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() > 0);\n    assert!(arr.iter().all(|&x|\
    \ x > 0));\n    let mut smallest_value = 0;\n    let mut smallest_index = 0;\n\
    \    let mut even_values = 0;\n    for &node in arr {\n        if node.is_even()\
    \ {\n            even_values += 1;\n        }\n        if node.value <= smallest_value\
    \ {\n            smallest_value = node.value;\n            smallest_index = node.index;\n\
    \        }\n        if even_values > 1 && node.value == smallest_value {\n   \
    \         smallest_value = node.value;\n            smallest_index = node.index;\n\
    \        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagges46r.rs:32:9\n   |\n\
    32 |     for &node in arr {\n   |         ^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `node`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n\n    let mut smalest_value = i32::MIN;\n    let mut smallest_index\
    \ = 0;\n    for node in arr.iter().rev() {\n        if node % 2 == 0 {\n     \
    \       if smalest_value < i32::MIN {\n                smalest_value = node;\n\
    \                smallest_index = 1;\n            } else if smalest_value == i32::MIN\
    \ {\n                smallest_index = smallest_index + 1;\n            }\n   \
    \     }\n    }\n\n    vec![smalest_value, smallest_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptm_pjw8a.rs:36:33\n   |\n\
    31 |     let mut smalest_value = i32::MIN;\n   |                             --------\
    \ expected due to this value\n...\n36 |                 smalest_value = node;\n\
    \   |                                 ^^^^ expected `i32`, found `&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptm_pjw8a.rs:44:10\n   |\n44 |  \
    \   vec![smalest_value, smallest_index]\n   |          ^^^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n44 |     vec![smalest_value.try_into().unwrap(),\
    \ smallest_index]\n   |                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().windows(2).map(|arr|\
    \ arr.min(|a, b| a % 2).unwrap_or(0)).collect().sorted()\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp4gmrgkc4.rs:27:25\n   |\n27 |     arr.iter().cloned().windows(2).map(|arr|\
    \ arr.min(|a, b| a % 2).unwrap_or(0)).collect().sorted()\n   |               \
    \          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut min_val = arr[0];\n    let mut min_idx = 0;\n  \
    \  for idx in 0..arr.len() {\n        if arr[idx] % 2 == 0 {\n            if min_val\
    \ < arr[idx] {\n                min_val = arr[idx];\n                min_idx =\
    \ idx;\n            }\n        }\n    }\n    return vec![min_val, min_idx];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wfrxk3k.rs:40:26\n   |\n\
    40 |     return vec![min_val, min_idx];\n   |                          ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n40 |     return\
    \ vec![min_val, min_idx.try_into().unwrap()];\n   |                          \
    \       ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min_val = arr[0];\n    let mut min_idx = arr.iter().skip(1).cloned().count();\n\
    \    for i in arr.iter().skip(1).cloned().rev() {\n        if *i % 2 == 0 {\n\
    \            if min_val == i {\n                if min_idx == i {\n          \
    \          break;\n                }\n            } else {\n                min_val\
    \ = i;\n                min_idx = i;\n            }\n        }\n    }\n    let\
    \ mut indexes = vec![];\n    for i in arr.iter().rev().cloned().skip(1).cloned().rev()\
    \ {\n        if i != min_val {\n            break;\n        }\n        indexes.push(i);\n\
    \    }\n    if min_idx == arr.iter().skip(1).cloned().count() {\n        return\
    \ vec![];\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpj1_a7ded.rs:33:12\n\
    \   |\n33 |         if *i % 2 == 0 {\n   |            ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj1_a7ded.rs:35:31\n   |\n35 |                 if min_idx\
    \ == i {\n   |                               ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |                 if min_idx == i.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj1_a7ded.rs:40:27\n   |\n31 |     let mut min_idx\
    \ = arr.iter().skip(1).cloned().count();\n   |                       -----------------------------------\
    \ expected due to this value\n...\n40 |                 min_idx = i;\n   |   \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0271]: type\
    \ mismatch resolving `<Rev<std::slice::Iter<'_, isize>> as Iterator>::Item ==\
    \ &&_`\n    --> /tmp/tmpj1_a7ded.rs:45:48\n     |\n45   |     for i in arr.iter().rev().cloned().skip(1).cloned().rev()\
    \ {\n     |                                                ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected reference `&&_`\n             \
    \   found reference `&isize`\n     = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Rev<std::slice::Iter<'_, isize>>>`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `rev` exists for\
    \ struct `Cloned<Skip<Cloned<Rev<std::slice::Iter<'_, isize>>>>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpj1_a7ded.rs:45:57\n   |\n45 |     \
    \   for i in arr.iter().rev().cloned().skip(1).cloned().rev() {\n   |        \
    \                                                    ^^^ method cannot be called\
    \ on `Cloned<Skip<Cloned<Rev<std::slice::Iter<'_, isize>>>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Skip<Cloned<Rev<std::slice::Iter<'_, isize>>>> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Skip<Clo"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.into_iter();\n\
    \    let mut min = arr[0];\n    let mut min_index = 0;\n    let mut min_value\
    \ = -1;\n    let mut even_values = vec![];\n    let mut i = 1;\n    while let\
    \ Some(mut v) = arr.next() {\n        if v % 2 == 0 {\n            even_values.push(v);\n\
    \            if v == min {\n                min_index = i;\n                min_value\
    \ = v;\n            }\n        }\n        i += 1;\n    }\n    if min_index ==\
    \ 0 {\n        return even_values.to_vec();\n    }\n    if min_value < 0 {\n \
    \       // no even value\n        return even_values.to_vec();\n    }\n    if\
    \ even_values.len() == 0 {\n        return even_values.to_vec();\n    }\n    if\
    \ even_values.len() == 1 {\n        return even_values.to_vec();\n    }\n    let\
    \ mut even_values = even_values.into_iter().nth(0);\n    if min_value == min_value\
    \ {\n        // two nodes have same value, return the smallest one with smallest\
    \ index.\n        if even_values == min_value {\n            return even_values.to_vec();\n\
    \        }\n        let mut even_values = even_values.into_iter().nth(0);\n  \
    \      let mut even_values = even_values.into_iter().nth(0);\n        return even_values.to_vec();\n\
    \    }\n    let mut even_values = even_values.into_iter().nth(1);\n    if min_value\
    \ > min_value {\n        // there is no node with smallest even value, return\
    \ the smallest even value with smallest index.\n        return even_values.to_vec();\n\
    \    }\n    let mut even_values = even_values.into_iter().nth(1);\n    let mut\
    \ even_values = even_values.into_iter().nth(1);\n    return even_values.to_vec();\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `std::vec::IntoIter<isize>`\n\
    \  --> /tmp/tmpooef21ev.rs:28:19\n   |\n28 |     let mut min = arr[0];\n   | \
    \                  ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpooef21ev.rs:59:27\n\
    \   |\n59 |         if even_values == min_value {\n   |                      \
    \     ^^^^^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found type `isize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n59 |         if even_values == Some(min_value) {\n\
    \   |                           +++++         +\n\nerror[E0599]: no method named\
    \ `to_vec` found for enum `Option` in the current scope\n  --> /tmp/tmpooef21ev.rs:60:32\n\
    \   |\n60 |             return even_values.to_vec();\n   |                   \
    \             ^^^^^^ method not found in `Option<isize>`\n\nerror[E0599]: no method\
    \ named `to_vec` found for enum `Option` in the current scope\n  --> /tmp/tmpooef21ev.rs:64:28\n\
    \   |\n64 |         return even_values.to_vec();\n   |                       \
    \     ^^^^^^ method not found in `Option<isize>`\n\nerror[E0599]: no method named\
    \ `to_vec` found for enum `Option` in the current scope\n  --> /tmp/tmpooef21ev.rs:69:28\n\
    \   |\n69 |         return even_values.to_vec();\n   |                       \
    \     ^^^^^^ method not found in `Option<isize>`\n\nerror[E0599]: no method named\
    \ `to_vec` found for enum `Option` in the current scope\n  --> /tmp/tmpooef21ev.rs:73:24\n\
    \   |\n73 |     return even_values.to_vec();\n   |                        ^^^^^^\
    \ method not found in `Option<isize>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even: Vec<isize> = vec![0;\
    \ arr.len()];\n    let mut index: Vec<isize> = vec![0; arr.len()];\n\n    for\
    \ n in arr {\n        if n % 2 == 0 {\n            even[n] = n;\n            index[n]\
    \ = even[n];\n        } else {\n            if even[n] > n {\n               \
    \ even[n] = n;\n                index[n] = even[n];\n            }\n        }\n\
    \    }\n    if even.len() > 0 {\n        even.sort();\n        return even;\n\
    \    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiaoo56b3.rs:32:13\n\
    \   |\n32 |             even[n] = n;\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiaoo56b3.rs:33:13\n   |\n33 |            \
    \ index[n] = even[n];\n   |             ^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiaoo56b3.rs:33:24\n   |\n33 |            \
    \ index[n] = even[n];\n   |                        ^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiaoo56b3.rs:35:16\n   |\n35 |            \
    \ if even[n] > n {\n   |                ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiaoo56b3.rs:36:17\n   |\n36 |            \
    \     even[n] = n;\n   |                 ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_idx = arr[0];\n    for i in 0..arr.len() {\n        if min_even_value\
    \ > arr[i] {\n            min_even_value = arr[i];\n            min_even_idx =\
    \ i;\n        }\n    }\n    let mut smalest_value = min_even_value;\n    let mut\
    \ smalest_idx = min_even_idx;\n    for mut i in 0..arr.len() {\n        if arr[i]\
    \ == smalest_value {\n            if i < min_even_idx {\n                smalest_value\
    \ = arr[i];\n                smalest_idx = i;\n            }\n        } else {\n\
    \            smalest_value = arr[i];\n            smalest_idx = i;\n        }\n\
    \    }\n    let mut result = vec![smalest_value, smalest_idx];\n    if arr.len()\
    \ == 0 {\n        result = vec![];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpflfjvyv9.rs:32:28\n   |\n\
    28 |     let mut min_even_idx = arr[0];\n   |                            ------\
    \ expected due to this value\n...\n32 |             min_even_idx = i;\n   |  \
    \                          ^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpflfjvyv9.rs:39:20\n   |\n39 |             if\
    \ i < min_even_idx {\n   |                    ^^^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n39 |             if i < min_even_idx.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpflfjvyv9.rs:41:31\n   |\n36 |     let mut smalest_idx\
    \ = min_even_idx;\n   |                           ------------ expected due to\
    \ this value\n...\n41 |                 smalest_idx = i;\n   |               \
    \                ^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpflfjvyv9.rs:45:27\n   |\n36 |     let mut smalest_idx =\
    \ min_even_idx;\n   |                           ------------ expected due to this\
    \ value\n...\n45 |             smalest_idx = i;\n   |                        \
    \   ^ expected `isize`, found `usize`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut min = arr[0];\n    let mut index = arr[0];\n   \
    \ let mut index = arr.iter().enumerate().filter (|(_, n)| n % 2 == 0).min_by (|&(_,\
    \ v)| v);\n    while index != Some(arr.iter().find(|&x| x == min).unwrap().0))\
    \ {\n        min = arr[index.0 + 1];\n        index = arr.iter().enumerate().filter\
    \ (|(_, n)| n % 2 == 0).min_by (|&(_, v)| v);\n    }\n    let mut vec: Vec<isize>\
    \ = vec![];\n    for i in 0..arr.len() {\n        if arr[i] == min {\n       \
    \     vec.push(i);\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpfey4kuzi.rs:44:1\n\
    \   |\n38 |     for i in 0..arr.len() {\n   |                           - this\
    \ opening brace...\n...\n42 |     }\n   |     - ...matches this closing brace\n\
    43 |     vec\n44 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched\
    \ closing delimiter: `)`\n  --> /tmp/tmpfey4kuzi.rs:26:41\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                         ^\
    \ unclosed delimiter\n...\n33 |     while index != Some(arr.iter().find(|&x| x\
    \ == min).unwrap().0)) {\n   |                                               \
    \                    ^ mismatched closing delimiter\n\nerror: aborting due to\
    \ 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), 10000);\n\
    \    let mut largest: Vec<isize> = vec![];\n    let mut smallest: Vec<isize> =\
    \ vec![];\n    let mut even: Vec<isize> = vec![];\n    for i in arr {\n      \
    \  if i % 2 == 0 {\n            even.push(i);\n        } else {\n            if\
    \ even.is_empty() {\n                if smallest == vec![i] {\n              \
    \      smallest = vec![i];\n                }\n                if largest == vec![i]\
    \ {\n                    largest = vec![i];\n                }\n            }\
    \ else {\n                if largest < vec![i] {\n                    largest\
    \ = vec![i];\n                }\n                if smallest > vec![i] {\n   \
    \                 smallest = vec![i];\n                }\n            }\n    \
    \    }\n    }\n    vec![(largest, largest.iter().count().unwrap())]\n        |\
    \ (smallest, smallest.iter().count().unwrap())\n        | (even, even.iter().count().unwrap())\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp2kongnoj.rs:52:43\n   |\n52 |     vec![(largest, largest.iter().count().unwrap())]\n\
    \   |                                           ^^^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp2kongnoj.rs:53:46\n   |\n53 |         | (smallest, smallest.iter().count().unwrap())\n\
    \   |                                              ^^^^^^ method not found in\
    \ `usize`\n\nerror[E0599]: no method named `unwrap` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmp2kongnoj.rs:54:38\n   |\n54 |         | (even,\
    \ even.iter().count().unwrap())\n   |                                      ^^^^^^\
    \ method not found in `usize`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut arrlen = arr.len();\n    if arrlen == 0 {\n        return vec![];\n\
    \    }\n    let mut min_index = arrlen - 1;\n    let mut min_value = arr[0].unwrap();\n\
    \    for &node in &arr {\n        let val = node.unwrap();\n        if val % 2\
    \ == 0 {\n            min_value = val;\n            if val < min_value {\n   \
    \             min_index = arr.iter().position(|&x| x == val).unwrap();\n     \
    \       }\n        }\n    }\n    arr[min_index].unwrap()\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe2d5pq1v.rs:33:32\n   |\n33 |     let mut min_value = arr[0].unwrap();\n\
    \   |                                ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpe2d5pq1v.rs:35:24\n   |\n35 |         let val = node.unwrap();\n   |\
    \                        ^^^^^^ method not found in `isize`\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpe2d5pq1v.rs:43:20\n\
    \   |\n43 |     arr[min_index].unwrap()\n   |                    ^^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() > 0);\n    let\
    \ mut lowest_even_value: isize = 0;\n    let mut smallest_index = 0;\n    let\
    \ mut even_values = vec![];\n    for &n in arr {\n        if n % 2 == 0 {\n  \
    \          even_values.push(n - lowest_even_value);\n        }\n        if n ==\
    \ lowest_even_value {\n            if even_values.len() == 1 {\n             \
    \   smallest_index = even_values.len() - 1;\n            } else {\n          \
    \      let mut smallest_index = even_values.iter().min_by_key(|x| *x).unwrap();\n\
    \                lowest_even_value = even_values[smallest_index];\n          \
    \  }\n        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    vec![even_values[smallest_index], smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8o6m0_t6.rs:31:9\n   |\n\
    31 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `&_`\n  --> /tmp/tmp8o6m0_t6.rs:40:37\n   |\n40 |     \
    \            lowest_even_value = even_values[smallest_index];\n   |          \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `&_`\n   = note: required because of the requirements on\
    \ the impl of `Index<&_>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8o6m0_t6.rs:47:39\n   |\n47 |     vec![even_values[smallest_index],\
    \ smallest_index]\n   |                                       ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n47 |     vec![even_values[smallest_index],\
    \ smallest_index.try_into().unwrap()]\n   |                                  \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = HashSet::new();\n\
    \    let mut smallest_index = HashSet::new();\n    for i in arr.iter().cloned().skip(1)\
    \ {\n        if i.is_even() {\n            even_values.insert(i);\n          \
    \  smallest_index.insert(i);\n        }\n    }\n    let mut result: Vec<_> = arr.iter().cloned().skip(1);\n\
    \    if even_values.len() != arr.len() {\n        result = []\n    } else {\n\
    \        smallest_index.sort_by_key(|i| i);\n        result = smallest_index.iter().cloned().collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp8aq8vwyv.rs:27:27\n   |\n27 |     let mut even_values = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp8aq8vwyv.rs:28:30\n\
    \   |\n28 |     let mut smallest_index = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `is_even` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp8aq8vwyv.rs:30:14\n   |\n30 |         if i.is_even() {\n   |       \
    \       ^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8aq8vwyv.rs:35:30\n   |\n35 |     let mut result: Vec<_> = arr.iter().cloned().skip(1);\n\
    \   |                     ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found struct `Skip`\n   |                     |\n   |               \
    \      expected due to this\n   |\n   = note: expected struct `Vec<_>`\n     \
    \         found struct `Skip<Cloned<std::slice::Iter<'_, isize>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8aq8vwyv.rs:37:18\n   |\n35 |     let mut result:\
    \ Vec<_> = arr.iter().cloned().skip(1);\n   |                     ------ expected\
    \ due to this type\n36 |     if even_values.len() != arr.len() {\n37 |       \
    \  result = []\n   |                  ^^- help: try using a conversion method:\
    \ `.to_vec()`\n   |                  |\n   |                  expected struct\
    \ `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<_>`\n\
    \               found array `[_; 0]`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        let\
    \ mut a_b = a * 100000000 + b;\n        let mut a_b_pow = pow(a_b, 100);\n   \
    \     a_b_pow = a_b_pow % 101;\n        if a_b_pow == 0 {\n            (b * 100000000)\
    \ % 101\n        } else {\n            (b * 100000000) % 101 - a_b_pow\n     \
    \   }\n    });\n    if arr.len() == 0 {\n        vec![]\n    } else {\n      \
    \  let mut smallest = vec![0];\n        let mut smallest_index = vec![0];\n  \
    \      for i in 0..arr.len() {\n            if smallest[0] == i {\n          \
    \      smallest_index[0] = i;\n            }\n            if smallest[0] != i\
    \ && arr[i] % 2 == 0 {\n                smallest = vec![i];\n                smallest_index\
    \ = vec![i];\n            }\n        }\n        if smallest_index.len() == 1 {\n\
    \            smallest\n        } else {\n            smallest_index\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpjmqwn0xq.rs:29:27\n\
    \   |\n29 |         let mut a_b_pow = pow(a_b, 100);\n   |                   \
    \        ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjmqwn0xq.rs:32:13\n   |\n32 |             (b * 100000000) % 101\n  \
    \ |             ^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjmqwn0xq.rs:52:13\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n52\
    \ |             smallest\n   |             ^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjmqwn0xq.rs:54:13\n   |\n26 |\
    \ fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                            \
    \  ---------- expected `Vec<isize>` because of return type\n...\n54 |        \
    \     smallest_index\n   |             ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    solve(&arr, 0).unwrap()\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve` in this scope\n  --> /tmp/tmptd49pem9.rs:27:5\n\
    \   |\n27 |     solve(&arr, 0).unwrap()\n   |     ^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens = vec![false; arr.len()\
    \ + 1];\n    let mut index = arr.len() - 1;\n    let mut smalest_even = 0;\n \
    \   for &i in arr {\n        if !evens[i as usize] {\n            evens[i as usize]\
    \ = true;\n            smalest_even = i as isize;\n            index = i;\n  \
    \      }\n    }\n    if evens.iter().any() {\n        vec![smalest_even, index].into_iter().collect()\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdn4n2n5u.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpdn4n2n5u.rs:37:21\n\
    \     |\n37   |     if evens.iter().any() {\n     |                     ^^^- supplied\
    \ 0 arguments\n     |                     |\n     |                     expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdn4n2n5u.rs:38:28\n   |\n38 |         vec![smalest_even,\
    \ index].into_iter().collect()\n   |                            ^^^^^ expected\
    \ `isize`, found `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut mut min_value = std::i32::MAX;\n    let mut min_value_index:\
    \ Option<usize> = None;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_value < i {\n                min_value = i;\n            \
    \    min_value_index = Some(i);\n            }\n        }\n    }\n    if min_value_index.is_none()\
    \ {\n        return vec![];\n    }\n    return vec![min_value_index.unwrap()];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmps2nkigmv.rs:30:13\n\
    \   |\n30 |     let mut mut min_value = std::i32::MAX;\n   |             ^^^ help:\
    \ remove the additional `mut`s\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2nkigmv.rs:34:28\n\
    \   |\n34 |             if min_value < i {\n   |                            ^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2nkigmv.rs:35:29\n\
    \   |\n30 |     let mut mut min_value = std::i32::MAX;\n   |                 \
    \            ------------- expected due to this value\n...\n35 |             \
    \    min_value = i;\n   |                             ^ expected `i32`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2nkigmv.rs:36:40\n\
    \   |\n36 |                 min_value_index = Some(i);\n   |                 \
    \                       ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps2nkigmv.rs:43:17\n   |\n43 |     return vec![min_value_index.unwrap()];\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n43 |     return vec![min_value_index.unwrap().try_into().unwrap()];\n\
    \   |                                         ++++++++++++++++++++\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min_val = i32::MAX;\n    let mut smallest_node_index\
    \ = -1;\n    let mut smallest_node = i32::MIN;\n    for mut val in arr.iter()\
    \ {\n        if val % 2 == 0 {\n            if val < smallest_node {\n       \
    \         smallest_node = val;\n                smallest_node_index = arr.len();\n\
    \            }\n        } else {\n            if val < min_val {\n           \
    \     min_val = val;\n            }\n        }\n    }\n    if min_val == i32::MAX\
    \ {\n        return vec![];\n    }\n    return vec![min_val, smallest_node_index];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaodyanxa.rs:35:22\n   |\n\
    35 |             if val < smallest_node {\n   |                      ^^^^^^^^^^^^^\
    \ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaodyanxa.rs:36:33\n\
    \   |\n32 |     let mut smallest_node = i32::MIN;\n   |                      \
    \       -------- expected due to this value\n...\n36 |                 smallest_node\
    \ = val;\n   |                                 ^^^ expected `i32`, found `&isize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpaodyanxa.rs:31:35\n\
    \   |\n31 |     let mut smallest_node_index = -1;\n   |                      \
    \             ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpaodyanxa.rs:40:22\n   |\n40 |\
    \             if val < min_val {\n   |                      ^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaodyanxa.rs:41:27\n\
    \   |\n30 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n41 |                 min_val = val;\n   | \
    \                          ^^^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaodyanxa.rs:48:17\n   |\n48 |     return vec![min_val,\
    \ smallest_node_index];\n   |                 ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n48 |     return vec![min_val.try_into().unwrap(), smallest_node_index];\n\
    \   |                        ++++++++++++++++++++\n\nerror: aborting due to 6\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = std::isize::MAX;\n\
    \    let mut smallest_index: usize = 0;\n    for i in arr.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v > 0) {\n        let v = i as usize;\n        if v > smallest_value {\n\
    \            smallest_value = v;\n            smallest_index = i as usize;\n \
    \       }\n    }\n\n    let mut result: Vec<isize> = vec![];\n    result.push(smallest_value);\n\
    \    result.push(smallest_index);\n\n    if result.iter().any(|&x| x < std::isize::MIN)\
    \ {\n        return vec![];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1jc71qui.rs:31:16\n   |\n\
    31 |         if v > smallest_value {\n   |                ^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |         if v > smallest_value.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1jc71qui.rs:32:30\n   |\n27 |     let mut smallest_value\
    \ = std::isize::MAX;\n   |                              --------------- expected\
    \ due to this value\n...\n32 |             smallest_value = v;\n   |         \
    \                     ^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1jc71qui.rs:39:17\n   |\n39 |     result.push(smallest_index);\n\
    \   |                 ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n39 |     result.push(smallest_index.try_into().unwrap());\n   | \
    \                              ++++++++++++++++++++\n\nerror[E0605]: non-primitive\
    \ cast: `(usize, isize)` as `usize`\n  --> /tmp/tmp1jc71qui.rs:30:17\n   |\n30\
    \ |         let v = i as usize;\n   |                 ^^^^^^^^^^ an `as` expression\
    \ can only be used to convert between primitive types or to coerce to a specific\
    \ trait object\n\nerror[E0605]: non-primitive cast: `(usize, isize)` as `usize`\n\
    \  --> /tmp/tmp1jc71qui.rs:33:30\n   |\n33 |             smallest_index = i as\
    \ usize;\n   |                              ^^^^^^^^^^ an `as` expression can\
    \ only be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0605.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    use std::cmp::Ordering;\n    let\
    \ mut arr = arr;\n    let mut smallest_value = -1;\n    let mut smallest_index\
    \ = 0;\n    while arr.len() > 0 {\n        if arr[0] % 2 == 0 {\n            smallest_value\
    \ = arr[0];\n            smallest_index = smallest_index as isize;\n        }\n\
    \        for &x in &arr {\n            if x < smallest_value {\n             \
    \   smallest_value = x;\n                smallest_index = x as isize;\n      \
    \      }\n        }\n        arr.iter().enumerate().for_each(|(index, value)|\
    \ {\n            if value < smallest_value {\n                smallest_value =\
    \ value;\n                smallest_index = index;\n            }\n        });\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmplutg7ypf.rs:27:9\n\
    \   |\n27 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplutg7ypf.rs:43:24\n   |\n43 |             if value < smallest_value\
    \ {\n   |                        ^^^^^^^^^^^^^^\n   |                        |\n\
    \   |                        expected `&isize`, found `isize`\n   |          \
    \              help: consider borrowing here: `&smallest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplutg7ypf.rs:44:34\n   |\n29 |     let mut smallest_value\
    \ = -1;\n   |                              -- expected due to this value\n...\n\
    44 |                 smallest_value = value;\n   |                           \
    \       ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n44 |                 smallest_value = *value;\n   |      \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplutg7ypf.rs:45:34\n\
    \   |\n30 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n45 |                 smallest_index = index;\n\
    \   |                                  ^^^^^ expected `isize`, found `usize`\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut minval = arr[0];\n    let mut min_index = 0;\n \
    \   for &mut node in  arr.iter_mut() {\n        if node.value % 2 == 0 {\n   \
    \         if minval < node.value {\n                minval = node.value;\n   \
    \             min_index = min_index + 1;\n            }\n        }\n    }\n  \
    \  if min_index == arr.len() {\n        return vec![];\n    }\n    let mut minval_clone\
    \ = minval;\n    let mut min_index_clone = min_index;\n    while minval == minval_clone\
    \ {\n        minval -= 2;\n        min_index -= 1;\n        if minval < minval_clone\
    \ {\n            minval_clone = minval;\n            min_index_clone = min_index;\n\
    \        }\n    }\n    let mut returnvec = vec![];\n    returnvec.push(minval);\n\
    \    returnvec.push(min_index_clone);\n    return returnvec;\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmploreqrnk.rs:33:17\n   |\n33 |         if node.value % 2 == 0 {\n\
    \   |                 ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmploreqrnk.rs:34:30\n   |\n34 |           \
    \  if minval < node.value {\n   |                              ^^^^^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmploreqrnk.rs:35:31\n\
    \   |\n35 |                 minval = node.value;\n   |                       \
    \        ^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmploreqrnk.rs:55:20\n\
    \   |\n55 |     returnvec.push(min_index_clone);\n   |                    ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n55 |     returnvec.push(min_index_clone.try_into().unwrap());\n\
    \   |                                   ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = HashSet::new();\n\
    \    let mut node_indexes = HashMap::new();\n    for i in arr.iter() {\n     \
    \   if even_values.contains(i) {\n            node_indexes.insert(i, node_indexes.entry(i).or_insert(0));\n\
    \        }\n        even_values.insert(i);\n    }\n    let mut smallest_value\
    \ = even_values.first();\n    let mut smallest_index_node_index;\n    for (i,\
    \ _) in node_indexes {\n        if i == smallest_value {\n            smallest_index_node_index\
    \ = i;\n            break;\n        }\n    }\n    vec![smallest_value, smallest_index_node_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp9yium7db.rs:27:27\n   |\n27 |     let mut even_values = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp9yium7db.rs:28:28\n\
    \   |\n28 |     let mut node_indexes = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut even = vec![];\n    let mut smallest = vec![];\n\
    \    for i in arr.iter().enumerate() {\n        if i[1].0 % 2 == 0 {\n       \
    \     even.push(i[1].0);\n        }\n        else {\n            let idx = i[0].0;\n\
    \            if even.len() == 0 {\n                smallest.push(i[1].0);\n  \
    \          }\n            else if (even.iter().min().unwrap() < (&even[even.len()\
    \ - 1]).unwrap()) {\n                smallest.push(i[1].0);\n            }\n \
    \           else {\n                smallest.push((&even[even.len() - 1]).unwrap());\n\
    \            }\n        }\n    }\n    smallest\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb763xa49.rs:41:21\n\
    \   |\n41 |             else if (even.iter().min().unwrap() < (&even[even.len()\
    \ - 1]).unwrap()) {\n   |                     ^                              \
    \                               ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n41 -             else if (even.iter().min().unwrap()\
    \ < (&even[even.len() - 1]).unwrap()) {\n41 +             else if even.iter().min().unwrap()\
    \ < (&even[even.len() - 1]).unwrap() {\n   | \n\nerror[E0608]: cannot index into\
    \ a value of type `(usize, &isize)`\n  --> /tmp/tmpb763xa49.rs:33:12\n   |\n33\
    \ |         if i[1].0 % 2 == 0 {\n   |            ^^^^ help: to access tuple elements,\
    \ use: `i.1`\n\nerror[E0608]: cannot index into a value of type `(usize, &isize)`\n\
    \  --> /tmp/tmpb763xa49.rs:34:23\n   |\n34 |             even.push(i[1].0);\n\
    \   |                       ^^^^ help: to access tuple elements, use: `i.1`\n\n\
    error[E0608]: cannot index into a value of type `(usize, &isize)`\n  --> /tmp/tmpb763xa49.rs:37:23\n\
    \   |\n37 |             let idx = i[0].0;\n   |                       ^^^^ help:\
    \ to access tuple elements, use: `i.0`\n\nerror[E0608]: cannot index into a value\
    \ of type `(usize, &isize)`\n  --> /tmp/tmpb763xa49.rs:39:31\n   |\n39 |     \
    \            smallest.push(i[1].0);\n   |                               ^^^^ help:\
    \ to access tuple elements, use: `i.1`\n\nerror[E0608]: cannot index into a value\
    \ of type `(usize, &isize)`\n  --> /tmp/tmpb763xa49.rs:42:31\n   |\n42 |     \
    \            smallest.push(i[1].0);\n   |                               ^^^^ help:\
    \ to access tuple elements, use: `i.1`\n\nerror: aborting due to 5 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut index: isize = 0;\n   \
    \ let mut value: isize = vec![0];\n    let mut min_value: isize = vec![0];\n \
    \   let mut even_values = vec![0];\n    for i in arr.iter() {\n        let mut\
    \ even_value = 0;\n        if i / 2 != 0 {\n            even_value = i / 2;\n\
    \        }\n        even_values.push(even_value);\n        for j in 0..index {\n\
    \            if even_values[j] <= even {\n                even_values[j] = even_value;\n\
    \            }\n        }\n        for j in 0..index {\n            if even_values[j]\
    \ == even {\n                if min_value[j] < i {\n                    min_value[j]\
    \ = i;\n                }\n            }\n        }\n        if min_value[index]\
    \ < i {\n            min_value[index] = i;\n        }\n        index++;\n    }\n\
    \    min_value.sort();\n    for i in 0..index {\n        if i == index - 1 {\n\
    \            even_values.pop();\n            even_values.sort();\n           \
    \ value = even_values[i];\n        } else {\n            if min_value[index] >\
    \ min_value[i + 1] {\n                value = min_value[i];\n            } else\
    \ {\n                value = min_value[i + 1];\n            }\n        }\n   \
    \     even_values.pop();\n        even_values.sort();\n        if even_values.len()\
    \ == 0 {\n            break;\n        }\n    }\n    vec![value, index].into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp3fpcotnq.rs:52:14\n\
    \   |\n52 |         index++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n52 |         { let tmp = index; index +=\
    \ 1; tmp };\n   |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n52 -         index++;\n\
    52 +         index += 1;\n   | \n\nerror[E0425]: cannot find value `even` in this\
    \ scope\n  --> /tmp/tmp3fpcotnq.rs:38:34\n   |\n38 |             if even_values[j]\
    \ <= even {\n   |                                  ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmp3fpcotnq.rs:43:34\n\
    \   |\n43 |             if even_values[j] == even {\n   |                    \
    \              ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3fpcotnq.rs:28:28\n   |\n28 |     let mut value: isize = vec![0];\n\
    \   |                    -----   ^^^^^^^ expected `isize`, found struct `Vec`\n\
    \   |                    |\n   |                    expected due to this\n   |\n\
    \   = note: expected type `isize`\n            found struct `Vec<{integer}>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3fpcotnq.rs:29:32\n\
    \   |\n29 |     let mut min_value: isize = vec![0];\n   |                    \
    \    -----   ^^^^^^^ expected `isize`, found struct `Vec`\n   |              \
    \          |\n   |                        expected due to this\n   |\n   = note:\
    \ expected type `isize`\n            found struct `Vec<{integer}>`\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp3fpcotnq.rs:38:16\n   |\n38 |             if even_values[j] <=\
    \ even {\n   |                ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usi"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = 0;\n    for i in 1..arr.len() {\n        if arr[i] % 2 == 0 && arr[i] < min_even_value\
    \ {\n            min_even_value = arr[i];\n            min_even_index = i;\n \
    \       }\n    }\n    vec![min_even_index, min_even_value]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_h3qxc2k.rs:38:10\n   |\n\
    38 |     vec![min_even_index, min_even_value]\n   |          ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n38 |     vec![min_even_index.try_into().unwrap(),\
    \ min_even_value]\n   |                        ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut max_value = -std::isize::MAX;\n\
    \    for i in 0..arr.len() {\n        if arr[i] < min_value {\n            min_value\
    \ = arr[i];\n            min_idx = i;\n        }\n        if arr[i] > max_value\
    \ {\n            max_value = arr[i];\n        }\n    }\n    if min_value == max_value\
    \ {\n        return vec![];\n    }\n    for i in 0..arr.len() {\n        if i\
    \ == min_idx {\n            result.push(min_value);\n        }\n        if i !=\
    \ min_idx {\n            result.push(arr[i]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 3]`,\n right: `[2, 1]`', /tmp/tmpxqy38_b6.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut index = 0;\n    let mut\
    \ smallest_value = arr[0];\n    let mut smallest_even_value = false;\n    for\
    \ node in arr.iter() {\n        if smallest_even_value\n            && smallest_value\
    \ > node\n            && smallest_value == node\n            && (index == 0 ||\
    \ smallest_value == arr[index - 1]) {\n                smallest_even_value = false;\n\
    \                smallest_value = node;\n                index = index;\n    \
    \        } else {\n                index += 1;\n                smallest_even_value\
    \ = (node % 2) == 0;\n                smallest_value = node;\n            }\n\
    \    }\n    if smallest_even_value\n        && smallest_value == arr[0]\n    \
    \    && (index == 0 || smallest_value == arr[index - 1]) {\n        smallest_even_value\
    \ = false;\n        smallest_value = arr[0];\n        index = index;\n    }\n\
    \    if index == 0 {\n        index = 1;\n    }\n    vec![smallest_value, index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jpw9cjc.rs:32:33\n   |\n\
    32 |             && smallest_value > node\n   |                              \
    \   ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |             && smallest_value > *node\n   |         \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8jpw9cjc.rs:33:34\n\
    \   |\n33 |             && smallest_value == node\n   |                      \
    \            ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |             && smallest_value == *node\n   |        \
    \                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8jpw9cjc.rs:36:34\n\
    \   |\n28 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n36 |                 smallest_value\
    \ = node;\n   |                                  ^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |        \
    \         smallest_value = *node;\n   |                                  +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8jpw9cjc.rs:41:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n41 |                 smallest_value = node;\n\
    \   |                                  ^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n41 |                 smallest_value\
    \ = *node;\n   |                                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8jpw9cjc.rs:54:26\n   |\n54 |     vec![smallest_value,\
    \ index]\n   |                          ^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n54 |     vec![smallest_value, index.try_into().unwrap()]\n\
    \   |                               ++++++++++++++++++++\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().filter(|x| *x % 2 ==\
    \ 0).collect::<Vec<_>>().min().unwrap_or(arr.len())\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpvjfhqdfn.rs:27:60\n    |\n27  |     arr.iter().filter(|x| *x %\
    \ 2 == 0).collect::<Vec<_>>().min().unwrap_or(arr.len())\n    |              \
    \                                              ^^^- supplied 0 arguments\n   \
    \ |                                                            |\n    |      \
    \                                                      expected 1 argument\n \
    \   |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `unwrap_or` found for struct `Vec<&isize>` in the current scope\n  --> /tmp/tmpvjfhqdfn.rs:27:66\n\
    \   |\n27 |     arr.iter().filter(|x| *x % 2 == 0).collect::<Vec<_>>().min().unwrap_or(arr.len())\n\
    \   |                                                                  ^^^^^^^^^\
    \ method not found in `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = 0;\n    let mut smallest_index = arr[0];\n\
    \    let mut index = 0;\n    let mut i = 0;\n    while i < arr.len() {\n     \
    \   let mut smallest_even_value_iter = smallest_even_value.iter().cloned();\n\
    \        let mut smallest_even_index_iter = smallest_even_index.iter().cloned();\n\
    \        let mut smallest_index_iter = smallest_index.iter().cloned();\n     \
    \   let mut index = smallest_index.clone();\n        let mut i = smallest_index.clone();\n\
    \        while i < arr.len() {\n            if arr[i] % 2 == 0 {\n           \
    \     if smallest_even_index_iter.any(|&v| *v < arr[i]) {\n                  \
    \  smallest_even_index_iter.push(*v);\n                    smallest_index_iter.push(i);\n\
    \                }\n                if smallest_even_value_iter.any(|&v| *v <\
    \ arr[i]) {\n                    smallest_even_value_iter.push(*v);\n        \
    \            smallest_index_iter.push(i);\n                }\n            }\n\
    \            i += 1;\n        }\n        if smallest_even_value_iter.any(|&v|\
    \ *v == smallest_even_value) {\n            smallest_even_index = smallest_index_iter[0];\n\
    \        }\n        if smallest_even_index_iter.any(|&v| *v == smallest_even_index)\
    \ {\n            smallest_even_index = smallest_index_iter[0];\n        }\n  \
    \      if smallest_even_value_iter.any(|&v| *v == smallest_even_value) {\n   \
    \         smallest_even_index = smallest_index_iter[0];\n        }\n        if\
    \ smallest_even_index_iter.any(|&v| *v == smallest_even_index) {\n           \
    \ smallest_even_index = smallest_index_iter[0];\n        }\n        if smallest_even_index_iter.any(|&v|\
    \ *v == smallest_even_index) {\n            smallest_even_index = smallest_index_iter[0];\n\
    \        }\n        if smallest_even_index_iter.any(|&v| *v == smallest_even_index)\
    \ {\n            smallest_even_index = smallest_index_iter[0];\n        }\n  \
    \      if smallest_even_index_iter.any(|&v| *v == smallest_even_index) {\n   \
    \         smallest_even_index = smallest_index_iter[0];\n        }\n        if\
    \ smallest_even_index_iter.any(|&v| *v == smallest_even_index) {\n           \
    \ smallest_even_index = smallest_index_iter[0];\n        }\n        if smallest_even_index_iter.any(|&v|\
    \ *v == smallest_even_index) {\n            smallest_even_index = smallest_index_iter[0];\n\
    \        }\n        if \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppem3h9tu.rs:91:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n32 |     while i < arr.len()\
    \ {\n   |                         - this delimiter might not be properly closed...\n\
    ...\n79 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    91 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmppem3h9tu.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `v`\
    \ in this scope\n  --> /tmp/tmppem3h9tu.rs:41:52\n   |\n41 |                 \
    \    smallest_even_index_iter.push(*v);\n   |                                \
    \                    ^ help: a local variable with a similar name exists: `i`\n\
    \nerror[E0425]: cannot find value `v` in this scope\n  --> /tmp/tmppem3h9tu.rs:45:52\n\
    \   |\n45 |                     smallest_even_value_iter.push(*v);\n   |     \
    \                                               ^ help: a local variable with\
    \ a similar name exists: `i`\n\nerror[E0599]: no method named `iter` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmppem3h9tu.rs:33:64\n   |\n33\
    \ |         let mut smallest_even_value_iter = smallest_even_value.iter().cloned();\n\
    \   |                                                                ^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `iter` found for type\
    \ `{integer}` in the current scope\n  --> /tmp/tmppem3h9tu.rs:34:64\n   |\n34\
    \ |         let mut smallest_even_index_iter = smallest_even_index.iter().cloned();\n\
    \   |                                                                ^^^^ method\
    \ not found in `{integer}`\n\nerror[E0599]: no method named `iter` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmppem3h9tu.rs:35:54\n   |\n35 |  \
    \       let mut smallest_index_iter = smallest_index.iter().cloned();\n   |  \
    \                                                    ^^^^ method not found in\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppem3h9tu.rs:38:19\n\
    \   |\n38 |         while i < arr.len() {\n   |   "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest = isize::MAX;\n\
    \    let mut smallest_index = isize::MAX;\n    for i in arr.iter() {\n       \
    \ if i.is_zero() {\n            continue;\n        }\n        if smallest.is_max(&i)\
    \ {\n            smallest = i;\n            smallest_index = i;\n        }\n \
    \   }\n    if smallest != isize::MAX {\n        let mut indexes = vec![];\n  \
    \      for i in arr.iter().rev() {\n            if i.is_zero() {\n           \
    \     continue;\n            }\n            if smallest.is_max(&i) {\n       \
    \         smallest = i;\n                smallest_index = i;\n            }\n\
    \            indexes.append(i);\n        }\n        indexes\n    } else {\n  \
    \      vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpi1ybosmo.rs:30:14\n   |\n30 |         if i.is_zero()\
    \ {\n   |              ^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `is_max` found for type `isize` in the current scope\n  --> /tmp/tmpi1ybosmo.rs:33:21\n\
    \   |\n33 |         if smallest.is_max(&i) {\n   |                     ^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi1ybosmo.rs:34:24\n\
    \   |\n27 |     let mut smallest = isize::MAX;\n   |                        ----------\
    \ expected due to this value\n...\n34 |             smallest = i;\n   |      \
    \                  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |             smallest = *i;\n   |                    \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi1ybosmo.rs:35:30\n  \
    \ |\n28 |     let mut smallest_index = isize::MAX;\n   |                     \
    \         ---------- expected due to this value\n...\n35 |             smallest_index\
    \ = i;\n   |                              ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |             smallest_index\
    \ = *i;\n   |                              +\n\nerror[E0599]: no method named\
    \ `is_zero` found for reference `&isize` in the current scope\n  --> /tmp/tmpi1ybosmo.rs:41:18\n\
    \   |\n41 |             if i.is_zero() {\n   |                  ^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `is_max` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpi1ybosmo.rs:44:25\n   |\n44 |  \
    \           if smallest.is_max(&i) {\n   |                         ^^^^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi1ybosmo.rs:45:28\n\
    \   |\n27 |     let mut smallest = isize::MAX;\n   |                        ----------\
    \ expected due to this value\n...\n45 |                 smallest = i;\n   |  \
    \                          ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n45 |                 smallest = "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = arr[0];\n    let\
    \ mut even = 1;\n    let mut indx = 0;\n\n    for node in &arr {\n        if node\
    \ % 2 == 0 {\n            even *= node;\n            indx += 1;\n        }\n \
    \       else {\n            if even == min {\n                min = node;\n  \
    \              even = 1;\n                indx += 1;\n            }\n        \
    \    else if (even > min) {\n                min = even;\n                even\
    \ = 1;\n                indx += 1;\n            }\n        }\n    }\n    vec![(min,\
    \ indx)]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpirizwejq.rs:42:21\n\
    \   |\n42 |             else if (even > min) {\n   |                     ^   \
    \       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n42 -             else if (even > min) {\n42 +     \
    \        else if even > min {\n   | \n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpirizwejq.rs:38:23\n   |\n27 |     let mut min = arr[0];\n   |      \
    \             ------ expected due to this value\n...\n38 |                 min\
    \ = node;\n   |                       ^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |                 min\
    \ = *node;\n   |                       +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpirizwejq.rs:49:10\n   |\n49 |     vec![(min, indx)]\n   |      \
    \    ^^^^^^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected type\
    \ `isize`\n             found tuple `(isize, {integer})`\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = arr[0];\n    let\
    \ mut index = -1;\n    for i in arr {\n        if i % 2 == 0 {\n            min\
    \ = i;\n            index = i;\n        }\n    }\n    if index == -1 {\n     \
    \   return vec![];\n    }\n    return vec![index];\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[2, 1]`', /tmp/tmpoyyhr6v_.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // Your code goes here\n    use\
    \ std::cmp::Ordering;\n    let mut smalest_value: isize = 0;\n    let mut smallest_index:\
    \ usize = 0;\n    for value in arr.iter() {\n        if smallest_index == 0 ||\
    \ value > arr[smallest_index] {\n            smalest_value = value;\n        \
    \    smallest_index = arr.iter().position(|&x| x > value).unwrap();\n        }\n\
    \    }\n    if smallest_index == 0 || arr.iter().position(|&x| x > arr[smallest_index]).is_none()\
    \ {\n        return vec![];\n    }\n    vec![smalest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmptc5pid7n.rs:28:9\n\
    \   |\n28 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptc5pid7n.rs:32:43\n   |\n32 |         if smallest_index\
    \ == 0 || value > arr[smallest_index] {\n   |                                \
    \           ^^^^^^^^^^^^^^^^^^^\n   |                                        \
    \   |\n   |                                           expected `&isize`, found\
    \ `isize`\n   |                                           help: consider borrowing\
    \ here: `&arr[smallest_index]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptc5pid7n.rs:33:29\n\
    \   |\n29 |     let mut smalest_value: isize = 0;\n   |                      \
    \      ----- expected due to this type\n...\n33 |             smalest_value =\
    \ value;\n   |                             ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |             smalest_value\
    \ = *value;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptc5pid7n.rs:34:59\n   |\n34 |             smallest_index = arr.iter().position(|&x|\
    \ x > value).unwrap();\n   |                                                 \
    \          ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |             smallest_index = arr.iter().position(|&x|\
    \ x > *value).unwrap();\n   |                                                \
    \           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptc5pid7n.rs:40:25\n\
    \   |\n40 |     vec![smalest_value, smallest_index]\n   |                    \
    \     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    40 |     vec![smalest_value, smallest_index.try_into().unwrap()]\n   |       \
    \                                ++++++++++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E030"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n    let mut smallest_value = 0;\n    let mut smallest_index =\
    \ 0;\n    let mut chosen_node = None;\n    let mut index = 0;\n    while index\
    \ < sorted_arr.len() {\n        if smallest_value == 0 && !(sorted_arr[index]\
    \ & 1u) {\n            chosen_node = Some(sorted_arr[index]);\n            smallest_value\
    \ = sorted_arr[index];\n            smallest_index = index;\n        } else {\n\
    \            smallest_value = sorted_arr[index];\n            if smallest_value\
    \ != 0 {\n                smallest_index = index;\n            }\n        }\n\
    \        index += 1;\n    }\n    if smallest_value != 0 {\n        chosen_node\
    \ = Some(smallest_value);\n    }\n    chosen_node\n        .clone()\n        .into_iter()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmpa2qxdc1u.rs:33:57\n\
    \   |\n33 |         if smallest_value == 0 && !(sorted_arr[index] & 1u) {\n  \
    \ |                                                         ^^ invalid suffix\
    \ `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror[E0599]: no method named `len` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmpa2qxdc1u.rs:32:30\n   |\n32 |     while\
    \ index < sorted_arr.len() {\n   |                              ^^^ method not\
    \ found in `()`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->\
    \ /tmp/tmpa2qxdc1u.rs:33:37\n   |\n33 |         if smallest_value == 0 && !(sorted_arr[index]\
    \ & 1u) {\n   |                                     ^^^^^^^^^^^^^^^^^\n   |\n\
    \   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\
    \nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpa2qxdc1u.rs:34:32\n\
    \   |\n34 |             chosen_node = Some(sorted_arr[index]);\n   |         \
    \                       ^^^^^^^^^^^^^^^^^\n   |\n   = help: to access tuple elements,\
    \ use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into\
    \ a value of type `()`\n  --> /tmp/tmpa2qxdc1u.rs:35:30\n   |\n35 |          \
    \   smallest_value = sorted_arr[index];\n   |                              ^^^^^^^^^^^^^^^^^\n\
    \   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\
    \nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpa2qxdc1u.rs:38:30\n\
    \   |\n38 |             smallest_value = sorted_arr[index];\n   |            \
    \                  ^^^^^^^^^^^^^^^^^\n   |\n   = help: to access tuple elements,\
    \ use tuple indexing syntax (e.g., `tuple.0`)\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter()\n        .cloned()\n\
    \        .map(|v| {\n            match {\n                v & 1 == 0 => v,\n \
    \               v & 1 == 1 => (v as isize) as usize - 1,\n                _ =>\
    \ panic!(\"Unsupported node {:?}\", v),\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpnj4xfcf1.rs:31:28\n   |\n31 |                 v & 1 == 0 => v,\n\
    \   |                            ^^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror: expected one of `.`, `?`, `{`, or an operator, found `}`\n\
    \  --> /tmp/tmpnj4xfcf1.rs:35:9\n   |\n30 |             match {\n   |        \
    \     ----- while parsing this `match` expression\n...\n34 |             }\n \
    \  |              - expected one of `.`, `?`, `{`, or an operator\n35 |      \
    \   })\n   |         ^ unexpected token\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660010833
- exit_code: -1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n\n    let mut min_index = 1;\n    let mut min_value = arr[0];\n\
    \    let mut smalest_value = 0;\n    for &x in arr.iter().rev() {\n        if\
    \ x % 2 == 0 {\n            if min_value < x {\n                min_value = x;\n\
    \                min_index = x;\n            }\n        } else {\n           \
    \ if min_value % 2 == 0 && min_value < x {\n                min_value = x;\n \
    \               min_index = x;\n            }\n        }\n    }\n\n    let mut\
    \ result = vec![min_value, min_index];\n    while result.len() > 1 {\n       \
    \ if result[1] % 2 == 0 {\n            if result[0] % 2 == 0 && result[1] < result[0]\
    \ {\n                result[1] = result[0];\n            }\n            result[0]\
    \ = result[1];\n        } else {\n            if result[0] % 2 == 0 && result[1]\
    \ < result[0] {\n                result[1] = result[0];\n            }\n     \
    \       result[0] = result[1];\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010838
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_index: isize = 0;\n    for value in arr {\n        if\
    \ value.parity().is_some() {\n            if smalest_value.is_some() {\n     \
    \           if smalest_value < value {\n                    smalest_value = value;\n\
    \                    smalest_index = 1;\n                } else {\n          \
    \          smalest_index += 1;\n                }\n            } else {\n    \
    \            smalest_value = value;\n                smalest_index = 1;\n    \
    \        }\n        }\n    }\n    vec![smalest_value, smalest_index]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `parity` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpp1yis8x2.rs:30:18\n   |\n30 |         if value.parity().is_some()\
    \ {\n   |                  ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `is_some` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpp1yis8x2.rs:31:30\n   |\n31 |             if smalest_value.is_some()\
    \ {\n   |                              ^^^^^^^ method not found in `isize`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n\
    \    sorted_arr.sort_unstable();\n    let mut smalest_value = -1;\n    let mut\
    \ smalest_index = -1;\n    for value in sorted_arr.iter() {\n        if value\
    \ % 2 == 0 {\n            if smalest_value == -1 || value < smalest_value {\n\
    \                smalest_value = value;\n                smalest_index = sorted_arr.iter().position(|&x|\
    \ x < value);\n            }\n        }\n    }\n    if smalest_value == -1 {\n\
    \        return vec![];\n    }\n    if smalest_index == -1 {\n        return vec![0];\n\
    \    }\n    return vec![smalest_value, smalest_index];\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpckajrguj.rs:33:47\n   |\n\
    33 |             if smalest_value == -1 || value < smalest_value {\n   |     \
    \                                          ^^^^^^^^^^^^^\n   |               \
    \                                |\n   |                                     \
    \          expected `&isize`, found integer\n   |                            \
    \                   help: consider borrowing here: `&smalest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpckajrguj.rs:34:33\n   |\n29 |     let mut smalest_value\
    \ = -1;\n   |                             -- expected due to this value\n...\n\
    34 |                 smalest_value = value;\n   |                            \
    \     ^^^^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 smalest_value = *value;\n   |       \
    \                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpckajrguj.rs:35:69\n\
    \   |\n35 |                 smalest_index = sorted_arr.iter().position(|&x| x\
    \ < value);\n   |                                                            \
    \         ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 smalest_index = sorted_arr.iter().position(|&x|\
    \ x < *value);\n   |                                                         \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpckajrguj.rs:35:33\n\
    \   |\n30 |     let mut smalest_index = -1;\n   |                            \
    \ -- expected due to this value\n...\n35 |                 smalest_index = sorted_arr.iter().position(|&x|\
    \ x < value);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    // let mut smalest_value = *arr.iter().min();\n\
    \    let mut smalest_value = arr[0];\n    let mut smalest_index = -1;\n    for\
    \ i in arr.iter().rev() {\n        if *i % 2 == 0 {\n            smalest_value\
    \ = *i;\n            smalest_index = i;\n        }\n    }\n    let mut index =\
    \ arr.iter().position(|x| x == smalest_value);\n    if index == arr.len() {\n\
    \        index = smalest_index;\n    } else {\n        index = *index;\n    }\n\
    \    let mut vec = vec![smalest_value, index];\n    vec.sort_unstable();\n   \
    \ vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsq307k75.rs:33:29\n   |\n\
    29 |     let mut smalest_index = -1;\n   |                             -- expected\
    \ due to this value\n...\n33 |             smalest_index = i;\n   |          \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |             smalest_index = *i;\n   |               \
    \              +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpsq307k75.rs:36:47\n\
    \   |\n36 |     let mut index = arr.iter().position(|x| x == smalest_value);\n\
    \   |                                               ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsq307k75.rs:37:17\n\
    \   |\n37 |     if index == arr.len() {\n   |                 ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n37 |     if index == Some(arr.len()) {\n   |                 +++++    \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsq307k75.rs:38:17\n \
    \  |\n36 |     let mut index = arr.iter().position(|x| x == smalest_value);\n\
    \   |                     ------------------------------------------- expected\
    \ due to this value\n37 |     if index == arr.len() {\n38 |         index = smalest_index;\n\
    \   |                 ^^^^^^^^^^^^^ expected enum `Option`, found integer\n  \
    \ |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n38 |         index = Some(smalest_index);\n\
    \   |                 +++++             +\n\nerror[E0614]: type `Option<usize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpsq307k75.rs:40:17\n   |\n40 |        \
    \ index = *ind"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut index_min = arr[0];\n \
    \   let mut smalest_value = arr[0];\n    for i in 1..arr.len() {\n        let\
    \ mut index_i_min = i;\n        let mut smalest_value = arr[i];\n        let mut\
    \ current_value = arr[i];\n        for j in (i + 1)..arr.len() {\n           \
    \ if current_value < smalest_value {\n                index_i_min = j;\n     \
    \           smalest_value = arr[j];\n                let mut current_value = arr[j];\n\
    \            }\n        }\n        if index_i_min < index_min {\n            index_min\
    \ = index_i_min;\n            smalest_value = current_value;\n        }\n    }\n\
    \    vec![smalest_value, index_min]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpep6su56z.rs:40:26\n   |\n\
    40 |         if index_i_min < index_min {\n   |                          ^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n40 |         if\
    \ index_i_min < index_min.try_into().unwrap() {\n   |                        \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpep6su56z.rs:41:25\n\
    \   |\n27 |     let mut index_min = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n41 |             index_min = index_i_min;\n\
    \   |                         ^^^^^^^^^^^ expected `isize`, found `usize`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = 0;\n \
    \   let mut smallest_index = 0;\n    let mut min_val = arr.iter().min_by_key(|x|\
    \ {\n        if x % 2 != 0 {\n            smallest_value = x;\n            smallest_index\
    \ = x;\n            smallest_value;\n        } else {\n            smallest_value;\n\
    \        }\n    });\n    let mut min_val_index = min_val.index();\n    if min_val_index\
    \ == 0 {\n        return Vec::new();\n    }\n    let mut min_val_index = min_val_index\
    \ - 1;\n    let mut arr = arr.iter().skip(min_val_index);\n    let mut even_values\
    \ = Vec::new();\n    for e in arr {\n        if e % 2 != 0 {\n            even_values.push(e);\n\
    \        } else {\n            break;\n        }\n    }\n    let mut min_val_vec_index\
    \ = 0;\n    even_values.iter().cloned().cloned().for_each(|x|\n        {\n   \
    \         if x <= min_val {\n                break;\n            }\n         \
    \   min_val_vec_index += 1;\n        }\n    );\n    min_val_index\n        .checked_sub(min_val_vec_index)\n\
    \        .expect(\"min_val_index should be equal to min_val_vec_index\")\n   \
    \     .expect(\"min_val_index should be greater or equal to min_val_vec_index\"\
    )\n        .expect(\"min_val_index should be less or equal to min_val_vec_index\"\
    )\n        .ok()\n        .ok();\n    even_values.iter().cloned().cloned().for_each(|x|\n\
    \        {\n            if x <= min_val {\n                break;\n          \
    \  }\n            min_val_vec_index += 1;\n        }\n    );\n    min_val_index\n\
    \        .checked_sub(min_val_vec_index)\n        .expect(\"min_val_index should\
    \ be equal to min_val_vec_index\")\n        .expect(\"min_val_index should be\
    \ greater or equal to min_val_vec_index\")\n        .expect(\"min_val_index should\
    \ be less or equal to min_val_vec_index\")\n        .ok()\n        .ok();\n  \
    \  even_values\n        .iter()\n        .skip(min_val_vec_index)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0267]: `break` inside of a closure\n  --> /tmp/tmptw_27hf5.rs:56:17\n\
    \   |\n53 |     even_values.iter().cloned().cloned().for_each(|x|\n   |      \
    \                                             --- enclosing closure\n...\n56 |\
    \                 break;\n   |                 ^^^^^ cannot `break` inside of\
    \ a closure\n\nerror[E0267]: `break` inside of a closure\n  --> /tmp/tmptw_27hf5.rs:71:17\n\
    \   |\n68 |     even_values.iter().cloned().cloned().for_each(|x|\n   |      \
    \                                             --- enclosing closure\n...\n71 |\
    \                 break;\n   |                 ^^^^^ cannot `break` inside of\
    \ a closure\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmptw_27hf5.rs:30:14\n\
    \   |\n30 |         if x % 2 != 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `x`\n   |\n30 |         if *x % 2 != 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptw_27hf5.rs:31:30\n   |\n\
    27 |     let mut smallest_value = 0;\n   |                              - expected\
    \ due to this value\n...\n31 |             smallest_value = x;\n   |         \
    \                     ^ expected integer, found `&&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |             smallest_value = **x;\n   |\
    \                              ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptw_27hf5.rs:32:30\n\
    \   |\n28 |     let mut smallest_index = 0;\n   |                            \
    \  - expected due to this value\n...\n32 |             smallest_index = x;\n \
    \  |                              ^ expected integer, found `&&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n32 |             smallest_index\
    \ = **x;\n   |                              ++\n\nerror[E0599]: no method named\
    \ `index` found for enum `Option` in the current scope\n  --> /tmp/tmptw_27hf5.rs:38:37\n\
    \   |\n38 |     let mut min_val_index = min_val.index();\n   |               \
    \                      ^^^^^ method not found in `Option<&isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptw_27hf5."
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_idx: usize = 0;\n    let mut max_idx = 0;\n    for ele\
    \ in arr.iter() {\n        if ele % 2 == 0 {\n            if ele < smalest_value\
    \ {\n                smalest_value = ele;\n                smalest_idx = max_idx;\n\
    \            }\n            max_idx = max_idx + 1;\n        }\n    }\n\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    if max_idx > 0 {\n        let mut\
    \ idx = max_idx;\n        while idx < arr.len() {\n            if arr[idx] % 2\
    \ == 0 {\n                result.push(arr[idx]);\n                idx = idx +\
    \ 1;\n            } else {\n                idx = idx + 1;\n            }\n  \
    \      }\n    } else {\n        result = vec![];\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyyg7rnbz.rs:32:22\n   |\n\
    32 |             if ele < smalest_value {\n   |                      ^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&smalest_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyyg7rnbz.rs:33:33\n   |\n27 |\
    \     let mut smalest_value: isize = 0;\n   |                            -----\
    \ expected due to this type\n...\n33 |                 smalest_value = ele;\n\
    \   |                                 ^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n33 |                 smalest_value\
    \ = *ele;\n   |                                 +\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    sorted_arr.sort_unstable_by_key(|x| {\n        let mut tmp = x;\n       \
    \ while tmp != 0 {\n            if tmp % 2 == 0 {\n                return tmp;\n\
    \            }\n            tmp = tmp / 2;\n        }\n    });\n    let mut smalest_value\
    \ = 0;\n    let mut smallest_index = 0;\n    for val in sorted_arr {\n       \
    \ let tmp = val << 1;\n        if tmp > smalest_value {\n            smalest_value\
    \ = val;\n            smallest_index = sorted_arr.iter().filter(|&v| v == tmp).count();\n\
    \        }\n    }\n    let mut out: Vec<isize> = vec![];\n    let mut smallest_idx\
    \ = smallest_index;\n    while smallest_idx < arr.len() {\n        out.push(arr[smallest_idx]);\n\
    \        smallest_idx += smallest_index;\n    }\n    out\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpyyw3ljsm.rs:30:19\n\
    \   |\n30 |         while tmp != 0 {\n   |                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyyw3ljsm.rs:34:19\n   |\n29 |         let mut tmp = x;\n   |       \
    \                - expected due to this value\n...\n34 |             tmp = tmp\
    \ / 2;\n   |                   ^^^^^^^\n   |                   |\n   |       \
    \            expected `&isize`, found `isize`\n   |                   help: consider\
    \ borrowing here: `&(tmp / 2)`\n   |\nnote: return type inferred to be `&isize`\
    \ here\n  --> /tmp/tmpyyw3ljsm.rs:32:24\n   |\n32 |                 return tmp;\n\
    \   |                        ^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyyw3ljsm.rs:30:9\n\
    \   |\n30 | /         while tmp != 0 {\n31 | |             if tmp % 2 == 0 {\n\
    32 | |                 return tmp;\n33 | |             }\n34 | |             tmp\
    \ = tmp / 2;\n35 | |         }\n   | |_________^ expected `&isize`, found `()`\n\
    \   |\nnote: return type inferred to be `&isize` here\n  --> /tmp/tmpyyw3ljsm.rs:32:24\n\
    \   |\n32 |                 return tmp;\n   |                        ^^^\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpyyw3ljsm.rs:43:62\n   |\n\
    43 |             smallest_index = sorted_arr.iter().filter(|&v| v == tmp).count();\n\
    \   |                                                              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n        "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr: [isize; 2]\
    \ = [0, 0];\n    let mut smallest_even_val = vec![0i32; arr.len()];\n    let mut\
    \ smallest_even_value = vec![0i32; arr.len()];\n    let mut smallest_idx = vec![0i32;\
    \ arr.len()];\n    for i in 0..arr.len() {\n        if i % 2 == 0 {\n        \
    \    sorted_arr[0] = (*sorted_arr[0]).wrapping_add(arr[i]);\n            smallest_even_val[i]\
    \ = (*smallest_even_val[i]).wrapping_add(arr[i]);\n            smallest_even_value[i]\
    \ = (*smallest_even_value[i]).wrapping_add(arr[i]);\n            smallest_idx[i]\
    \ = (*smallest_idx[i]).wrapping_add(arr[i]);\n        }\n    }\n    if smallest_even_val\
    \ == sorted_arr {\n        return smallest_even_value;\n    }\n    if smallest_even_val\
    \ < sorted_arr {\n        return smallest_idx;\n    }\n    if smallest_even_value[0]\
    \ < smallest_even_val[1] {\n        return smallest_even_value;\n    }\n    return\
    \ smallest_idx;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpjtaj1bue.rs:33:29\n\
    \   |\n33 |             sorted_arr[0] = (*sorted_arr[0]).wrapping_add(arr[i]);\n\
    \   |                             ^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `i32`\
    \ cannot be dereferenced\n  --> /tmp/tmpjtaj1bue.rs:34:36\n   |\n34 |        \
    \     smallest_even_val[i] = (*smallest_even_val[i]).wrapping_add(arr[i]);\n \
    \  |                                    ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `i32` cannot be dereferenced\n  --> /tmp/tmpjtaj1bue.rs:35:38\n   |\n35\
    \ |             smallest_even_value[i] = (*smallest_even_value[i]).wrapping_add(arr[i]);\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `i32` cannot be dereferenced\n  --> /tmp/tmpjtaj1bue.rs:36:31\n   |\n36\
    \ |             smallest_idx[i] = (*smallest_idx[i]).wrapping_add(arr[i]);\n \
    \  |                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjtaj1bue.rs:40:16\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n40 |         return smallest_even_value;\n   |\
    \                ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<i32>`\n\n\
    error[E0277]: can't compare `i32` with `isize`\n  --> /tmp/tmpjtaj1bue.rs:39:26\n\
    \   |\n39 |     if smallest_even_val == sorted_arr {\n   |                   \
    \       ^^ no implementation for `i32 == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `i32`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<[isize; 2]>` for `Vec<i32>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjtaj1bue.rs:42:28\n   |\n42 |     if smallest_even_val\
    \ < sorted_arr {\n   |           "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() { return vec![];\
    \ }\n    let mut min_even = 0;\n    let mut min_idx = 0;\n    let mut min_val\
    \ = arr[0];\n    for i in arr.iter_mut() {\n        if i%2 == 0 {\n          \
    \  *i -= min_even;\n            if *i <= min_val {\n                min_val =\
    \ *i;\n                min_even = 1;\n            }\n        } else {\n      \
    \      i += 1;\n        }\n        *i %= min_even;\n        if i == min_idx {\n\
    \            min_even = 0;\n            min_idx = 0;\n        } else {\n     \
    \       min_even = 1;\n            min_idx = i;\n        }\n    }\n    let mut\
    \ vec = vec![min_val];\n    vec.push(min_idx);\n    vec\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmper4v80zd.rs:32:13\n\
    \   |\n32 |         if i%2 == 0 {\n   |            -^- {integer}\n   |       \
    \     |\n   |            &mut isize\n   |\nhelp: `%` can be used on `isize`, you\
    \ can dereference `i`\n   |\n32 |         if *i%2 == 0 {\n   |            +\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ isize`\n  --> /tmp/tmper4v80zd.rs:39:13\n   |\n39 |             i += 1;\n  \
    \ |             -^^^^^\n   |             |\n   |             cannot use `+=` on\
    \ type `&mut isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference\
    \ `i`\n   |\n39 |             *i += 1;\n   |             +\n\nerror[E0277]: can't\
    \ compare `&mut isize` with `{integer}`\n  --> /tmp/tmper4v80zd.rs:42:14\n   |\n\
    42 |         if i == min_idx {\n   |              ^^ no implementation for `&mut\
    \ isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not\
    \ implemented for `&mut isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmper4v80zd.rs:47:23\n   |\n29 |     let mut min_idx = 0;\n   |       \
    \                - expected due to this value\n...\n47 |             min_idx =\
    \ i;\n   |                       ^ expected integer, found `&mut isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n47 |             min_idx = *i;\n\
    \   |                       +\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0368, E0369.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut index_counter = 1;\n    let mut smallest_value = arr[0];\n    let mut smallest_index\
    \ = 0;\n    for i in arr {\n        if i % 2 == 0 {\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = index_counter;\n\
    \            }\n        }\n        index_counter += 1;\n    }\n    let mut smallest_value_index\
    \ = vec![smallest_value];\n    let mut current_index = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_value {\n          \
    \      smallest_value = i;\n                smallest_index = current_index;\n\
    \            }\n            current_index += 1;\n        }\n    }\n    let mut\
    \ current_index = 0;\n    while current_index < arr.len() {\n        if arr[current_index]\
    \ == smallest_value {\n            smallest_value_index.push(current_index);\n\
    \            current_index += 1;\n        } else {\n            current_index\
    \ += 1;\n        }\n    }\n    for i in smallest_value_index {\n        result.push(i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps91lx7ff.rs:44:20\n   |\n\
    44 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmps91lx7ff.rs:45:34\n   |\n29 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n45 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n45 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps91lx7ff.rs:54:39\n   |\n54 |             smallest_value_index.push(current_index);\n\
    \   |                                       ^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n54 |             smallest_value_index.push(current_index.try_into().unwrap());\n\
    \   |                                                    ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    debugln!(\"pluck(vec!{})\", arr);\n\
    \n    // Solution 1. Sort the vector.\n    arr.sort_unstable();\n\n    // Solution\
    \ 2. Iterate through and find lowest even value using &mut borrow of isize to\
    \ swap the values.\n    let mut lowest_even = arr[0];\n\n    for i in arr.iter().skip(1)\
    \ {\n        if *i % 2 == 0 {\n            *lowest_even = i;\n            *lowest_even\
    \ += 1;\n            lowest_even = i;\n        } else {\n            *lowest_even\
    \ = i;\n        }\n    }\n\n    vec![lowest_even, *arr.iter().skip(1)]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmps99gz8n5.rs:27:5\n\
    \   |\n27 |     debugln!(\"pluck(vec!{})\", arr);\n   |     ^^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmps99gz8n5.rs:37:13\n   |\n\
    37 |             *lowest_even = i;\n   |             ^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmps99gz8n5.rs:38:13\n   |\n\
    38 |             *lowest_even += 1;\n   |             ^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps99gz8n5.rs:39:27\n   |\n33 |     let mut lowest_even\
    \ = arr[0];\n   |                           ------ expected due to this value\n\
    ...\n39 |             lowest_even = i;\n   |                           ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    39 |             lowest_even = *i;\n   |                           +\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmps99gz8n5.rs:41:13\n   |\n\
    41 |             *lowest_even = i;\n   |             ^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Skip<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmps99gz8n5.rs:45:23\n\
    \   |\n45 |     vec![lowest_even, *arr.iter().skip(1)]\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = arr[0];\n    let\
    \ mut index = 0;\n    for val in arr.iter().rev() {\n        if val % 2 == 0 {\n\
    \            if val < min {\n                min = val;\n                index\
    \ = 0;\n            } else {\n                index += 1;\n            }\n   \
    \     }\n    }\n    vec![min, index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4gms9r_d.rs:31:22\n   |\n\
    31 |             if val < min {\n   |                      ^^^\n   |         \
    \             |\n   |                      expected `&isize`, found `isize`\n\
    \   |                      help: consider borrowing here: `&min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4gms9r_d.rs:32:23\n   |\n27 |     let mut min\
    \ = arr[0];\n   |                   ------ expected due to this value\n...\n32\
    \ |                 min = val;\n   |                       ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \               min = *val;\n   |                       +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smalest_value = arr[0];\n    let mut smalest_idx\
    \ = 0;\n    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n           \
    \ if smalest_value < i {\n                smalest_value = i;\n               \
    \ smalest_idx = i;\n            }\n        }\n    }\n    let mut ans = vec![smalest_value,\
    \ smalest_idx];\n    ans.sort();\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppdlwe4pb.rs:34:32\n   |\n\
    34 |             if smalest_value < i {\n   |                                ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n34 |             if smalest_value < *i {\n   |                        \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppdlwe4pb.rs:35:33\n\
    \   |\n30 |     let mut smalest_value = arr[0];\n   |                        \
    \     ------ expected due to this value\n...\n35 |                 smalest_value\
    \ = i;\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 smalest_value\
    \ = *i;\n   |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppdlwe4pb.rs:36:31\n   |\n31 |     let mut smalest_idx = 0;\n  \
    \ |                           - expected due to this value\n...\n36 |        \
    \         smalest_idx = i;\n   |                               ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |  \
    \               smalest_idx = *i;\n   |                               +\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().min(|a, b| a > b).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp1rn1jfzt.rs:27:16\n     |\n27   |     arr.iter().min(|a, b| a\
    \ > b).cloned().collect()\n     |                ^^^ ------------ supplied 1 argument\n\
    \     |                |\n     |                expected 0 arguments\n     |\n\
    note: associated function defined here\n\nerror[E0599]: `Option<isize>` is not\
    \ an iterator\n   --> /tmp/tmp1rn1jfzt.rs:27:43\n    |\n27  |       arr.iter().min(|a,\
    \ b| a > b).cloned().collect()\n    |                                        \
    \     ^^^^^^^ `Option<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<isize>: Iterator`\n  \
    \          which is required by `&mut Option<isize>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut smalest_value = arr[0];\n    let mut smalest_index\
    \ = 0;\n    for i in arr.iter() {\n        let even_value = if i % 2 == 0 {\n\
    \            true\n        } else {\n            false\n        };\n        if\
    \ even_value.cmp(&smalest_value) == Option::Some(&1) {\n            smalest_value\
    \ = i;\n            smalest_index = i;\n        }\n    }\n    vec![smalest_value,\
    \ smalest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8l88mplf.rs:38:27\n   |\n\
    38 |         if even_value.cmp(&smalest_value) == Option::Some(&1) {\n   |   \
    \                        ^^^^^^^^^^^^^^ expected `bool`, found `isize`\n   |\n\
    \   = note: expected reference `&bool`\n              found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8l88mplf.rs:38:46\n   |\n38 |\
    \         if even_value.cmp(&smalest_value) == Option::Some(&1) {\n   |      \
    \                                        ^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<&{integer}>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8l88mplf.rs:39:29\n   |\n30 |     let mut smalest_value = arr[0];\n\
    \   |                             ------ expected due to this value\n...\n39 |\
    \             smalest_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    39 |             smalest_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8l88mplf.rs:40:29\n   |\n31 |     let mut smalest_index\
    \ = 0;\n   |                             - expected due to this value\n...\n40\
    \ |             smalest_index = i;\n   |                             ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    40 |             smalest_index = *i;\n   |                             +\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut pivot_index = arr.iter().min_by_key(|x|\
    \ {\n        if x % 2 == 0 {\n            Some(x)\n        } else {\n        \
    \    None\n        }\n    }).unwrap();\n    let mut pivot_value = arr[pivot_index];\n\
    \    if pivot_value % 2 == 0 {\n        pivot_value += 1;\n    }\n    let mut\
    \ arr2 = vec![pivot_value, pivot_index];\n    arr.iter().for_each(|x| {\n    \
    \    if x % 2 != 0 {\n            arr2.push(x)\n        }\n    });\n    arr2\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpcyfw25dh.rs:28:14\n\
    \   |\n28 |         if x % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `x`\n   |\n28 |         if *x % 2 == 0 {\n   |         \
    \   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpcyfw25dh.rs:34:27\n   |\n34 |     let mut pivot_value = arr[pivot_index];\n\
    \   |                           ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: cannot add-assign `{integer}`\
    \ to `&isize`\n  --> /tmp/tmpcyfw25dh.rs:36:21\n   |\n36 |         pivot_value\
    \ += 1;\n   |                     ^^ no implementation for `&isize += {integer}`\n\
    \   |\n   = help: the trait `AddAssign<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcyfw25dh.rs:44:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n44 |     arr2\n   |     ^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort_unstable_by(|a, b| {\n\
    \        a.cmp(b)\n    });\n    let mut even_value: isize = 0;\n    let mut index\
    \ = 0;\n    loop {\n        if arr[index] % 2 == 0 {\n            even_value =\
    \ arr[index];\n            break;\n        }\n        index += 1\n    }\n    vec![even_value,index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyqh4lend.rs:39:21\n   |\n\
    39 |     vec![even_value,index]\n   |                     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n39 |     vec![even_value,index.try_into().unwrap()]\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even = arr.iter().filter(|x|\
    \ x % 2 == 0).count();\n    let mut smallest = 0;\n    arr.iter().filter(|x| x\
    \ % 2 == 0).min_by_key(|x| {\n        if even == 0 {\n            smallest = x;\n\
    \            even = 1;\n        } else {\n            even = even / 2;\n     \
    \   }\n        x\n    });\n    let mut sorted_arr = arr.iter().cloned().sort();\n\
    \    sorted_arr.remove(&smallest);\n    smallest\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpcuw3ijwc.rs:27:44\n\
    \   |\n27 |     let mut even = arr.iter().filter(|x| x % 2 == 0).count();\n  \
    \ |                                          - ^ - {integer}\n   |           \
    \                               |\n   |                                      \
    \    &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference `x`\n\
    \   |\n27 |     let mut even = arr.iter().filter(|x| *x % 2 == 0).count();\n \
    \  |                                          +\n\nerror[E0369]: cannot mod `&&isize`\
    \ by `{integer}`\n  --> /tmp/tmpcuw3ijwc.rs:29:29\n   |\n29 |     arr.iter().filter(|x|\
    \ x % 2 == 0).min_by_key(|x| {\n   |                           - ^ - {integer}\n\
    \   |                           |\n   |                           &&isize\n  \
    \ |\nhelp: `%` can be used on `isize`, you can dereference `x`\n   |\n29 |   \
    \  arr.iter().filter(|x| *x % 2 == 0).min_by_key(|x| {\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcuw3ijwc.rs:31:24\n\
    \   |\n28 |     let mut smallest = 0;\n   |                        - expected\
    \ due to this value\n...\n31 |             smallest = x;\n   |               \
    \         ^ expected integer, found `&&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n31 |             smallest = **x;\n   |                   \
    \     ++\n\nerror[E0599]: no method named `sort` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpcuw3ijwc.rs:38:46\n   |\n38 |     let mut sorted_arr\
    \ = arr.iter().cloned().sort();\n   |                                        \
    \      ^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcuw3ijwc.rs:40:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n40 |     smallest\n   |     ^^^^^^^^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `{integer}`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smalest_value = arr[0];\n    let mut smalest_index\
    \ = 0;\n    let mut largest_value_index = arr.len() - 1;\n    let mut largest_value\
    \ = 0;\n    while largest_value_index >= 0 && largest_value <= arr[0] {\n    \
    \    largest_value = arr.pop().unwrap();\n        largest_value_index -= 1;\n\
    \    }\n    for value in arr.iter().rev() {\n        if value == smalest_value\
    \ {\n            smalest_index += 1;\n        } else {\n            if smalest_value\
    \ < value {\n                smalest_value = value;\n                smalest_index\
    \ = smalest_index;\n            }\n            smalest_index = smalest_index;\n\
    \        }\n    }\n    arr\n        .iter()\n        .take(smalest_index + 1)\n\
    \        .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp1ysagudz.rs:39:18\n\
    \   |\n39 |         if value == smalest_value {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1ysagudz.rs:42:32\n   |\n42 |             if smalest_value < value {\n\
    \   |                                ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n42 |             if smalest_value\
    \ < *value {\n   |                                +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1ysagudz.rs:43:33\n   |\n30 |     let mut smalest_value\
    \ = arr[0];\n   |                             ------ expected due to this value\n\
    ...\n43 |                 smalest_value = value;\n   |                       \
    \          ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n43 |                 smalest_value = *value;\n   |       \
    \                          +\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_index = arr.iter().enumerate().min_by_key(|(idx,\
    \ node)| {\n        node.0 % 2 != 0\n    });\n    let mut smallest_val = min_index.as_ref().unwrap();\n\
    \    let mut smallest_node = vec![];\n    smallest_node.push(smallest_val.0);\n\
    \    smallest_node.push(min_index.as_ref().unwrap().1);\n    smallest_node\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&&isize`\n  --> /tmp/tmp3e6fnzau.rs:28:14\n\
    \   |\n28 |         node.0 % 2 != 0\n   |              ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3e6fnzau.rs:33:24\n   |\n33 |     smallest_node.push(min_index.as_ref().unwrap().1);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3e6fnzau.rs:34:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n34\
    \ |     smallest_node\n   |     ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() <= 10000, \"\
    The nodes in the given array should not be more than 10000.\");\n    assert!(arr.len()\
    \ >= 1, \"The nodes in the given array should not be less than 1.\");\n    assert!(arr.iter().all(|&v|\
    \ v >= 0), \"The nodes in the given array should only contain positive integers.\"\
    );\n\n    let mut smalest_value = arr[0];\n    let mut smalest_index: usize =\
    \ 0;\n    let mut even_value: isize = 0;\n    let mut index: usize = 0;\n    let\
    \ mut counter: usize = 0;\n\n    for x in arr.iter() {\n        match x % 2 {\n\
    \            0 => {\n                if even_value < x {\n                   \
    \ even_value = x;\n                    smalest_value = x;\n                  \
    \  smalest_index = index;\n                }\n            }\n            1 =>\
    \ {\n                if smalest_value == x {\n                    smalest_index\
    \ = index as usize;\n                }\n                index += 1;\n        \
    \        counter += 1;\n            }\n        }\n    }\n    let mut result: Vec<isize>\
    \ = vec![];\n    if counter > 0 {\n        result = vec![smalest_value, smalest_index];\n\
    \    }\n    debug!(\"{:?}\", result);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmp8cjrlmtr.rs:59:5\n\
    \   |\n59 |     debug!(\"{:?}\", result);\n   |     ^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8cjrlmtr.rs:40:33\n   |\n40 |                 if even_value\
    \ < x {\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |                 if\
    \ even_value < *x {\n   |                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8cjrlmtr.rs:41:34\n   |\n33 |     let mut even_value: isize\
    \ = 0;\n   |                         ----- expected due to this type\n...\n41\
    \ |                     even_value = x;\n   |                                \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n41 |                     even_value = *x;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8cjrlmtr.rs:42:37\n\
    \   |\n31 |     let mut smalest_value = arr[0];\n   |                        \
    \     ------ expected due to this value\n...\n42 |                     smalest_value\
    \ = x;\n   |                                     ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n42 |                   \
    \  smalest_value = *x;\n   |                                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8cjrlmtr.rs:47:37\n   |\n47 |              \
    \   if smalest_value == x {\n   |                                     ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    47 |                 if smalest_value == *x {\n   |                          \
    \           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8cjrlmtr.rs:57:38\n\
    \   |\n57 |         result = vec![smalest_value, smalest_index];\n   |       \
    \                               ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n57 |         result = vec![smalest_value, smalest_index.try_into().unwrap()];\n\
    \   |                  "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_val = INT_MAX;\n    let mut smallest_even_i\
    \ = 0;\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n          \
    \  if smallest_even_val < arr[i] {\n                smallest_even_val = arr[i];\n\
    \                smallest_even_i = i;\n            }\n        }\n    }\n    let\
    \ mut result = vec![smallest_even_val, smallest_even_i];\n    arr.drain(smallest_even_i\
    \ + 1);\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `INT_MAX` in this scope\n  --> /tmp/tmpvfax5ra0.rs:30:33\n\
    \   |\n30 |     let mut smallest_even_val = INT_MAX;\n   |                   \
    \              ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvfax5ra0.rs:40:46\n   |\n40 |     let mut result = vec![smallest_even_val,\
    \ smallest_even_i];\n   |                                              ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: the trait bound `usize: RangeBounds<usize>`\
    \ is not satisfied\n    --> /tmp/tmpvfax5ra0.rs:41:15\n     |\n41   |     arr.drain(smallest_even_i\
    \ + 1);\n     |         ----- ^^^^^^^^^^^^^^^^^^^ the trait `RangeBounds<usize>`\
    \ is not implemented for `usize`\n     |         |\n     |         required by\
    \ a bound introduced by this call\n     |\n     = help: the following other types\
    \ implement trait `RangeBounds<T>`:\n               (Bound<&'a T>, Bound<&'a T>)\n\
    \               (Bound<T>, Bound<T>)\n               RangeFrom<&T>\n         \
    \      RangeFrom<T>\n               RangeFull\n               RangeInclusive<&T>\n\
    \               RangeInclusive<T>\n               RangeTo<&T>\n             and\
    \ 5 others\nnote: required by a bound in `Vec::<T, A>::drain`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        vec![]\n\
    \    }\n    let mut min_value_index = vec![];\n    let mut min_value = vec![];\n\
    \    for node in arr.iter().rev() {\n        if node.is_odd() && node.is_even()\
    \ {\n            if min_value.len() == 0 || min_value[0] > node.value {\n    \
    \            min_value[0] = node.value;\n                min_value_index.push(i);\n\
    \            }\n        }\n    }\n    if min_value_index.len() == 0 {\n      \
    \  min_value_index.push(0)\n    }\n    min_value_index\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpzsyj_5xp.rs:36:38\n\
    \   |\n36 |                 min_value_index.push(i);\n   |                   \
    \                   ^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzsyj_5xp.rs:28:9\n   |\n27 | /     if arr.len() == 0 {\n28 | |\
    \         vec![]\n   | |         ^^^^^^ expected `()`, found struct `Vec`\n29\
    \ | |     }\n   | |_____- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                 found struct `Vec<_>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\nhelp: consider using a semicolon here\n   |\n29 |     };\n \
    \  |      +\n\nerror[E0599]: no method named `is_odd` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpzsyj_5xp.rs:33:17\n   |\n33 |         if\
    \ node.is_odd() && node.is_even() {\n   |                 ^^^^^^ method not found\
    \ in `&isize`\n\nerror[E0599]: no method named `is_even` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpzsyj_5xp.rs:33:34\n   |\n33 |         if\
    \ node.is_odd() && node.is_even() {\n   |                                  ^^^^^^^\
    \ method not found in `&isize`\n\nerror[E0609]: no field `value` on type `&isize`\n\
    \  --> /tmp/tmpzsyj_5xp.rs:34:60\n   |\n34 |             if min_value.len() ==\
    \ 0 || min_value[0] > node.value {\n   |                                     \
    \                       ^^^^^\n\nerror[E0609]: no field `value` on type `&isize`\n\
    \  --> /tmp/tmpzsyj_5xp.rs:35:37\n   |\n35 |                 min_value[0] = node.value;\n\
    \   |                                     ^^^^^\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = arr[0];\n    let\
    \ mut index = -1;\n\n    for &i in arr.iter() {\n        if i % 2 != 0 {\n   \
    \         continue;\n        }\n        if min > i {\n            min = i;\n \
    \           index = i;\n        }\n    }\n    vec![min, index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmp_c6ijxcg.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut pluck_arr = arr\n     \
    \   .iter()\n        .map(|x| {\n            let mut result = x;\n           \
    \ if x % 2 == 0 {\n                result = x + 1;\n            }\n          \
    \  result\n        })\n        .collect::<Vec<isize>>();\n    let mut min_even_values\
    \ = pluck_arr\n        .iter()\n        .cloned()\n        .filter(|&x| x % 2\
    \ == 0)\n        .map(|x| x).collect::<Vec<isize>>();\n    let mut min_even_value_index\
    \ = Vec::new();\n    if min_even_values.len() >= 2 {\n        let mut min = min_even_values[0];\n\
    \        let mut min_index = pluck_arr\n            .iter()\n            .position(|x|\
    \ x == min)\n            .cloned()\n            .unwrap_or(0);\n        for i\
    \ in min_even_values.iter() {\n            if i % 2 == 0 {\n                min\
    \ = i;\n                min_index = i;\n            }\n        }\n        min_even_value_index.push(min_index);\n\
    \    }\n    pluck_arr\n        .iter()\n        .cloned()\n        .filter(|&x|\
    \ x % 2 == 0)\n        .cloned()\n        .filter(|&x| !min_even_value_index.contains(x))\n\
    \        .cloned()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2dgb4fqu.rs:32:26\n   |\n\
    30 |             let mut result = x;\n   |                              - expected\
    \ due to this value\n31 |             if x % 2 == 0 {\n32 |                 result\
    \ = x + 1;\n   |                          ^^^^^\n   |                        \
    \  |\n   |                          expected `&isize`, found `isize`\n   |   \
    \                       help: consider borrowing here: `&(x + 1)`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `&isize`\n    --> /tmp/tmp2dgb4fqu.rs:36:10\n     |\n36   |        \
    \ .collect::<Vec<isize>>();\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp2dgb4fqu.rs:47:29\n   |\n47 |             .position(|x| x == min)\n\
    \   |                             ^^ no implementation for `&isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmp2dgb4fqu.rs:48:14\n\
    \    |\n48  |               .cloned()\n    |                ^^^^^^ `Option<usize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2dgb4fqu.rs:52:23\n\
    \   |\n44 |         let mut min = min_even_values[0];\n   |                  \
    \     ------------------ expected due to this value\n...\n52 |               \
    \  min = i;\n   |                      "
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = vec![];\n\
    \    if arr.is_empty() {\n        return vec;\n    }\n    let mut smallest_even:\
    \ isize = 0;\n    let mut smallest_idx: usize = 0;\n    for &x in &arr {\n   \
    \     if x % 2 == 0 {\n            smallest_even += x;\n            if smallest_even\
    \ < smallest_idx {\n                smallest_idx = smallest_even;\n          \
    \  }\n        } else {\n            vec.push(x);\n        }\n    }\n    vec\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3rv9zekm.rs:36:32\n   |\n\
    36 |             if smallest_even < smallest_idx {\n   |                     \
    \           ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n36 |             if smallest_even < smallest_idx.try_into().unwrap() {\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3rv9zekm.rs:37:32\n   |\n32 |     let mut smallest_idx:\
    \ usize = 0;\n   |                           ----- expected due to this type\n\
    ...\n37 |                 smallest_idx = smallest_even;\n   |                \
    \                ^^^^^^^^^^^^^ expected `usize`, found `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize =\
    \ 0;\n    let mut smalest_index: usize = 0;\n    let mut index: usize = 0;\n \
    \   let mut vec: Vec<isize> = Vec::new();\n    \n    arr.sort_unstable_by(|a,\
    \ b| {\n        if a % 2 == 0 {\n            if b < smalest_value {\n        \
    \        smalest_value = b;\n                smalest_index = 0;\n            }\n\
    \        } else {\n            if b > smalest_value {\n                smalest_value\
    \ = b;\n                smalest_index = 0;\n            }\n        }\n       \
    \ smalest_index += 1;\n        index += 1;\n        a\n    });\n    \n    if smalest_index\
    \ > 0 {\n        vec.push(smalest_value);\n        vec.push(smalest_index);\n\
    \    } else {\n        vec.push(0);\n        vec.push(index);\n    }\n    vec\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxs5h2w8v.rs:34:20\n   |\n\
    34 |             if b < smalest_value {\n   |                    ^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smalest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxs5h2w8v.rs:35:33\n   |\n27 |     let mut smalest_value:\
    \ isize = 0;\n   |                            ----- expected due to this type\n\
    ...\n35 |                 smalest_value = b;\n   |                           \
    \      ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 smalest_value = *b;\n   |           \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxs5h2w8v.rs:39:20\n\
    \   |\n39 |             if b > smalest_value {\n   |                    ^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smalest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxs5h2w8v.rs:40:33\n   |\n27 |     let mut smalest_value:\
    \ isize = 0;\n   |                            ----- expected due to this type\n\
    ...\n40 |                 smalest_value = b;\n   |                           \
    \      ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n40 |                 smalest_value = *b;\n   |           \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxs5h2w8v.rs:46:9\n\
    \   |\n46 |         a\n   |         ^ expected enum `std::cmp::Ordering`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxs5h2w8v.rs:51:18\n\
    \   |\n51 |         vec.push(smalest_index);\n   |                  ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n51 |         vec.push(smalest_index.try_into().unwrap());\n\
    \   |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxs5h2w8v.rs:54:1"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = vec![];\n\
    \    arr.sort();\n    for i in arr.iter() {\n        if i % 2 == 0 {\n       \
    \     vec.push(i);\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsudm_5kq.rs:31:22\n   |\n\
    31 |             vec.push(i);\n   |                      ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |        \
    \     vec.push(*i);\n   |                      +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n\n    let mut min = arr[0] as isize;\n    let mut index = min_idx(arr.iter(),\
    \ |v| v as isize);\n    let mut even = true;\n\n    for val in arr.iter().skip(1)\
    \ {\n        if even {\n            if val as isize > min {\n                min\
    \ = val as isize;\n                index = min_idx(arr.iter(), |v| v as isize);\n\
    \            }\n        } else {\n            if val as isize < min {\n      \
    \          min = val as isize;\n                index = min_idx(arr.iter(), |v|\
    \ v as isize);\n            }\n        }\n        even = !even;\n    }\n\n   \
    \ vec![min, index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmpob9n41o2.rs:42:29\n   |\n42 |             if\
    \ val as isize < min {\n   |                             ^ ----- interpreted as\
    \ generic arguments\n   |                             |\n   |                \
    \             not interpreted as comparison\n   |\nhelp: try comparing the cast\
    \ value\n   |\n42 |             if (val as isize) < min {\n   |              \
    \  +            +\n\nerror[E0425]: cannot find function `min_idx` in this scope\n\
    \  --> /tmp/tmpob9n41o2.rs:32:21\n   |\n32 |     let mut index = min_idx(arr.iter(),\
    \ |v| v as isize);\n   |                     ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `min_idx` in this scope\n  --> /tmp/tmpob9n41o2.rs:39:25\n\
    \   |\n39 |                 index = min_idx(arr.iter(), |v| v as isize);\n   |\
    \                         ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `min_idx` in this scope\n  --> /tmp/tmpob9n41o2.rs:44:25\n   |\n\
    44 |                 index = min_idx(arr.iter(), |v| v as isize);\n   |      \
    \                   ^^^^^^^ not found in this scope\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmpob9n41o2.rs:37:16\n   |\n37 |         \
    \    if val as isize > min {\n   |                ---^^^^^^^^^\n   |         \
    \       |\n   |                cannot cast `&isize` as `isize`\n   |         \
    \       help: dereference the expression: `*val`\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmpob9n41o2.rs:38:23\n   |\n38 |         \
    \        min = val as isize;\n   |                       ---^^^^^^^^^\n   |  \
    \                     |\n   |                       cannot cast `&isize` as `isize`\n\
    \   |                       help: dereference the expression: `*val`\n\nerror[E0606]:\
    \ casting `&isize` as `isize` is invalid\n  --> /tmp/tmpob9n41o2.rs:42:16\n  \
    \ |\n42 |             if val as isize < min {\n   |                ---^^^^^^^^^\n\
    \   |                |\n   |                cannot cast `&isize` as `isize`\n\
    \   |                help: dereference the expression: `*"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value: isize;\n\
    \    let mut smalest_index: isize;\n    for i in 0..arr.len() {\n        if i\
    \ % 2 == 0 {\n            if smalest_value == i32::MAX {\n                smalest_value\
    \ = i;\n                smalest_index = i;\n            } else {\n           \
    \     if arr[i] < smalest_value {\n                    smalest_value = arr[i];\n\
    \                    smalest_index = i;\n                }\n            }\n  \
    \      }\n    }\n    if smalest_value == i32::MAX {\n        return vec![];\n\
    \    }\n    return vec![smalest_value, smalest_index];\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe2lg1hnt.rs:31:33\n   |\n\
    31 |             if smalest_value == i32::MAX {\n   |                        \
    \         ^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    31 |             if smalest_value == i32::MAX.try_into().unwrap() {\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe2lg1hnt.rs:32:33\n   |\n27 |     let mut smalest_value:\
    \ isize;\n   |                            ----- expected due to this type\n...\n\
    32 |                 smalest_value = i;\n   |                                \
    \ ^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe2lg1hnt.rs:33:33\n\
    \   |\n28 |     let mut smalest_index: isize;\n   |                          \
    \  ----- expected due to this type\n...\n33 |                 smalest_index =\
    \ i;\n   |                                 ^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe2lg1hnt.rs:37:37\n   |\n28 |\
    \     let mut smalest_index: isize;\n   |                            ----- expected\
    \ due to this type\n...\n37 |                     smalest_index = i;\n   |   \
    \                                  ^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe2lg1hnt.rs:42:25\n   |\n42 |     if smalest_value\
    \ == i32::MAX {\n   |                         ^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n42 |     if smalest_value == i32::MAX.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.clone()\n        .sort::<isize>()\n\
    \        .filter(|&x| x % 2 == 0)\n        .take(arr.len() / 2)\n        .cloned()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0107]: this associated function takes 0 generic arguments but 1\
    \ generic argument was supplied\n  --> /tmp/tmpe6finhwz.rs:28:10\n   |\n28 | \
    \        .sort::<isize>()\n   |          ^^^^--------- help: remove these generics\n\
    \   |          |\n   |          expected 0 generic arguments\n\nerror[E0599]:\
    \ `()` is not an iterator\n  --> /tmp/tmpe6finhwz.rs:29:10\n   |\n29 |       \
    \  .filter(|&x| x % 2 == 0)\n   |          ^^^^^^ `()` is not an iterator\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0107, E0599.\n\
    For more information about an error, try `rustc --explain E0107`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = arr[0];\n  \
    \  let mut min_even_count = 1;\n    let mut min_even_node = 0;\n    let mut min_even_node_index\
    \ = 0;\n    for i in arr.iter() {\n        let even = i & 1 == 0;\n        if\
    \ even != min_even {\n            min_even = even;\n            min_even_count\
    \ = if even {\n                min_even_count + 1\n            } else {\n    \
    \            min_even_count\n            };\n            min_even_node = i;\n\
    \            min_even_node_index = i;\n        }\n    }\n    if min_even_count\
    \ == 1 {\n        vec![min_even, min_even_node_index]\n    } else {\n        vec![min_even,\
    \ min_even_node_index, min_even_node]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu399eswk.rs:33:20\n   |\n\
    33 |         if even != min_even {\n   |                    ^^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu399eswk.rs:34:24\n\
    \   |\n27 |     let mut min_even = arr[0];\n   |                        ------\
    \ expected due to this value\n...\n34 |             min_even = even;\n   |   \
    \                     ^^^^ expected `isize`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu399eswk.rs:40:29\n   |\n29 |     let mut min_even_node\
    \ = 0;\n   |                             - expected due to this value\n...\n40\
    \ |             min_even_node = i;\n   |                             ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    40 |             min_even_node = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu399eswk.rs:41:35\n   |\n30 |     let mut min_even_node_index\
    \ = 0;\n   |                                   - expected due to this value\n\
    ...\n41 |             min_even_node_index = i;\n   |                         \
    \          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n41 |             min_even_node_index = *i;\n   |         \
    \                          +\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().map(|e| {\n\
    \        if e % 2 == 0 {\n            Some(e)\n        } else {\n            None\n\
    \        }\n    }).filter(|v| v.is_some()).map(|v| {\n        let mut min = *v;\n\
    \        let mut index = 0;\n        for i in 1..arr.len() {\n            if min\
    \ < arr[i] {\n                min = arr[i];\n                index = i;\n    \
    \        }\n        }\n        (min, index)\n    }).min_by_key(|v| v.0).unwrap()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpj8udhbr3.rs:34:23\n\
    \   |\n34 |         let mut min = *v;\n   |                       ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj8udhbr3.rs:27:5\n   |\n26 |   fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                ----------\
    \ expected `Vec<isize>` because of return type\n27 | /     arr.iter().cloned().map(|e|\
    \ {\n28 | |         if e % 2 == 0 {\n29 | |             Some(e)\n30 | |      \
    \   } else {\n...  |\n42 | |         (min, index)\n43 | |     }).min_by_key(|v|\
    \ v.0).unwrap()\n   | |___________________________________^ expected struct `Vec`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<isize>`\n               found\
    \ tuple `(isize, usize)`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut pluck_arr: Vec<isize> =\
    \ Vec::new();\n    let mut smalest_value: isize = arr.iter().min(|a, b| {\n  \
    \      let mut a_val = a;\n        let mut b_val = b;\n        let mut val: isize\
    \ = a_val - b_val;\n        \n        while val == 0 && a_val < b_val {\n    \
    \        a_val += 1;\n            b_val += 1;\n            val += 1;\n       \
    \ }\n\n        a_val - b_val\n    })?;\n\n    for v in arr {\n        if v ==\
    \ smalest_value {\n            pluck_arr.push(smalest_value);\n        }\n   \
    \ }\n    pluck_arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpvv_17bu2.rs:28:47\n     |\n28   |       let mut smalest_value:\
    \ isize = arr.iter().min(|a, b| {\n     |  _______________________________________________^^^_-\n\
    \     | |                                               |\n     | |          \
    \                                     expected 0 arguments\n29   | |         let\
    \ mut a_val = a;\n30   | |         let mut b_val = b;\n31   | |         let mut\
    \ val: isize = a_val - b_val;\n...    |\n39   | |         a_val - b_val\n40  \
    \ | |     })?;\n     | |_____- supplied 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: `?` operator has incompatible types\n  --> /tmp/tmpvv_17bu2.rs:28:36\n\
    \   |\n28 |       let mut smalest_value: isize = arr.iter().min(|a, b| {\n   |\
    \  ____________________________________^\n29 | |         let mut a_val = a;\n\
    30 | |         let mut b_val = b;\n31 | |         let mut val: isize = a_val -\
    \ b_val;\n...  |\n39 | |         a_val - b_val\n40 | |     })?;\n   | |_______^\
    \ expected `isize`, found `&isize`\n   |\n   = note: `?` operator cannot convert\
    \ from `&isize` to `isize`\nhelp: consider dereferencing the borrow\n   |\n28\
    \ |     let mut smalest_value: isize = *arr.iter().min(|a, b| {\n   |        \
    \                            +\n\nerror[E0277]: the `?` operator can only be used\
    \ in a function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmpvv_17bu2.rs:40:7\n   |\n26 | / fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n27 | |     let mut pluck_arr: Vec<isize> = Vec::new();\n\
    28 | |     let mut smalest_value: isize = arr.iter().min(|a, b| {\n29 | |    \
    \     let mut a_val = a;\n...  |\n40 | |     })?;\n   | |       ^ cannot use the\
    \ `?` operator in a function that returns `Vec<isize>`\n...  |\n47 | |     pluck_arr\n\
    48 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>` is not implemented\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed ex"
  stdout: ''
  timestamp: 1660010833
