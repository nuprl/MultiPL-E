language: rs
name: HumanEval_20_find_closest_elements
results:
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.size() >= 2);\n    let mut closest_num\
    \ = numbers[0];\n    let mut second_closest_num = numbers[0];\n    let mut closest_distance\
    \ = 1.0;\n    for &num in &numbers {\n        if closest_distance > f64::abs(num\
    \ - closest_num) {\n            closest_distance = num - closest_num;\n      \
    \      closest_num = num;\n        }\n        if closest_distance > f64::abs(num\
    \ - second_closest_num) {\n            second_closest_num = num;\n        }\n\
    \    }\n    (closest_num, second_closest_num)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `Vec<f64>` in the\
    \ current scope\n --> /tmp/tmpy52f34yb.rs:8:21\n  |\n8 |     assert!(numbers.size()\
    \ >= 2);\n  |                     ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = f64::MAX;\n    let mut min_number\
    \ = f64::MAX;\n    for &n in numbers {\n        let dist = n.abs();\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_number = n;\n\
    \        }\n    }\n\n    (min_number, min_dist)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagxge_ns.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_num = 0.;\n    let mut max_num = 0.;\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        let dist = std::f64::abs(n - numbers[0]);\n        if dist < min_dist\
    \ {\n            min_dist = dist;\n            min_num = numbers[0];\n       \
    \     max_num = numbers[0];\n        } else if dist == min_dist {\n          \
    \  if n > numbers[0] {\n                max_num = n;\n            } else {\n \
    \               min_num = n;\n            }\n        }\n    }\n    (min_num, max_num)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpqp60oowr.rs:12:30\n\
    \   |\n12 |         let dist = std::f64::abs(n - numbers[0]);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqp60oowr.rs:18:20\n   |\n18 |             if n > numbers[0] {\n\
    \   |                    ^^^^^^^^^^\n   |                    |\n   |         \
    \           expected `&f64`, found `f64`\n   |                    help: consider\
    \ borrowing here: `&numbers[0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqp60oowr.rs:19:27\n\
    \   |\n10 |     let mut max_num = 0.;\n   |                       -- expected\
    \ due to this value\n...\n19 |                 max_num = n;\n   |            \
    \               ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n19 |                 max_num = *n;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqp60oowr.rs:21:27\n\
    \   |\n9  |     let mut min_num = 0.;\n   |                       -- expected\
    \ due to this value\n...\n21 |                 min_num = n;\n   |            \
    \               ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |                 min_num = *n;\n   |                 \
    \          +\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    for (i, number) in numbers.iter().enumerate() {\n        if\
    \ number > max {\n            max = number;\n        }\n        if number < min\
    \ {\n            min = number;\n        }\n    }\n    (min, max)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0y88c7x.rs:11:21\n   |\n\
    11 |         if number > max {\n   |                     ^^^\n   |           \
    \          |\n   |                     expected `&f64`, found `f64`\n   |    \
    \                 help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb0y88c7x.rs:12:19\n   |\n9  |     let mut max = numbers[0];\n\
    \   |                   ---------- expected due to this value\n...\n12 |     \
    \        max = number;\n   |                   ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |             max = *number;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0y88c7x.rs:14:21\n\
    \   |\n14 |         if number < min {\n   |                     ^^^\n   |    \
    \                 |\n   |                     expected `&f64`, found `f64`\n \
    \  |                     help: consider borrowing here: `&min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb0y88c7x.rs:15:19\n   |\n8  |     let mut min\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n15 |             min = number;\n   |                   ^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |    \
    \         min = *number;\n   |                   +\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_number = f64::MAX;\n    let\
    \ mut largest_number = f64::MIN;\n\n    for i in 0..numbers.len() {\n        let\
    \ distance = numbers[i] - largest_number;\n\n        if distance < smallest_number\
    \ {\n            smallest_number = distance;\n        }\n        if distance >\
    \ largest_number {\n            largest_number = distance;\n        }\n    }\n\
    \n    (smallest_number, largest_number)\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(-1.7976931348623157e308, 1.7976931348623157e308)`,\n right: `(3.9, 4.0)`',\
    \ /tmp/tmp12spopzy.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0],\
    \ numbers[0]);\n    }\n    let mut min_val = numbers[0];\n    let mut max_val\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        let mut min_val = numbers[i];\n\
    \        let mut max_val = numbers[i];\n        for j in 0..i {\n            let\
    \ distance = std::f64::consts::PI * std::f64::consts::PI / (2.0 * j);\n      \
    \      if numbers[j] < (min_val + distance) {\n                min_val = numbers[j];\n\
    \            }\n            if numbers[j] > (max_val - distance) {\n         \
    \       max_val = numbers[j];\n            }\n        }\n        return (min_val,\
    \ max_val);\n    }\n    (numbers[0], numbers[0]);\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply `{float}` by `usize`\n  --> /tmp/tmphxub539q.rs:17:79\n\
    \   |\n17 |             let distance = std::f64::consts::PI * std::f64::consts::PI\
    \ / (2.0 * j);\n   |                                                         \
    \                      ^ no implementation for `{float} * usize`\n   |\n   = help:\
    \ the trait `Mul<usize>` is not implemented for `{float}`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphxub539q.rs:7:48\n   |\n7  | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |    ---------------------                   \
    \    ^^^^^^^^^^ expected tuple, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n27 |     (numbers[0],\
    \ numbers[0]);\n   |                             - help: remove this semicolon\n\
    \   |\n   = note:  expected tuple `(f64, f64)`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_number = numbers[0];\n    let\
    \ mut largest_number = numbers[0];\n    for i in numbers.iter().rev() {\n    \
    \    if i >= smallest_number {\n            continue;\n        }\n        if largest_number\
    \ < i {\n            largest_number = i;\n        }\n        if smallest_number\
    \ > i {\n            smallest_number = i;\n        }\n    }\n\n    (smallest_number,\
    \ largest_number)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf2_ax4gl.rs:11:17\n   |\n\
    11 |         if i >= smallest_number {\n   |                 ^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 expected `&f64`, found `f64`\n \
    \  |                 help: consider borrowing here: `&smallest_number`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf2_ax4gl.rs:14:29\n   |\n14 |         if largest_number\
    \ < i {\n   |                             ^ expected `f64`, found `&f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n14 |         if largest_number\
    \ < *i {\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf2_ax4gl.rs:15:30\n   |\n9  |     let mut largest_number = numbers[0];\n\
    \   |                              ---------- expected due to this value\n...\n\
    15 |             largest_number = i;\n   |                              ^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15\
    \ |             largest_number = *i;\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpf2_ax4gl.rs:17:30\n   |\n17 |  \
    \       if smallest_number > i {\n   |                              ^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n17\
    \ |         if smallest_number > *i {\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpf2_ax4gl.rs:18:31\n   |\n8  |  \
    \   let mut smallest_number = numbers[0];\n   |                              \
    \ ---------- expected due to this value\n...\n18 |             smallest_number\
    \ = i;\n   |                               ^ expected `f64`, found `&f64`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n18 |             smallest_number\
    \ = *i;\n   |                               +\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    for number in numbers {\n        if number > max {\n      \
    \      max = number;\n        }\n        if number < min {\n            min =\
    \ number;\n        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpwzekhne_.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // find the smallest and largest numbers in the\
    \ numbers\n    let smallest = numbers[0];\n    let largest = numbers[0];\n   \
    \ for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number;\n        }\n        if number > largest {\n            largest = number;\n\
    \        }\n    }\n\n    // find the midpoint between the smallest and largest\n\
    \    let midpoint = smallest + (largest - smallest) / 2;\n\n    // find the two\
    \ numbers closest to each other\n    let closest_to_smallest = numbers[numbers\n\
    \        .iter()\n        .min_by(|&number| f64::abs(number - smallest))\n   \
    \     .unwrap() as usize];\n    let closest_to_largest = numbers[numbers\n   \
    \     .iter()\n        .min_by(|&number| f64::abs(number - largest))\n       \
    \ .unwrap() as usize];\n\n    // return the values\n    (smallest, midpoint),\
    \ (largest, closest_to_smallest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpq7y028mq.rs:34:25\n   |\n34 |     (smallest, midpoint), (largest,\
    \ closest_to_smallest)\n   |                         ^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror[E0277]: cannot divide `f64` by `{integer}`\n\
    \  --> /tmp/tmpq7y028mq.rs:21:52\n   |\n21 |     let midpoint = smallest + (largest\
    \ - smallest) / 2;\n   |                                                    ^\
    \ no implementation for `f64 / {integer}`\n   |\n   = help: the trait `Div<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n21 |     let midpoint = smallest + (largest - smallest)\
    \ / 2.0;\n   |                                                       ++\n\nerror[E0593]:\
    \ closure is expected to take 2 arguments, but it takes 1 argument\n  --> /tmp/tmpq7y028mq.rs:26:10\n\
    \   |\n26 |         .min_by(|&number| f64::abs(number - smallest))\n   |     \
    \     ^^^^^^ --------- takes 1 argument\n   |          |\n   |          expected\
    \ closure that takes 2 arguments\n\nerror[E0593]: closure is expected to take\
    \ 2 arguments, but it takes 1 argument\n  --> /tmp/tmpq7y028mq.rs:30:10\n   |\n\
    30 |         .min_by(|&number| f64::abs(number - largest))\n   |          ^^^^^^\
    \ --------- takes 1 argument\n   |          |\n   |          expected closure\
    \ that takes 2 arguments\n\nerror[E0606]: casting `&f64` as `usize` is invalid\n\
    \  --> /tmp/tmpq7y028mq.rs:24:39\n   |\n24 |       let closest_to_smallest = numbers[numbers\n\
    \   |  _______________________________________^\n25 | |         .iter()\n26 |\
    \ |         .min_by(|&number| f64::abs(number - smallest))\n27 | |         .unwrap()\
    \ as usize];\n   | |_"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_number = std::f64::MAX;\n    let\
    \ mut max_number = std::f64::MIN;\n    for number in numbers {\n        if number\
    \ < min_number {\n            min_number = number;\n        }\n        if number\
    \ > max_number {\n            max_number = number;\n        }\n    }\n    (min_number,\
    \ max_number)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp607w72yx.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.iter().cloned().enumerate().for_each(|(i,\
    \ n)| {\n        let mut min_dist = std::f64::MAX;\n        let mut min_i = -1;\n\
    \n        for j in 0..i {\n            let dist: f64 = n.0 - numbers[j].0;\n \
    \           if dist < min_dist {\n                min_dist = dist;\n         \
    \       min_i = j;\n            }\n        }\n\n        if min_dist == std::f64::MAX\
    \ {\n            println!(\"found all elements {}\", numbers);\n        } else\
    \ {\n            println!(\"found element {} (dist={}) and element {} (dist={})\"\
    , min_i, min_dist, i + 1, n - 1);\n        }\n    });\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `f64` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmptq2il6vm.rs:13:31\n   |\n13 |             let dist: f64 = n.0 -\
    \ numbers[j].0;\n   |                               ^\n\nerror[E0610]: `f64` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmptq2il6vm.rs:13:46\n\
    \   |\n13 |             let dist: f64 = n.0 - numbers[j].0;\n   |            \
    \                                  ^\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmptq2il6vm.rs:10:25\n   |\n10 |         let\
    \ mut min_i = -1;\n   |                         ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmptq2il6vm.rs:21:47\n   |\n21 |             println!(\"found all\
    \ elements {}\", numbers);\n   |                                             \
    \  ^^^^^^^ `Vec<f64>` cannot be formatted with the default formatter\n   |\n \
    \  = help: the trait `std::fmt::Display` is not implemented for `Vec<f64>`\n \
    \  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::format_args_nl`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ cannot subtract `{integer}` from `f64`\n  --> /tmp/tmptq2il6vm.rs:23:103\n \
    \  |\n23 |             println!(\"found element {} (dist={}) and element {} (dist={})\"\
    , min_i, min_dist, i + 1, n - 1);\n   |                                      \
    \                                                                 ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = numbers[0];\n    let mut\
    \ min_number = numbers[0];\n\n    for i in 1..numbers.len() {\n        let mut\
    \ distance = 0;\n        let mut number = numbers[0];\n\n        for j in 1..numbers.len()\
    \ {\n            distance += &numbers[j] - &mut number;\n            number =\
    \ numbers[j];\n        }\n\n        if distance < min_distance {\n           \
    \ min_distance = distance;\n            min_number = number;\n        }\n    }\n\
    \n    (min_number, min_distance)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `&mut f64` from `&f64`\n  --> /tmp/tmpbb2ytidm.rs:16:37\n\
    \   |\n16 |             distance += &numbers[j] - &mut number;\n   |         \
    \                            ^ no implementation for `&f64 - &mut f64`\n   |\n\
    \   = help: the trait `Sub<&mut f64>` is not implemented for `&f64`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbb2ytidm.rs:20:23\n   |\n20 |         if distance < min_distance\
    \ {\n   |                       ^^^^^^^^^^^^ expected integer, found `f64`\n\n\
    error[E0277]: can't compare `{integer}` with `f64`\n  --> /tmp/tmpbb2ytidm.rs:20:21\n\
    \   |\n20 |         if distance < min_distance {\n   |                     ^ no\
    \ implementation for `{integer} < f64` and `{integer} > f64`\n   |\n   = help:\
    \ the trait `PartialOrd<f64>` is not implemented for `{integer}`\n   = help: the\
    \ following other types implement trait `PartialOrd<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbb2ytidm.rs:21:28\n   |\n8  |\
    \     let mut min_distance = numbers[0];\n   |                            ----------\
    \ expected due to this value\n...\n21 |             min_distance = distance;\n\
    \   |                            ^^^^^^^^ expected `f64`, found integer\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    fn get_closest_index(number: f64) -> usize {\n\
    \        (number as usize - numbers.iter().enumerate().filter(|(_, v)| *v == number).count()\
    \ as usize)\n    }\n\n    let mut min_index = get_closest_index(numbers.iter().min());\n\
    \    let mut max_index = get_closest_index(numbers.iter().max());\n\n    if max_index\
    \ < min_index {\n        (numbers.iter().min(), numbers.iter().max())\n    } else\
    \ {\n        (numbers.iter()\n            .zip(&numbers[min_index..max_index])\n\
    \            .min(|(_, x)| x.0)\n            .0,\n            numbers.iter()\n\
    \                .zip(&numbers[min_index..max_index])\n                .max(|(_,\
    \ x)| x.0)\n                .0,\n        )\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n --> /tmp/tmp8cm7zdoy.rs:9:28\n\
    \  |\n9 |         (number as usize - numbers.iter().enumerate().filter(|(_, v)|\
    \ *v == number).count() as usize)\n  |                            ^^^^^^^\n  |\n\
    \  = help: use the `|| { ... }` closure form instead\n\nwarning: unnecessary parentheses\
    \ around block return value\n --> /tmp/tmp8cm7zdoy.rs:9:9\n  |\n9 |         (number\
    \ as usize - numbers.iter().enumerate().filter(|(_, v)| *v == number).count()\
    \ as usize)\n  |         ^                                                   \
    \                                        ^\n  |\n  = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n  |\n9 -         (number as usize\
    \ - numbers.iter().enumerate().filter(|(_, v)| *v == number).count() as usize)\n\
    9 +         number as usize - numbers.iter().enumerate().filter(|(_, v)| *v ==\
    \ number).count() as usize\n  | \n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmp8cm7zdoy.rs:12:58\n     |\n12   |     let mut\
    \ min_index = get_closest_index(numbers.iter().min());\n     |               \
    \                                           ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8cm7zdoy.rs:12:43\n   |\n12 |\
    \     let mut min_index = get_closest_index(numbers.iter().min());\n   |     \
    \                                      ^^^^^^^^^^^^^^^^^^^^ expected `f64`, found\
    \ enum `Option`\n   |\n   = note: expected type `f64`\n              found enum\
    \ `Option<&f64>`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmp8cm7zdoy.rs:13:58\n     |\n13   |     let mut max_index = get_closest_index(num"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // We are going to try and find the closest number\
    \ from each\n    // number. If we find two numbers that are closer then they will\n\
    \    // be returned. If we only find one then we will return the smallest\n  \
    \  // one\n    let mut min_distance = numbers[0]\n    let mut smallest_number\
    \ = numbers[0]\n    for i in numbers.iter().rev() {\n        let distance = i\
    \ - smallest_number;\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            smallest_number = i;\n        }\n    }\n    (smallest_number,\
    \ min_distance)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpi31qg4o9.rs:12:38\n\
    \   |\n12 |     let mut min_distance = numbers[0]\n   |                      \
    \                ^ help: add `;` here\n13 |     let mut smallest_number = numbers[0]\n\
    \   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n \
    \ --> /tmp/tmpi31qg4o9.rs:13:41\n   |\n13 |     let mut smallest_number = numbers[0]\n\
    \   |                                         ^ help: add `;` here\n14 |     for\
    \ i in numbers.iter().rev() {\n   |     --- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi31qg4o9.rs:18:31\n   |\n13 |     let mut smallest_number\
    \ = numbers[0]\n   |                               ---------- expected due to\
    \ this value\n...\n18 |             smallest_number = i;\n   |               \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |             smallest_number = *i;\n   |             \
    \                  +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = numbers[0] as f64;\n \
    \   let mut best_index = numbers[0];\n    for (i, &n) in numbers.iter().enumerate()\
    \ {\n        let distance = n.abs() - min_distance;\n        if distance < best_distance\
    \ {\n            best_index = i;\n            best_distance = distance;\n    \
    \    }\n    }\n    (numbers[best_index], numbers[best_index + 1] as f64)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `best_distance` in this scope\n  --> /tmp/tmp_l41xm4q.rs:12:23\n\
    \   |\n12 |         if distance < best_distance {\n   |                      \
    \ ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `min_distance`\n\
    \nerror[E0425]: cannot find value `best_distance` in this scope\n  --> /tmp/tmp_l41xm4q.rs:14:13\n\
    \   |\n14 |             best_distance = distance;\n   |             ^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `min_distance`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_l41xm4q.rs:13:26\n   |\n9  |     let mut best_index\
    \ = numbers[0];\n   |                          ---------- expected due to this\
    \ value\n...\n13 |             best_index = i;\n   |                         \
    \ ^ expected `f64`, found `usize`\n   |\nhelp: you can cast a `usize` to an `f64`,\
    \ producing the floating point representation of the integer, rounded if necessary\n\
    \   |\n13 |             best_index = i as f64;\n   |                         \
    \   ++++++\n\nerror[E0277]: the type `[f64]` cannot be indexed by `f64`\n  -->\
    \ /tmp/tmp_l41xm4q.rs:17:6\n   |\n17 |     (numbers[best_index], numbers[best_index\
    \ + 1] as f64)\n   |      ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not\
    \ implemented for `f64`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<f64>` for `Vec<f64>`\n\nerror[E0277]: cannot add `{integer}` to `f64`\n\
    \  --> /tmp/tmp_l41xm4q.rs:17:46\n   |\n17 |     (numbers[best_index], numbers[best_index\
    \ + 1] as f64)\n   |                                              ^ no implementation\
    \ for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n      "
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    debug_assert!(numbers.len() >= 2);\n    let mut\
    \ min_d = std::f64::MAX;\n    let mut min_num = numbers[0];\n\n    for &d in &numbers[1..]\
    \ {\n        if d < min_d {\n            min_d = d;\n            min_num = *min_num;\n\
    \        }\n    }\n\n    (min_num, min_d)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpvl62m870.rs:15:23\n\
    \   |\n15 |             min_num = *min_num;\n   |                       ^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (mut lower, mut upper) = numbers.windows(2);\n\
    \    let mut current_lower = f64::MAX;\n    let mut current_upper = -f64::MAX;\n\
    \n    for &n in &numbers {\n        if n < lower {\n            lower = n;\n \
    \       }\n        if n > upper {\n            upper = n;\n        }\n    }\n\n\
    \    while !lower.is_nan() && !upper.is_nan() {\n        let delta_lower = lower\
    \ - current_lower;\n        let delta_upper = upper - current_upper;\n\n     \
    \   if delta_lower < delta_upper {\n            // Lower\n            current_lower\
    \ = lower;\n        } else {\n            // Upper\n            current_upper\
    \ = upper;\n        }\n        lower = numbers.remove(&lower);\n        upper\
    \ = numbers.remove(&upper);\n    }\n\n    (lower, upper)\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk7crc_b6.rs:8:9\n  |\n8 |\
    \     let (mut lower, mut upper) = numbers.windows(2);\n  |         ^^^^^^^^^^^^^^^^^^^^^^\
    \   ------------------ this expression has type `Windows<'_, f64>`\n  |      \
    \   |\n  |         expected struct `Windows`, found tuple\n  |\n  = note: expected\
    \ struct `Windows<'_, f64>`\n              found tuple `(_, _)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[1])\n    } else {\n        let mut smallest = numbers[0];\n        let\
    \ mut largest = numbers[0];\n        let mut i = 0;\n\n        while i < numbers.len()\
    \ {\n            smallest = numbers[i];\n\n            for j in i + 1 .. numbers.len()\
    \ {\n                largest = numbers[j];\n\n                if smallest < largest\
    \ {\n                    (smallest, largest)\n                } else {\n     \
    \               smallest = largest;\n                }\n            }\n\n    \
    \        i += 1;\n        }\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xl9hm1z.rs:22:21\n   |\n\
    21 | /                 if smallest < largest {\n22 | |                     (smallest,\
    \ largest)\n   | |                     ^^^^^^^^^^^^^^^^^^^ expected `()`, found\
    \ tuple\n23 | |                 } else {\n24 | |                     smallest\
    \ = largest;\n25 | |                 }\n   | |_________________- expected this\
    \ to be `()`\n   |\n   = note: expected unit type `()`\n                  found\
    \ tuple `(f64, f64)`\nhelp: you might have meant to return this value\n   |\n\
    22 |                     return (smallest, largest);\n   |                   \
    \  ++++++                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3xl9hm1z.rs:15:9\n\
    \   |\n7  |   fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \ |                                                  ---------- expected `(f64,\
    \ f64)` because of return type\n...\n15 | /         while i < numbers.len() {\n\
    16 | |             smallest = numbers[i];\n17 | |\n18 | |             for j in\
    \ i + 1 .. numbers.len() {\n...  |\n28 | |             i += 1;\n29 | |       \
    \  }\n   | |_________^ expected tuple, found `()`\n   |\n   = note:  expected\
    \ tuple `(f64, f64)`\n           found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0]; // smallest number\n\
    \    let mut largest = numbers[0]; // largest number\n    for number in numbers\
    \ {\n        if number < smallest {\n            largest = number;\n        }\
    \ else if number > largest {\n            smallest = number;\n        }\n    }\n\
    \    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp_thryzt4.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_difference = numbers[0].clone();\
    \ // smallest difference to numbers[0]\n    let mut largest_difference = numbers[0].clone();\
    \ // largest difference to numbers[0]\n    let mut smallest_index = numbers[0].clone();\
    \ // smallest number to numbers[0]\n    let mut largest_index = numbers[0].clone();\
    \ // largest number to numbers[0]\n    for n in numbers {\n        let d = n.f64()\
    \ - smallest_difference;\n        if d < smallest_difference {\n            smallest_difference\
    \ = d;\n            smallest_index = n;\n        }\n        let d = n.f64() -\
    \ largest_difference;\n        if d > largest_difference {\n            largest_difference\
    \ = d;\n            largest_index = n;\n        }\n    }\n    (smallest_index,\
    \ largest_index)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp0cblkd0r.rs:13:19\n   |\n13 |         let d = n.f64() -\
    \ smallest_difference;\n   |                   ^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `f64` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp0cblkd0r.rs:18:19\n   |\n18 |         let d = n.f64() - largest_difference;\n\
    \   |                   ^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = None;\n    let mut max = None;\n\
    \n    for &n in numbers {\n        if min == None || n < min {\n            min\
    \ = Some(n);\n        }\n        if max == None || n > max {\n            max\
    \ = Some(n);\n        }\n    }\n\n    (min, max).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi7ghbzn5.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `unwrap` found for tuple `(Option<_>, Option<_>)` in the current\
    \ scope\n  --> /tmp/tmpi7ghbzn5.rs:20:16\n   |\n20 |     (min, max).unwrap()\n\
    \   |                ^^^^^^ method not found in `(Option<_>, Option<_>)`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut best = numbers[0].min(numbers[1]);\n\
    \    let mut second = numbers[0].min(numbers[0]);\n    for n in numbers.iter().skip(1)\
    \ {\n        let mut c = n.min(&mut second);\n        second = n.min(&mut best);\n\
    \        best = c;\n    }\n    (best, second)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw1kuqjza.rs:11:27\n   |\n\
    11 |         let mut c = n.min(&mut second);\n   |                           ^^^^^^^^^^^\
    \ expected `f64`, found `&mut f64`\n   |\nhelp: consider removing the borrow\n\
    \   |\n11 -         let mut c = n.min(&mut second);\n11 +         let mut c =\
    \ n.min(second);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1kuqjza.rs:12:24\n\
    \   |\n12 |         second = n.min(&mut best);\n   |                        ^^^^^^^^^\
    \ expected `f64`, found `&mut f64`\n   |\nhelp: consider removing the borrow\n\
    \   |\n12 -         second = n.min(&mut best);\n12 +         second = n.min(best);\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_diff_index = -1;\n    let mut max_diff = 0;\n    let mut max_diff_index\
    \ = 0;\n    let mut max_number = numbers[0];\n    let mut min_number = numbers[0];\n\
    \n    for &n in &numbers[1..] {\n        let diff = (n - min_number).abs();\n\n\
    \        if diff < min_diff {\n            min_diff = diff;\n            min_diff_index\
    \ = -1;\n        }\n        if diff > max_diff {\n            max_diff = diff;\n\
    \            max_diff_index = 0;\n        }\n\n        if n == min_number {\n\
    \            min_diff_index = 0;\n            break;\n        }\n        if n\
    \ == max_number {\n            max_diff_index = 1;\n            break;\n     \
    \   }\n    }\n\n    (min_number, max_number)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx7t1kn98.rs:22:19\n   |\n\
    22 |         if diff > max_diff {\n   |                   ^^^^^^^^ expected `f64`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx7t1kn98.rs:23:24\n\
    \   |\n10 |     let mut max_diff = 0;\n   |                        - expected\
    \ due to this value\n...\n23 |             max_diff = diff;\n   |            \
    \            ^^^^ expected integer, found `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.size() > 1);\n    if numbers[0]\
    \ - numbers[1] > 0 {\n        (numbers[0], numbers[1])\n    } else {\n       \
    \ (numbers[1], numbers[0])\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `Vec<f64>` in the\
    \ current scope\n --> /tmp/tmpudpz_t7u.rs:8:21\n  |\n8 |     assert!(numbers.size()\
    \ > 1);\n  |                     ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpudpz_t7u.rs:9:34\n\
    \  |\n9 |     if numbers[0] - numbers[1] > 0 {\n  |                          \
    \        ^\n  |                                  |\n  |                      \
    \            expected `f64`, found integer\n  |                              \
    \    help: use a float literal: `0.0`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.is_empty() {\n        return (-1,\
    \ -1);\n    }\n    let mut min_distance = vec![numbers[0]; 2];\n    let mut min_dist_idx\
    \ = 2;\n    for (i, &number) in numbers.iter().enumerate() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        let distance = numbers.iter().map(|number|\
    \ number - numbers[i]).sum();\n        if distance < min_distance[0] {\n     \
    \       min_distance[0] = distance;\n            min_dist_idx = i;\n        }\n\
    \    }\n    (min_distance[min_dist_idx], numbers[min_dist_idx])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0vdtmwf2.rs:9:17\n  |\n9 |\
    \         return (-1, -1);\n  |                 ^^\n  |                 |\n  |\
    \                 expected `f64`, found integer\n  |                 help: use\
    \ a float literal: `-1.0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0vdtmwf2.rs:9:21\n\
    \  |\n9 |         return (-1, -1);\n  |                     ^^\n  |          \
    \           |\n  |                     expected `f64`, found integer\n  |    \
    \                 help: use a float literal: `-1.0`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest: usize = 0;\n    let mut largest\
    \ = 0;\n    for &num in numbers {\n        if smallest == 0 {\n            smallest\
    \ = largest = num;\n        }\n        else {\n            if num < smallest {\n\
    \                smallest = num;\n            }\n            else if num > largest\
    \ {\n                largest = num;\n            }\n        }\n    }\n    (numbers[smallest],\
    \ numbers[largest])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpisxez0p6.rs:10:9\n   |\n\
    10 |     for &num in numbers {\n   |         ^^^^    ------- this expression has\
    \ type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpisxez0p6.rs:12:24\n   |\n8  |     let mut smallest:\
    \ usize = 0;\n   |                       ----- expected due to this type\n...\n\
    12 |             smallest = largest = num;\n   |                        ^^^^^^^^^^^^^\
    \ expected `usize`, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest = numbers[0];\n    let mut smallest\
    \ = numbers[0];\n\n    for n in numbers {\n        if n < smallest {\n       \
    \     smallest = n;\n            closest = n;\n        } else if n > smallest\
    \ {\n            let mut mid = closest;\n            let mut delta = n - closest;\n\
    \            while delta >= smallest {\n                mid = numbers[(mid.index()\
    \ + 1) % numbers.len()];\n                delta = mid - closest;\n           \
    \ }\n            (closest, mid);\n        }\n    }\n    (closest, smallest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp18cq8zwq.rs:19:36\n   |\n19 |                 mid = numbers[(mid.index()\
    \ + 1) % numbers.len()];\n   |                                    ^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for &number in numbers {\n        if smallest > number {\n\
    \            smallest = number;\n        }\n        if largest < number {\n  \
    \          largest = number;\n        }\n    }\n    (smallest, largest)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppmaoxqy0.rs:10:9\n   |\n\
    10 |     for &number in numbers {\n   |         ^^^^^^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `number`\n  \
    \ |\n   = note:   expected type `f64`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.iter().enumerate().filter(|(_, n)| n\
    \ < numbers.len() && n >= 1).map(|(i, v)| v as f64 - numbers[i * 2] as f64).min_by(|a,\
    \ b| a.abs() < b.abs()).unwrap()\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm6sbcw1l.rs:8:52\n  |\n8 |\
    \     numbers.iter().enumerate().filter(|(_, n)| n < numbers.len() && n >= 1).map(|(i,\
    \ v)| v as f64 - numbers[i * 2] as f64).min_by(|a, b| ...\n  |               \
    \                                     ^^^^^^^^^^^^^ expected `&&f64`, found `usize`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpm6sbcw1l.rs:8:74\n  |\n8 |    \
    \ numbers.iter().enumerate().filter(|(_, n)| n < numbers.len() && n >= 1).map(|(i,\
    \ v)| v as f64 - numbers[i * 2] as f64).min_by(|a, b| ...\n  |               \
    \                                                           ^ expected `&&f64`,\
    \ found integer\n\nerror[E0308]: mismatched types\n --> /tmp/tmpm6sbcw1l.rs:8:138\n\
    \  |\n8 | ...bers[i * 2] as f64).min_by(|a, b| a.abs() < b.abs()).unwrap()\n \
    \ |                                      ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpm6sbcw1l.rs:8:5\n\
    \  |\n7 | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  |   \
    \                                             ---------- expected `(f64, f64)`\
    \ because of return type\n8 |     numbers.iter().enumerate().filter(|(_, n)| n\
    \ < numbers.len() && n >= 1).map(|(i, v)| v as f64 - numbers[i * 2] as f64).min_by(|a,\
    \ b| a.abs() < b.abs()).unwrap()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `f64`\n  |\n  = note: expected tuple `(f64, f64)`\n  \
    \            found type `f64`\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n\
    \ --> /tmp/tmpm6sbcw1l.rs:8:90\n  |\n8 |     numbers.iter().enumerate().filter(|(_,\
    \ n)| n < numbers.len() && n >= 1).map(|(i, v)| v as f64 - numbers[i * 2] as f64).min_by(|a,\
    \ b| ...\n  |                                                                \
    \                          -^^^^^^^\n  |                                     \
    \                                                     |\n  |                 \
    \                                                  "
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut low = numbers[0];\n    let mut high =\
    \ numbers[0];\n\n    for &n in numbers {\n        if n > high {\n            high\
    \ = n;\n        }\n        if n < low {\n            low = n;\n        }\n   \
    \ }\n    (low, high)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrbb33h_.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut best_d = std::f64::MAX;\n    let mut\
    \ best_elem = Vec::new();\n\n    for (i, &value) in numbers.iter().enumerate()\
    \ {\n        let d = value.dist(numbers[0]);\n        if d < best_d {\n      \
    \      best_d = d;\n            best_elem = vec![i];\n        }\n    }\n\n   \
    \ (numbers[best_elem[0]], numbers[best_elem[1]])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `dist` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpq1qzvcn7.rs:12:23\n   |\n12 |         let d = value.dist(numbers[0]);\n\
    \   |                       ^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff: f64 = numbers[0];\n    let\
    \ mut max_diff: f64 = numbers[0];\n    let mut index: usize = 0;\n\n    for number\
    \ in numbers {\n        if number < min_diff {\n            min_diff = number;\n\
    \        }\n\n        if number > max_diff {\n            max_diff = number;\n\
    \        }\n\n        let mut min_diff_num: f64 = number;\n        let mut max_diff_num:\
    \ f64 = number;\n\n        let mut current_index = index;\n\n        while current_index\
    \ != 0 {\n            if current_index > 0 && numbers[current_index - 1] < min_diff_num\
    \ {\n                min_diff_num = numbers[current_index - 1];\n            \
    \    let mut current_index = current_index - 1;\n            } else {\n      \
    \          break;\n            }\n        }\n\n        while current_index !=\
    \ numbers.len() - 1 {\n            if numbers[current_index + 1] < min_diff_num\
    \ {\n                min_diff_num = numbers[current_index + 1];\n            \
    \    let mut current_index = current_index + 1;\n            } else {\n      \
    \          break;\n            }\n        }\n\n        index = current_index;\n\
    \n        if min_diff_num > max_diff_num {\n            (min_diff_num, max_diff_num)\n\
    \        } else {\n            (max_diff_num, min_diff_num)\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprsaft6u3.rs:47:13\n   |\n\
    46 | /         if min_diff_num > max_diff_num {\n47 | |             (min_diff_num,\
    \ max_diff_num)\n   | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`,\
    \ found tuple\n48 | |         } else {\n49 | |             (max_diff_num, min_diff_num)\n\
    50 | |         }\n   | |_________- expected this to be `()`\n   |\n   = note:\
    \ expected unit type `()`\n                  found tuple `(f64, f64)`\nhelp: you\
    \ might have meant to return this value\n   |\n47 |             return (min_diff_num,\
    \ max_diff_num);\n   |             ++++++                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprsaft6u3.rs:49:13\n   |\n46 | /         if min_diff_num\
    \ > max_diff_num {\n47 | |             (min_diff_num, max_diff_num)\n48 | |  \
    \       } else {\n49 | |             (max_diff_num, min_diff_num)\n   | |    \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found tuple\n50 | |    \
    \     }\n   | |_________- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                  found tuple `(f64, f64)`\nhelp: you might\
    \ have meant to return this value\n   |\n49 |             return (max_diff_num,\
    \ min_diff_num);\n   |             ++++++                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprsaft6u3.rs:12:5\n   |\n7  |   fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                                            \
    \      ---------- expected `(f64, f64)` because of return type\n...\n12 | /  \
    \   for number in numbers {\n13 | |         if number < min_diff {\n14 | |   \
    \          min_diff = number;\n15 | |         }\n...  |\n50 | |         }\n51\
    \ | |     }\n   | |_____^ expected tuple, found `()`\n   |\n   = note:  expected\
    \ tuple `(f64, f64)`\n           found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ closest_elem = numbers[0];\n    let mut closest_idx = 1;\n\n    for x in &numbers[1..]\
    \ {\n        let diff = (*x - closest_elem).abs();\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            closest_elem = x;\n           \
    \ closest_idx = closest_idx + 1;\n        }\n    }\n\n    (closest_elem, closest_idx)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6nr9ua6g.rs:16:28\n   |\n\
    9  |     let mut closest_elem = numbers[0];\n   |                            ----------\
    \ expected due to this value\n...\n16 |             closest_elem = x;\n   |  \
    \                          ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |             closest_elem = *x;\n   |  \
    \                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6nr9ua6g.rs:21:20\n\
    \   |\n21 |     (closest_elem, closest_idx)\n   |                    ^^^^^^^^^^^\
    \ expected `f64`, found integer\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut mindiff = numbers[0] as f64;\n    let\
    \ mut mindiff = numbers[0] as f64;\n    for n in numbers.iter().skip(1) {\n  \
    \      match n {\n            n if n < mindiff =>\n                if n == mindiff\
    \ {\n                    mindiff = n;\n                    mindiff = n;\n    \
    \            } else {\n                    mindiff = n;\n                }\n \
    \           n if n > mindiff =>\n                if n == mindiff {\n         \
    \           mindiff = n;\n                } else {\n                    mindiff\
    \ = n;\n                }\n        }\n    }\n    (mindiff, mindiff)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjwx67zxn.rs:12:22\n   |\n\
    12 |             n if n < mindiff =>\n   |                      ^^^^^^^\n   |\
    \                      |\n   |                      expected `&f64`, found `f64`\n\
    \   |                      help: consider borrowing here: `&mindiff`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjwx67zxn.rs:14:31\n   |\n9  |     let mut mindiff\
    \ = numbers[0] as f64;\n   |                       ----------------- expected\
    \ due to this value\n...\n14 |                     mindiff = n;\n   |        \
    \                       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |                     mindiff = *n;\n   |             \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwx67zxn.rs:15:31\n\
    \   |\n9  |     let mut mindiff = numbers[0] as f64;\n   |                   \
    \    ----------------- expected due to this value\n...\n15 |                 \
    \    mindiff = n;\n   |                               ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \           mindiff = *n;\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjwx67zxn.rs:17:31\n   |\n9  |     let mut mindiff\
    \ = numbers[0] as f64;\n   |                       ----------------- expected\
    \ due to this value\n...\n17 |                     mindiff = n;\n   |        \
    \                       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |                     mindiff = *n;\n   |             \
    \                  +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpjwx67zxn.rs:13:22\n\
    \   |\n13 |                 if n == mindiff {\n   |                      ^^ no\
    \ implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>`\
    \ is not implemented for `&f64`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.sort();\n\n    let mut first_idx = vec![];\n\
    \    let mut second_idx = vec![];\n\n    let mut largest_different_idx = 0;\n\
    \    let mut second_largest_different_idx = 0;\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        let first_diff = f64::abs(numbers[i] - numbers[i + 1]);\n\n \
    \       if first_diff > largest_different_idx {\n            largest_different_idx\
    \ = first_diff;\n            first_idx.push(i);\n        }\n    }\n\n    for j\
    \ in 0..numbers.len() - 1 {\n        let second_diff = f64::abs(numbers[j] - numbers[first_idx[j]\
    \ + 1]);\n\n        if second_diff > second_largest_different_idx {\n        \
    \    second_largest_different_idx = second_diff;\n            second_idx.push(j);\n\
    \        }\n    }\n\n    (numbers[first_idx[0]], numbers[second_idx[0]])\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmptbp0mvwa.rs:8:13\n\
    \    |\n8   |     numbers.sort();\n    |             ^^^^ the trait `Ord` is not\
    \ implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptbp0mvwa.rs:19:25\n\
    \   |\n19 |         if first_diff > largest_different_idx {\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptbp0mvwa.rs:20:37\n   |\n13 |     let mut largest_different_idx\
    \ = 0;\n   |                                     - expected due to this value\n\
    ...\n20 |             largest_different_idx = first_diff;\n   |              \
    \                       ^^^^^^^^^^ expected integer, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptbp0mvwa.rs:28:26\n   |\n28 |         if second_diff\
    \ > second_largest_different_idx {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptbp0mvwa.rs:29:44\n\
    \   |\n14 |     let mut second_largest_different_idx = 0;\n   |              \
    \                              - expected due to this value\n...\n29 |       \
    \      second_largest_different_idx = second_diff;\n   |                     \
    \                       ^^^^^^^^^^^ expected integer, found `f64`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0.f64,\
    \ 0.f64);\n    }\n\n    let mut min_index = 0;\n    let mut max_index = numbers.len()\
    \ - 1;\n\n    let mut min_value = numbers[min_index];\n    let mut max_value =\
    \ numbers[max_index];\n\n    while min_index < max_index {\n        let mut mid_index\
    \ = min_index + (max_index - min_index) / 2;\n        let mut mid_value = numbers[mid_index];\n\
    \n        if mid_value < min_value {\n            min_value = mid_value;\n   \
    \         min_index = mid_index;\n        } else {\n            max_index = mid_index;\n\
    \            max_value = mid_value;\n        }\n    }\n\n    (min_value, max_value)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n --> /tmp/tmp2dq6k6wn.rs:9:19\n  |\n9 |         return (0.f64, 0.f64);\n\
    \  |                   ^^^\n\nerror[E0610]: `{integer}` is a primitive type and\
    \ therefore doesn't have fields\n --> /tmp/tmp2dq6k6wn.rs:9:26\n  |\n9 |     \
    \    return (0.f64, 0.f64);\n  |                          ^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0610`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_element = numbers.iter().min().unwrap();\n    let mut max_element =\
    \ numbers.iter().max().unwrap();\n    for i in numbers.iter().rev() {\n      \
    \  let distance = &i - &min_element;\n        if distance < min_distance {\n \
    \           min_element = i;\n            min_distance = distance;\n        }\n\
    \        let distance = &max_element - &i;\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            max_element = i;\n    \
    \    }\n    }\n    (min_element, max_element)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp7e3ad1to.rs:9:42\n\
    \     |\n9    |     let mut min_element = numbers.iter().min().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp7e3ad1to.rs:10:42\n\
    \     |\n10   |     let mut max_element = numbers.iter().max().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0369]: cannot subtract `&&f64` from `&&f64`\n  --> /tmp/tmp7e3ad1to.rs:12:27\n\
    \   |\n12 |         let distance = &i - &min_element;\n   |                  \
    \      -- ^ ------------ &&f64\n   |                        |\n   |          \
    \              &&f64\n\nerror[E0369]: cannot subtract `&&f64` from `&&f64`\n \
    \ --> /tmp/tmp7e3ad1to.rs:17:37\n   |\n17 |         let distance = &max_element\
    \ - &i;\n   |                        ------------ ^ -- &&f64\n   |           \
    \             |\n   |                        &&f64\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7e3ad1to.rs:23:6\n   |\n23 |     (min_element, max_element)\n\
    \   |      ^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |     (*min_element, max_element)\n   |  "
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for\
    \ number in numbers.iter() {\n        let distance = number.abs() - min_number;\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n        if number > max_number {\n\
    \            max_number = number;\n        }\n    }\n    (min_number, max_number)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprky8xm_t.rs:15:26\n   |\n\
    9  |     let mut min_number = numbers[0];\n   |                          ----------\
    \ expected due to this value\n...\n15 |             min_number = number;\n   |\
    \                          ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |             min_number = *number;\n   |\
    \                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprky8xm_t.rs:17:21\n\
    \   |\n17 |         if number > max_number {\n   |                     ^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&max_number`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprky8xm_t.rs:18:26\n   |\n10 |     let mut max_number\
    \ = numbers[0];\n   |                          ---------- expected due to this\
    \ value\n...\n18 |             max_number = number;\n   |                    \
    \      ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |             max_number = *number;\n   |             \
    \             +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    for n in numbers {\n        if min > n {\n            min =\
    \ n;\n        }\n        if max < n {\n            max = n;\n        }\n    }\n\
    \n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpu5q5gkrl.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_value = numbers[0];\n    let mut\
    \ max_value = numbers[0];\n\n    for &n in numbers {\n        if n < min_value\
    \ {\n            min_value = n;\n        }\n\n        if n > max_value {\n   \
    \         max_value = n;\n        }\n    }\n\n    (min_value, max_value)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaknv4f5i.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_difference = std::f64::MAX;\n\
    \    let mut second_smallest_difference = std::f64::MAX;\n    for i in numbers.iter()\
    \ {\n        if i >= smallest_difference {\n            smallest_difference =\
    \ i;\n        }\n        if second_smallest_difference < i {\n            second_smallest_difference\
    \ = i;\n        }\n    }\n    (smallest_difference, second_smallest_difference)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps785fius.rs:11:17\n   |\n\
    11 |         if i >= smallest_difference {\n   |                 ^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 expected `&f64`, found `f64`\n \
    \  |                 help: consider borrowing here: `&smallest_difference`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmps785fius.rs:12:35\n   |\n8  |  \
    \   let mut smallest_difference = std::f64::MAX;\n   |                       \
    \            ------------- expected due to this value\n...\n12 |             smallest_difference\
    \ = i;\n   |                                   ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |             smallest_difference\
    \ = *i;\n   |                                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps785fius.rs:14:41\n   |\n14 |         if second_smallest_difference\
    \ < i {\n   |                                         ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |         if\
    \ second_smallest_difference < *i {\n   |                                    \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps785fius.rs:15:42\n \
    \  |\n9  |     let mut second_smallest_difference = std::f64::MAX;\n   |     \
    \                                     ------------- expected due to this value\n\
    ...\n15 |             second_smallest_difference = i;\n   |                  \
    \                        ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |             second_smallest_difference\
    \ = *i;\n   |                                          +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = f64::MAX;\n    let mut max = 0.0;\n\
    \    for n in numbers {\n        let d = n - min;\n        if d < 0.0 {\n    \
    \        d = 0.0;\n        }\n        if d > f64::MAX as f64 {\n            d\
    \ = f64::MAX;\n        }\n        if d < min {\n            min = d;\n       \
    \ }\n        if d > max {\n            max = d;\n        }\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `d`\n  --> /tmp/tmpx5zvbesf.rs:13:13\n\
    \   |\n11 |         let d = n - min;\n   |             -\n   |             |\n\
    \   |             first assignment to `d`\n   |             help: consider making\
    \ this binding mutable: `mut d`\n12 |         if d < 0.0 {\n13 |             d\
    \ = 0.0;\n   |             ^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror[E0384]: cannot assign twice to immutable variable `d`\n  --> /tmp/tmpx5zvbesf.rs:16:13\n\
    \   |\n11 |         let d = n - min;\n   |             -\n   |             |\n\
    \   |             first assignment to `d`\n   |             help: consider making\
    \ this binding mutable: `mut d`\n...\n16 |             d = f64::MAX;\n   |   \
    \          ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_element = numbers[0];\n    let\
    \ mut second_smallest_element = numbers[0];\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        if i < numbers.len() - 1 {\n            let dist = f64::distance(n\
    \ as f64, numbers[i + 1] as f64);\n            if dist < smallest_element {\n\
    \                smallest_element = n as f64;\n            }\n            if dist\
    \ < second_smallest_element {\n                second_smallest_element = n as\
    \ f64;\n            }\n        }\n    }\n    (smallest_element, second_smallest_element)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `distance` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpxvoc_357.rs:12:29\n   |\n12 |\
    \             let dist = f64::distance(n as f64, numbers[i + 1] as f64);\n   |\
    \                             ^^^^^^^^ function or associated item not found in\
    \ `f64`\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n  --> /tmp/tmpxvoc_357.rs:12:38\n\
    \   |\n12 |             let dist = f64::distance(n as f64, numbers[i + 1] as f64);\n\
    \   |                                      -^^^^^^^\n   |                    \
    \                  |\n   |                                      cannot cast `&f64`\
    \ as `f64`\n   |                                      help: dereference the expression:\
    \ `*n`\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n  --> /tmp/tmpxvoc_357.rs:14:36\n\
    \   |\n14 |                 smallest_element = n as f64;\n   |               \
    \                     -^^^^^^^\n   |                                    |\n  \
    \ |                                    cannot cast `&f64` as `f64`\n   |     \
    \                               help: dereference the expression: `*n`\n\nerror[E0606]:\
    \ casting `&f64` as `f64` is invalid\n  --> /tmp/tmpxvoc_357.rs:17:43\n   |\n\
    17 |                 second_smallest_element = n as f64;\n   |               \
    \                            -^^^^^^^\n   |                                  \
    \         |\n   |                                           cannot cast `&f64`\
    \ as `f64`\n   |                                           help: dereference the\
    \ expression: `*n`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0606.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_difference = numbers[0] as f64;\n\
    \    let mut largest_difference = numbers[0] as f64;\n    let mut smallest_element\
    \ = numbers[0] as f64;\n    let mut largest_element = numbers[0] as f64;\n   \
    \ let mut smallest_number = numbers[0] as f64;\n    let mut largest_number = numbers[0]\
    \ as f64;\n    for i in 1..numbers.len() {\n        let difference = numbers[i]\
    \ - numbers[i - 1];\n        if smallest == largest {\n            if difference\
    \ < smallest_difference {\n                smallest_difference = difference;\n\
    \                smallest_element = numbers[i - 1];\n                smallest_number\
    \ = numbers[i - 1];\n            }\n            if difference > largest_difference\
    \ {\n                largest_difference = difference;\n                largest_element\
    \ = numbers[i - 1];\n                largest_number = numbers[i - 1];\n      \
    \      }\n        } else {\n            if difference < smallest_difference {\n\
    \                smallest_difference = difference;\n                smallest_element\
    \ = numbers[i - 1];\n                smallest_number = numbers[i - 1];\n     \
    \       }\n            if difference > largest_difference {\n                largest_difference\
    \ = difference;\n                largest_element = numbers[i - 1];\n         \
    \       largest_number = numbers[i - 1];\n            }\n        }\n    }\n  \
    \  (smallest_element, largest_element)\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `smallest` in this scope\n  --> /tmp/tmp0zsj6ar2.rs:16:12\n\
    \   |\n16 |         if smallest == largest {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `largest` in this scope\n \
    \ --> /tmp/tmp0zsj6ar2.rs:16:24\n   |\n16 |         if smallest == largest {\n\
    \   |                        ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    for number in numbers {\n        if number < min {\n      \
    \      min = number;\n        }\n        if number > max {\n            max =\
    \ number;\n        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpal_cwe2w.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    debug_assert!(numbers.len() >= 2);\n    let smallest\
    \ = numbers[0] + f64::EPSILON;\n    let mut result = numbers[0] + f64::EPSILON;\n\
    \    for i in 1..numbers.len() {\n        let difference = numbers[i] - result;\n\
    \        if difference < smallest {\n            smallest = difference;\n    \
    \        result = numbers[i];\n        }\n    }\n    (result, smallest)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `smallest`\n  -->\
    \ /tmp/tmpx6wca3m1.rs:14:13\n   |\n9  |     let smallest = numbers[0] + f64::EPSILON;\n\
    \   |         --------\n   |         |\n   |         first assignment to `smallest`\n\
    \   |         help: consider making this binding mutable: `mut smallest`\n...\n\
    14 |             smallest = difference;\n   |             ^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::INFINITY;\n    let\
    \ mut min_element = numbers[0];\n    for num in numbers {\n        let dist =\
    \ abs(num - min_element);\n        if dist < min_dist {\n            min_dist\
    \ = dist;\n            min_element = num;\n        }\n    }\n    (min_element,\
    \ min_dist)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpcof5tnkq.rs:11:20\n\
    \   |\n11 |         let dist = abs(num - min_element);\n   |                 \
    \   ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    debug_assert!(numbers.size() >= 2);\n    let\
    \ mut min_diff = std::f64::MAX;\n    let mut min = numbers[0];\n    let mut max\
    \ = numbers[0];\n    for i in numbers[1..] {\n        let d = f64::abs(i - min);\n\
    \        if d < min_diff {\n            min = i;\n        }\n        if d > max_diff\
    \ {\n            max = i;\n        }\n    }\n    (min, max)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_diff` in this scope\n  --> /tmp/tmprnu3s_8y.rs:17:16\n\
    \   |\n17 |         if d > max_diff {\n   |                ^^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_diff`\n\nerror[E0599]: no method named\
    \ `size` found for struct `Vec<f64>` in the current scope\n --> /tmp/tmprnu3s_8y.rs:8:27\n\
    \  |\n8 |     debug_assert!(numbers.size() >= 2);\n  |                       \
    \    ^^^^ help: there is an associated function with a similar name: `resize`\n\
    \nerror[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmprnu3s_8y.rs:12:14\n   |\n12 |     for i in numbers[1..]\
    \ {\n   |              ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n12 |     for i in &numbers[1..]\
    \ {\n   |              +\n12 |     for i in &mut numbers[1..] {\n   |        \
    \      ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmprnu3s_8y.rs:12:14\n\
    \   |\n12 |     for i in numbers[1..] {\n   |              ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n12 |     for i in &numbers[1..] {\n   |              +\n12 |     for i in\
    \ &mut numbers[1..] {\n   |              ++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = vec![];\n    let mut min_element\
    \ = vec![];\n\n    for &number in numbers {\n        for &dist in min_dist {\n\
    \            if number - dist < 0 {\n                min_dist.push(dist);\n  \
    \              min_element.push(number);\n                break;\n           \
    \ }\n        }\n    }\n\n    let mut max_dist = vec![];\n    let mut max_element\
    \ = vec![];\n\n    for &dist in min_dist {\n        for &number in min_element\
    \ {\n            if number + dist > 0 {\n                max_dist.push(dist);\n\
    \                max_element.push(number);\n                break;\n         \
    \   }\n        }\n    }\n\n    (min_element.len(), max_element.len())\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9cam75go.rs:11:9\n   |\n\
    11 |     for &number in numbers {\n   |         ^^^^^^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `number`\n  \
    \ |\n   = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9cam75go.rs:14:31\n   |\n14 |              \
    \   min_dist.push(dist);\n   |                               ^^^^\n   |      \
    \                         |\n   |                               cyclic type of\
    \ infinite size\n   |                               help: consider borrowing here:\
    \ `&dist`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9cam75go.rs:34:6\n\
    \   |\n34 |     (min_element.len(), max_element.len())\n   |      ^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `usize`\n   |\nhelp: you can cast a `usize` to an `f64`,\
    \ producing the floating point representation of the integer, rounded if necessary\n\
    \   |\n34 |     (min_element.len() as f64, max_element.len())\n   |          \
    \              ++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9cam75go.rs:34:25\n\
    \   |\n34 |     (min_element.len(), max_element.len())\n   |                 \
    \        ^^^^^^^^^^^^^^^^^ expected `f64`, found `usize`\n   |\nhelp: you can\
    \ cast a `usize` to an `f64`, producing the floating point representation of the\
    \ integer, rounded if necessary\n   |\n34 |     (min_element.len(), max_element.len()\
    \ as f64)\n   |                                           ++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0].clone();\n    let\
    \ mut largest = numbers[0].clone();\n\n    for i in 1..numbers.len() {\n     \
    \   if numbers[i - 1] <= numbers[i] {\n            if numbers[i - 1] > largest\
    \ {\n                largest = numbers[i - 1];\n            }\n\n            if\
    \ numbers[i - 1] < smallest {\n                smallest = numbers[i - 1];\n  \
    \          }\n        } else {\n            if numbers[i - 1] < largest {\n  \
    \              largest = numbers[i - 1];\n            }\n\n            if numbers[i\
    \ - 1] > smallest {\n                smallest = numbers[i - 1];\n            }\n\
    \        }\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 4.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp3u2lh1d8.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // The smallest distance between any two given\
    \ numbers\n    let mut closest_distance = std::f64::MAX;\n    // The two closest\
    \ numbers to the first given number\n    let mut closest_one: f64 = std::f64::MAX;\n\
    \    // The two closest numbers to the second given number\n    let mut closest_two:\
    \ f64 = std::f64::MAX;\n    // Look for two numbers in the vector whose distance\
    \ is smallest to each other\n    for &i in numbers {\n        closest_distance\
    \ = i.abs();\n        if closest_distance < closest_distance {\n            closest_one\
    \ = i;\n        }\n        if closest_distance < closest_distance {\n        \
    \    closest_two = i;\n        }\n    }\n\n    (closest_one, closest_two)\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyjkddnmb.rs:15:9\n   |\n\
    15 |     for &i in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_element = numbers[0];\n    let mut\
    \ max_element = numbers[0];\n    for element in numbers {\n        if element\
    \ < min_element {\n            min_element = element;\n        }\n        if element\
    \ > max_element {\n            max_element = element;\n        }\n    }\n    (min_element,\
    \ max_element)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmprvu3n0eh.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        assert!(false,\
    \ \"Must have at least two values to find closest to\");\n    }\n\n    let mut\
    \ index = 0;\n    let mut min_dist = std::f64::MAX;\n    let mut min_number =\
    \ numbers[index];\n\n    while index < numbers.len() {\n        let dist = numbers[index]\
    \ - min_number;\n        if dist < min_dist {\n            min_number = numbers[index];\n\
    \            min_dist = dist;\n        }\n        index += 1;\n    }\n    (min_number,\
    \ min_dist)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 0.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp0mt51gg5.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    use std::cmp::min;\n\n    numbers.windows(2)\n\
    \        .min_by(|a, b| a.partial_cmp(b))\n        .unwrap_or_else(|| {\n    \
    \        assert!(numbers[numbers.size() - 2].partial_cmp(&numbers[numbers.size()\
    \ - 1]) <= 0);\n            numbers[numbers.size() - 2]\n        })\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::min`\n --> /tmp/tmput9b96xe.rs:8:9\n\
    \  |\n8 |     use std::cmp::min;\n  |         ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmput9b96xe.rs:11:24\n\
    \   |\n11 |         .min_by(|a, b| a.partial_cmp(b))\n   |                   \
    \     ^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found enum `Option`\n\
    \   |\n   = note: expected enum `std::cmp::Ordering`\n              found enum\
    \ `Option<std::cmp::Ordering>`\n\nerror[E0599]: no method named `size` found for\
    \ struct `Vec<f64>` in the current scope\n  --> /tmp/tmput9b96xe.rs:13:37\n  \
    \ |\n13 |             assert!(numbers[numbers.size() - 2].partial_cmp(&numbers[numbers.size()\
    \ - 1]) <= 0);\n   |                                     ^^^^ help: there is an\
    \ associated function with a similar name: `resize`\n\nerror[E0599]: no method\
    \ named `size` found for struct `Vec<f64>` in the current scope\n  --> /tmp/tmput9b96xe.rs:13:78\n\
    \   |\n13 |             assert!(numbers[numbers.size() - 2].partial_cmp(&numbers[numbers.size()\
    \ - 1]) <= 0);\n   |                                                         \
    \                     ^^^^ help: there is an associated function with a similar\
    \ name: `resize`\n\nerror[E0599]: no method named `size` found for struct `Vec<f64>`\
    \ in the current scope\n  --> /tmp/tmput9b96xe.rs:14:29\n   |\n14 |          \
    \   numbers[numbers.size() - 2]\n   |                             ^^^^ help: there\
    \ is an associated function with a similar name: `resize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmput9b96xe.rs:10:5\n   |\n7  |   fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                                            \
    \      ---------- expected `(f64, f64)` because of return type\n...\n10 | /  \
    \   numbers.windows(2)\n11 | |         .min_by(|a, b| a.partial_cmp(b))\n12 |\
    \ |         .unwrap_or_else(|| {\n13 | |             assert!(numbers[numbers.size()\
    \ - 2].partial_cmp(&numbers[numbers.size() - 1]) <= 0);\n14 | |             numbers[numbers.size()\
    \ - 2]\n15 | |         })\n   | |__________^ e"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    fn compare(number1: f64, number2: f64) -> Ordering\
    \ {\n        Ordering::Less if number1 < number2 else Ordering::Greater\n    }\n\
    \n    if numbers.len() <= 1 {\n        (0, 1)\n    } else {\n        let mut smaller\
    \ = numbers[0];\n        let mut larger = numbers[0];\n\n        for number in\
    \ numbers.iter().skip(1) {\n            let ordering = compare(number, smaller);\n\
    \n            if ordering == Ordering::Less {\n                smaller = number;\n\
    \            } else {\n                larger = number;\n            }\n     \
    \   }\n\n        (smaller, larger)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n --> /tmp/tmptq0itqj8.rs:9:24\n  |\n9 |         Ordering::Less\
    \ if number1 < number2 else Ordering::Greater\n  |                        ^^ expected\
    \ one of 8 possible tokens\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmptq0itqj8.rs:21:28\n   |\n21 |             if\
    \ ordering == Ordering::Less {\n   |                            ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0412]: cannot find type `Ordering` in this\
    \ scope\n --> /tmp/tmptq0itqj8.rs:8:47\n  |\n8 |     fn compare(number1: f64,\
    \ number2: f64) -> Ordering {\n  |                                           \
    \    ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing one of these\
    \ items\n  |\n1 | use std::cmp::Ordering;\n  |\n1 | use std::sync::atomic::Ordering;\n\
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptq0itqj8.rs:13:10\n   |\n\
    13 |         (0, 1)\n   |          ^\n   |          |\n   |          expected\
    \ `f64`, found integer\n   |          help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptq0itqj8.rs:13:13\n   |\n13 |         (0, 1)\n\
    \   |             ^\n   |             |\n   |             expected `f64`, found\
    \ integer\n   |             help: use a float literal: `1.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptq0itqj8.rs:19:36\n   |\n19 |             let\
    \ ordering = compare(number, smaller);\n   |                                 \
    \   ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n19 |             let ordering = compare(*number, smaller);\n \
    \  |                                    +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptq0itqj8.rs:22:27\n   |\n15 |         let mut smaller = numbers[0];\n\
    \   |                           ---------- expected due to this value\n...\n22\
    \ |                 smaller = number;\n   |                           ^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n22\
    \ |                 smaller = *number;\n   |                     "
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_num = numbers[0];\n    let mut\
    \ largest_num = numbers[0];\n\n    for num in numbers {\n        if num < smallest_num\
    \ {\n            smallest_num = num;\n        }\n        if num > largest_num\
    \ {\n            largest_num = num;\n        }\n    }\n\n    (smallest_num, largest_num)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpi3m47est.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min: f64;\n    let mut max: f64;\n  \
    \  for i in numbers.iter() {\n        let mut min_diff = std::f64::MAX;\n    \
    \    for j in numbers.iter() {\n            let diff = (*i - j).abs();\n     \
    \       if diff < min_diff {\n                min_diff = diff;\n             \
    \   min = i;\n                max = j;\n            }\n        }\n    }\n    (min,\
    \ max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpee6i2dan.rs:16:23\n   |\n\
    8  |     let mut min: f64;\n   |                  --- expected due to this type\n\
    ...\n16 |                 min = i;\n   |                       ^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |    \
    \             min = *i;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpee6i2dan.rs:17:23\n   |\n9  |     let mut max: f64;\n \
    \  |                  --- expected due to this type\n...\n17 |               \
    \  max = j;\n   |                       ^ expected `f64`, found `&f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n17 |                 max = *j;\n\
    \   |                       +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n\n    for i in numbers {\n        if i < smallest {\n       \
    \     smallest = i;\n        }\n        if i > largest {\n            largest\
    \ = i;\n        }\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpp9140h72.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_val = numbers[0];\n    let mut max_val\
    \ = numbers[0];\n    let mut min_index = -1;\n    let mut max_index = -1;\n  \
    \  for &val in &numbers {\n        if val < min_val {\n            min_val = val;\n\
    \            min_index = 0;\n        }\n        if val > max_val {\n         \
    \   max_val = val;\n            max_index = i;\n        }\n    }\n    (min_val,\
    \ max_val, min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpd5u968qn.rs:19:25\n\
    \   |\n19 |             max_index = i;\n   |                         ^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpd5u968qn.rs:7:48\n\
    \  |\n7 | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  |   \
    \ ---------------------                       ^^^^^^^^^^ expected tuple, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note:  expected tuple `(f64, f64)`\n          found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    for i in numbers.iter() {\n        if i < min {\n         \
    \   min = i;\n        }\n        if i > max {\n            max = i;\n        }\n\
    \    }\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnih_4t03.rs:11:16\n   |\n\
    11 |         if i < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnih_4t03.rs:12:19\n\
    \   |\n8  |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n12 |             min = i;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n12 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnih_4t03.rs:14:16\n   |\n14 |         if i > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnih_4t03.rs:15:19\n   |\n9  |     let mut max\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n15 |             max = i;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \   max = *i;\n   |                   +\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_distance = std::f64::MAX;\n\
    \    let mut largest_distance = 0;\n\n    for i in numbers {\n        let distance\
    \ = i - numbers.iter().min().unwrap();\n        if distance < smallest_distance\
    \ {\n            smallest_distance = distance;\n        }\n        if distance\
    \ > largest_distance {\n            largest_distance = distance;\n        }\n\
    \    }\n\n    (smallest_distance, largest_distance)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjewr55ym.rs:12:43\n\
    \     |\n12   |         let distance = i - numbers.iter().min().unwrap();\n  \
    \   |                                           ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjewr55ym.rs:16:23\n   |\n16 |\
    \         if distance > largest_distance {\n   |                       ^^^^^^^^^^^^^^^^\
    \ expected `f64`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjewr55ym.rs:17:32\n\
    \   |\n9  |     let mut largest_distance = 0;\n   |                          \
    \      - expected due to this value\n...\n17 |             largest_distance =\
    \ distance;\n   |                                ^^^^^^^^ expected integer, found\
    \ `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjewr55ym.rs:21:25\n \
    \  |\n21 |     (smallest_distance, largest_distance)\n   |                   \
    \      ^^^^^^^^^^^^^^^^ expected `f64`, found integer\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let mut mid = (smallest + largest) / 2;\n        if numbers[i] >\
    \ mid {\n            largest = mid;\n        } else {\n            smallest =\
    \ mid;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n  --> /tmp/tmp_6aaufsq.rs:12:44\n\
    \   |\n12 |         let mut mid = (smallest + largest) / 2;\n   |            \
    \                                ^ no implementation for `f64 / {integer}`\n \
    \  |\n   = help: the trait `Div<{integer}>` is not implemented for `f64`\n   =\
    \ help: the following other types implement trait `Div<Rhs>`:\n             <&'a\
    \ f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128\
    \ as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as\
    \ Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n12 |         let\
    \ mut mid = (smallest + largest) / 2.0;\n   |                                \
    \               ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut a =\
    \ numbers[0];\n    let mut b = numbers[0];\n    let mut dist = std::f64::MAX;\n\
    \    let mut index = 0;\n    for (i, &mut number) in numbers.iter_mut().zip(&mut\
    \ numbers[index..]) {\n        if number < a {\n            a = number;\n    \
    \        index = i;\n        }\n        if number > b {\n            b = number;\n\
    \            index = i;\n        }\n        dist = std::f64::MAX;\n    }\n   \
    \ (index as f64, a as f64)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1fjuc04.rs:16:21\n   |\n\
    12 |     let mut index = 0;\n   |                     - expected due to this value\n\
    ...\n16 |             index = i;\n   |                     ^ expected `usize`,\
    \ found `&mut f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy1fjuc04.rs:20:21\n\
    \   |\n12 |     let mut index = 0;\n   |                     - expected due to\
    \ this value\n...\n20 |             index = i;\n   |                     ^ expected\
    \ `usize`, found `&mut f64`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_val: f64 = numbers[0];\n    let mut\
    \ min_idx: usize = 0;\n    let mut max_val: f64 = numbers[0];\n    let mut max_idx:\
    \ usize = 0;\n\n    for i in 1..numbers.len() {\n        if numbers[i] < min_val\
    \ {\n            min_val = numbers[i];\n            min_idx = i;\n        } else\
    \ {\n            if numbers[i] > max_val {\n                max_val = numbers[i];\n\
    \                max_idx = i;\n            }\n        }\n    }\n\n    (min_val,\
    \ numbers[min_idx], max_val, numbers[max_idx])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj7t3z47m.rs:25:5\n   |\n\
    7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |       \
    \                                         ---------- expected `(f64, f64)` because\
    \ of return type\n...\n25 |     (min_val, numbers[min_idx], max_val, numbers[max_idx])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected a tuple\
    \ with 2 elements, found one with 4 elements\n   |\n   = note: expected tuple\
    \ `(f64, f64)`\n              found tuple `(f64, f64, f64, f64)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut index = 0;\n    let mut min_dist = numbers.len();\n\
    \    while index < numbers.len() {\n        let dist = dist(numbers[index], numbers[index\
    \ + 1], numbers[min_dist]);\n        if dist < min_dist {\n            min_dist\
    \ = dist;\n        }\n        index += 1\n    }\n\n    (numbers[min_dist], numbers[min_dist\
    \ + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `dist` in this scope\n  --> /tmp/tmpa76cip_9.rs:11:20\n\
    \   |\n11 |         let dist = dist(numbers[index], numbers[index + 1], numbers[min_dist]);\n\
    \   |                    ^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_delta = numbers[0];\n    let mut\
    \ min_number = numbers[1];\n    let mut max_number = numbers[0];\n    for i in\
    \ &numbers[1..] {\n        if *i < min_delta {\n            min_delta = *i;\n\
    \            min_number = i;\n        } else {\n            *i -= min_delta;\n\
    \        }\n        if *i > *max_number {\n            max_number = i;\n     \
    \   }\n    }\n    (min_number, max_number)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpueqwwdvq.rs:14:26\n   |\n\
    9  |     let mut min_number = numbers[1];\n   |                          ----------\
    \ expected due to this value\n...\n14 |             min_number = i;\n   |    \
    \                      ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             min_number = *i;\n   |                  \
    \        +\n\nerror[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpueqwwdvq.rs:18:17\n\
    \   |\n18 |         if *i > *max_number {\n   |                 ^^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpueqwwdvq.rs:19:26\n   |\n10 |  \
    \   let mut max_number = numbers[0];\n   |                          ----------\
    \ expected due to this value\n...\n19 |             max_number = i;\n   |    \
    \                      ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n19 |             max_number = *i;\n   |                  \
    \        +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut best = Some(numbers[0]);\n    let mut\
    \ worst = Some(numbers[0]);\n    for num in numbers.iter().rev() {\n        if\
    \ num > best.as_ref() {\n            best = Some(num);\n        } else if num\
    \ < worst.as_ref() {\n            worst = Some(num);\n        }\n    }\n    (best.as_ref(),\
    \ worst.as_ref())\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77du5644.rs:11:18\n   |\n\
    11 |         if num > best.as_ref() {\n   |                  ^^^^^^^^^^^^^ expected\
    \ `&f64`, found enum `Option`\n   |\n   = note: expected reference `&f64`\n  \
    \                 found enum `Option<&f64>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp77du5644.rs:12:25\n   |\n12 |             best = Some(num);\n \
    \  |                         ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n12 |             best = Some(*num);\n   |  \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77du5644.rs:13:25\n\
    \   |\n13 |         } else if num < worst.as_ref() {\n   |                   \
    \      ^^^^^^^^^^^^^^ expected `&f64`, found enum `Option`\n   |\n   = note: expected\
    \ reference `&f64`\n                   found enum `Option<&f64>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77du5644.rs:14:26\n   |\n14 |             worst\
    \ = Some(num);\n   |                          ^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             worst =\
    \ Some(*num);\n   |                          +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp77du5644.rs:17:6\n   |\n17 |     (best.as_ref(), worst.as_ref())\n\
    \   |      ^^^^^^^^^^^^^ expected `f64`, found enum `Option`\n   |\n   = note:\
    \ expected type `f64`\n              found enum `Option<&f64>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77du5644.rs:17:21\n   |\n17 |     (best.as_ref(),\
    \ worst.as_ref())\n   |                     ^^^^^^^^^^^^^^ expected `f64`, found\
    \ enum `Option`\n   |\n   = note: expected type `f64`\n              found enum\
    \ `Option<&f64>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers_iter = numbers.iter().enumerate().rev();\n\
    \    let mut index = 0;\n    let mut min = f64::MAX;\n    let mut max = f64::MIN;\n\
    \n    while let Some((i, number)) = numbers_iter.next() {\n        if number <\
    \ min {\n            min = number;\n            index = i;\n        } else if\
    \ number > max {\n            max = number;\n        }\n    }\n\n    (numbers[index],\
    \ numbers[index + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9rmf2_ni.rs:14:21\n   |\n\
    14 |         if number < min {\n   |                     ^^^\n   |           \
    \          |\n   |                     expected `&f64`, found `f64`\n   |    \
    \                 help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9rmf2_ni.rs:15:19\n   |\n10 |     let mut min = f64::MAX;\n\
    \   |                   -------- expected due to this value\n...\n15 |       \
    \      min = number;\n   |                   ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |             min = *number;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rmf2_ni.rs:17:28\n\
    \   |\n17 |         } else if number > max {\n   |                           \
    \ ^^^\n   |                            |\n   |                            expected\
    \ `&f64`, found `f64`\n   |                            help: consider borrowing\
    \ here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rmf2_ni.rs:18:19\n\
    \   |\n11 |     let mut max = f64::MIN;\n   |                   -------- expected\
    \ due to this value\n...\n18 |             max = number;\n   |               \
    \    ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n18 |             max = *number;\n   |                   +\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_one = numbers[0];\n    let mut\
    \ second_smallest_one = numbers[0];\n    for &x in numbers {\n        if x < smallest_one\
    \ {\n            smallest_one = x;\n        }\n        if x > second_smallest_one\
    \ {\n            second_smallest_one = x;\n        }\n    }\n    (smallest_one,\
    \ second_smallest_one)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqfwn5cqj.rs:10:9\n   |\n\
    10 |     for &x in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0] as f64;\n    let\
    \ mut largest = numbers[0] as f64;\n\n    for number in numbers.iter().skip(1)\
    \ {\n        if number < smallest {\n            smallest = number;\n        }\n\
    \        if number > largest {\n            largest = number;\n        }\n   \
    \ }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaeeocj_c.rs:12:21\n   |\n\
    12 |         if number < smallest {\n   |                     ^^^^^^^^\n   | \
    \                    |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&smallest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaeeocj_c.rs:13:24\n   |\n8  |     let mut smallest\
    \ = numbers[0] as f64;\n   |                        ----------------- expected\
    \ due to this value\n...\n13 |             smallest = number;\n   |          \
    \              ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |             smallest = *number;\n   |               \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaeeocj_c.rs:15:21\n\
    \   |\n15 |         if number > largest {\n   |                     ^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&largest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaeeocj_c.rs:16:23\n   |\n9  |     let mut largest\
    \ = numbers[0] as f64;\n   |                       ----------------- expected\
    \ due to this value\n...\n16 |             largest = number;\n   |           \
    \            ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             largest = *number;\n   |                \
    \       +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut best_idx = numbers.iter().min().unwrap();\n\
    \    let mut worst_idx = numbers.iter().max().unwrap();\n\n    let mut new_numbers\
    \ = Vec::new();\n\n    for idx in 0..numbers.len() {\n        let (smallest_idx,\
    \ largest_idx) = find_best_match(&numbers, idx, best_idx, worst_idx);\n      \
    \  new_numbers.push(numbers[smallest_idx]);\n        new_numbers.push(numbers[largest_idx]);\n\
    \n        best_idx = largest_idx;\n        worst_idx = smallest_idx;\n    }\n\n\
    \    (new_numbers[0], new_numbers[1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_best_match` in this scope\n  -->\
    \ /tmp/tmp5w3k_mlc.rs:14:43\n   |\n14 |         let (smallest_idx, largest_idx)\
    \ = find_best_match(&numbers, idx, best_idx, worst_idx);\n   |               \
    \                            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5w3k_mlc.rs:8:39\n\
    \     |\n8    |     let mut best_idx = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5w3k_mlc.rs:9:40\n\
    \     |\n9    |     let mut worst_idx = numbers.iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp5w3k_mlc.rs:16:26\n\
    \   |\n16 |         new_numbers.push(numbers[largest_idx]);\n   |            \
    \              ^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented\
    \ for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&f6"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., numbers[0]);\n\
    \    }\n    let mut min_dist = numbers[0] as f64;\n    let mut min_val = numbers[1];\n\
    \    for &num in numbers[1..] {\n        let dist = num - min_val;\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_val = num;\n\
    \        }\n    }\n    (min_val, min_dist)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpqi1es4ae.rs:13:17\n   |\n13 |     for &num in numbers[1..]\
    \ {\n   |                 ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n13 |     for &num in &numbers[1..]\
    \ {\n   |                 +\n13 |     for &num in &mut numbers[1..] {\n   |  \
    \               ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmpqi1es4ae.rs:13:17\n\
    \   |\n13 |     for &num in numbers[1..] {\n   |                 ^^^^^^^^^^^^\
    \ expected an implementor of trait `IntoIterator`\n   |\n   = note: the trait\
    \ bound `[f64]: IntoIterator` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing\
    \ here\n   |\n13 |     for &num in &numbers[1..] {\n   |                 +\n13\
    \ |     for &num in &mut numbers[1..] {\n   |                 ++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976420
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut sorted_numbers = numbers.clone();\n\n\
    \    sorted_numbers.sort_unstable_by(|a, b| a.partial_cmp(b));\n\n    let lower\
    \ = sorted_numbers[..numbers.len()/2];\n    let upper = sorted_numbers[numbers.len()/2..];\n\
    \n    (lower.iter().min().unwrap(), upper.iter().max().unwrap())\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiblfih5v.rs:10:44\n   |\n\
    10 |     sorted_numbers.sort_unstable_by(|a, b| a.partial_cmp(b));\n   |     \
    \                                       ^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<std::cmp::Ordering>`\n\nerror[E0277]: the size\
    \ for values of type `[f64]` cannot be known at compilation time\n  --> /tmp/tmpiblfih5v.rs:12:9\n\
    \   |\n12 |     let lower = sorted_numbers[..numbers.len()/2];\n   |         ^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `[f64]`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n12 |     let lower = &sorted_numbers[..numbers.len()/2];\n\
    \   |                 +\n\nerror[E0277]: the size for values of type `[f64]` cannot\
    \ be known at compilation time\n  --> /tmp/tmpiblfih5v.rs:13:9\n   |\n13 |   \
    \  let upper = sorted_numbers[numbers.len()/2..];\n   |         ^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[f64]`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n13 |     let upper = &sorted_numbers[numbers.len()/2..];\n\
    \   |                 +\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmpiblfih5v.rs:15:19\n     |\n15   |     (lower.iter().min().unwrap(),\
    \ upper.iter().max().unwrap())\n     |                   ^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bou"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (f64::MAX_POSITIVE,\
    \ f64::MAX_POSITIVE);\n    }\n    let mut best = (f64::MAX_POSITIVE, f64::MAX_POSITIVE);\n\
    \    let mut best_index = -1;\n    for index in 1..numbers.len() {\n        let\
    \ distance = numbers.iter().nth(index).unwrap().fabs();\n        if distance <\
    \ best.0 {\n            best = distance;\n            best_index = index;\n  \
    \      }\n    }\n    (numbers[best_index], numbers[best_index - 1])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `MAX_POSITIVE` found for type `f64`\
    \ in the current scope\n --> /tmp/tmpjhmlurf4.rs:9:22\n  |\n9 |         return\
    \ (f64::MAX_POSITIVE, f64::MAX_POSITIVE);\n  |                      ^^^^^^^^^^^^\n\
    \  |                      |\n  |                      associated item not found\
    \ in `f64`\n  |                      help: there is an associated constant with\
    \ a similar name: `MIN_POSITIVE`\n\nerror[E0599]: no associated item named `MAX_POSITIVE`\
    \ found for type `f64` in the current scope\n --> /tmp/tmpjhmlurf4.rs:9:41\n \
    \ |\n9 |         return (f64::MAX_POSITIVE, f64::MAX_POSITIVE);\n  |         \
    \                                ^^^^^^^^^^^^\n  |                           \
    \              |\n  |                                         associated item\
    \ not found in `f64`\n  |                                         help: there\
    \ is an associated constant with a similar name: `MIN_POSITIVE`\n\nerror[E0599]:\
    \ no associated item named `MAX_POSITIVE` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpjhmlurf4.rs:11:26\n   |\n11 |     let mut best = (f64::MAX_POSITIVE,\
    \ f64::MAX_POSITIVE);\n   |                          ^^^^^^^^^^^^\n   |      \
    \                    |\n   |                          associated item not found\
    \ in `f64`\n   |                          help: there is an associated constant\
    \ with a similar name: `MIN_POSITIVE`\n\nerror[E0599]: no associated item named\
    \ `MAX_POSITIVE` found for type `f64` in the current scope\n  --> /tmp/tmpjhmlurf4.rs:11:45\n\
    \   |\n11 |     let mut best = (f64::MAX_POSITIVE, f64::MAX_POSITIVE);\n   | \
    \                                            ^^^^^^^^^^^^\n   |              \
    \                               |\n   |                                      \
    \       associated item not found in `f64`\n   |                             \
    \                help: there is an associated constant with a similar name: `MIN_POSITIVE`\n\
    \nerror[E0599]: no method named `fabs` found for reference `&f64` in the current\
    \ scope\n  --> /tmp/tmpjhmlurf4.rs:14:59\n   |\n14 |         let distance = numbers.iter().nth(index).unwrap()"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    use std::cmp::Ordering;\n    let mut min = std::cmp::Ordering::Less;\n\
    \    let mut max = std::cmp::Ordering::Greater;\n\n    let mut index = 0;\n  \
    \  let mut distance = std::f64::MAX;\n\n    while index < numbers.len() {\n  \
    \      let number = numbers[index];\n        let new_distance = number.abs() -\
    \ distance;\n\n        if new_distance < distance {\n            index = index\
    \ * 2;\n            distance = new_distance;\n        } else {\n            index\
    \ = index + 1;\n            distance = std::f64::MAX;\n        }\n\n        if\
    \ index > numbers.len() / 2 {\n            break;\n        }\n\n        let mut\
    \ new_min = number;\n        let mut new_max = number;\n        if index >= numbers.len()\
    \ / 2 {\n            new_min = numbers[index];\n            new_max = numbers[0];\n\
    \        } else {\n            new_min = numbers[index * 2];\n            new_max\
    \ = numbers[index * 2 + 1];\n        }\n\n        if new_min > new_max {\n   \
    \         max = new_min;\n            min = new_max;\n        } else {\n     \
    \       min = new_min;\n            max = new_max;\n        }\n    }\n\n    (min,\
    \ max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n --> /tmp/tmpqxozecei.rs:8:9\n\
    \  |\n8 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqxozecei.rs:42:19\n   |\n10 |     let mut max = std::cmp::Ordering::Greater;\n\
    \   |                   --------------------------- expected due to this value\n\
    ...\n42 |             max = new_min;\n   |                   ^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `f64`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpqxozecei.rs:43:19\n   |\n9  |     let mut min = std::cmp::Ordering::Less;\n\
    \   |                   ------------------------ expected due to this value\n\
    ...\n43 |             min = new_max;\n   |                   ^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `f64`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpqxozecei.rs:45:19\n   |\n9  |     let mut min = std::cmp::Ordering::Less;\n\
    \   |                   ------------------------ expected due to this value\n\
    ...\n45 |             min = new_min;\n   |                   ^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `f64`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpqxozecei.rs:46:19\n   |\n10 |     let mut max = std::cmp::Ordering::Greater;\n\
    \   |                   --------------------------- expected due to this value\n\
    ...\n46 |             max = new_max;\n   |                   ^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `f64`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpqxozecei.rs:50:6\n   |\n50 |     (min, max)\n   |      ^^^ expected\
    \ `f64`, found enum `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpqxozecei.rs:50:11\n   |\n50 |     (min, max)\n   |           ^^^\
    \ expected `f64`, found enum `std::cmp::Ordering`\n\nerror: aborting due to 6\
    \ previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() <= 2 {\n        return numbers[0],\
    \ numbers[0];\n    }\n    let mut smallest_element = numbers[0];\n    let mut\
    \ largest_element = numbers[0];\n    for element in &numbers[1..] {\n        if\
    \ element < smallest_element {\n            smallest_element = element;\n    \
    \    }\n        if element > largest_element {\n            largest_element =\
    \ element;\n        }\n    }\n    (smallest_element, largest_element)\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \ --> /tmp/tmpfdm90wyw.rs:9:26\n  |\n9 |         return numbers[0], numbers[0];\n\
    \  |                          ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfdm90wyw.rs:14:22\n   |\n14 |\
    \         if element < smallest_element {\n   |                      ^^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&f64`, found\
    \ `f64`\n   |                      help: consider borrowing here: `&smallest_element`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfdm90wyw.rs:15:32\n   |\n11 |\
    \     let mut smallest_element = numbers[0];\n   |                           \
    \     ---------- expected due to this value\n...\n15 |             smallest_element\
    \ = element;\n   |                                ^^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \   smallest_element = *element;\n   |                                +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfdm90wyw.rs:17:22\n   |\n17 |         if element\
    \ > largest_element {\n   |                      ^^^^^^^^^^^^^^^\n   |       \
    \               |\n   |                      expected `&f64`, found `f64`\n  \
    \ |                      help: consider borrowing here: `&largest_element`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfdm90wyw.rs:18:31\n   |\n12 |  \
    \   let mut largest_element = numbers[0];\n   |                              \
    \ ---------- expected due to this value\n...\n18 |             largest_element\
    \ = element;\n   |                               ^^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |          \
    \   largest_element = *element;\n   |                               +\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut a = numbers[0];\n    let mut b = numbers[0];\n\
    \    let mut min_a = a;\n    let mut min_b = b;\n    for &n in numbers {\n   \
    \     if *n <= min_a {\n            min_a = *n;\n        }\n        if *n <= min_b\
    \ {\n            min_b = *n;\n        }\n    }\n    let mut max_a = a;\n    let\
    \ mut max_b = b;\n    for &n in numbers {\n        if *n >= max_a {\n        \
    \    max_a = *n;\n        }\n        if *n >= max_b {\n            max_b = *n;\n\
    \        }\n    }\n    (min_a, min_b), (max_a, max_b)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpfqcx3pqs.rs:30:19\n   |\n30 |     (min_a, min_b), (max_a, max_b)\n\
    \   |                   ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfqcx3pqs.rs:12:9\n   |\n12 | \
    \    for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfqcx3pqs.rs:22:9\n   |\n22 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n\n    for &n in numbers {\n        if n < smallest {\n      \
    \      smallest = n;\n        }\n\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8zmzm_v1.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        let mut min = numbers[0];\n        let mut\
    \ max = numbers[0];\n        for &n in &numbers[1..] {\n            if n < min\
    \ {\n                min = n;\n            }\n            if n > max {\n     \
    \           max = n;\n            }\n        }\n        (min, max)\n    }\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpay22q2kt.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_element = numbers[0];\n    let mut\
    \ max_element = numbers[0];\n\n    for n in numbers {\n        if n <= min_element\
    \ {\n            min_element = n;\n        }\n        if n > max_element {\n \
    \           max_element = n;\n        }\n    }\n\n    (min_element, max_element)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmplb58tbtz.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n    let mut index = 1;\n\n\
    \    for number in &numbers {\n        if number > largest {\n            largest\
    \ = number;\n        }\n\n        if number < smallest {\n            smallest\
    \ = number;\n        }\n        if number == largest {\n            if index >\
    \ numbers.len() - 1 {\n                break;\n            }\n            largest\
    \ = numbers[index];\n        }\n\n        if number == smallest {\n          \
    \  if index > numbers.len() - 1 {\n                break;\n            }\n   \
    \         smallest = numbers[index];\n        }\n\n        index += 1;\n    }\n\
    \n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm2y8nuzh.rs:14:21\n   |\n\
    14 |         if number > largest {\n   |                     ^^^^^^^\n   |   \
    \                  |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&largest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm2y8nuzh.rs:15:23\n   |\n10 |     let mut largest\
    \ = numbers[0];\n   |                       ---------- expected due to this value\n\
    ...\n15 |             largest = number;\n   |                       ^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15\
    \ |             largest = *number;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm2y8nuzh.rs:18:21\n   |\n18 |         if number\
    \ < smallest {\n   |                     ^^^^^^^^\n   |                     |\n\
    \   |                     expected `&f64`, found `f64`\n   |                 \
    \    help: consider borrowing here: `&smallest`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm2y8nuzh.rs:19:24\n   |\n9  |     let mut smallest = numbers[0];\n\
    \   |                        ---------- expected due to this value\n...\n19 |\
    \             smallest = number;\n   |                        ^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n19\
    \ |             smallest = *number;\n   |                        +\n\nerror[E0277]:\
    \ can't compare `&f64` with `f64`\n  --> /tmp/tmpm2y8nuzh.rs:21:19\n   |\n21 |\
    \         if number == largest {\n   |                   ^^ no implementation\
    \ for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented\
    \ for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpm2y8nuzh.rs:28:19\n\
    \   |\n28 |         if number == smallest {\n   |                   ^^ no implementation\
    \ for `&f64 == f64`\n   |\n   = help: the"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    debug_assert!(numbers[0] <= numbers[1]);\n\n\
    \    let mut smallest = numbers[0] as f64;\n    let mut largest_1 = numbers[0]\
    \ as f64;\n    let mut largest_2 = numbers[0] as f64;\n\n    for n in numbers[1..]\
    \ {\n        let diff: f64 = (n - smallest).abs();\n        if diff < largest_1\
    \ {\n            smallest = n;\n            largest_1 = diff;\n        }\n   \
    \     if diff > largest_2 {\n            largest_2 = diff;\n            largest_2\
    \ = n;\n        }\n    }\n    (smallest, largest_2)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmp668yqdla.rs:14:14\n   |\n14 |     for n in numbers[1..]\
    \ {\n   |              ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n14 |     for n in &numbers[1..]\
    \ {\n   |              +\n14 |     for n in &mut numbers[1..] {\n   |        \
    \      ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmp668yqdla.rs:14:14\n\
    \   |\n14 |     for n in numbers[1..] {\n   |              ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n14 |     for n in &numbers[1..] {\n   |              +\n14 |     for n in\
    \ &mut numbers[1..] {\n   |              ++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        debug_assert_eq!(numbers.len(),\
    \ 0);\n        return (f64::NEG_INFINITY, f64::NEG_INFINITY);\n    }\n    let\
    \ mut smallest_difference = numbers[0];\n    let mut second_smallest_difference\
    \ = numbers[0];\n    for &n in numbers {\n        smallest_difference = if *n\
    \ < smallest_difference { *n } else {\n            smallest_difference };\n  \
    \      second_smallest_difference =\n            if smallest_difference == f64::NEG_INFINITY\
    \ {\n                f64::NEG_INFINITY\n            } else {\n               \
    \ if *n < second_smallest_difference { *n } else {\n                    second_smallest_difference\
    \ };\n            };\n    }\n    (smallest_difference, second_smallest_difference)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4texe_o7.rs:14:9\n   |\n\
    14 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4texe_o7.rs:20:20\n   |\n20 |              \
    \ } else {\n   |  ____________________^\n21 | |                 if *n < second_smallest_difference\
    \ { *n } else {\n22 | |                     second_smallest_difference };\n23\
    \ | |             };\n   | |_____________^ expected `f64`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_elem = &numbers[0];\n    let mut max_elem = &numbers[0];\n\n    for num\
    \ in numbers.iter() {\n        let dist = num.abs() - min_dist;\n        if dist\
    \ < min_dist {\n            min_dist = dist;\n            min_elem = &num;\n \
    \       } else if dist > min_dist {\n            max_elem = &num;\n        }\n\
    \    }\n\n    (min_elem, max_elem)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2fjr255e.rs:22:6\n   |\n\
    22 |     (min_elem, max_elem)\n   |      ^^^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |     (*min_elem, max_elem)\n\
    \   |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2fjr255e.rs:22:16\n\
    \   |\n22 |     (min_elem, max_elem)\n   |                ^^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |    \
    \ (min_elem, *max_elem)\n   |                +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO: make faster\n\n    // If the vector\
    \ is empty then return an empty tuple\n    let mut closest_elem = Vec::with_capacity(2);\n\
    \    let mut smallest_elem = numbers[0];\n    let mut largest_elem = numbers[0];\n\
    \n    // Check if each element in the vector is less than the previous or not\n\
    \    for num in numbers {\n        if smallest_elem > num {\n            smallest_elem\
    \ = num;\n        }\n        if largest_elem < num {\n            largest_elem\
    \ = num;\n        }\n    }\n\n    // If the vector is empty then return an empty\
    \ tuple\n    if smallest_elem == largest_elem {\n        (smallest_elem, smallest_elem)\n\
    \    } else {\n        let mut close_num = smallest_elem;\n        let mut close_num_idx\
    \ = 1;\n\n        // Loop through the vector to find the closest number from the\
    \ largest\n        // number in the vector\n        for num in numbers {\n   \
    \         if num == largest_elem {\n                continue;\n            }\n\
    \            let mut distance = Vec::with_capacity(2);\n            let mut smallest_val\
    \ = Vec::with_capacity(2);\n            let mut largest_val = Vec::with_capacity(2);\n\
    \            let mut smallest_idx = Vec::with_capacity(2);\n            let mut\
    \ largest_idx = Vec::with_capacity(2);\n\n            // Find the closest number\
    \ from the smallest\n            for num_idx in 0..2 {\n                distance.push(std::f64::MAX);\n\
    \                smallest_val.push(std::f64::MAX);\n                smallest_idx.push(0);\n\
    \                largest_val.push(std::f64::MIN);\n                largest_idx.push(0);\n\
    \            }\n\n            // Find the closest number from the largest\n  \
    \          for num_idx in 0..2 {\n                if num_idx < 2 {\n         \
    \           let mut difference = num - close_num;\n                    smallest_val[num_idx]\
    \ = smallest_val[num_idx + 1] + difference;\n                    smallest_idx[num_idx]\
    \ = smallest_idx[num_idx + 1] + 1;\n                } else {\n               \
    \     let mut difference = largest_val[num_idx - 2] - num;\n                 \
    \   largest_val[num_idx] = largest_val[num_idx - 2] + difference;\n          \
    \          largest_idx[num_idx] = largest_idx[num_idx - 2] + 1;\n            \
    \    }\n            }\n\n            // Find the smallest difference\n       \
    \     for num_idx in 0..2 {\n                if smallest_val[num_idx] < close_num\
    \ && largest_val[num_idx] >= close_num {\n                    let mut smallest_diff\
    \ = close_num - smallest_val[num_idx];\n                    if \n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpom2_y9un.rs:80:3\n\
    \   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n28 |     } else {\n   |            - unclosed delimiter\n...\n34 |      \
    \   for num in numbers {\n   |                            - unclosed delimiter\n\
    ...\n67 |             for num_idx in 0..2 {\n   |                            \
    \     - unclosed delimiter\n68 |                 if smallest_val[num_idx] < close_num\
    \ && largest_val[num_idx] >= close_num {\n   |                               \
    \                                                            - this delimiter\
    \ might not be properly closed...\n...\n71 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n80 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmpom2_y9un.rs:71:1\n   |\n71 | }\n   | ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpom2_y9un.rs:34:9\n   |\n7  | \
    \  fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |         \
    \                                         ---------- expected `(f64, f64)` because\
    \ of return type\n...\n34 | /         for num in numbers {\n35 | |           \
    \  if num == largest_elem {\n36 | |                 continue;\n37 | |        \
    \     }\n...  |\n79 | |     assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n80 | | }\n   | |__^ expected tuple, found `()`\n   |\n   = note:\
    \  expected tuple `(f64, f64)`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let numbers_clone = numbers.clone();\n    let\
    \ mut min = numbers_clone[0];\n    let mut max = numbers_clone[0];\n    for i\
    \ in numbers_clone.iter_mut() {\n        if *i < min {\n            min = *i;\n\
    \        }\n        if *i > max {\n            max = *i;\n        }\n    }\n \
    \   (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `numbers_clone` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp667d7c6x.rs:11:14\n   |\n8  |     let numbers_clone\
    \ = numbers.clone();\n   |         ------------- help: consider changing this\
    \ to be mutable: `mut numbers_clone`\n...\n11 |     for i in numbers_clone.iter_mut()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_distance = std::f64::MAX;\n\
    \    let mut smallest_index = -1;\n\n    for i in 0..numbers.len() - 1 {\n   \
    \     let difference = numbers[i] - numbers[smallest_index];\n        if difference\
    \ < smallest_distance {\n            smallest_distance = difference;\n       \
    \     smallest_index = i;\n        }\n    }\n\n    (numbers[smallest_index], numbers[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp_43pn267.rs:9:30\n\
    \  |\n9 |     let mut smallest_index = -1;\n  |                              ^^\
    \ the trait `Neg` is not implemented for `usize`\n  |\n  = help: the following\
    \ other types implement trait `Neg`:\n            &f32\n            &f64\n   \
    \         &i128\n            &i16\n            &i32\n            &i64\n      \
    \      &i8\n            &isize\n          and 8 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0].clone();\n    let\
    \ mut largest = numbers[0].clone();\n\n    for n in numbers.iter().skip(1) {\n\
    \        let diff = n.abs() - smallest;\n        if diff < smallest {\n      \
    \      smallest = diff;\n        }\n        if diff > largest {\n            largest\
    \ = diff;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 4.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpgll6rdva.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let min_element = numbers[0] as f64;\n    let\
    \ max_element = numbers[0] as f64;\n\n    for i in 1..numbers.len() {\n      \
    \  let curr_element = numbers[i] as f64;\n        if curr_element > max_element\
    \ {\n            max_element = curr_element;\n        } else if curr_element <\
    \ min_element {\n            min_element = curr_element;\n        }\n    }\n\n\
    \    (min_element, max_element)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `max_element`\n\
    \  --> /tmp/tmpgwrj7f2h.rs:14:13\n   |\n9  |     let max_element = numbers[0]\
    \ as f64;\n   |         -----------\n   |         |\n   |         first assignment\
    \ to `max_element`\n   |         help: consider making this binding mutable: `mut\
    \ max_element`\n...\n14 |             max_element = curr_element;\n   |      \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror[E0384]: cannot assign twice to immutable variable `min_element`\n  -->\
    \ /tmp/tmpgwrj7f2h.rs:16:13\n   |\n8  |     let min_element = numbers[0] as f64;\n\
    \   |         -----------\n   |         |\n   |         first assignment to `min_element`\n\
    \   |         help: consider making this binding mutable: `mut min_element`\n\
    ...\n16 |             min_element = curr_element;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // The algorithm is simple: find the smallest\
    \ number in the list and move it to the front\n    // if it's not already present.\
    \ Repeat this until there are two elements that are farthest apart.\n    let mut\
    \ smallest = numbers[0];\n    let mut second: f64 = numbers.iter().next().unwrap();\n\
    \    let mut last: Option<(f64, f64)> = None;\n\n    for i in &numbers[1..] {\n\
    \        if i != smallest {\n            last = Some((smallest, i));\n       \
    \ }\n\n        if i != second {\n            second = i;\n        }\n\n      \
    \  if i == first {\n            break;\n        }\n\n        smallest = i;\n \
    \   }\n\n    if let Some((smallest, second)) = last {\n        (smallest, second)\n\
    \    } else {\n        (numbers[0], numbers[1..])\n    }\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `first` in this scope\n  --> /tmp/tmpcuhgp6wo.rs:23:17\n\
    \   |\n23 |         if i == first {\n   |                 ^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcuhgp6wo.rs:11:27\n \
    \  |\n11 |     let mut second: f64 = numbers.iter().next().unwrap();\n   |   \
    \                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found\
    \ `&f64`\n   |                     |\n   |                     expected due to\
    \ this\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |     let mut\
    \ second: f64 = *numbers.iter().next().unwrap();\n   |                       \
    \    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpcuhgp6wo.rs:15:14\n\
    \   |\n15 |         if i != smallest {\n   |              ^^ no implementation\
    \ for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented\
    \ for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcuhgp6wo.rs:16:36\n\
    \   |\n16 |             last = Some((smallest, i));\n   |                    \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             last = Some((smallest, *i));\n   |      \
    \                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcuhgp6wo.rs:20:22\n\
    \   |\n11 |     let mut second: f64 = numbers.iter().next().unwrap();\n   |  \
    \                   --- expected due to this type\n...\n20 |             second\
    \ = i;\n   |                      ^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n20 |             second = *i;\n   |\
    \                      +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  -->\
    \ /tmp/tmpcuhgp6wo.rs:19:14\n   |\n19 |         if i != second {\n   |       \
    \       ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>`\
    \ is not implemented for `&f64`\n   "
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0] as f64;\n    let\
    \ mut largest = numbers[0] as f64;\n\n    for number in numbers.iter().skip(1)\
    \ {\n        let mut new_number = number;\n        if number < smallest {\n  \
    \          new_number = smallest;\n        }\n        if number > largest {\n\
    \            new_number = largest;\n        }\n        if new_number < smallest\
    \ {\n            smallest = number;\n        }\n        if new_number > largest\
    \ {\n            largest = number;\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp50uv7dlz.rs:13:21\n   |\n\
    13 |         if number < smallest {\n   |                     ^^^^^^^^\n   | \
    \                    |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&smallest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp50uv7dlz.rs:14:26\n   |\n12 |         let mut\
    \ new_number = number;\n   |                              ------ expected due\
    \ to this value\n13 |         if number < smallest {\n14 |             new_number\
    \ = smallest;\n   |                          ^^^^^^^^\n   |                  \
    \        |\n   |                          expected `&f64`, found `f64`\n   | \
    \                         help: consider borrowing here: `&smallest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp50uv7dlz.rs:16:21\n   |\n16 |         if number\
    \ > largest {\n   |                     ^^^^^^^\n   |                     |\n\
    \   |                     expected `&f64`, found `f64`\n   |                 \
    \    help: consider borrowing here: `&largest`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp50uv7dlz.rs:17:26\n   |\n12 |         let mut new_number = number;\n\
    \   |                              ------ expected due to this value\n...\n17\
    \ |             new_number = largest;\n   |                          ^^^^^^^\n\
    \   |                          |\n   |                          expected `&f64`,\
    \ found `f64`\n   |                          help: consider borrowing here: `&largest`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp50uv7dlz.rs:19:25\n   |\n19 |\
    \         if new_number < smallest {\n   |                         ^^^^^^^^\n\
    \   |                         |\n   |                         expected `&f64`,\
    \ found `f64`\n   |                         help: consider borrowing here: `&smallest`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp50uv7dlz.rs:20:24\n   |\n8  |\
    \     let mut smallest = numbers[0] as f64;\n   |                        -----------------\
    \ expected due to this value\n...\n20 |             smallest = number;\n   | \
    \                       ^^^^^^ expected `f64`, found `"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min: Option<f64> = None;\n    let mut\
    \ max: Option<f64> = None;\n    for n in numbers {\n        if let Some(n) = min\
    \ {\n            if n < n {\n                min = Some(n);\n            } else\
    \ {\n                max = Some(n);\n            }\n        } else {\n       \
    \     min = Some(n);\n        }\n    }\n\n    while let Some(mut min) = min {\n\
    \        if let Some(max) = max {\n            if max < min {\n              \
    \  min = max;\n            } else {\n                max = Some(min);\n      \
    \      }\n        } else {\n            max = Some(min);\n        }\n    }\n\n\
    \    (*min).expect(\"min is none\"), (*max).expect(\"max is none\")\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpp6laj924.rs:34:33\n   |\n34 |     (*min).expect(\"min is none\"\
    ), (*max).expect(\"max is none\")\n   |                                 ^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp6laj924.rs:27:23\n   |\n23 |         if let Some(max) = max {\n\
    \   |                     --- expected due to the type of this binding\n...\n\
    27 |                 max = Some(min);\n   |                       ^^^^^^^^^ expected\
    \ `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n         \
    \     found enum `Option<f64>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n\n    for num in numbers {\n        if num < smallest {\n   \
    \         largest = num;\n            smallest = num;\n        } else {\n    \
    \        if num > largest {\n                largest = num;\n            }\n \
    \       }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp82f5yuvi.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // First element in the vector should be the\
    \ lowest value\n    let lowest_number = numbers[0];\n\n    // Find the next highest\
    \ value\n    let lowest_number = numbers[1];\n    let mut index = 1;\n    let\
    \ mut found = false;\n    while !found {\n        let number = numbers[index];\n\
    \        if number > lowest_number {\n            found = true;\n        }\n \
    \       else {\n            // Increment index\n            index += 1;\n    \
    \        if index >= numbers.len() {\n                index = 0;\n           \
    \ }\n        }\n    }\n    (lowest_number, numbers[index])\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.0, 3.9)`,\n right: `(3.9, 4.0)`', /tmp/tmpokqhxzaa.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Find the first index\n    let mut index =\
    \ numbers.iter().min_by_key(|n| f64::abs(n));\n    // Find the second index\n\
    \    let mut index2 = numbers.iter().max_by_key(|n| f64::abs(n));\n    (numbers[index],\
    \ numbers[index2])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9wqwoccc.rs:9:60\n  |\n9 |\
    \     let mut index = numbers.iter().min_by_key(|n| f64::abs(n));\n  |       \
    \                                                     ^ expected `f64`, found\
    \ `&&f64`\n  |\nhelp: consider dereferencing the borrow\n  |\n9 |     let mut\
    \ index = numbers.iter().min_by_key(|n| f64::abs(**n));\n  |                 \
    \                                           ++\n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmp9wqwoccc.rs:9:47\n     |\n9   \
    \ |     let mut index = numbers.iter().min_by_key(|n| f64::abs(n));\n     |  \
    \                                  ---------- ^^^^^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |                                    |\n\
    \     |                                    required by a bound introduced by this\
    \ call\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::iter::Iterator::min_by_key`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9wqwoccc.rs:11:61\n   |\n11 |\
    \     let mut index2 = numbers.iter().max_by_key(|n| f64::abs(n));\n   |     \
    \                                                        ^ expected `f64`, found\
    \ `&&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |     let mut\
    \ index2 = numbers.iter().max_by_key(|n| f64::abs(**n));\n   |               \
    \                                              ++\n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmp9wqwoccc.rs:11:48\n     |\n11 \
    \  |     let mut index2 = numbers.iter().max_by_key(|n| f64::abs(n));\n     |\
    \                                     ---------- ^^^^^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |                                     |\n\
    \     |                                     required by a bound introduced by\
    \ this call\n     |\n     = help: the following other types implement trait `O"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_number = None;\n\n    for number in numbers {\n        let distance\
    \ = number.powf(2.0);\n        if min_distance > distance {\n            min_distance\
    \ = distance;\n            min_number = number;\n        }\n    }\n    (min_number,\
    \ min_distance)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9a8don3h.rs:15:26\n   |\n\
    9  |     let mut min_number = None;\n   |                          ---- expected\
    \ due to this value\n...\n15 |             min_number = number;\n   |        \
    \                  ^^^^^^ expected enum `Option`, found `f64`\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `f64`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n15 |             min_number = Some(number);\n\
    \   |                          +++++      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9a8don3h.rs:18:6\n   |\n18 |     (min_number, min_distance)\n \
    \  |      ^^^^^^^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected\
    \ type `f64`\n              found enum `Option<_>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_val = 0.0;\n    for n in numbers {\n        let diff = &n - &min_val;\n\
    \        if diff < &min_diff {\n            min_val = n;\n            min_diff\
    \ = diff;\n        }\n    }\n\n    (min_val, min_diff)\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbl8q66dh.rs:12:19\n   |\n\
    12 |         if diff < &min_diff {\n   |                   ^^^^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider removing the borrow\n   |\n12 -  \
    \       if diff < &min_diff {\n12 +         if diff < min_diff {\n   | \n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., 0.);\n\
    \    }\n    find_closest_elements_impl_inner(numbers, numbers[0], numbers[1])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_closest_elements_impl_inner` in\
    \ this scope\n  --> /tmp/tmpu1f_u7v7.rs:11:5\n   |\n11 |     find_closest_elements_impl_inner(numbers,\
    \ numbers[0], numbers[1])\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.iter()\n        .zip(numbers.iter().cloned().skip(1))\n\
    \        .filter(|(_, v)| v != numbers[0])\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmp1db1gs_g.rs:10:28\n\
    \   |\n10 |         .filter(|(_, v)| v != numbers[0])\n   |                  \
    \          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait\
    \ `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n\
    \             i128\n             i16\n             i32\n             i64\n   \
    \          i8\n             isize\n           and 6 others\n\nerror[E0277]: a\
    \ value of type `(f64, f64)` cannot be built from an iterator over elements of\
    \ type `(&f64, f64)`\n    --> /tmp/tmp1db1gs_g.rs:11:10\n     |\n11   |      \
    \   .collect()\n     |          ^^^^^^^ value of type `(f64, f64)` cannot be built\
    \ from `std::iter::Iterator<Item=(&f64, f64)>`\n     |\n     = help: the trait\
    \ `FromIterator<(&f64, f64)>` is not implemented for `(f64, f64)`\n     = help:\
    \ the trait `FromIterator<()>` is implemented for `()`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_val = numbers[0];\n    let mut max_val\
    \ = numbers[0];\n    let mut min_idx = 1;\n    let mut max_idx = 1;\n\n    for\
    \ i in numbers.iter_mut() {\n        if *i < min_val {\n            *i = min_val;\n\
    \            min_idx += 1;\n        } else if *i > max_val {\n            *i =\
    \ max_val;\n            max_idx += 1;\n        }\n    }\n\n    (min_val, numbers[min_idx\
    \ as usize])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "warning: variable `max_idx` is assigned to, but never used\n  --> /tmp/tmp125s473z.rs:11:13\n\
    \   |\n11 |     let mut max_idx = 1;\n   |             ^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_idx`\
    \ instead\n\nwarning: variable does not need to be mutable\n --> /tmp/tmp125s473z.rs:8:9\n\
    \  |\n8 |     let mut min_val = numbers[0];\n  |         ----^^^^^^^\n  |    \
    \     |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/tmp125s473z.rs:9:9\n\
    \  |\n9 |     let mut max_val = numbers[0];\n  |         ----^^^^^^^\n  |    \
    \     |\n  |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `numbers`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp125s473z.rs:13:14\n\
    \   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |\
    \                          ------- help: consider changing this to be mutable:\
    \ `mut numbers`\n...\n13 |     for i in numbers.iter_mut() {\n   |           \
    \   ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error; 3 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n\n    let mut min_distance:\
    \ f64 = numbers[0];\n    let mut max_distance: f64 = numbers[0];\n    for number\
    \ in numbers {\n        if number < min_distance {\n            min_distance =\
    \ number;\n        }\n        if number > max_distance {\n            max_distance\
    \ = number;\n        }\n    }\n    (min_distance, max_distance)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpeyiph39q.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ closest_numbers = Vec::new();\n    for i in 0..numbers.len() - 1 {\n       \
    \ let diff = numbers[i] - numbers[i - 1].abs();\n        if diff < min_diff {\n\
    \            closest_numbers.push((numbers[i], numbers[i - 1]));\n           \
    \ min_diff = diff;\n        } else if diff == min_diff {\n            closest_numbers.push((numbers[i],\
    \ numbers[i - 1]));\n        }\n    }\n    (closest_numbers[0].0, closest_numbers[1])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz_31lcw3.rs:19:28\n   |\n\
    19 |     (closest_numbers[0].0, closest_numbers[1])\n   |                    \
    \        ^^^^^^^^^^^^^^^^^^ expected `f64`, found tuple\n   |\n   = note: expected\
    \ type `f64`\n             found tuple `(f64, f64)`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_val = numbers[0] as f64;\n \
    \   let mut largest_val = numbers[0] as f64;\n    let mut current_index = numbers.iter().skip(1).count();\n\
    \    for i in numbers.iter().rev() {\n        if current_index == 0 {\n      \
    \      return (i, i);\n        }\n        if i.abs() < smallest_val.abs() {\n\
    \            smallest_val = i;\n        }\n        if largest_val < i {\n    \
    \        largest_val = i;\n        }\n        current_index -= 1;\n    }\n   \
    \ (smallest_val, largest_val)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoeo5beau.rs:13:21\n   |\n\
    13 |             return (i, i);\n   |                     ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |          \
    \   return (*i, i);\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoeo5beau.rs:13:24\n   |\n13 |             return (i, i);\n   |\
    \                        ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n13 |             return (i, *i);\n   |     \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoeo5beau.rs:16:28\n\
    \   |\n8  |     let mut smallest_val = numbers[0] as f64;\n   |              \
    \              ----------------- expected due to this value\n...\n16 |       \
    \      smallest_val = i;\n   |                            ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |          \
    \   smallest_val = *i;\n   |                            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoeo5beau.rs:18:26\n   |\n18 |         if largest_val <\
    \ i {\n   |                          ^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n18 |         if largest_val < *i {\n\
    \   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoeo5beau.rs:19:27\n\
    \   |\n9  |     let mut largest_val = numbers[0] as f64;\n   |               \
    \            ----------------- expected due to this value\n...\n19 |         \
    \    largest_val = i;\n   |                           ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |          \
    \   largest_val = *i;\n   |                           +\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., 0.);\n\
    \    }\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for i in 0..numbers.len() {\n        let val = numbers[i];\n        if val\
    \ < min_val {\n            min_val = val;\n        }\n        if val > max_val\
    \ {\n            max_val = val;\n        }\n    }\n    (min_val, max_val)\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmppoqozgsd.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // If there are less than two numbers, there's\
    \ nothing to do.\n    if numbers.len() < 2 {\n        return (0.f64, 0.f64);\n\
    \    }\n\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \n    // Loop through the vector.\n    for number in numbers.iter().rev() {\n\
    \        // Find the smallest and largest numbers.\n        if smallest > number\
    \ {\n            smallest = number;\n        }\n        if largest < number {\n\
    \            largest = number;\n        }\n    }\n    (smallest, largest)\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpf8nknst9.rs:10:19\n   |\n10 |         return (0.f64, 0.f64);\n\
    \   |                   ^^^\n\nerror[E0610]: `{integer}` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmpf8nknst9.rs:10:26\n   |\n10 | \
    \        return (0.f64, 0.f64);\n   |                          ^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8nknst9.rs:19:23\n   |\n19 |         if smallest\
    \ > number {\n   |                       ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         if smallest\
    \ > *number {\n   |                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf8nknst9.rs:20:24\n   |\n13 |     let mut smallest = numbers[0];\n\
    \   |                        ---------- expected due to this value\n...\n20 |\
    \             smallest = number;\n   |                        ^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n20\
    \ |             smallest = *number;\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8nknst9.rs:22:22\n   |\n22 |         if largest\
    \ < number {\n   |                      ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |         if largest\
    \ < *number {\n   |                      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf8nknst9.rs:23:23\n   |\n14 |     let mut largest = numbers[0];\n\
    \   |                       ---------- expected due to this value\n...\n23 | \
    \            largest = number;\n   |                       ^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |    \
    \         largest = *number;\n   |                       +\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers[0] < numbers[1] {\n        numbers.swap(0,\
    \ 1)\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r400_v0.rs:11:5\n   |\n\
    7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |       \
    \                                         ---------- expected `(f64, f64)` because\
    \ of return type\n...\n11 |     numbers\n   |     ^^^^^^^ expected tuple, found\
    \ struct `Vec`\n   |\n   = note: expected tuple `(f64, f64)`\n             found\
    \ struct `Vec<f64>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let (min_elem, max_elem) = (numbers[0], 1.0);\n\
    \    let mut min_distance = 1.0;\n    let mut min_idx = 1;\n    for (i, x) in\
    \ numbers.iter().enumerate() {\n        let distance = (x - min_elem).abs();\n\
    \        if min_distance > distance {\n            min_distance = distance;\n\
    \            min_idx = i;\n        }\n    }\n    (numbers[min_idx], numbers[min_idx\
    \ + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpbegvd97e.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_to_center = numbers[0].clone();\
    \ // default to the first number if the vector is empty\n    let mut furthest_from_center\
    \ = numbers[0].clone();\n    let mut smallest_distance = numbers[0].clone();\n\
    \n    for i in 1..numbers.len() {\n        let current_distance = closest_to_center.partial_cmp(&numbers[i]).unwrap();\n\
    \        if current_distance < smallest_distance.partial_cmp(&numbers[i]) {\n\
    \            smallest_distance = current_distance;\n            closest_to_center\
    \ = numbers[i];\n        }\n\n        // Now that we know the distance to the\
    \ center of the vector and the distance to the furthest point,\n        // it's\
    \ easy to calculate the distances to the other points using basic trigonometry\
    \ (cos and sin)\n        let theta = numbers[i] - closest_to_center;\n       \
    \ let distance_to_furthest_point = furthest_from_center.partial_cmp(&numbers[i]).unwrap();\n\
    \        if distance_to_furthest_point < smallest_distance.partial_cmp(&numbers[i])\
    \ {\n            smallest_distance = distance_to_furthest_point;\n           \
    \ furthest_from_center = numbers[i];\n        }\n    }\n\n    // Return the 2\
    \ closest points\n    (closest_to_center, furthest_from_center)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp8ltyoz5.rs:14:31\n   |\n\
    14 |         if current_distance < smallest_distance.partial_cmp(&numbers[i])\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp8ltyoz5.rs:15:33\n   |\n10 |\
    \     let mut smallest_distance = numbers[0].clone();\n   |                  \
    \               ------------------ expected due to this value\n...\n15 |     \
    \        smallest_distance = current_distance;\n   |                         \
    \        ^^^^^^^^^^^^^^^^ expected `f64`, found enum `std::cmp::Ordering`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpp8ltyoz5.rs:23:41\n   |\n23 |  \
    \       if distance_to_furthest_point < smallest_distance.partial_cmp(&numbers[i])\
    \ {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp8ltyoz5.rs:24:33\n   |\n10 |\
    \     let mut smallest_distance = numbers[0].clone();\n   |                  \
    \               ------------------ expected due to this value\n...\n24 |     \
    \        smallest_distance = distance_to_furthest_point;\n   |               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found enum `std::cmp::Ordering`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_index = (0.0, 0.0);\n    let\
    \ mut closest_element = (0.0, 0.0);\n    let mut closest = numbers[0];\n\n   \
    \ for index in 1..numbers.len() {\n        if numbers[index] < closest {\n   \
    \         closest_element = (numbers[index], index);\n            closest_index\
    \ = (numbers[index], index);\n            closest = numbers[index];\n        }\
    \ else {\n            if numbers[index] < closest_element {\n                closest_element\
    \ = (numbers[index], index);\n                closest_index = (numbers[index],\
    \ index);\n            }\n        }\n    }\n    closest_element\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi61oyoi4.rs:14:48\n   |\n\
    14 |             closest_element = (numbers[index], index);\n   |            \
    \                                    ^^^^^ expected floating-point number, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi61oyoi4.rs:15:46\n\
    \   |\n15 |             closest_index = (numbers[index], index);\n   |       \
    \                                       ^^^^^ expected floating-point number,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi61oyoi4.rs:18:33\n\
    \   |\n18 |             if numbers[index] < closest_element {\n   |          \
    \                       ^^^^^^^^^^^^^^^ expected `f64`, found tuple\n   |\n  \
    \ = note: expected type `f64`\n             found tuple `(f64, {float})`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi61oyoi4.rs:19:52\n   |\n19 |              \
    \   closest_element = (numbers[index], index);\n   |                         \
    \                           ^^^^^ expected floating-point number, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi61oyoi4.rs:20:50\n   |\n20 |\
    \                 closest_index = (numbers[index], index);\n   |             \
    \                                     ^^^^^ expected floating-point number, found\
    \ `usize`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smaller_num = numbers[0];\n    let mut\
    \ larger_num = numbers[0];\n    for num in numbers {\n        if num < smaller_num\
    \ {\n            smaller_num = num;\n        } else if num > larger_num {\n  \
    \          larger_num = num;\n        }\n    }\n    (smaller_num, larger_num)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpfqo_tulr.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() >= 2 {\n        let mut max_diff\
    \ =\n            numbers[0]\n                .abs()\n                .min(numbers[1].abs())\n\
    \                .unwrap_or(numbers[0]);\n        let mut min_diff =\n       \
    \     numbers[0]\n                .abs()\n                .min(numbers[1].abs())\n\
    \                .unwrap_or(numbers[0]);\n        let mut smallest = numbers[0];\n\
    \        let mut largest = numbers[0];\n        for n in numbers[1..] {\n    \
    \        let d = n.abs();\n            if d < min_diff {\n                min_diff\
    \ = d\n            }\n            if d > max_diff {\n                max_diff\
    \ = d\n            }\n            if n < smallest {\n                smallest\
    \ = n\n            }\n            if n > largest {\n                largest =\
    \ n\n            }\n        }\n        (smallest, largest)\n    } else {\n   \
    \     (numbers[0], numbers[0])\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp1889wr9r.rs:13:18\n   |\n13 |                 .unwrap_or(numbers[0]);\n\
    \   |                  ^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `unwrap_or` found for type `f64` in the current scope\n  --> /tmp/tmp1889wr9r.rs:18:18\n\
    \   |\n18 |                 .unwrap_or(numbers[0]);\n   |                  ^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0277]: the size for values of type `[f64]`\
    \ cannot be known at compilation time\n  --> /tmp/tmp1889wr9r.rs:21:18\n   |\n\
    21 |         for n in numbers[1..] {\n   |                  ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n21 |         for n in &numbers[1..] {\n   |                  +\n21 |   \
    \      for n in &mut numbers[1..] {\n   |                  ++++\n\nerror[E0277]:\
    \ `[f64]` is not an iterator\n  --> /tmp/tmp1889wr9r.rs:21:18\n   |\n21 |    \
    \     for n in numbers[1..] {\n   |                  ^^^^^^^^^^^^ expected an\
    \ implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n21 |         for n in &numbers[1..] {\n   |                  +\n21 |   \
    \      for n in &mut numbers[1..] {\n   |                  ++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_number = numbers[0] as f64;\n\
    \    let mut largest_number = numbers[0] as f64;\n\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < smallest_number {\n            smallest_number =\
    \ numbers[i];\n        }\n        if numbers[i] > largest_number {\n         \
    \   largest_number = numbers[i];\n        }\n    }\n\n    (smallest_number, largest_number)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmprym7tplj.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_two = numbers[..];\n    let\
    \ mut closest_two = numbers[..];\n\n    let mut smallest_one = numbers[..];\n\
    \    let mut closest_one = numbers[..];\n\n    for i in 0..numbers.len() - 1 {\n\
    \        if smallest_two.last().unwrap() < numbers[i].unwrap() {\n           \
    \ smallest_one = numbers[..i];\n            closest_one = numbers[i .. numbers.len()].clone();\n\
    \        }\n        if smallest_one.last().unwrap() < numbers[i].unwrap() {\n\
    \            smallest_two = numbers[i .. numbers.len()].clone();\n           \
    \ closest_two = numbers[..i].clone();\n        }\n    }\n    (closest_one, closest_two)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n --> /tmp/tmpy12agupv.rs:8:9\n  |\n8 |     let mut smallest_two = numbers[..];\n\
    \  |         ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n\
    \  = help: the trait `Sized` is not implemented for `[f64]`\n  = note: all local\
    \ variables must have a statically known size\n  = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n  |\n8 |     let mut\
    \ smallest_two = &numbers[..];\n  |                            +\n\nerror[E0277]:\
    \ the size for values of type `[f64]` cannot be known at compilation time\n -->\
    \ /tmp/tmpy12agupv.rs:9:9\n  |\n9 |     let mut closest_two = numbers[..];\n \
    \ |         ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n \
    \ = help: the trait `Sized` is not implemented for `[f64]`\n  = note: all local\
    \ variables must have a statically known size\n  = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n  |\n9 |     let mut\
    \ closest_two = &numbers[..];\n  |                           +\n\nerror[E0277]:\
    \ the size for values of type `[f64]` cannot be known at compilation time\n  -->\
    \ /tmp/tmpy12agupv.rs:11:9\n   |\n11 |     let mut smallest_one = numbers[..];\n\
    \   |         ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[f64]`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n11 |     let mut\
    \ smallest_one = &numbers[..];\n   |                            +\n\nerror[E0277]:\
    \ the size for values of type `[f64]` cannot be known at compilation time\n  -->\
    \ /tmp/tmpy12agupv.rs:12:9\n   |\n12 |     let mut closest_one = numbers[..];\n\
    \   |         ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[f64]`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider bor"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Find smallest and largest number\n    let\
    \ (smallest_num, largest_num) = numbers.iter().fold((numbers[0], numbers[1]),\
    \ |(smallest, largest), number| {\n        if smallest > number {\n          \
    \  smallest, number\n        } else {\n            largest, number\n        }\n\
    \    });\n\n    // Calculate midpoint between the two\n    let mid = (f64::from(largest_num)\
    \ + f64::from(smallest_num)) / 2.0;\n\n    // Find two numbers whose midpoint\
    \ is closest to each other\n    let mid1 = (f64::from(mid) - f64::from(smallest_num))\
    \ / 2.0;\n    let mid2 = (f64::from(mid) + f64::from(largest_num)) / 2.0;\n\n\
    \    // Return closest number pairs\n    (mid1, mid2)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: struct literals are not allowed here\n  --> /tmp/tmpi4lvxacp.rs:10:23\n\
    \   |\n10 |           if smallest > number {\n   |  _______________________^\n\
    11 | |             smallest, number\n12 | |         } else {\n   | |_________^\n\
    \   |\nhelp: surround the struct literal with parentheses\n   |\n10 ~        \
    \ if smallest > (number {\n11 |             smallest, number\n12 ~         })\
    \ else {\n   |\n\nerror: missing condition for `if` expression\n  --> /tmp/tmpi4lvxacp.rs:10:11\n\
    \   |\n10 |         if smallest > number {\n   |           ^ expected if condition\
    \ here\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpi4lvxacp.rs:13:20\n   |\n13 |             largest,\
    \ number\n   |                    ^ expected one of 8 possible tokens\n\nerror[E0574]:\
    \ expected struct, variant or union type, found local variable `number`\n  -->\
    \ /tmp/tmpi4lvxacp.rs:10:23\n   |\n10 |         if smallest > number {\n   | \
    \                      ^^^^^^ not a struct, variant or union type\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0574`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut best\
    \ = numbers[0] as f64;\n    let mut worst = numbers[0] as f64;\n    let mut min_diff\
    \ = std::f64::MAX;\n    for i in 0..numbers.len() {\n        let diff = (numbers[i]\
    \ - best).abs();\n        if diff < min_diff {\n            best = numbers[i];\n\
    \            min_diff = diff;\n        }\n        let diff = (numbers[i] - worst).abs();\n\
    \        if diff > min_diff {\n            worst = numbers[i];\n            min_diff\
    \ = diff;\n        }\n    }\n    (best, worst)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.2, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpajw39d0q.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // find the two numbers with the smallest difference\n\
    \    // subtract both numbers from the first number - smallest difference\n  \
    \  let min_difference = numbers[0] - numbers[1];\n\n    // find the two numbers\
    \ with the largest difference\n    let max_difference = numbers[0] - numbers[2];\n\
    \n    // subtract both numbers from the second number - largest difference\n \
    \   let second_number = numbers[1] - max_difference;\n\n    (min_difference, second_number)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(-1.0, 4.9)`,\n right: `(3.9, 4.0)`', /tmp/tmpf90taqn0.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut max\
    \ = std::f64::MIN;\n    for n in numbers.iter() {\n        let delta = n - min;\n\
    \        if delta < min {\n            min = delta;\n        }\n        if delta\
    \ > max {\n            max = delta;\n        }\n    }\n    min, max\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmp7ws0p8ms.rs:19:8\n   |\n19 |     min, max\n   |   \
    \     ^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.windows(2).min_by_key(|&a| a)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpe59tdfml.rs:8:35\n\
    \     |\n8    |     numbers.windows(2).min_by_key(|&a| a)\n     |            \
    \            ---------- ^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |                        |\n     |                        required by a\
    \ bound introduced by this call\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\n     = note: required\
    \ because of the requirements on the impl of `Ord` for `[f64]`\n     = note: 1\
    \ redundant requirement hidden\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&[f64]`\nnote: required by a bound in `std::iter::Iterator::min_by_key`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpe59tdfml.rs:8:5\n  |\n7 | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n  |                                             \
    \   ---------- expected `(f64, f64)` because of return type\n8 |     numbers.windows(2).min_by_key(|&a|\
    \ a)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found enum\
    \ `Option`\n  |\n  = note: expected tuple `(f64, f64)`\n              found enum\
    \ `Option<&[f64]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        panic!(\"Numbers\
    \ vector must have at least two elements\");\n    }\n\n    let mut smallest_diff\
    \ = std::f64::MAX;\n    let mut largest_diff = -std::f64::MAX;\n    let mut best_match\
    \ = (numbers[0], numbers[0]);\n    let mut best_match_vec: Vec<f64> = vec![];\n\
    \n    for i in 1..numbers.len() {\n        let diff = (numbers[i] - best_match[0]);\n\
    \        let mut new_diff = diff as f64;\n\n        if smallest_diff > new_diff\
    \ {\n            smallest_diff = new_diff;\n            best_match = (numbers[i],\
    \ best_match[0]);\n            best_match_vec.push(best_match[0]);\n        }\
    \ else {\n            largest_diff = new_diff;\n        }\n\n        let mut best_match_vec:\
    \ Vec<f64> = vec![];\n    }\n\n    (best_match, best_match_vec)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp_3q3r161.rs:18:20\n\
    \   |\n18 |         let diff = (numbers[i] - best_match[0]);\n   |           \
    \         ^                          ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n18 -         let diff =\
    \ (numbers[i] - best_match[0]);\n18 +         let diff = numbers[i] - best_match[0];\n\
    \   | \n\nerror[E0608]: cannot index into a value of type `(f64, f64)`\n  -->\
    \ /tmp/tmp_3q3r161.rs:18:34\n   |\n18 |         let diff = (numbers[i] - best_match[0]);\n\
    \   |                                  ^^^^^^^^^^^^^ help: to access tuple elements,\
    \ use: `best_match.0`\n\nerror[E0608]: cannot index into a value of type `(f64,\
    \ f64)`\n  --> /tmp/tmp_3q3r161.rs:23:39\n   |\n23 |             best_match =\
    \ (numbers[i], best_match[0]);\n   |                                       ^^^^^^^^^^^^^\
    \ help: to access tuple elements, use: `best_match.0`\n\nerror[E0608]: cannot\
    \ index into a value of type `(f64, f64)`\n  --> /tmp/tmp_3q3r161.rs:24:33\n \
    \  |\n24 |             best_match_vec.push(best_match[0]);\n   |             \
    \                    ^^^^^^^^^^^^^ help: to access tuple elements, use: `best_match.0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_3q3r161.rs:32:6\n   |\n32 | \
    \    (best_match, best_match_vec)\n   |      ^^^^^^^^^^ expected `f64`, found\
    \ tuple\n   |\n   = note: expected type `f64`\n             found tuple `(f64,\
    \ f64)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3q3r161.rs:32:18\n \
    \  |\n32 |     (best_match, best_match_vec)\n   |                  ^^^^^^^^^^^^^^\
    \ expected `f64`, found struct `Vec`\n   |\n   = note: expected type `f64`\n \
    \           found struct `Vec<f64>`\n\nerror: aborting due to 5 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    use std::cmp::Ordering;\n    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n    for &n in numbers {\n\
    \        if smallest > n {\n            smallest = n;\n        }\n        if largest\
    \ < n {\n            largest = n;\n        }\n    }\n    let mut min = Ordering::<f64>().cloned();\n\
    \    let mut max = Ordering::<f64>().cloned();\n    for i in 0..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        if numbers[i] < min {\n            min = numbers[i];\n        }\n   \
    \ }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected function, tuple struct or tuple variant, found enum\
    \ `Ordering`\n  --> /tmp/tmpcp040x40.rs:19:19\n   |\n19 |     let mut min = Ordering::<f64>().cloned();\n\
    \   |                   ^^^^^^^^^^^^^^^\n   |\n   = help: the enum has no tuple\
    \ variants to construct\n   = help: you might have meant to construct one of the\
    \ enum's non-tuple variants\n\nerror[E0423]: expected function, tuple struct or\
    \ tuple variant, found enum `Ordering`\n  --> /tmp/tmpcp040x40.rs:20:19\n   |\n\
    20 |     let mut max = Ordering::<f64>().cloned();\n   |                   ^^^^^^^^^^^^^^^\n\
    \   |\n   = help: the enum has no tuple variants to construct\n   = help: you\
    \ might have meant to construct one of the enum's non-tuple variants\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcp040x40.rs:11:9\n   |\n11 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0] as f64;\n    let\
    \ mut largest = numbers[0] as f64;\n    for n in numbers {\n        if n > largest\
    \ {\n            largest = n as f64;\n        }\n        if n < smallest {\n \
    \           smallest = n as f64;\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpgzk8c6q6.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0.f64,\
    \ 0.f64);\n    }\n\n    let mut closest_to_small = numbers[0];\n    let mut closest_to_large\
    \ = numbers[0];\n\n    for number in numbers.iter().rev() {\n        if number\
    \ < closest_to_large {\n            closest_to_small = closest_to_large;\n   \
    \         closest_to_large = number;\n        } else if number < closest_to_small\
    \ {\n            closest_to_small = number;\n        }\n    }\n\n    (closest_to_small,\
    \ closest_to_large)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n --> /tmp/tmpbwf_ha_a.rs:9:19\n  |\n9 |         return (0.f64, 0.f64);\n\
    \  |                   ^^^\n\nerror[E0610]: `{integer}` is a primitive type and\
    \ therefore doesn't have fields\n --> /tmp/tmpbwf_ha_a.rs:9:26\n  |\n9 |     \
    \    return (0.f64, 0.f64);\n  |                          ^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbwf_ha_a.rs:16:21\n   |\n16 |         if number\
    \ < closest_to_large {\n   |                     ^^^^^^^^^^^^^^^^\n   |      \
    \               |\n   |                     expected `&f64`, found `f64`\n   |\
    \                     help: consider borrowing here: `&closest_to_large`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbwf_ha_a.rs:18:32\n   |\n13 |     let mut closest_to_large\
    \ = numbers[0];\n   |                                ---------- expected due to\
    \ this value\n...\n18 |             closest_to_large = number;\n   |         \
    \                       ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |             closest_to_large = *number;\n\
    \   |                                +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbwf_ha_a.rs:19:28\n   |\n19 |         } else if number < closest_to_small\
    \ {\n   |                            ^^^^^^^^^^^^^^^^\n   |                  \
    \          |\n   |                            expected `&f64`, found `f64`\n \
    \  |                            help: consider borrowing here: `&closest_to_small`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbwf_ha_a.rs:20:32\n   |\n12 |\
    \     let mut closest_to_small = numbers[0];\n   |                           \
    \     ---------- expected due to this value\n...\n20 |             closest_to_small\
    \ = number;\n   |                                ^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |          \
    \   closest_to_small = *number;\n   |                                +\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0610.\nFor more information about an error, try `rust"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    use std::cmp::min;\n    use std::cmp::max;\n\n\
    \    if numbers.len() < 2 {\n        return (0, 0);\n    }\n    let mut largest\
    \ = numbers[0] as f64;\n    let mut smallest = numbers[0] as f64;\n    for &n\
    \ in &numbers[1..] {\n        let distance = max(n - largest, n - smallest);\n\
    \        if distance == 0.0 {\n            continue;\n        }\n        if n\
    \ == largest {\n            largest = n;\n        } else if n == smallest {\n\
    \            smallest = n;\n        } else {\n            (smallest, largest);\n\
    \        }\n    }\n    (smallest, largest);\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::min`\n --> /tmp/tmpeaqjl179.rs:8:9\n\
    \  |\n8 |     use std::cmp::min;\n  |         ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeaqjl179.rs:12:17\n\
    \   |\n12 |         return (0, 0);\n   |                 ^\n   |             \
    \    |\n   |                 expected `f64`, found integer\n   |             \
    \    help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpeaqjl179.rs:12:20\n   |\n12 |         return (0, 0);\n   |         \
    \           ^\n   |                    |\n   |                    expected `f64`,\
    \ found integer\n   |                    help: use a float literal: `0.0`\n\n\
    error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpeaqjl179.rs:17:24\n\
    \     |\n17   |         let distance = max(n - largest, n - smallest);\n     |\
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeaqjl179.rs:7:48\n   |\n7  | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |    ---------------------                   \
    \    ^^^^^^^^^^ expected tuple, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n29 |     (smallest,\
    \ largest);\n   |                        - help: remove this semicolon\n   |\n\
    \   = note:  expected tuple `(f64, f64)`\n           found unit type `()`\n\n\
    error: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut best = match &numbers[1..] {\n      \
    \  &[a, b] if b - a < 0.01 => (a, a),\n        &[a, b] if b - a > 0.01 => (a,\
    \ b),\n        _ => (numbers[0], numbers[0]),\n    };\n\n    for i in 2..numbers.len()\
    \ {\n        let mut cur = match &numbers[i..] {\n            &[a, b] if b - a\
    \ < 0.01 => (a, b),\n            &[a, b] if b - a > 0.01 => (b, a),\n        \
    \    _ => (numbers[0], numbers[0]),\n        };\n\n        if cur.0 > best.0 {\n\
    \            best = cur;\n        }\n        if cur.1 > best.1 {\n           \
    \ best = cur;\n        }\n    }\n\n    (best.0, best.1)\n}\n\nfn main() {\n  \
    \  let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpgyy2acyp.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.is_empty() {\n        return (0.0,\
    \ 0.0);\n    }\n    let mut smaller = numbers[0];\n    let mut larger = numbers[0];\n\
    \    for i in numbers.iter().rev() {\n        if smaller.partial_cmp(&i) < 0 {\n\
    \            smaller = i;\n        }\n        if larger.partial_cmp(&i) > 0 {\n\
    \            larger = i;\n        }\n    }\n    (smaller, larger)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwg6zxsi.rs:14:38\n   |\n\
    14 |         if smaller.partial_cmp(&i) < 0 {\n   |                          \
    \            ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<std::cmp::Ordering>`\n              found type `{integer}`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptwg6zxsi.rs:15:23\n   |\n11 |  \
    \   let mut smaller = numbers[0];\n   |                       ---------- expected\
    \ due to this value\n...\n15 |             smaller = i;\n   |                \
    \       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n15 |             smaller = *i;\n   |                       +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptwg6zxsi.rs:17:37\n   |\n17 |\
    \         if larger.partial_cmp(&i) > 0 {\n   |                              \
    \       ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<std::cmp::Ordering>`\n              found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptwg6zxsi.rs:18:22\n   |\n12 |     let mut larger\
    \ = numbers[0];\n   |                      ---------- expected due to this value\n\
    ...\n18 |             larger = i;\n   |                      ^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |    \
    \         larger = *i;\n   |                      +\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_diff = std::f64::MAX;\n    let mut min_ele = std::f64::MAX;\n    for (i,\
    \ x) in numbers.iter().enumerate() {\n        let diff = x - numbers[0];\n   \
    \     if diff < min_diff {\n            min_diff = diff;\n            min_ele\
    \ = i;\n        }\n    }\n\n    (numbers[min_ele], numbers[min_ele + 1])\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi29r5mez.rs:15:23\n   |\n\
    10 |     let mut min_ele = std::f64::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n15 |             min_ele = i;\n   |       \
    \                ^ expected `f64`, found `usize`\n   |\nhelp: you can cast a `usize`\
    \ to an `f64`, producing the floating point representation of the integer, rounded\
    \ if necessary\n   |\n15 |             min_ele = i as f64;\n   |             \
    \            ++++++\n\nerror[E0277]: the type `[f64]` cannot be indexed by `f64`\n\
    \  --> /tmp/tmpi29r5mez.rs:19:6\n   |\n19 |     (numbers[min_ele], numbers[min_ele\
    \ + 1])\n   |      ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented\
    \ for `f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<f64>` for\
    \ `Vec<f64>`\n\nerror[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpi29r5mez.rs:19:40\n\
    \   |\n19 |     (numbers[min_ele], numbers[min_ele + 1])\n   |               \
    \                         ^ no implementation for `f64 + {integer}`\n   |\n  \
    \ = help: the trait `Add<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\nhelp: consider using\
    \ a floating-point literal by writing it with `.0`\n   |\n19 |     (numbers[min_ele],\
    \ numbers[min_ele + 1.0])\n   |                                           ++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0.f64,\
    \ 0.f64);\n    }\n\n    let mut smallest_distance = numbers[0].abs();\n    let\
    \ mut closest_numbers = [numbers[0], 0.f64];\n    let mut second_closest_numbers\
    \ = [0.f64, 0.f64];\n\n    for (i, number) in numbers.iter().enumerate() {\n \
    \       let distance = number.abs();\n        if i == 0 {\n            smallest_distance\
    \ = distance;\n        }\n\n        if distance < smallest_distance {\n      \
    \      smallest_distance = distance;\n            closest_numbers[0] = number;\n\
    \            closest_numbers[1] = closest_numbers[0];\n        }\n        else\
    \ {\n            closest_numbers[1] = number;\n        }\n\n        if i == numbers.len()\
    \ - 1 {\n            second_closest_numbers[0] = closest_numbers[1];\n       \
    \     second_closest_numbers[1] = closest_numbers[0];\n        }\n    }\n\n  \
    \  (closest_numbers[0], closest_numbers[1])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n --> /tmp/tmppjflpqh3.rs:9:19\n  |\n9 |         return (0.f64, 0.f64);\n\
    \  |                   ^^^\n\nerror[E0610]: `{integer}` is a primitive type and\
    \ therefore doesn't have fields\n --> /tmp/tmppjflpqh3.rs:9:26\n  |\n9 |     \
    \    return (0.f64, 0.f64);\n  |                          ^^^\n\nerror[E0610]:\
    \ `{integer}` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmppjflpqh3.rs:13:46\n\
    \   |\n13 |     let mut closest_numbers = [numbers[0], 0.f64];\n   |         \
    \                                     ^^^\n\nerror[E0610]: `{integer}` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmppjflpqh3.rs:14:41\n  \
    \ |\n14 |     let mut second_closest_numbers = [0.f64, 0.f64];\n   |         \
    \                                ^^^\n\nerror[E0610]: `{integer}` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmppjflpqh3.rs:14:48\n  \
    \ |\n14 |     let mut second_closest_numbers = [0.f64, 0.f64];\n   |         \
    \                                       ^^^\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0610`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        let mut min: f64 = numbers[0];\n        let\
    \ mut max: f64 = numbers[0];\n        for i in 1..numbers.len() {\n          \
    \  if numbers[i] > max {\n                max = numbers[i];\n            }\n \
    \           if numbers[i] < min {\n                min = numbers[i];\n       \
    \     }\n        }\n        (min, max)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp6a8hkt9e.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    let mut min_idx = 1;\n    let mut max_idx = 1;\n\n    for i\
    \ in 1..numbers.len() {\n        if min > numbers[i] {\n            max = numbers[i];\n\
    \            max_idx = i;\n        } else {\n            min = numbers[i];\n \
    \           min_idx = i;\n        }\n    }\n    (min, max);\n    (min_idx, max_idx);\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpuahpvbi7.rs:7:48\n  |\n7 |\
    \ fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  |    ---------------------\
    \                       ^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n \
    \ |\n  = note:  expected tuple `(f64, f64)`\n          found unit type `()`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_distance = std::f64::MAX;\n\
    \    let mut largest_distance: f64 = std::f64::MIN;\n\n    let mut closest_element1:\
    \ usize = 0;\n    let mut closest_element2: usize = 0;\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        // first element\n        let difference = numbers[i] - numbers[0];\n\
    \n        // check if the number is closer\n        if difference < smallest_distance\
    \ {\n            smallest_distance = difference;\n            closest_element1\
    \ = i;\n        }\n\n        // second element\n        let difference = numbers[i\
    \ + 1] - numbers[i + 2];\n\n        // check if the number is closer\n       \
    \ if difference < smallest_distance {\n            smallest_distance = difference;\n\
    \            closest_element2 = i + 1;\n        }\n\n        // if the smallest\
    \ distance is smaller than the maximum distance\n        // then update the max\
    \ distance\n        if smallest_distance > largest_distance {\n            largest_distance\
    \ = smallest_distance;\n        }\n    }\n\n    (numbers[closest_element1], numbers[closest_element2])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmpt8ra6hlp.rs:25:43

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        let mut smallest = numbers[0];\n        let\
    \ mut largest = numbers[0];\n\n        for i in 1..numbers.len() {\n         \
    \   let mut diff = numbers[i] - smallest;\n            if diff < smallest {\n\
    \                smallest = diff;\n            }\n            diff = numbers[i]\
    \ - largest;\n            if diff > largest {\n                largest = diff;\n\
    \            }\n        }\n\n        (smallest, largest)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.9)`,\n right: `(3.9, 4.0)`', /tmp/tmp8yk0j8jf.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smaller = numbers[0];\n    let mut larger\
    \ = numbers[0];\n    let mut smallest_idx = 0;\n    let mut largest_idx = numbers.len();\n\
    \n    while smallest_idx < largest_idx {\n        let mut current_idx = smallest_idx;\n\
    \        let mut current_number = numbers[smallest_idx];\n        smallest_idx\
    \ += 1;\n\n        for idx in 0..smallest_idx {\n            let current_number\
    \ = numbers[idx];\n            if current_number < current_number {\n        \
    \        smaller = current_number;\n                current_idx = idx;\n     \
    \       }\n        }\n        largest_idx -= 1;\n\n        for idx in 0..largest_idx\
    \ {\n            let current_number = numbers[idx];\n            if current_number\
    \ > current_number {\n                larger = current_number;\n             \
    \   current_idx = idx;\n            }\n        }\n\n        // We found the smaller\
    \ number\n        if smaller * larger == current_number\n            || smaller\
    \ * larger < current_number\n        {\n            return (smaller, larger);\n\
    \        }\n    }\n    (numbers[largest_idx], numbers[largest_idx])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmphgxcn9gf.rs:47:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut min_element\
    \ = numbers[0];\n    let mut max_element = numbers[0];\n    for element in &numbers[1..]\
    \ {\n        if element < min_element {\n            min_element = element;\n\
    \        }\n        if element > max_element {\n            max_element = element;\n\
    \        }\n    }\n    (min_element, max_element)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp33__z9ta.rs:12:22\n   |\n\
    12 |         if element < min_element {\n   |                      ^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&f64`, found\
    \ `f64`\n   |                      help: consider borrowing here: `&min_element`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp33__z9ta.rs:13:27\n   |\n9  |\
    \     let mut min_element = numbers[0];\n   |                           ----------\
    \ expected due to this value\n...\n13 |             min_element = element;\n \
    \  |                           ^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n13 |             min_element = *element;\n\
    \   |                           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp33__z9ta.rs:15:22\n\
    \   |\n15 |         if element > max_element {\n   |                      ^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&f64`, found\
    \ `f64`\n   |                      help: consider borrowing here: `&max_element`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp33__z9ta.rs:16:27\n   |\n10 |\
    \     let mut max_element = numbers[0];\n   |                           ----------\
    \ expected due to this value\n...\n16 |             max_element = element;\n \
    \  |                           ^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |             max_element = *element;\n\
    \   |                           +\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.windows(2).min_by_key(|i| {\n       \
    \ i.partial_cmp(&i.0).unwrap()\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&&[f64]`\n --> /tmp/tmpveo9qw7y.rs:9:26\n\
    \  |\n9 |         i.partial_cmp(&i.0).unwrap()\n  |                          ^\n\
    \nerror[E0599]: `Option<&[f64]>` is not an iterator\n   --> /tmp/tmpveo9qw7y.rs:10:8\n\
    \    |\n10  |       }).collect()\n    |          ^^^^^^^ `Option<&[f64]>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<&[f64]>: Iterator`\n            which is required by `&mut\
    \ Option<&[f64]>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.iter().enumerate().fold(\n        std::cmp::min(\n\
    \            numbers[0],\n            numbers.iter()\n                .map(|&n|\
    \ f64::abs(n - numbers[0]))\n                .min_by(|a, b| b.partial_cmp(a).unwrap()),\n\
    \        ),\n        |min| std::cmp::min(min, numbers[0]),\n    )\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2i93my_4.rs:10:13\n   |\n\
    10 |             numbers[0],\n   |             ^^^^^^^^^^ expected tuple, found\
    \ `f64`\n   |\n   = note: expected tuple `(f64, f64)`\n               found type\
    \ `f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    -->\
    \ /tmp/tmp2i93my_4.rs:9:9\n     |\n9    |         std::cmp::min(\n     |     \
    \    ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n    \
    \ = help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `(f64, f64)`\nnote: required by a bound in `std::cmp::min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2i93my_4.rs:11:13\n   |\n11 | /            \
    \ numbers.iter()\n12 | |                 .map(|&n| f64::abs(n - numbers[0]))\n\
    13 | |                 .min_by(|a, b| b.partial_cmp(a).unwrap()),\n   | |_________________________________________________________^\
    \ expected tuple, found enum `Option`\n   |\n   = note: expected tuple `(f64,\
    \ f64)`\n               found enum `Option<f64>`\n\nerror[E0593]: closure is expected\
    \ to take 2 arguments, but it takes 1 argument\n  --> /tmp/tmp2i93my_4.rs:8:32\n\
    \   |\n8  |     numbers.iter().enumerate().fold(\n   |                       \
    \         ^^^^ expected closure that takes 2 arguments\n...\n15 |         |min|\
    \ std::cmp::min(min, numbers[0]),\n   |         ----- takes 1 argument\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0593.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut current_minimum = numbers[0]\n    let\
    \ mut current_maximum = numbers[0];\n\n    let mut smaller_element = numbers[1];\n\
    \    let mut larger_element = numbers[1];\n\n    for i in numbers.iter().rev()\
    \ {\n        if i < current_minimum {\n            current_minimum = i;\n    \
    \        smaller_element = numbers[i];\n        }\n\n        if i > current_maximum\
    \ {\n            current_maximum = i;\n            larger_element = numbers[i];\n\
    \        }\n    }\n\n    (current_minimum, current_maximum)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpjb__f1qx.rs:8:41\n\
    \  |\n8 |     let mut current_minimum = numbers[0]\n  |                      \
    \                   ^ help: add `;` here\n9 |     let mut current_maximum = numbers[0];\n\
    \  |     --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjb__f1qx.rs:15:16\n\
    \   |\n15 |         if i < current_minimum {\n   |                ^^^^^^^^^^^^^^^\n\
    \   |                |\n   |                expected `&f64`, found `f64`\n   |\
    \                help: consider borrowing here: `&current_minimum`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjb__f1qx.rs:16:31\n   |\n8  |     let mut current_minimum\
    \ = numbers[0]\n   |                               ---------- expected due to\
    \ this value\n...\n16 |             current_minimum = i;\n   |               \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             current_minimum = *i;\n   |             \
    \                  +\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n\
    \  --> /tmp/tmpjb__f1qx.rs:17:31\n   |\n17 |             smaller_element = numbers[i];\n\
    \   |                               ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not\
    \ implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&f64>` for `Vec<f64>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjb__f1qx.rs:20:16\n\
    \   |\n20 |         if i > current_maximum {\n   |                ^^^^^^^^^^^^^^^\n\
    \   |                |\n   |                expected `&f64`, found `f64`\n   |\
    \                help: consider borrowing here: `&current_maximum`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjb__f1qx.rs:21:31\n   |\n9  |     let mut current_maximum\
    \ = numbers[0];\n   |                               ---------- expected due to\
    \ this value\n...\n21 |             current_maximum = i;\n   |               \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider de"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.size() >= 2);\n\n    let mut\
    \ best = numbers[0];\n    let mut worst = numbers[0];\n    for n in numbers {\n\
    \        if n > best {\n            worst = best;\n            best = (n as f64).abs();\n\
    \        } else {\n            worst = (n as f64).abs();\n        }\n    }\n\n\
    \    (best, worst)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `Vec<f64>` in the\
    \ current scope\n --> /tmp/tmpn5v6x_95.rs:8:21\n  |\n8 |     assert!(numbers.size()\
    \ >= 2);\n  |                     ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let len = numbers.size();\n    if len < 2 {\n\
    \        panic!(\"find_closest_elements(): Vec must have at least 2 elements\"\
    );\n    }\n\n    let min_diff = std::f64::MAX;\n    let min_val = numbers[0];\n\
    \    let min_idx = 1;\n    for (i, n) in numbers.iter().enumerate() {\n      \
    \  let diff = std::f64::abs(n - min_val);\n        if diff < min_diff {\n    \
    \        min_diff = diff;\n            min_val = n;\n            min_idx = i;\n\
    \        }\n    }\n\n    (min_val, min_idx)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpghvwi409.rs:17:30\n\
    \   |\n17 |         let diff = std::f64::abs(n - min_val);\n   |             \
    \                 ^^^ not found in `std::f64`\n\nerror[E0599]: no method named\
    \ `size` found for struct `Vec<f64>` in the current scope\n --> /tmp/tmpghvwi409.rs:8:23\n\
    \  |\n8 |     let len = numbers.size();\n  |                       ^^^^ help:\
    \ there is an associated function with a similar name: `resize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpghvwi409.rs:20:23\n   |\n14 |     let min_val\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n20 |             min_val = n;\n   |                       ^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |    \
    \         min_val = *n;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpghvwi409.rs:25:15\n   |\n25 |     (min_val, min_idx)\n\
    \   |               ^^^^^^^ expected `f64`, found `usize`\n   |\nhelp: you can\
    \ cast a `usize` to an `f64`, producing the floating point representation of the\
    \ integer, rounded if necessary\n   |\n25 |     (min_val, min_idx as f64)\n  \
    \ |                       ++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.is_empty() {\n        return (0, 0);\n\
    \    }\n\n    let mut largest = numbers[0];\n    let mut smallest = numbers[0];\n\
    \    let mut index = 0;\n    while index < numbers.len() {\n        if numbers[index]\
    \ < smallest {\n            smallest = numbers[index];\n        }\n        if\
    \ numbers[index] > largest {\n            largest = numbers[index];\n        }\n\
    \        index += 1;\n    }\n\n    smallest, largest\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpc3jaqtdj.rs:25:13\n   |\n25 |     smallest, largest\n\
    \   |             ^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpc3jaqtdj.rs:9:17\n  |\n9 |         return (0, 0);\n  | \
    \                ^\n  |                 |\n  |                 expected `f64`,\
    \ found integer\n  |                 help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpc3jaqtdj.rs:9:20\n  |\n9 |         return (0,\
    \ 0);\n  |                    ^\n  |                    |\n  |               \
    \     expected `f64`, found integer\n  |                    help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number;\n        } else if number > largest {\n      \
    \      largest = number;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpvz7yfyj9.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut current_min = numbers[0];\n    let mut\
    \ current_max = numbers[0];\n    for number in &numbers[1..] {\n        let dist\
    \ = number.abs();\n        if dist < current_min {\n            current_min =\
    \ dist;\n        }\n        if dist > current_max {\n            current_max =\
    \ dist;\n        }\n    }\n    (current_min, current_max)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpzyzibvai.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // If there are less than two elements, just\
    \ return the numbers.\n    if numbers.len() < 2 {\n        return numbers;\n \
    \   }\n\n    // Calculate the distance between each pair of elements and return\
    \ the one with the smallest distance.\n    let mut min_distance = Vec::new();\n\
    \    for (i, &number) in numbers.iter().enumerate() {\n        for j in (i + 1).iter().skip(1)\
    \ {\n            let distance = (number - numbers[j]).abs();\n            min_distance.push(distance);\n\
    \        }\n    }\n    min_distance.sort_unstable_by(|a, b| a.partial_cmp(b));\n\
    \n    // Return the smallest two numbers in the vector.\n    let mut numbers_filtered\
    \ = Vec::new();\n    for distance in min_distance {\n        if numbers_filtered.len()\
    \ < 2 {\n            numbers_filtered.push(numbers[distance]);\n        } else\
    \ {\n            if numbers_filtered[0] == numbers[distance] {\n             \
    \   if numbers_filtered[1] < numbers[distance] {\n                    // If the\
    \ first number in the list is less than the second number in the list, we must\
    \ choose the first number\n                    // to be the new first number in\
    \ the list.\n                    numbers_filtered[0] = numbers[distance];\n  \
    \              } else {\n                    // If the second number in the list\
    \ is less than the second number in the list, we must choose the second\n    \
    \                // number to be the new first number in the list.\n         \
    \           numbers_filtered[1] = numbers[distance];\n                }\n    \
    \        } else {\n                // If the first number in the list is less\
    \ than the second number in the list, we must choose the first\n             \
    \   // number to be the new first number in the list.\n                numbers_filtered.push(numbers[distance]);\n\
    \            }\n        }\n    }\n    (numbers_filtered[0], numbers_filtered[1])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgjjstdwi.rs:10:16\n   |\n\
    7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |       \
    \                                         ---------- expected `(f64, f64)` because\
    \ of return type\n...\n10 |         return numbers;\n   |                ^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(f64, f64)`\n\
    \             found struct `Vec<f64>`\n\nerror[E0599]: no method named `iter`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpgjjstdwi.rs:16:26\n\
    \   |\n16 |         for j in (i + 1).iter().skip(1) {\n   |                  \
    \        ^^^^ method not found in `usize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.iter()\n        .enumerate()\n      \
    \  .sort_by(|(a, b), (i, _)| f64::cmp(&a[1], &b[1]))\n        .take(2)\n     \
    \   .map(|(i, _)| (numbers[i], numbers[i + 1]))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpcpuc2h8x.rs:10:10\n   |\n10 |         .sort_by(|(a,\
    \ b), (i, _)| f64::cmp(&a[1], &b[1]))\n   |          ^^^^^^^ method not found\
    \ in `Enumerate<std::slice::Iter<'_, f64>>`\n\nerror[E0599]: the function or associated\
    \ item `cmp` exists for type `f64`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpcpuc2h8x.rs:10:40\n   |\n10 |         .sort_by(|(a, b), (i, _)|\
    \ f64::cmp(&a[1], &b[1]))\n   |                                        ^^^ function\
    \ or associated item cannot be called on `f64` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `f64:\
    \ Ord`\n           which is required by `&f64: Ord`\n           `f64: Ord`\n \
    \          which is required by `&mut f64: Ord`\n           `f64: Iterator`\n\
    \           which is required by `&mut f64: Iterator`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min: f64 = numbers[0];\n    let mut max:\
    \ f64 = numbers[0];\n\n    for number in numbers.iter().skip(1) {\n        let\
    \ delta = number.sub(min);\n        if delta < 0.0 {\n            min = number;\n\
    \        } else {\n            max = number;\n        }\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sub` found for reference `&f64` in the current\
    \ scope\n  --> /tmp/tmpdcscb7sw.rs:12:28\n   |\n12 |         let delta = number.sub(min);\n\
    \   |                            ^^^ method not found in `&f64`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Sub;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdcscb7sw.rs:14:19\n\
    \   |\n8  |     let mut min: f64 = numbers[0];\n   |                  --- expected\
    \ due to this type\n...\n14 |             min = number;\n   |                \
    \   ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n14 |             min = *number;\n   |                   +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdcscb7sw.rs:16:19\n   |\n9  |  \
    \   let mut max: f64 = numbers[0];\n   |                  --- expected due to\
    \ this type\n...\n16 |             max = number;\n   |                   ^^^^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |             max = *number;\n   |                   +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        let mut new_smallest\
    \ = numbers[i];\n        let mut new_largest = numbers[i];\n        if smallest\
    \ > new_smallest {\n            new_smallest = smallest;\n        }\n        if\
    \ largest < new_largest {\n            new_largest = largest;\n        }\n   \
    \     if smallest > new_smallest {\n            smallest = new_smallest;\n   \
    \     }\n        if largest < new_largest {\n            largest = new_largest;\n\
    \        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmptifhxqmi.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for n in numbers.iter() {\n        if n < smallest {\n  \
    \          smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprdhen51t.rs:11:16\n   |\n\
    11 |         if n < smallest {\n   |                ^^^^^^^^\n   |           \
    \     |\n   |                expected `&f64`, found `f64`\n   |              \
    \  help: consider borrowing here: `&smallest`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprdhen51t.rs:12:24\n   |\n8  |     let mut smallest = numbers[0];\n\
    \   |                        ---------- expected due to this value\n...\n12 |\
    \             smallest = n;\n   |                        ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |          \
    \   smallest = *n;\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprdhen51t.rs:14:16\n   |\n14 |         if n > largest {\n\
    \   |                ^^^^^^^\n   |                |\n   |                expected\
    \ `&f64`, found `f64`\n   |                help: consider borrowing here: `&largest`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprdhen51t.rs:15:23\n   |\n9  |\
    \     let mut largest = numbers[0];\n   |                       ---------- expected\
    \ due to this value\n...\n15 |             largest = n;\n   |                \
    \       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n15 |             largest = *n;\n   |                       +\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers_iter = numbers.iter().cloned();\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    let\
    \ mut cur_val = numbers[0];\n    while let Some(&x) = numbers_iter.next() {\n\
    \        cur_val = x;\n        if min_val == x {\n            min_val = x;\n \
    \       }\n        if max_val == x {\n            max_val = x;\n        }\n  \
    \  }\n    let min_val_index = numbers.iter().position(|&x| x == min_val);\n  \
    \  let max_val_index = numbers.iter().position(|&x| x == max_val);\n    (min_val\
    \ + max_val) / 2, numbers[min_val_index]\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmp0rsxtfkp.rs:23:28\n   |\n23 |     (min_val + max_val) / 2, numbers[min_val_index]\n\
    \   |                            ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0rsxtfkp.rs:12:20\n   |\n12 |\
    \     while let Some(&x) = numbers_iter.next() {\n   |                    ^^ \
    \   ------------------- this expression has type `Option<f64>`\n   |         \
    \           |\n   |                    expected `f64`, found reference\n   | \
    \                   help: you can probably remove the explicit borrow: `x`\n \
    \  |\n   = note:   expected type `f64`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., 0.);\n\
    \    }\n    let mut max_element = numbers[0];\n    let mut min_element = numbers[0];\n\
    \n    for &n in numbers {\n        if n > max_element {\n            max_element\
    \ = n;\n        }\n        if n < min_element {\n            min_element = n;\n\
    \        }\n    }\n\n    (min_element, max_element)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphdmmuh9y.rs:14:9\n   |\n\
    14 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_value = numbers[0];\n    let mut\
    \ max_value = numbers[0];\n    for num in numbers {\n        let difference =\
    \ num - min_value;\n        if difference < 0 {\n            min_value = num;\n\
    \        } else if difference > 0 {\n            max_value = num;\n        }\n\
    \    }\n    (min_value, max_value)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpor7v8djk.rs:12:25\n   |\n\
    12 |         if difference < 0 {\n   |                         ^\n   |       \
    \                  |\n   |                         expected `f64`, found integer\n\
    \   |                         help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpor7v8djk.rs:14:32\n   |\n14 |         } else\
    \ if difference > 0 {\n   |                                ^\n   |           \
    \                     |\n   |                                expected `f64`, found\
    \ integer\n   |                                help: use a float literal: `0.0`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.size() < 2 {\n        return (0, numbers[0]);\n\
    \    }\n\n    let mut closest = (numbers[0], numbers[0]);\n    let mut smallest\
    \ = (numbers[0], numbers[0]);\n\n    for &num in &numbers[1..] {\n        let\
    \ mut closest = (numbers[0], numbers[0]);\n\n        for &value in &mut closest\
    \ {\n            if value < num {\n                *value = num;\n           \
    \ }\n        }\n\n        if smallest == (numbers[0], numbers[0]) {\n        \
    \    smallest = closest;\n        } else {\n            if smallest == closest\n\
    \                || (smallest as f64) - (closest as f64) < smallest\n        \
    \    {\n                smallest = closest;\n            }\n        }\n    }\n\
    \n    (closest, smallest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `Vec<f64>` in the\
    \ current scope\n --> /tmp/tmpca13sek6.rs:8:16\n  |\n8 |     if numbers.size()\
    \ < 2 {\n  |                ^^^^ help: there is an associated function with a\
    \ similar name: `resize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpca13sek6.rs:9:17\n\
    \  |\n9 |         return (0, numbers[0]);\n  |                 ^\n  |        \
    \         |\n  |                 expected `f64`, found integer\n  |          \
    \       help: use a float literal: `0.0`\n\nerror[E0277]: `(f64, f64)` is not\
    \ an iterator\n  --> /tmp/tmpca13sek6.rs:18:23\n   |\n18 |         for &value\
    \ in &mut closest {\n   |                       ^^^^^^^^^^^^ `(f64, f64)` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `(f64,\
    \ f64)`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `&mut (f64, f64)`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `&mut (f64, f64)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpca13sek6.rs:28:59\n   |\n28 |                 || (smallest as f64)\
    \ - (closest as f64) < smallest\n   |                                        \
    \                   ^^^^^^^^ expected `f64`, found tuple\n   |\n   = note: expected\
    \ type `f64`\n             found tuple `(f64, f64)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpca13sek6.rs:35:6\n   |\n35 |     (closest, smallest)\n\
    \   |      ^^^^^^^ expected `f64`, found tuple\n   |\n   = note: expected type\
    \ `f64`\n             found tuple `(f64, f64)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpca13sek6.rs:35:15\n   |\n35 |     (closest, smallest)\n   |   \
    \            ^^^^^^^^ expected `f64`, found tuple\n   |\n   = note: expected type\
    \ `f64`\n             found tuple `(f64, f64)`\n\nerror[E0605]: non-primitive\
    \ cast: `(f64, f64)` as `f64`\n  --> /tmp/tmpca13sek6.rs:28:20\n   |\n28 |   \
    \              || (smallest as f64) - (closest as f64) < smallest\n   |      \
    \              ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror[E0"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut result = numbers[0];\n    let mut best\
    \ = f64::MAX;\n    for i in 1..numbers.len() {\n        if numbers[i] - result\
    \ < best {\n            best = numbers[i] - result;\n            result = i;\n\
    \        }\n    }\n    (result, best)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwvsa7_1.rs:13:22\n   |\n\
    8  |     let mut result = numbers[0];\n   |                      ---------- expected\
    \ due to this value\n...\n13 |             result = i;\n   |                 \
    \     ^ expected `f64`, found `usize`\n   |\nhelp: you can cast a `usize` to an\
    \ `f64`, producing the floating point representation of the integer, rounded if\
    \ necessary\n   |\n13 |             result = i as f64;\n   |                 \
    \       ++++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_difference = numbers[0];\n \
    \   let mut second_smallest_difference = numbers[0];\n    for (i, number) in numbers.iter().enumerate()\
    \ {\n        let difference_with_smallest = (number.abs() - smallest_difference).abs();\n\
    \        if difference_with_smallest < second_smallest_difference {\n        \
    \    second_smallest_difference = difference_with_smallest;\n            smallest_difference\
    \ = number;\n        } else if difference_with_smallest == second_smallest_difference\
    \ {\n            smallest_difference = number;\n        }\n    }\n    (smallest_difference,\
    \ second_smallest_difference)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl4_0s0a4.rs:14:35\n   |\n\
    8  |     let mut smallest_difference = numbers[0];\n   |                     \
    \              ---------- expected due to this value\n...\n14 |             smallest_difference\
    \ = number;\n   |                                   ^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |          \
    \   smallest_difference = *number;\n   |                                   +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl4_0s0a4.rs:16:35\n   |\n8  |\
    \     let mut smallest_difference = numbers[0];\n   |                        \
    \           ---------- expected due to this value\n...\n16 |             smallest_difference\
    \ = number;\n   |                                   ^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |          \
    \   smallest_difference = *number;\n   |                                   +\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_num = numbers[0] as f64;\n    let mut max_num = numbers[0] as f64;\n   \
    \ for num in numbers.iter().rev() {\n        let dist = *num - min_num;\n    \
    \    if dist < min_dist {\n            min_dist = dist;\n            min_num =\
    \ num;\n        } else if dist > min_dist {\n            max_num = num;\n    \
    \    }\n    }\n    (min_num, max_num)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplta6et0h.rs:15:23\n   |\n\
    9  |     let mut min_num = numbers[0] as f64;\n   |                       -----------------\
    \ expected due to this value\n...\n15 |             min_num = num;\n   |     \
    \                  ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             min_num = *num;\n   |                   \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplta6et0h.rs:17:23\n  \
    \ |\n10 |     let mut max_num = numbers[0] as f64;\n   |                     \
    \  ----------------- expected due to this value\n...\n17 |             max_num\
    \ = num;\n   |                       ^^^ expected `f64`, found `&f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n17 |             max_num = *num;\n\
    \   |                       +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut current_min = (numbers[0].clone(), numbers[1].clone());\n\
    \    let mut current_max = (numbers[0].clone(), numbers[1].clone());\n    let\
    \ mut next_min = (numbers[0].clone(), numbers[1].clone());\n    let mut next_max\
    \ = (numbers[0].clone(), numbers[1].clone());\n    for number in numbers[1..]\
    \ {\n        let (min, max) = if number > current_min.1 {\n            current_min\
    \ = number\n        } else {\n            current_max = number\n        };\n \
    \       if number < next_min.1 {\n            next_min = number\n        } else\
    \ {\n            next_max = number\n        };\n    }\n    (current_min, next_min),\
    \ (current_max, next_max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpn1txrame.rs:24:28\n   |\n24 |     (current_min, next_min), (current_max,\
    \ next_max)\n   |                            ^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror[E0277]: the size for values of type `[f64]` cannot\
    \ be known at compilation time\n  --> /tmp/tmpn1txrame.rs:12:19\n   |\n12 |  \
    \   for number in numbers[1..] {\n   |                   ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n12 |     for number in &numbers[1..] {\n   |                   +\n12 | \
    \    for number in &mut numbers[1..] {\n   |                   ++++\n\nerror[E0277]:\
    \ `[f64]` is not an iterator\n  --> /tmp/tmpn1txrame.rs:12:19\n   |\n12 |    \
    \ for number in numbers[1..] {\n   |                   ^^^^^^^^^^^^ expected an\
    \ implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n12 |     for number in &numbers[1..] {\n   |                   +\n12 | \
    \    for number in &mut numbers[1..] {\n   |                   ++++\n\nerror[E0277]:\
    \ can't compare `(f64, f64)` with `f64`\n  --> /tmp/tmpn1txrame.rs:13:36\n   |\n\
    13 |         let (min, max) = if number > current_min.1 {\n   |              \
    \                      ^ no implementation for `(f64, f64) < f64` and `(f64, f64)\
    \ > f64`\n   |\n   = help: the trait `PartialOrd<f64>` is not implemented for\
    \ `(f64, f64)`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n        \
    \     (B, C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J,\
    \ K, L)\n             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I,\
    \ J, K, L)\n             (F, G, H, I, J, K, L)\n             "
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        std::vec::Vec::new()\n\
    \    } else {\n        let mut current_distance = std::vec::Vec::new();\n    \
    \    let mut current_index = std::vec::Vec::new();\n\n        for &n in &numbers\
    \ {\n            if !current_distance.is_empty() {\n                if current_distance.last().unwrap()\
    \ < n {\n                    current_index.remove_last_mut();\n              \
    \      current_distance.pop();\n                } else {\n                   \
    \ current_index.push(i);\n                }\n            }\n\n            current_distance.push(n);\n\
    \            current_index.push(i);\n        }\n\n        if current_distance.is_empty()\
    \ {\n            (0.0, 0.0)\n        } else {\n            (\n               \
    \ numbers[current_index[0].unwrap()],\n                numbers[current_index[1].unwrap()],\n\
    \            )\n        }\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpx5uv20s8.rs:20:40\n\
    \   |\n20 |                     current_index.push(i);\n   |                 \
    \                       ^ help: a local variable with a similar name exists: `n`\n\
    \nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpx5uv20s8.rs:25:32\n\
    \   |\n25 |             current_index.push(i);\n   |                         \
    \       ^ help: a local variable with a similar name exists: `n`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpx5uv20s8.rs:9:9\n  |\n7 | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n  |                                             \
    \   ---------- expected `(f64, f64)` because of return type\n8 |     if numbers.len()\
    \ < 2 {\n9 |         std::vec::Vec::new()\n  |         ^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found struct `Vec`\n  |\n  = note: expected tuple `(f64, f64)`\n    \
    \        found struct `Vec<_>`\n\nerror[E0277]: can't compare `&_` with `f64`\n\
    \  --> /tmp/tmpx5uv20s8.rs:16:53\n   |\n16 |                 if current_distance.last().unwrap()\
    \ < n {\n   |                                                     ^ no implementation\
    \ for `&_ < f64` and `&_ > f64`\n   |\n   = help: the trait `PartialOrd<f64>`\
    \ is not implemented for `&_`\n\nerror[E0599]: no method named `remove_last_mut`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpx5uv20s8.rs:17:35\n\
    \   |\n17 |                     current_index.remove_last_mut();\n   |       \
    \                            ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `last_mut`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n    for &num in numbers {\n        if num < min {\n           \
    \ min = num;\n        }\n        if num > max {\n            max = num;\n    \
    \    }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv7hps92r.rs:10:9\n   |\n\
    10 |     for &num in numbers {\n   |         ^^^^    ------- this expression has\
    \ type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let len = numbers.len();\n    if len < 2 {\n\
    \        return numbers[0], numbers[0];\n    }\n\n    let mut smallest = numbers[0];\n\
    \    let mut largest = numbers[0];\n\n    for number in numbers {\n        if\
    \ number > largest {\n            largest = number;\n        }\n        if number\
    \ < smallest {\n            smallest = number;\n        }\n    }\n\n    (smallest,\
    \ largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpxrbtrqtg.rs:10:26\n   |\n10 |         return numbers[0], numbers[0];\n\
    \   |                          ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_value = numbers[0];\n    let mut\
    \ min_distance_to_min_value = f64::MAX;\n    let mut max_value = numbers[0];\n\
    \    let mut max_distance_to_max_value = f64::MAX;\n\n    for i in 1..numbers.len()\
    \ {\n        let value = numbers[i];\n        let distance_to_min_value = f64::MAX;\n\
    \        let distance_to_max_value = f64::MAX;\n        for j in 0..i-1 {\n  \
    \          let d = f64::max(value - numbers[j], f64::MIN);\n            distance_to_min_value\
    \ = f64::min(distance_to_min_value, d);\n            distance_to_max_value = f64::max(distance_to_max_value,\
    \ d);\n        }\n        let distance = (distance_to_min_value as f64) + (distance_to_max_value\
    \ as f64);\n        if distance < min_distance_to_min_value {\n            min_distance_to_min_value\
    \ = distance;\n            min_value = value;\n        }\n        if distance\
    \ > max_distance_to_max_value {\n            max_distance_to_max_value = distance;\n\
    \            max_value = value;\n        }\n    }\n    (min_value, max_value)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `distance_to_min_value`\n\
    \  --> /tmp/tmp6vodukxw.rs:19:13\n   |\n15 |         let distance_to_min_value\
    \ = f64::MAX;\n   |             ---------------------\n   |             |\n  \
    \ |             first assignment to `distance_to_min_value`\n   |            \
    \ help: consider making this binding mutable: `mut distance_to_min_value`\n...\n\
    19 |             distance_to_min_value = f64::min(distance_to_min_value, d);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `distance_to_max_value`\n  --> /tmp/tmp6vodukxw.rs:20:13\n   |\n16\
    \ |         let distance_to_max_value = f64::MAX;\n   |             ---------------------\n\
    \   |             |\n   |             first assignment to `distance_to_max_value`\n\
    \   |             help: consider making this binding mutable: `mut distance_to_max_value`\n\
    ...\n20 |             distance_to_max_value = f64::max(distance_to_max_value,\
    \ d);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    debug_assert!(numbers.len() >= 2);\n\n    let\
    \ mut min_num = numbers[0] as f64;\n    let mut min_dist = numbers[0] as f64;\n\
    \    let mut max_num = numbers[0] as f64;\n    let mut max_dist = numbers[0] as\
    \ f64;\n\n    for i in 1..numbers.len() {\n        let num = numbers[i] as f64;\n\
    \        let dist = i - 1;\n        let (mut min_num2, mut min_dist2, mut max_num2,\
    \ mut max_dist2) = find_closest_elements_helper(num, dist, min_num, min_dist,\
    \ max_num, max_dist, numbers, i);\n        (min_num2, min_dist2)\n        => (min_num2,\
    \ min_dist2)\n        if min_num2 < min_num {\n            min_num = min_num2;\n\
    \            min_dist = min_dist2;\n        }\n\n        (max_num2, max_dist2)\n\
    \        => (max_num2, max_dist2)\n        if max_num2 > max_num {\n         \
    \   max_num = max_num2;\n            max_dist = max_dist2;\n        }\n    }\n\
    \n    (min_num, min_dist)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpuj74gf8j.rs:20:9\n   |\n19 |         (min_num2, min_dist2)\n  \
    \ |                              - expected one of `.`, `;`, `?`, `}`, or an operator\n\
    20 |         => (min_num2, min_dist2)\n   |         ^^ unexpected token\n\nerror[E0425]:\
    \ cannot find function `find_closest_elements_helper` in this scope\n  --> /tmp/tmpuj74gf8j.rs:18:74\n\
    \   |\n18 | ...   let (mut min_num2, mut min_dist2, mut max_num2, mut max_dist2)\
    \ = find_closest_elements_helper(num, dist, min_num, min_dist, max_num...\n  \
    \ |                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_number = numbers[0];\n    let mut\
    \ max_number = numbers[0];\n    for number in numbers {\n        if number < min_number\
    \ {\n            min_number = number;\n        } else if number > max_number {\n\
    \            max_number = number;\n        }\n    }\n\n    let mut min_element\
    \ = min_number;\n    let mut max_element = max_number;\n\n    for element in numbers\
    \ {\n        if element < min_number {\n            min_element = element;\n \
    \       } else if element > max_number {\n            max_element = element;\n\
    \        }\n    }\n\n    (min_element, max_element)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp21qqq4w3.rs:21:20\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n10  |     for number in numbers\
    \ {\n    |                   ------- `numbers` moved due to this implicit call\
    \ to `.into_iter()`\n...\n21  |     for element in numbers {\n    |          \
    \          ^^^^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \    |\n10  |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_number = numbers[0];\n    let\
    \ mut greatest_number = numbers[0];\n\n    for (i, element) in numbers.iter().enumerate()\
    \ {\n        let current_number = element;\n        if current_number < greatest_number\
    \ {\n            greatest_number = current_number;\n            smallest_number\
    \ = greatest_number;\n        } else if current_number > greatest_number {\n \
    \           greatest_number = current_number;\n            smallest_number = current_number;\n\
    \        }\n    }\n    (smallest_number, greatest_number)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj1v03q31.rs:13:29\n   |\n\
    13 |         if current_number < greatest_number {\n   |                     \
    \        ^^^^^^^^^^^^^^^\n   |                             |\n   |           \
    \                  expected `&f64`, found `f64`\n   |                        \
    \     help: consider borrowing here: `&greatest_number`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj1v03q31.rs:14:31\n   |\n9  |     let mut greatest_number\
    \ = numbers[0];\n   |                               ---------- expected due to\
    \ this value\n...\n14 |             greatest_number = current_number;\n   |  \
    \                             ^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n14 |             greatest_number\
    \ = *current_number;\n   |                               +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj1v03q31.rs:16:36\n   |\n16 |         } else if current_number\
    \ > greatest_number {\n   |                                    ^^^^^^^^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&f64`, found `f64`\n   |                                   \
    \ help: consider borrowing here: `&greatest_number`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj1v03q31.rs:17:31\n   |\n9  |     let mut greatest_number\
    \ = numbers[0];\n   |                               ---------- expected due to\
    \ this value\n...\n17 |             greatest_number = current_number;\n   |  \
    \                             ^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n17 |             greatest_number\
    \ = *current_number;\n   |                               +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj1v03q31.rs:18:31\n   |\n8  |     let mut smallest_number\
    \ = numbers[0];\n   |                               ---------- expected due to\
    \ this value\n...\n18 |             smallest_number = current_number;\n   |  \
    \                             ^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n18 |             sm"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO: assert all numbers are >= 0\n    let\
    \ mut smallest = (numbers[0], numbers[0]);\n    let mut largest = (numbers[0],\
    \ numbers[0]);\n    for num in numbers {\n        let delta = largest.0 - num;\n\
    \        if delta < smallest.1 {\n            smallest = (num, num);\n       \
    \ } else {\n            largest = (num, num);\n        }\n    }\n    // Now smallest\
    \ is the closest number but largest is still the largest\n    (smallest.0, largest.1)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.2, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpbxi0z1r2.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    debug_assert!(numbers.len() >= 2);\n\n    let\
    \ mut min_element = numbers[0];\n    let mut max_element = numbers[0];\n    for\
    \ i in 1..numbers.len() {\n        let element = numbers[i];\n        let dist\
    \ = i - min_element;\n        if dist < 0 {\n            continue;\n        }\n\
    \        let tmp = element;\n        element = min_element;\n        min_element\
    \ = tmp;\n        let tmp = max_element;\n        max_element = element;\n   \
    \     element = tmp;\n    }\n    (min_element, max_element)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `f64` from `usize`\n  --> /tmp/tmpvi_nq1r1.rs:14:22\n\
    \   |\n14 |         let dist = i - min_element;\n   |                      ^ no\
    \ implementation for `usize - f64`\n   |\n   = help: the trait `Sub<f64>` is not\
    \ implemented for `usize`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = numbers.iter().min().unwrap();\n\
    \    let mut min_element = numbers.iter().min().unwrap();\n\n    let mut max_dist\
    \ = numbers.iter().max().unwrap();\n    let mut max_element = numbers.iter().max().unwrap();\n\
    \n    for x in numbers {\n        if x < min_element {\n            min_element\
    \ = x;\n            min_dist = x;\n        }\n        if x > max_element {\n \
    \           max_element = x;\n            max_dist = x;\n        }\n    }\n\n\
    \    (min_element, min_dist)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3g7q4zdn.rs:8:39\n\
    \     |\n8    |     let mut min_dist = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3g7q4zdn.rs:9:42\n\
    \     |\n9    |     let mut min_element = numbers.iter().min().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3g7q4zdn.rs:11:39\n\
    \     |\n11   |     let mut max_dist = numbers.iter().max().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3g7q4zdn.rs:12:42\n\
    \     |\n12   |     let m"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0] as f64;\n    let\
    \ mut largest = numbers[0] as f64;\n    for i in 1..numbers.len() {\n        smallest\
    \ = f32::min(smallest, numbers[i] as f64);\n        largest = f32::max(largest,\
    \ numbers[i] as f64);\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbarib5ui.rs:11:29\n   |\n\
    11 |         smallest = f32::min(smallest, numbers[i] as f64);\n   |         \
    \                    ^^^^^^^^ expected `f32`, found `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbarib5ui.rs:11:39\n   |\n11 |         smallest = f32::min(smallest,\
    \ numbers[i] as f64);\n   |                                       ^^^^^^^^^^^^^^^^^\
    \ expected `f32`, found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbarib5ui.rs:11:20\n\
    \   |\n8  |     let mut smallest = numbers[0] as f64;\n   |                  \
    \      ----------------- expected due to this value\n...\n11 |         smallest\
    \ = f32::min(smallest, numbers[i] as f64);\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `f32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbarib5ui.rs:12:28\n\
    \   |\n12 |         largest = f32::max(largest, numbers[i] as f64);\n   |    \
    \                        ^^^^^^^ expected `f32`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbarib5ui.rs:12:37\n   |\n12 |         largest\
    \ = f32::max(largest, numbers[i] as f64);\n   |                              \
    \       ^^^^^^^^^^^^^^^^^ expected `f32`, found `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbarib5ui.rs:12:19\n   |\n9  |     let mut largest = numbers[0]\
    \ as f64;\n   |                       ----------------- expected due to this value\n\
    ...\n12 |         largest = f32::max(largest, numbers[i] as f64);\n   |      \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `f32`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut lowest = vec![2**56, -2**56];\n    let\
    \ mut highest = vec![2**56, -2**56];\n\n    for &n in numbers {\n        let d\
    \ = &n - lowest[0];\n        if d < 0 {\n            continue;\n        }\n  \
    \      let mut tmp = lowest;\n        lowest[0] = n;\n        lowest[1] = tmp;\n\
    \    }\n\n    for &n in numbers {\n        let d = &n - highest[0];\n        if\
    \ d > 0 {\n            continue;\n        }\n        let mut tmp = highest;\n\
    \        highest[0] = n;\n        highest[1] = tmp;\n    }\n\n    (lowest[0],\
    \ lowest[1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n --> /tmp/tmpvzxv8_th.rs:8:29\n\
    \  |\n8 |     let mut lowest = vec![2**56, -2**56];\n  |                     \
    \        ^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n --> /tmp/tmpvzxv8_th.rs:8:37\n\
    \  |\n8 |     let mut lowest = vec![2**56, -2**56];\n  |                     \
    \                ^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \ --> /tmp/tmpvzxv8_th.rs:9:30\n  |\n9 |     let mut highest = vec![2**56, -2**56];\n\
    \  |                              ^^^\n\nerror[E0614]: type `{integer}` cannot\
    \ be dereferenced\n --> /tmp/tmpvzxv8_th.rs:9:38\n  |\n9 |     let mut highest\
    \ = vec![2**56, -2**56];\n  |                                      ^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvzxv8_th.rs:11:9\n   |\n11 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpvzxv8_th.rs:18:21\n   |\n18 |         lowest[1] = tmp;\n   |   \
    \      ---------   ^^^ expected integer, found struct `Vec`\n   |         |\n\
    \   |         expected due to the type of this binding\n   |\n   = note: expected\
    \ type `{integer}`\n            found struct `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvzxv8_th.rs:21:9\n   |\n21 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpvzxv8_th.rs:28:22\n   |\n28 |         highest[1] = tmp;\n   |  \
    \       ----------   ^^^ expected integer, found struct `Vec`\n   |         |\n\
    \   |         expected due to the type of this binding\n   |\n   = note: expected\
    \ type `{integer}`\n            found struct `V"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut i1 = 0;\n    let mut i2 = numbers.len()\
    \ - 1;\n    let mut diff1 = 0.0; // difference\n    let mut diff2 = 0.0; // difference\n\
    \    let mut best = f64::MAX;\n\n    while i1 != i2 {\n        if numbers[i1]\
    \ < numbers[i2] {\n            diff1 = numbers[i1];\n            diff2 = numbers[i2];\n\
    \            best = numbers[i2];\n            i2 = i2 - 1;\n        } else {\n\
    \            diff1 = numbers[i1];\n            diff2 = numbers[i2];\n        \
    \    best = numbers[i1];\n            i1 = i1 - 1;\n        }\n\n        if diff1\
    \ <= diff2 {\n            best = diff1;\n        } else {\n            best =\
    \ diff2;\n        }\n    }\n\n    (numbers[best], best)\n}\n\nfn main() {\n  \
    \  let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[f64]` cannot be indexed by `f64`\n  --> /tmp/tmpmmkxalrj.rs:34:6\n\
    \   |\n34 |     (numbers[best], best)\n   |      ^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>`\
    \ is not implemented for `f64`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<f64>` for `Vec<f64>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // find minimum value first (if there are more\
    \ min values then return the last one we find).\n    let mut min: f64 = numbers.iter().min(|a,\
    \ b| a.partial_cmp(b).unwrap_or(b.partial_cmp(a).unwrap_or(0)))\n        .unwrap();\n\
    \    let mut min_index = 0;\n\n    // Now find second minimum value\n    for element\
    \ in numbers {\n        if element.partial_cmp(min).unwrap_or(element.partial_cmp(min).unwrap_or(0))\
    \ < 0 {\n            min = element;\n            min_index = elements.len() -\
    \ 1;\n        } else {\n            min_index -= 1;\n        }\n    }\n    (min,\
    \ min_index)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `elements` in this scope\n  --> /tmp/tmpooi791bg.rs:17:25\n\
    \   |\n17 |             min_index = elements.len() - 1;\n   |                \
    \         ^^^^^^^^ help: a local variable with a similar name exists: `element`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpooi791bg.rs:9:39\n\
    \     |\n9    |     let mut min: f64 = numbers.iter().min(|a, b| a.partial_cmp(b).unwrap_or(b.partial_cmp(a).unwrap_or(0)))\n\
    \     |                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpooi791bg.rs:9:39\n     |\n9    |     let mut min: f64 = numbers.iter().min(|a,\
    \ b| a.partial_cmp(b).unwrap_or(b.partial_cmp(a).unwrap_or(0)))\n     |      \
    \                                 ^^^ ----------------------------------------------------------------\
    \ supplied 1 argument\n     |                                       |\n     |\
    \                                       expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpooi791bg.rs:9:24\n\
    \   |\n9  |       let mut min: f64 = numbers.iter().min(|a, b| a.partial_cmp(b).unwrap_or(b.partial_cmp(a).unwrap_or(0)))\n\
    \   |  __________________---___^\n   | |                  |\n   | |          \
    \        expected due to this\n10 | |         .unwrap();\n   | |_________________^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n9  |     let mut min: f64 = *numbers.iter().min(|a, b| a.partial_cmp(b).unwrap_or(b.partial_cmp(a).unwrap_or(0)))\n\
    \   |                        +\n\nerror[E0308]: mismatched t"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_x = numbers[0];\n    let mut\
    \ closest_y = numbers[0];\n\n    for i in 1..numbers.len() {\n        let distance\
    \ = distance(&numbers[i], &closest_x);\n        if distance < closest_y {\n  \
    \          closest_x = numbers[i];\n            closest_y = distance;\n      \
    \  }\n    }\n\n    (closest_x, closest_y)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `distance` in this scope\n  --> /tmp/tmp2m1s0wtc.rs:12:24\n\
    \   |\n12 |         let distance = distance(&numbers[i], &closest_x);\n   |  \
    \                      ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    let mut smallest_index = -1;\n    let mut largest_index =\
    \ -1;\n\n    for i in 1..numbers.len() {\n        if numbers[i] < smallest {\n\
    \            smallest = numbers[i];\n            smallest_index = i;\n       \
    \ }\n        if numbers[i] > largest {\n            largest = numbers[i];\n  \
    \          largest_index = i;\n        }\n    }\n\n    (smallest_index, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpl9z8eg4i.rs:10:30\n\
    \   |\n10 |     let mut smallest_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpl9z8eg4i.rs:11:29\n\
    \   |\n11 |     let mut largest_index = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl9z8eg4i.rs:24:6\n   |\n24 |     (smallest_index,\
    \ largest)\n   |      ^^^^^^^^^^^^^^ expected `f64`, found `usize`\n   |\nhelp:\
    \ you can cast a `usize` to an `f64`, producing the floating point representation\
    \ of the integer, rounded if necessary\n   |\n24 |     (smallest_index as f64,\
    \ largest)\n   |                     ++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut best_dist = f64::MAX;\n    let mut best_num1\
    \ = f64::MAX;\n    let mut best_num2 = f64::MAX;\n\n    for num1 in numbers {\n\
    \        let mut best_num2 = f64::MAX;\n\n        for num2 in numbers {\n    \
    \        let dist = num1 - num2;\n            if dist < best_dist {\n        \
    \        best_dist = dist;\n                best_num1 = num1;\n              \
    \  best_num2 = num2;\n            }\n        }\n\n        // If we found a pair\
    \ of numbers that are closer to each other than the\n        // first pair then\
    \ we break out of the inner loop\n        if best_num1 > best_num2 {\n       \
    \     break;\n        }\n    }\n\n    (best_num1, best_num2)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp1fp9pvn0.rs:10:9\n\
    \   |\n10 |     let mut best_num2 = f64::MAX;\n   |         ----^^^^^^^^^\n  \
    \ |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1fp9pvn0.rs:15:21\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n12  |     for num1 in numbers\
    \ {\n    |                 ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |         for num2 in numbers {\n    |            \
    \         ^^^^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \    |\n12  |     for num1 in &numbers {\n    |                 +\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        let mut min = numbers[0];\n        let mut\
    \ max = numbers[0];\n\n        for n in numbers.iter().rev() {\n            let\
    \ delta_n = max - min;\n            if delta_n >= 0 {\n                // We found\
    \ a number in the middle, return the two numbers\n                let mut mid\
    \ = min + ((max - min) / 2);\n                (mid, n - delta_n + mid)\n     \
    \       } else {\n                // We found the smallest, return the two numbers\n\
    \                let mut mid = min + ((max - min) / 2);\n                (n -\
    \ delta_n, mid)\n            }\n            min = n;\n            max = n;\n \
    \       }\n        (min, max)\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbyxr32k3.rs:16:27\n   |\n\
    16 |             if delta_n >= 0 {\n   |                           ^\n   |   \
    \                        |\n   |                           expected `f64`, found\
    \ integer\n   |                           help: use a float literal: `0.0`\n\n\
    error[E0277]: cannot divide `f64` by `{integer}`\n  --> /tmp/tmpbyxr32k3.rs:18:50\n\
    \   |\n18 |                 let mut mid = min + ((max - min) / 2);\n   |     \
    \                                             ^ no implementation for `f64 / {integer}`\n\
    \   |\n   = help: the trait `Div<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `Div<Rhs>`:\n            \
    \ <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n18 |         \
    \        let mut mid = min + ((max - min) / 2.0);\n   |                      \
    \                               ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbyxr32k3.rs:19:17\n\
    \   |\n16 | /             if delta_n >= 0 {\n17 | |                 // We found\
    \ a number in the middle, return the two numbers\n18 | |                 let mut\
    \ mid = min + ((max - min) / 2);\n19 | |                 (mid, n - delta_n + mid)\n\
    \   | |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found tuple\n\
    ...  |\n23 | |                 (n - delta_n, mid)\n24 | |             }\n   |\
    \ |_____________- expected this to be `()`\n   |\n   = note: expected unit type\
    \ `()`\n                  found tuple `(_, _)`\nhelp: you might have meant to\
    \ return this value\n   |\n19 |                 return (mid, n - delta_n + mid);\n\
    \   |                 ++++++                         +\n\nerror[E0277]: cannot\
    \ divide `f64` by `{integer}`\n  --> /tmp/tmpbyxr32k3.rs:22:50\n   |\n22 |   \
    \              let mut mid = min + ((max - min"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    debug_assert!(numbers.len() >= 2);\n    let mut\
    \ min_diff = numbers.iter().map(|n| f64::abs(n - numbers[0])).min().unwrap();\n\
    \    let mut max_diff = numbers.iter().map(|n| f64::abs(n - numbers[0])).max().unwrap();\n\
    \    let mut min_dist = numbers.iter().map(|n| f64::abs(n - numbers[0])).min_by_unstable().unwrap();\n\
    \    let mut max_dist = numbers.iter().map(|n| f64::abs(n - numbers[0])).max_by_unstable().unwrap();\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    let mut min_dist\
    \ = numbers[0];\n    let mut max_dist = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let diff = numbers[i] - numbers[i - 1];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_dist = numbers[i];\n      \
    \  }\n        if diff > max_diff {\n            max_diff = diff;\n           \
    \ max_dist = numbers[i];\n        }\n        if numbers[i] < min {\n         \
    \   min = numbers[i];\n        }\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        if numbers[i] < min_dist {\n            min_dist\
    \ = numbers[i];\n        }\n        if numbers[i] > max_dist {\n            max_dist\
    \ = numbers[i];\n        }\n    }\n    (min_dist, min_diff)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpq_cxn3e1.rs:9:73\n\
    \     |\n9    |     let mut min_diff = numbers.iter().map(|n| f64::abs(n - numbers[0])).min().unwrap();\n\
    \     |                                                                      \
    \   ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the\
    \ following other types implement trait `Ord`:\n               i128\n        \
    \       i16\n               i32\n               i64\n               i8\n     \
    \          isize\n               u128\n               u16\n             and 4\
    \ others\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpq_cxn3e1.rs:10:73\n\
    \     |\n10   |     let mut max_diff = numbers.iter().map(|n| f64::abs(n - numbers[0])).max().unwrap();\n\
    \     |                                                                      \
    \   ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the\
    \ following other types implement trait `Ord`:\n               i128\n        \
    \       i16\n               i32\n               i64\n               i8\n     \
    \          isize\n               u128\n               u16\n             and 4\
    \ others\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0599]:\
    \ no method named `min_by_unstable` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmpq_cxn3e1.rs:11:73\n   |\n11 |     let mut min_dist = numbers.iter().map(|n|\
    \ f64::abs(n - numbers[0])).min_by_unstable().unwrap();\n   |                \
    \                                                         ^^^^^^^^^^^^^^^ method\
    \ not found in `Map<std::slice::Iter<'_, f64>, [closure@/tmp/tmpq_cxn3e1.rs:11:43:\
    \ 11:71]>`\n\nerror[E0599]: no method named `max_by_unstable` found for struct\
    \ `Map` in the current scope\n  --> /tmp/tmpq_cxn3e1.rs:12:73\n   |\n12 |    \
    \ let mut max_dist = numbers.iter().map(|n| f64::abs(n - numbers[0])).max_by_unstable().unwrap();\n\
    \   |                                                                        \
    \ ^^^^^^^^^^^^^^^ method not found in `Map<std::slice::It"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Find the two elements that are closest to\
    \ each other in the vector\n    let mut min_dist = f64::MAX;\n    let mut max_dist\
    \ = numbers[0];\n\n    let mut min_element = numbers[0];\n    let mut max_element\
    \ = numbers[0];\n\n    for x in numbers {\n        let distance = x - min_element;\n\
    \n        // If a new min has been found update the current min\n        if distance\
    \ < min_dist {\n            min_dist = distance;\n            min_element = x;\n\
    \        }\n\n        // If a new max has been found update the current max\n\
    \        if distance > max_dist {\n            max_dist = distance;\n        \
    \    max_element = x;\n        }\n    }\n\n    (min_element, max_element)\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpfxfr83p9.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0],\
    \ numbers[1]);\n    }\n    let mut min_diff = std::f64::MAX;\n    let mut min_i\
    \ = 1;\n    let mut min_val = numbers[0];\n    for &i in numbers[1..] {\n    \
    \    let diff = (i - min_val).abs();\n        if diff < min_diff {\n         \
    \   min_diff = diff;\n            min_i = i;\n        }\n    }\n    (min_val,\
    \ min_i)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmphmgtfmea.rs:14:15\n   |\n14 |     for &i in numbers[1..]\
    \ {\n   |               ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n14 |     for &i in &numbers[1..]\
    \ {\n   |               +\n14 |     for &i in &mut numbers[1..] {\n   |      \
    \         ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmphmgtfmea.rs:14:15\n\
    \   |\n14 |     for &i in numbers[1..] {\n   |               ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n14 |     for &i in &numbers[1..] {\n   |               +\n14 |     for &i\
    \ in &mut numbers[1..] {\n   |               ++++\n\nerror[E0277]: cannot subtract\
    \ `f64` from `{integer}`\n  --> /tmp/tmphmgtfmea.rs:15:23\n   |\n15 |        \
    \ let diff = (i - min_val).abs();\n   |                       ^ no implementation\
    \ for `{integer} - f64`\n   |\n   = help: the trait `Sub<f64>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphmgtfmea.rs:21:15\n\
    \   |\n21 |     (min_val, min_i)\n   |               ^^^^^ expected `f64`, found\
    \ integer\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n    for (i, element) in numbers.iter().enumerate() {\n      \
    \  let mut smallest_new = smallest;\n        let mut largest_new = largest;\n\
    \        if element < smallest_new {\n            smallest_new = element;\n  \
    \      }\n        if element > largest_new {\n            largest_new = element;\n\
    \        }\n        if element < smallest {\n            smallest = smallest_new;\n\
    \        }\n        if element > largest {\n            largest = largest_new;\n\
    \        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1zocyobt.rs:13:22\n   |\n\
    13 |         if element < smallest_new {\n   |                      ^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&f64`, found\
    \ `f64`\n   |                      help: consider borrowing here: `&smallest_new`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1zocyobt.rs:14:28\n   |\n11 |\
    \         let mut smallest_new = smallest;\n   |                             \
    \   -------- expected due to this value\n...\n14 |             smallest_new =\
    \ element;\n   |                            ^^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             smallest_new\
    \ = *element;\n   |                            +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1zocyobt.rs:16:22\n   |\n16 |         if element > largest_new\
    \ {\n   |                      ^^^^^^^^^^^\n   |                      |\n   |\
    \                      expected `&f64`, found `f64`\n   |                    \
    \  help: consider borrowing here: `&largest_new`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1zocyobt.rs:17:27\n   |\n12 |         let mut largest_new = largest;\n\
    \   |                               ------- expected due to this value\n...\n\
    17 |             largest_new = element;\n   |                           ^^^^^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |             largest_new = *element;\n   |                        \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zocyobt.rs:19:22\n   |\n\
    19 |         if element < smallest {\n   |                      ^^^^^^^^\n   |\
    \                      |\n   |                      expected `&f64`, found `f64`\n\
    \   |                      help: consider borrowing here: `&smallest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1zocyobt.rs:22:22\n   |\n22 |         if element\
    \ > largest {\n   |                      ^^^^^^^\n   |                      |\n\
    \   |                      expected `&f64`, found `f64`\n   |                \
    \      help: consider borrowing here: `&largest`\n\nerror: abort"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest = &numbers[..];\n    let mut\
    \ smallest = &numbers[..];\n    let mut largest = &numbers[..];\n\n    for i in\
    \ 0..(numbers.len() - 1) {\n        if *closest < *smallest\n            || *closest\
    \ > *largest\n            || *smallest < *largest\n        {\n            smallest\
    \ = &numbers[i];\n            largest = &numbers[i];\n        } else {\n     \
    \       smallest = &numbers[i - 1];\n            largest = &numbers[i + 1];\n\
    \        }\n    }\n\n    closest,\n    (smallest, largest),\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmprbzcztr7.rs:25:12\n   |\n25 |     closest,\n   |  \
    \          ^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprbzcztr7.rs:17:24\n   |\n9  |     let mut smallest = &numbers[..];\n\
    \   |                        ------------ expected due to this value\n...\n17\
    \ |             smallest = &numbers[i];\n   |                        ^^^^^^^^^^^\
    \ expected slice `[f64]`, found `f64`\n   |\n   = note: expected reference `&[f64]`\n\
    \              found reference `&f64`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprbzcztr7.rs:18:23\n   |\n10 |     let mut largest = &numbers[..];\n\
    \   |                       ------------ expected due to this value\n...\n18 |\
    \             largest = &numbers[i];\n   |                       ^^^^^^^^^^^ expected\
    \ slice `[f64]`, found `f64`\n   |\n   = note: expected reference `&[f64]`\n \
    \             found reference `&f64`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprbzcztr7.rs:20:24\n   |\n9  |     let mut smallest = &numbers[..];\n\
    \   |                        ------------ expected due to this value\n...\n20\
    \ |             smallest = &numbers[i - 1];\n   |                        ^^^^^^^^^^^^^^^\
    \ expected slice `[f64]`, found `f64`\n   |\n   = note: expected reference `&[f64]`\n\
    \              found reference `&f64`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprbzcztr7.rs:21:23\n   |\n10 |     let mut largest = &numbers[..];\n\
    \   |                       ------------ expected due to this value\n...\n21 |\
    \             largest = &numbers[i + 1];\n   |                       ^^^^^^^^^^^^^^^\
    \ expected slice `[f64]`, found `f64`\n   |\n   = note: expected reference `&[f64]`\n\
    \              found reference `&f64`\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut max\
    \ = std::f64::MIN;\n    for n in numbers {\n        if n < min {\n           \
    \ min = n;\n        }\n        if n > max {\n            max = n;\n        }\n\
    \    }\n    let mut min_diff = std::f64::MAX;\n    let mut max_diff = std::f64::MIN;\n\
    \    for n in numbers {\n        if n < min {\n            continue;\n       \
    \ }\n        if n > max {\n            continue;\n        }\n        let diff\
    \ = n - min;\n        if diff < min_diff {\n            min_diff = diff;\n   \
    \     }\n        if diff > max_diff {\n            max_diff = diff;\n        }\n\
    \    }\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmphyxpl8rg.rs:20:14\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n10  |     for n in numbers {\n\
    \    |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n10  |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest = numbers[0] as f64;\n    let\
    \ mut largest = numbers[0] as f64;\n\n    for i in numbers.iter().skip(1) {\n\
    \        if *i < smallest {\n            smallest = *i;\n        }\n        if\
    \ *i > largest {\n            largest = *i;\n        }\n    }\n\n    smallest,\
    \ largest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpquidb6d5.rs:20:13\n   |\n20 |     smallest, largest\n\
    \   |             ^ expected one of 8 possible tokens\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.is_empty() {\n        (0.0, 0.0)\n\
    \    } else {\n        let mut min = numbers[0]\n        let mut max = numbers[0]\n\
    \        for n in &numbers[1..] {\n            if n < min {\n                min\
    \ = n\n            }\n            if n > max {\n                max = n\n    \
    \        }\n        }\n        (min, max)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpih_2jfy6.rs:11:33\n\
    \   |\n11 |         let mut min = numbers[0]\n   |                           \
    \      ^ help: add `;` here\n12 |         let mut max = numbers[0]\n   |     \
    \    --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpih_2jfy6.rs:12:33\n\
    \   |\n12 |         let mut max = numbers[0]\n   |                           \
    \      ^ help: add `;` here\n13 |         for n in &numbers[1..] {\n   |     \
    \    --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpih_2jfy6.rs:14:20\n\
    \   |\n14 |             if n < min {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected `&f64`, found `f64`\n   | \
    \                   help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpih_2jfy6.rs:15:23\n   |\n11 |         let mut min = numbers[0]\n\
    \   |                       ---------- expected due to this value\n...\n15 | \
    \                min = n\n   |                       ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |                 min\
    \ = *n\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpih_2jfy6.rs:17:20\n   |\n17 |             if n > max {\n   |       \
    \             ^^^\n   |                    |\n   |                    expected\
    \ `&f64`, found `f64`\n   |                    help: consider borrowing here:\
    \ `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpih_2jfy6.rs:18:23\n\
    \   |\n12 |         let mut max = numbers[0]\n   |                       ----------\
    \ expected due to this value\n...\n18 |                 max = n\n   |        \
    \               ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |                 max = *n\n   |                      \
    \ +\n\nerror: aborting due to 6 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (-1, -1);\n\
    \    }\n\n    let mut min_dist = numbers.len() - 1;\n    let mut min_idx = numbers.iter().rev().find(|&n|\
    \ n < numbers[0]).unwrap();\n    let mut max_idx = numbers.iter().rev().find(|&n|\
    \ n > numbers[0]).unwrap();\n\n    while min_idx < max_idx {\n        let mut\
    \ dist = max_idx - min_idx + 1;\n\n        while dist > 0 {\n            dist\
    \ = (min_idx - min_idx + 1) + ((min_idx - min_idx) % dist);\n            min_idx\
    \ = min_idx - 1;\n        }\n\n        let mut min_dist2 = numbers.iter().rev().find(|&n|\
    \ n == numbers[min_idx]).unwrap();\n        let mut max_dist2 = numbers.iter().rev().find(|&n|\
    \ n == numbers[max_idx]).unwrap();\n\n        if min_dist2 > min_dist {\n    \
    \        dist *= 2;\n        }\n        if max_dist2 < min_dist {\n          \
    \  dist *= 2;\n        }\n\n        min_dist = min_dist2;\n        max_idx = max_dist2;\n\
    \    }\n\n    (numbers[min_idx], numbers[max_idx])\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgnwhqp9g.rs:9:17\n  |\n9 |\
    \         return (-1, -1);\n  |                 ^^\n  |                 |\n  |\
    \                 expected `f64`, found integer\n  |                 help: use\
    \ a float literal: `-1.0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgnwhqp9g.rs:9:21\n\
    \  |\n9 |         return (-1, -1);\n  |                     ^^\n  |          \
    \           |\n  |                     expected `f64`, found integer\n  |    \
    \                 help: use a float literal: `-1.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgnwhqp9g.rs:13:58\n   |\n13 |     let mut min_idx = numbers.iter().rev().find(|&n|\
    \ n < numbers[0]).unwrap();\n   |                                            \
    \              ^^^^^^^^^^\n   |                                              \
    \            |\n   |                                                         \
    \ expected `&f64`, found `f64`\n   |                                         \
    \                 help: consider borrowing here: `&numbers[0]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgnwhqp9g.rs:14:58\n   |\n14 |     let mut max_idx\
    \ = numbers.iter().rev().find(|&n| n > numbers[0]).unwrap();\n   |           \
    \                                               ^^^^^^^^^^\n   |             \
    \                                             |\n   |                        \
    \                                  expected `&f64`, found `f64`\n   |        \
    \                                                  help: consider borrowing here:\
    \ `&numbers[0]`\n\nerror[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpgnwhqp9g.rs:17:42\n\
    \   |\n17 |         let mut dist = max_idx - min_idx + 1;\n   |              \
    \                            ^ no implementation for `f64 + {integer}`\n   |\n\
    \   = help: the trait `Add<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64"
  stdout: ''
  timestamp: 1659976422
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() <= 2 {\n        (numbers[0],\
    \ numbers[1])\n    } else {\n        let mut min_distance = numbers[0].abs();\n\
    \        let mut min_element_id = 1;\n        for (i, num) in numbers.iter().enumerate()\
    \ {\n            if num.abs() < min_distance {\n                min_distance =\
    \ num.abs();\n                min_element_id = i;\n            }\n        }\n\
    \        (numbers[min_element_id], numbers[min_element_id + 1])\n    }\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.0, 3.9)`,\n right: `(3.9, 4.0)`', /tmp/tmphg4ef8e5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for (i,\
    \ number) in numbers.iter().enumerate() {\n        let dist = number.abs() - min_dist;\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = number;\n        }\n        if i == 0 {\n            max_number = number;\n\
    \        } else {\n            max_number = numbers[i..i].iter().max().unwrap();\n\
    \        }\n    }\n    (min_number, max_number)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf83mrbbh.rs:15:26\n   |\n\
    9  |     let mut min_number = numbers[0];\n   |                          ----------\
    \ expected due to this value\n...\n15 |             min_number = number;\n   |\
    \                          ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |             min_number = *number;\n   |\
    \                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf83mrbbh.rs:18:26\n\
    \   |\n10 |     let mut max_number = numbers[0];\n   |                       \
    \   ---------- expected due to this value\n...\n18 |             max_number =\
    \ number;\n   |                          ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |             max_number\
    \ = *number;\n   |                          +\n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmpf83mrbbh.rs:20:47\n     |\n20 \
    \  |             max_number = numbers[i..i].iter().max().unwrap();\n     |   \
    \                                            ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf83mrbbh.rs:20:26\n   |\n10 |\
    \     let mut max_number = numbers[0];\n   |                          ----------\
    \ expected due to this value\n...\n20 |             max_number = numbers[i..i].iter().max().unwrap();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |    \
    \         max_number = *numbers[i..i].iter().max().unwrap();\n   |           \
    \               +\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanatio"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance: f64 = std::f64::MAX;\n\
    \    let mut closest_val = numbers[0];\n    let mut closest_idx = 1; // starts\
    \ at 1 not 0\n    let mut closest = numbers[0]; // start at first value\n    for\
    \ (i, val) in numbers.iter().enumerate() {\n        let distance = val - closest;\n\
    \        if min_distance > distance {\n            min_distance = distance;\n\
    \            closest_val = val;\n            closest_idx = i;\n        }\n   \
    \ }\n    (closest_val, closest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptq5ybe6_.rs:16:27\n   |\n\
    9  |     let mut closest_val = numbers[0];\n   |                           ----------\
    \ expected due to this value\n...\n16 |             closest_val = val;\n   | \
    \                          ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |             closest_val = *val;\n   | \
    \                          +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    numbers.iter().cloned().windows(2).min().min().unwrap_or((0,\
    \ 0))\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmp2jof1xfl.rs:8:29\n  |\n8 |     numbers.iter().cloned().windows(2).min().min().unwrap_or((0,\
    \ 0))\n  |                             ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ f64>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        let mut min_number = numbers[0];\n      \
    \  let mut max_number = numbers[0];\n        for i in 1..numbers.len() {\n   \
    \         let n = numbers[i];\n            if n < min_number {\n             \
    \   min_number = n;\n            }\n            if n > max_number {\n        \
    \        max_number = n;\n            }\n        }\n        (min_number, max_number)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpy09i_2_i.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_number1 = f64::INFINITY;\n  \
    \  let mut closest_number2 = f64::INFINITY;\n\n    for i in numbers {\n      \
    \  let mut current_difference = f64::INFINITY;\n        for j in numbers {\n \
    \           if i == j {\n                continue;\n            }\n\n        \
    \    let new_difference = i - j;\n            if new_difference < current_difference\
    \ {\n                current_difference = new_difference;\n                closest_number1\
    \ = i;\n                closest_number2 = j;\n            }\n        }\n    }\n\
    \n    (closest_number1, closest_number2)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmplq6xg18r.rs:13:18\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n11  |     for i in numbers {\n\
    \    |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    12  |         let mut current_difference = f64::INFINITY;\n13  |         for j\
    \ in numbers {\n    |                  ^^^^^^^ value used here after move\n  \
    \  |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n11  |     for i in &numbers {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976421
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = Vec::new();\n    let mut min_num\
    \ = Vec::new();\n\n    let mut num_found = 0;\n    for (i, n) in numbers.into_iter().enumerate()\
    \ {\n        min_dist.push(n);\n        if min_dist.len() == 2 {\n           \
    \ min_num.push(min_dist[0]);\n            min_num.push(min_dist[1]);\n       \
    \     num_found += 1;\n        }\n\n        if num_found == 2 {\n            break;\n\
    \        }\n    }\n\n    (min_num[0], min_num[1])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpyo0ixl00.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.is_empty() {\n        (1, 1)\n   \
    \ } else {\n        let mut current_value = numbers[0];\n        let mut best_value\
    \ = numbers[0];\n        let mut best_distance = numbers[0] as f64;\n        let\
    \ mut current_index = 1;\n        for &number in &numbers {\n            let new_distance\
    \ = current_value - number;\n            if new_distance < best_distance {\n \
    \               best_value = number;\n                best_distance = new_distance;\n\
    \            } else {\n                best_value = number;\n            }\n \
    \           current_value = number;\n            current_index += 1;\n       \
    \ }\n        (best_value, best_distance)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp233vskvt.rs:9:10\n  |\n9 |\
    \         (1, 1)\n  |          ^\n  |          |\n  |          expected `f64`,\
    \ found integer\n  |          help: use a float literal: `1.0`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp233vskvt.rs:9:13\n  |\n9 |         (1, 1)\n \
    \ |             ^\n  |             |\n  |             expected `f64`, found integer\n\
    \  |             help: use a float literal: `1.0`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut a = numbers.clone();\n    let mut b =\
    \ numbers.clone();\n    let mut max_dist = std::f64::MAX;\n    let mut min_dist\
    \ = std::f64::MIN;\n    let mut min_i = -1;\n    let mut max_i = 0;\n\n    for\
    \ i in 0..a.len() {\n        for j in 0..b.len() {\n            let dist = (*a.get(i)\
    \ - *b.get(j)).abs();\n            if min_dist > dist {\n                min_dist\
    \ = dist;\n                min_i = i;\n            }\n            if max_dist\
    \ < dist {\n                max_dist = dist;\n                max_i = j;\n   \
    \         }\n        }\n    }\n    (min_dist, max_dist)\n}\n\nfn main() {\n  \
    \  let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&f64>` cannot be dereferenced\n  --> /tmp/tmp5l2paask.rs:17:25\n\
    \   |\n17 |             let dist = (*a.get(i) - *b.get(j)).abs();\n   |      \
    \                   ^^^^^^^^^\n\nerror[E0614]: type `Option<&f64>` cannot be dereferenced\n\
    \  --> /tmp/tmp5l2paask.rs:17:37\n   |\n17 |             let dist = (*a.get(i)\
    \ - *b.get(j)).abs();\n   |                                     ^^^^^^^^^\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5l2paask.rs:12:21\n\
    \   |\n12 |     let mut min_i = -1;\n   |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = 2.0;\n    let mut max_number\
    \ = numbers[0];\n    let mut min_number = numbers[0];\n    for &n in numbers {\n\
    \        if n == min_number {\n            max_number = n;\n        } else if\
    \ n != max_number {\n            if f64::from(min_distance) < f64::from(n - min_number)\
    \ {\n                min_distance = n - min_number;\n                min_number\
    \ = n;\n            }\n        }\n    }\n    (min_number, max_number)\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprzqr4_gd.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for &n in\
    \ &numbers[1..] {\n        let dist = n.abs();\n        if dist < min_dist {\n\
    \            min_dist = dist;\n            min_number = n;\n        } else if\
    \ dist > max_dist {\n            max_dist = dist;\n            max_number = n;\n\
    \        }\n    }\n    (min_number, max_number)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_dist` in this scope\n  --> /tmp/tmpkn5ru_3d.rs:16:26\n\
    \   |\n16 |         } else if dist > max_dist {\n   |                        \
    \  ^^^^^^^^ help: a local variable with a similar name exists: `min_dist`\n\n\
    error[E0425]: cannot find value `max_dist` in this scope\n  --> /tmp/tmpkn5ru_3d.rs:17:13\n\
    \   |\n17 |             max_dist = dist;\n   |             ^^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_dist`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min1 = numbers[0];\n    let mut max1\
    \ = numbers[0];\n    let mut min2 = numbers[0];\n    let mut max2 = numbers[0];\n\
    \n    for i in numbers {\n        if i < min1 {\n            min1 = i;\n     \
    \   }\n        if i > max1 {\n            max1 = i;\n        }\n        if i <\
    \ min2 {\n            min2 = i;\n        }\n        if i > max2 {\n          \
    \  max2 = i;\n        }\n    }\n    (*min1, *max1)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmp0mxfja1c.rs:27:6\n\
    \   |\n27 |     (*min1, *max1)\n   |      ^^^^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmp0mxfja1c.rs:27:13\n   |\n27 |     (*min1, *max1)\n\
    \   |             ^^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // Sort the input numbers by their absolute value\
    \ from large to small\n    let mut sorted_numbers = numbers.iter().cloned().collect::<Vec<f64>>();\n\
    \    sorted_numbers.sort_by(|a, b| std::cmp::lt(a, b));\n\n    // Find the two\
    \ numbers in sorted order\n    let mut closest = std::cmp::max(f64::MAX, 0.);\n\
    \    let mut second = std::cmp::max(f64::MAX, 0.);\n    for num in &mut sorted_numbers[..2]\
    \ {\n        match std::cmp::min(num, closest.clone()) {\n            None =>\
    \ break,\n            Some(closest) => {\n                if closest.abs() < num.abs()\
    \ {\n                    second = closest;\n                } else {\n       \
    \             closest = num;\n                }\n            }\n        }\n  \
    \  }\n\n    (closest, second)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `lt` in module `std::cmp`\n  --> /tmp/tmp_ph47v_b.rs:10:45\n\
    \   |\n10 |     sorted_numbers.sort_by(|a, b| std::cmp::lt(a, b));\n   |     \
    \                                        ^^ not found in `std::cmp`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_ph47v_b.rs:13:23\n\
    \     |\n13   |     let mut closest = std::cmp::max(f64::MAX, 0.);\n     |   \
    \                    ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_ph47v_b.rs:14:22\n\
    \     |\n14   |     let mut second = std::cmp::max(f64::MAX, 0.);\n     |    \
    \                  ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_ph47v_b.rs:16:15\n\
    \     |\n16   |         match std::cmp::min(num, closest.clone()) {\n     |  \
    \             ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&mut f64`\nnote: required by a bound in `std::cmp::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_ph47v_b.rs:16:34\n   |\n16 |\
    \         match std::cmp::min(num, closest"
  stdout: ''
  timestamp: 1659976422
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n\n    let mut low\
    \ = numbers[0].clone() + 0.01;\n    let mut high = numbers[0].clone() - 0.01;\n\
    \n    for i in 1..numbers.len() {\n        if numbers[i] > high {\n          \
    \  high = numbers[i].clone();\n        }\n\n        if numbers[i] < low {\n  \
    \          low = numbers[i].clone();\n        }\n    }\n\n    (low, high)\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.01, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpnqzurtcl.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., 0.);\n\
    \    }\n    let mut min1 = numbers[0];\n    let mut min2 = numbers[0];\n    let\
    \ mut min3 = numbers[0];\n    for n in numbers {\n        if n < min1 {\n    \
    \        min1 = n;\n        } else if n < min2 {\n            min2 = n;\n    \
    \    } else if n < min3 {\n            min3 = n;\n        }\n    }\n    (min1,\
    \ min2)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpjl68dl7j.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    if numbers[0] < numbers[1] {\n        (numbers[0],\
    \ numbers[1])\n    } else {\n        (numbers[1], numbers[0])\n    }\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpgo9tsdx8.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 101
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut smallest_number = numbers[0];\n    let\
    \ mut largest_number = numbers[0];\n\n    for number in numbers {\n        if\
    \ number < smallest_number {\n            smallest_number = number;\n        }\n\
    \n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n\n    (smallest_number, largest_number)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpsbcc4c_k.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max =\
    \ numbers[0];\n\n    for i in 1..numbers.len() {\n        if numbers[i] < min\
    \ {\n            min = numbers[i];\n        }\n\n        if numbers[i] > max {\n\
    \            max = numbers[i];\n        }\n    }\n\n    min, max\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmp0lh8i1lo.rs:21:8\n   |\n21 |     min, max\n   |   \
    \     ^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976422
- exit_code: 1
  program: "/// From a supplied vector of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let len = numbers.len();\n    if len < 2 {\n\
    \        (numbers[0], numbers[1])\n    } else {\n        let mut closest: Vec<f64>\
    \ = numbers.iter().cloned().collect();\n        let mut closest2: Vec<f64> = numbers.iter().cloned().collect();\n\
    \        let mut lower = 0.0f64;\n        let mut upper = numbers.iter().cloned().collect::<Vec<_>>()[0];\n\
    \        for n in numbers.iter().cloned().collect::<Vec<_>>() {\n            if\
    \ n < lower {\n                lower = n;\n            }\n            if n > upper\
    \ {\n                upper = n;\n            }\n        }\n        if upper -\
    \ lower < 1E-4 {\n            for n in numbers.iter().cloned().collect::<Vec<_>>()\
    \ {\n                if n < lower {\n                    lower = n;\n        \
    \        }\n                if n > upper {\n                    upper = n;\n \
    \               }\n            }\n        }\n        if closest == closest2 {\n\
    \            (0.f64, upper)\n        } else {\n            let mut lower = 0.0f64;\n\
    \            let mut upper = numbers.iter().cloned().collect::<Vec<_>>()[0];\n\
    \            for n in numbers.iter().cloned().collect::<Vec<_>>() {\n        \
    \        if n < lower {\n                    lower = n;\n                }\n \
    \               if n > upper {\n                    upper = n;\n             \
    \   }\n            }\n            if upper - lower < 1E-4 {\n                for\
    \ n in numbers.iter().cloned().collect::<Vec<_>>() {\n                    if n\
    \ < lower {\n                        lower = n;\n                    }\n     \
    \               if n > upper {\n                        upper = n;\n         \
    \           }\n                }\n            }\n            (lower, upper)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpx2j93_da.rs:35:16\n   |\n35 |             (0.f64, upper)\n\
    \   |                ^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0610`.\n"
  stdout: ''
  timestamp: 1659976422
