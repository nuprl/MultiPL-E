language: rs
name: HumanEval_91_is_bored
results:
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| *c != 'i' && *c != '.' && *c != '?' && *c != '!').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_zoo8dtg.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.chars().filter(|c| *c != 'i' && *c\
    \ != '.' && *c != '?' && *c != '!').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ *c != 'i' && *c != '.' && *c != '?' && *c != '!').count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n\n    for (i, word) in S.char_indices().rev()\
    \ {\n        if let Some(x) = &word {\n            if x == 'I' {\n           \
    \     boredoms += 1;\n            }\n        }\n    }\n\n    boredoms\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmrakgl9w.rs:13:16\n   |\n\
    13 |         if let Some(x) = &word {\n   |                ^^^^^^^   ----- this\
    \ expression has type `&char`\n   |                |\n   |                expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<_>`\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpmrakgl9w.rs:14:18\n   |\n14 |             if x == 'I' {\n   | \
    \                 ^^ no implementation for `&_ == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&_`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S // TODO: replace with S match statement\n        .split_whitespace()\n\
    \        .filter(|&s| s.starts_with(\"I\"))\n        .count()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzykm_nim.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S // TODO: replace with\
    \ S match statement\n11 | |         .split_whitespace()\n12 | |         .filter(|&s|\
    \ s.starts_with(\"I\"))\n13 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = 0;\n    for c in S {\n        if c.is_ascii_digit() {\n \
    \           return i;\n        }\n        i += 1;\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpyrbfro5z.rs:11:14\n\
    \   |\n11 |     for c in S {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom(S).count() + is_bored(S, true)\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom` in this scope\n  --> /tmp/tmp71apjc9u.rs:10:5\n\
    \   |\n10 |     boredom(S).count() + is_bored(S, true)\n   |     ^^^^^^^ not found\
    \ in this scope\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n  --> /tmp/tmp71apjc9u.rs:10:26\n   |\n10 |     boredom(S).count()\
    \ + is_bored(S, true)\n   |                          ^^^^^^^^ -  ---- supplied\
    \ 2 arguments\n   |                          |\n   |                         \
    \ expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp71apjc9u.rs:9:4\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |    ^^^^^^^^ ---------\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0425.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter_map(|c|\n        match c {\n            '.' => Some(true),\n\
    \            '?' => Some(true),\n            '!' => Some(true),\n            _\
    \ => None,\n        }\n    ).count() == 3\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpclmq74m7.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.chars().filter_map(|c|\n\
    11 | |         match c {\n12 | |             '.' => Some(true),\n13 | |      \
    \       '?' => Some(true),\n...  |\n16 | |         }\n17 | |     ).count() ==\
    \ 3\n   | |__________________^ expected `isize`, found `bool`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    count_boredoms(S, \"\", false)\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_boredoms` in this scope\n  -->\
    \ /tmp/tmp6i0swm8c.rs:10:5\n   |\n10 |     count_boredoms(S, \"\", false)\n  \
    \ |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if is_bored_impl(&S) != 0 {\n        1\n    } else {\n        0\n   \
    \ }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_bored_impl` in this scope\n  -->\
    \ /tmp/tmpmfgzgnaf.rs:10:8\n   |\n10 |     if is_bored_impl(&S) != 0 {\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.split(|&&c| c.is_alphabetic()).filter(|&&c| c == 'I').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&&_`\n  --> /tmp/tmpvty1b3oj.rs:10:14\n\
    \   |\n10 |     S.split(|&&c| c.is_alphabetic()).filter(|&&c| c == 'I').count()\
    \ + 1\n   |              ^^^ consider giving this closure parameter the explicit\
    \ type `&&_`, with the type parameters specified\n   |\n   = note: type must be\
    \ known at this point\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpvty1b3oj.rs:10:48\n   |\n10 |  \
    \   S.split(|&&c| c.is_alphabetic()).filter(|&&c| c == 'I').count() + 1\n   |\
    \                                                ^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\n\nerror[E0277]: can't compare\
    \ `str` with `char`\n  --> /tmp/tmpvty1b3oj.rs:10:53\n   |\n10 |     S.split(|&&c|\
    \ c.is_alphabetic()).filter(|&&c| c == 'I').count() + 1\n   |                \
    \                                     ^^ no implementation for `str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvty1b3oj.rs:10:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n10 |     S.split(|&&c| c.is_alphabetic()).filter(|&&c| c == 'I').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value d"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut num_boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let mut j = i;\n        while j < S.len() {\n            if S[j]\
    \ == '.' || S[j] == '?' || S[j] == '!' {\n                break;\n           \
    \ }\n            j += 1\n        }\n        if j - i < 3 {\n            num_boredoms.push(i);\n\
    \        }\n        i = j;\n    }\n    num_boredoms.len()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpainu7hkm.rs:15:16\n\
    \   |\n15 |             if S[j] == '.' || S[j] == '?' || S[j] == '!' {\n   | \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpainu7hkm.rs:15:31\n   |\n15 |             if S[j] == '.' || S[j]\
    \ == '?' || S[j] == '!' {\n   |                               ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpainu7hkm.rs:15:46\n   |\n15 |             if S[j] == '.' || S[j]\
    \ == '?' || S[j] == '!' {\n   |                                              ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = S.len();\n    let mut bored: isize = 0;\n    while i > 0\
    \ {\n        bored += 1;\n        i -= 1;\n        if S[i] == '.' || S[i] == '?'\
    \ || S[i] == '!' {\n            i += 1;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjhxpbx52.rs:15:12\n\
    \   |\n15 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjhxpbx52.rs:15:27\n   |\n15 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjhxpbx52.rs:15:42\n   |\n15 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if is_bored_1(S) == 0\n    || is_bored_2(S) == 0\n    || is_bored_3(S)\
    \ == 0\n    || is_bored_4(S) == 0\n    || is_bored_5(S) == 0\n    || is_bored_6(S)\
    \ == 0\n    || is_bored_7(S) == 0\n    || is_bored_8(S) == 0\n    || is_bored_9(S)\
    \ == 0\n    || is_bored_10(S) == 0\n    || is_bored_11(S) == 0\n    || is_bored_12(S)\
    \ == 0\n    || is_bored_13(S) == 0\n    || is_bored_14(S) == 0\n    || is_bored_15(S)\
    \ == 0\n    || is_bored_16(S) == 0\n    || is_bored_17(S) == 0\n    || is_bored_18(S)\
    \ == 0\n    || is_bored_19(S) == 0\n    || is_bored_20(S) == 0\n    || is_bored_21(S)\
    \ == 0\n    || is_bored_22(S) == 0\n    || is_bored_23(S) == 0\n    || is_bored_24(S)\
    \ == 0\n    || is_bored_25(S) == 0\n    || is_bored_26(S) == 0\n    || is_bored_27(S)\
    \ == 0\n    || is_bored_28(S) == 0\n    || is_bored_29(S) == 0\n    || is_bored_30(S)\
    \ == 0\n    || is_bored_31(S) == 0\n    || is_bored_32(S) == 0\n    || is_bored_33(S)\
    \ == 0\n    || is_bored_34(S) == 0\n    || is_bored_35(S) == 0\n    || is_bored_36(S)\
    \ == 0\n    || is_bored_37(S) == 0\n    || is_bored_38(S) == 0\n    || is_bored_39(S)\
    \ == 0\n    || is_bored_40(S) == 0\n    || is_bored_41(S) == 0\n    || is_bored_42(S)\
    \ == 0\n    || is_bored_43(S) == 0\n    || is_bored_44(S) == 0\n    || is_bored_45(S)\
    \ == 0\n    || is_bored_46(S) == 0\n    || is_bored_47(S) == 0\n    || is_bored_48(S)\
    \ == 0\n    || is_bored_49(S) == 0\n    || is_bored_50(S) == 0\n    || is_bored_51(S)\
    \ == 0\n    || is_bored_52(S) == 0\n    || is_bored_53(S) == 0\n    || is_bored_54(S)\
    \ == 0\n    || is_bored_55(S) == 0\n    || is_bored_56(S) == 0\n    || is_bored_57(S)\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpvnisxrnc.rs:67:1\n   |\n\
    10 |     if is_bored_1(S) == 0\n   |     -- this `if` expression has a condition,\
    \ but no block\n...\n67 | }\n   | ^ expected `{`\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S\n        .split_whitespace()\n        .next()\n        .unwrap()\n\
    \        .starts_with(\"I\")\n    {\n        1\n    } else {\n        0\n    }\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpc1js0_jk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = 0; // Start out with 0.\n    for (i, char) in S\n\
    \        .chars()\n        .skip(1)\n        .enumerate()\n    {\n        if char\
    \ == \".\" || char == \"?\" || char == \"!\" {\n            boredoms += 1;\n \
    \       }\n    }\n    return boredoms;\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6po_35aq.rs:16:20\n   |\n\
    16 |         if char == \".\" || char == \"?\" || char == \"!\" {\n   |      \
    \              ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to\
    \ write a `char` literal, use single quotes\n   |\n16 |         if char == '.'\
    \ || char == \"?\" || char == \"!\" {\n   |                    ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6po_35aq.rs:16:35\n   |\n16 |         if char\
    \ == \".\" || char == \"?\" || char == \"!\" {\n   |                         \
    \          ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write\
    \ a `char` literal, use single quotes\n   |\n16 |         if char == \".\" ||\
    \ char == '?' || char == \"!\" {\n   |                                   ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6po_35aq.rs:16:50\n   |\n16 |\
    \         if char == \".\" || char == \"?\" || char == \"!\" {\n   |         \
    \                                         ^^^ expected `char`, found `&str`\n\
    \   |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    16 |         if char == \".\" || char == \"?\" || char == '!' {\n   |        \
    \                                          ~~~\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    count_boredom(S).0\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_boredom` in this scope\n  -->\
    \ /tmp/tmpl2b1b0sq.rs:10:5\n   |\n10 |     count_boredom(S).0\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut words = S.split_whitespace();\n    words.push(String::new());\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while j < S.len() {\n        i +=\
    \ 1;\n        if i > words.len() {\n            break;\n        }\n        if\
    \ words[j].starts_with(\"I\") {\n            if i == words.len() {\n         \
    \       return i;\n            }\n        } else {\n            j += 1;\n    \
    \    }\n    }\n    0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpp6info0g.rs:11:11\n   |\n11 |     words.push(String::new());\n\
    \   |           ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpp6info0g.rs:16:22\n   |\n16 |         if i > words.len() {\n  \
    \ |                      ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpp6info0g.rs:19:12\n\
    \   |\n19 |         if words[j].starts_with(\"I\") {\n   |            ^^^^^^^^\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpp6info0g.rs:20:27\n   |\n20 |             if i\
    \ == words.len() {\n   |                           ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = S.len();\n    let mut bored = false;\n    while i >= 0 {\n\
    \        if S[i] == 'I' {\n            bored = true;\n            break;\n   \
    \     }\n        i -= 1;\n    }\n    bored == true ? 1 : 0\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n\
    \  --> /tmp/tmph02p20x2.rs:19:21\n   |\n19 |     bored == true ? 1 : 0\n   | \
    \                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph02p20x2.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = S.find(\"I\").unwrap();\n    while i != S.len()-1 {\n   \
    \     if S[0..i].contains(\".\")\n            || S[0..i].contains(\"?\")\n   \
    \         || S[0..i].contains(\"!\")\n        {\n            i += 1;\n       \
    \ } else {\n            return 0;\n        }\n        i = S.find(\"I\", i+1).unwrap();\n\
    \    }\n    1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp5wy0gndr.rs:20:15\n     |\n20   |         i = S.find(\"I\", i+1).unwrap();\n\
    \     |               ^^^^ ---  --- supplied 2 arguments\n     |             \
    \  |\n     |               expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut s: Vec<&str> = S.split_whitespace();\n    let mut counter = 0;\n\
    \    let mut i = s.len();\n    while i != 0 {\n        if s[i] == \"I\" {\n  \
    \          counter = counter + 1;\n        }\n        i -= 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp83f_0ei6.rs:10:28\n   |\n\
    10 |     let mut s: Vec<&str> = S.split_whitespace();\n   |                ---------\
    \   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `SplitWhitespace`\n\
    \   |                |\n   |                expected due to this\n   |\n   = note:\
    \ expected struct `Vec<&str>`\n              found struct `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut I = 0;\n    for s in S.chars() {\n        match s {\n       \
    \     '.' | '?' | '!' => I += 1,\n            _ => continue,\n        }\n    }\n\
    \    I\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpgxoje1g6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    let mut sentence_split = S.split(\".\");\n\n\
    \    for i in 0..sentence_split.len() {\n        let s = sentence_split[i];\n\n\
    \        if s.starts_with(\"I\") {\n            counter += 1;\n        }\n   \
    \ }\n\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpkfplyliu.rs:13:32\n   |\n13 |     for i\
    \ in 0..sentence_split.len() {\n   |                                ^^^ method\
    \ not found in `std::str::Split<'_, &str>`\n\nerror[E0608]: cannot index into\
    \ a value of type `std::str::Split<'_, &str>`\n  --> /tmp/tmpkfplyliu.rs:14:17\n\
    \   |\n14 |         let s = sentence_split[i];\n   |                 ^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    use std::str::Chars;\n\n    let boredoms = S.chars().filter_map(|c| {\n\
    \        match c {\n            Chars::new('.', '?', '!') => Some(true),\n   \
    \         _ => None,\n        }\n    });\n\n    boredoms.count() == S.len()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `new` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmp5769teui.rs:14:20\n   |\n14 |  \
    \           Chars::new('.', '?', '!') => Some(true),\n   |                   \
    \ ^^^ function or associated item not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5769teui.rs:19:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n19 |     boredoms.count() == S.len()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n\n    for c in S.chars() {\n        if c == b'I'\
    \ {\n            count += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsz9ryclz.rs:13:17\n   |\n\
    13 |         if c == b'I' {\n   |                 ^^^^ expected `char`, found\
    \ `u8`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0usize;\n    loop {\n        let mut word_iterator\
    \ = S.char_indices().cloned().skip_while(|c| c.0 != 'I');\n        while let Some(next)\
    \ = word_iterator.next() {\n            if next.0 == 0 {\n                break;\n\
    \            }\n            counter += 1;\n        }\n        word_iterator.resume();\n\
    \        if !word_iterator.next().is_some() {\n            break;\n        }\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<CharIndices<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpam_wftlo.rs:12:50\n     |\n12   |         let mut word_iterator\
    \ = S.char_indices().cloned().skip_while(|c| c.0 != 'I');\n     |            \
    \                                      ^^^^^^ expected reference, found tuple\n\
    \     |\n     = note: expected reference `&_`\n                    found tuple\
    \ `(usize, char)`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the\
    \ method `skip_while` exists for struct `Cloned<CharIndices<'_>>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpam_wftlo.rs:12:59\n    |\n12  |  \
    \         let mut word_iterator = S.char_indices().cloned().skip_while(|c| c.0\
    \ != 'I');\n    |                                                            \
    \ ^^^^^^^^^^ method cannot be called on `Cloned<CharIndices<'_>>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `<CharIndices<'_> as Iterator>::Item = &_`\n            which is\
    \ required by `Cloned<CharIndices<'_>>: Iterator`\n            `Cloned<CharIndices<'_>>:\
    \ Iterator`\n            which is required by `&mut Cloned<CharIndices<'_>>: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpam_wftlo.rs:24:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n24 |     counter\n   |     ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |     counter.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for word in S.split_whitespace() {\n        if\
    \ word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp6y63wcte.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let boredoms = S\n        .lines()\n        .filter(|x| x.chars().all(|c|\
    \ c == 'I'))\n        .count();\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1jhnr3px.rs:14:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n14 |     boredoms\n   |     ^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |     boredoms.try_into().unwrap()\n\
    \   |             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if let Ok(s) = s.split_whitespace() {\n        if let Ok(i) = s.split_ascii_lowercase().find(\"\
    i\") {\n            if i.is_ok() {\n                if let Ok(k) = s.find_first_non_ascii_lowercase()\
    \ {\n                    if let Ok(k) = s.find_first_ascii_lowercase() {\n   \
    \                     let mut count = 0;\n                        for s in S {\n\
    \                            if s.starts_with(k) {\n                         \
    \       count += 1;\n                            }\n                        }\n\
    \                        return count;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmpvejk14wn.rs:10:20\n\
    \   |\n10 |     if let Ok(s) = s.split_whitespace() {\n   |                  \
    \  ^ help: a local variable with a similar name exists (notice the capitalization):\
    \ `S`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpvejk14wn.rs:16:34\n\
    \   |\n16 |                         for s in S {\n   |                       \
    \           ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for word in S.split() {\n        let mut suffix\
    \ = word.to_ascii_lowercase();\n        suffix.pop();\n        if suffix.starts_with(\"\
    i\") {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp4ww3ialk.rs:11:19\n     |\n11   |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // Your code here\n    let mut i: isize = 0;\n    for i in S.chars()\
    \ {\n        if i.as_str() == String::from(\"I\") {\n            i += 1;\n   \
    \     }\n    }\n    i;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_str` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpeyd07mwz.rs:13:14\n   |\n13 |         if i.as_str() ==\
    \ String::from(\"I\") {\n   |              ^^^^^^ method not found in `char`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `char`\n\
    \  --> /tmp/tmpeyd07mwz.rs:14:13\n   |\n14 |             i += 1;\n   |       \
    \      -^^^^^\n   |             |\n   |             cannot use `+=` on type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpeyd07mwz.rs:9:27\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n...\n17 |     i;\n   |      - help: remove\
    \ this semicolon\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = 0;\n    while i < S.len() {\n        if S.chars().next().unwrap()\
    \ == 'I' {\n            i += 1;\n        } else {\n            i += 1;\n     \
    \   }\n    }\n    i\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4km8ls_.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     i\n   |     ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     i.try_into().unwrap()\n \
    \  |      ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    count!(1, S, |i| is_bored(i, S));\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `count` in this scope\n  --> /tmp/tmpw4if2wcu.rs:10:5\n\
    \   |\n10 |     count!(1, S, |i| is_bored(i, S));\n   |     ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpw4if2wcu.rs:9:27\n  |\n9 | fn is_bored(S: String)\
    \ -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut S = S.to_string();\n    S.replace(S, S.chars().filter(|c| c !=\
    \ '?').filter(|c| c != '.').collect::<Vec<char>>(), \"*\");\n    let mut num_bored\
    \ = 0;\n    let mut first_word_end = 0;\n    while let Some(end) = S.find(' ')\
    \ {\n        if S[first_word_end..end].starts_with(\"I\") {\n            num_bored\
    \ += 1;\n        }\n        first_word_end = end;\n    }\n    num_bored\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbf_5s9rh.rs:11:41\n\
    \   |\n11 |     S.replace(S, S.chars().filter(|c| c != '?').filter(|c| c != '.').collect::<Vec<char>>(),\
    \ \"*\");\n   |                                         ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbf_5s9rh.rs:11:62\n\
    \   |\n11 |     S.replace(S, S.chars().filter(|c| c != '?').filter(|c| c != '.').collect::<Vec<char>>(),\
    \ \"*\");\n   |                                                              ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0061]: this function takes 2 arguments but 3 arguments\
    \ were supplied\n   --> /tmp/tmpbf_5s9rh.rs:11:7\n    |\n11  |     S.replace(S,\
    \ S.chars().filter(|c| c != '?').filter(|c| c != '.').collect::<Vec<char>>(),\
    \ \"*\");\n    |       ^^^^^^^ -  --------------------------------------------------------------------------\
    \  --- supplied 3 arguments\n    |       |\n    |       expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    let mut word = String::from(\"I\");\n    loop\
    \ {\n        let mut pos = S.find(&mut word);\n        if pos == S.npos {\n  \
    \          break;\n        }\n        let mut boredom = String::from(\"I\");\n\
    \        if S.is_prefix(&boredom) {\n            counter = counter + 1;\n    \
    \    }\n        word = String::from(S[(pos + 1) as usize]);\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpbbclo8uh.rs:13:30\n     |\n13   |         let mut pos = S.find(&mut\
    \ word);\n     |                         ---- ^^^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `String`\n     |                         |\n     |          \
    \               required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `FnMut<(char,)>` is not implemented for `String`\n     = help: the\
    \ following other types implement trait `Pattern<'a>`:\n               &'b String\n\
    \               &'b str\n               &'c &'b str\n     = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&mut String`\n   \
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&mut String`\nnote: required by a bound in `core::str::<impl str>::find`\n\n\
    error[E0609]: no field `npos` on type `String`\n  --> /tmp/tmpbbclo8uh.rs:14:21\n\
    \   |\n14 |         if pos == S.npos {\n   |                     ^^^^ unknown\
    \ field\n\nerror[E0599]: no method named `is_prefix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpbbclo8uh.rs:18:14\n   |\n18 |         if\
    \ S.is_prefix(&boredom) {\n   |              ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `strip_prefix`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpbbclo8uh.rs:21:36\n   |\n21 |         word\
    \ = String::from(S[(pos + 1) as usize]);\n   |                               \
    \ --- ^ - {integer}\n   |                                |\n   |             \
    \                   Option<usize>\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369, E0599, E0609.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| *c == 'I' || *c == '.' || *c == '!' || c == '?').count()\
    \ + 0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd69loi_3.rs:10:67\n\
    \   |\n10 |     S.chars().filter(|c| *c == 'I' || *c == '.' || *c == '!' || c\
    \ == '?').count() + 0\n   |                                                  \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpd69loi_3.rs:10:5\n   |\n9  | fn is_bored(S: String) -> isize {\n   |\
    \                           ----- expected `isize` because of return type\n10\
    \ |     S.chars().filter(|c| *c == 'I' || *c == '.' || *c == '!' || c == '?').count()\
    \ + 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ *c == 'I' || *c == '.' || *c == '!' || c == '?').count() + 0).try_into().unwrap()\n\
    \   |     +                                                                  \
    \               +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter_map(|c| *c >= 'I' as i32).count() == 3\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpf0pl68mp.rs:10:30\n\
    \   |\n10 |     S.chars().filter_map(|c| *c >= 'I' as i32).count() == 3\n   |\
    \                              ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf0pl68mp.rs:10:30\n\
    \   |\n10 |     S.chars().filter_map(|c| *c >= 'I' as i32).count() == 3\n   |\
    \                              ^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `bool`\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `bool`\nhelp: try wrapping the expression in `Some`\n   |\n10 |     S.chars().filter_map(|c|\
    \ Some(*c >= 'I' as i32)).count() == 3\n   |                              +++++\
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf0pl68mp.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter_map(|c|\
    \ *c >= 'I' as i32).count() == 3\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0u64;\n\n    for word in S.chars() {\n        match word\
    \ {\n            '.' | '.?' | '!' | '!?' => {\n                count += 1;\n \
    \           },\n            _ => {\n                continue;\n            }\n\
    \        }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmprh3_5hxa.rs:14:19\n\
    \   |\n14 |             '.' | '.?' | '!' | '!?' => {\n   |                   ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    14 |             '.' | \".?\" | '!' | '!?' => {\n   |                   ~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmprh3_5hxa.rs:14:32\n\
    \   |\n14 |             '.' | '.?' | '!' | '!?' => {\n   |                   \
    \             ^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n14 |             '.' | '.?' | '!' | \"!?\" => {\n   |        \
    \                        ~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprh3_5hxa.rs:23:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n23 |     count\n   |   \
    \  ^^^^^ expected `isize`, found `u64`\n   |\nhelp: you can convert a `u64` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n23 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter_map(|c|\n        match c {\n            'I' => {\n \
    \               Some(true)\n            }\n            '.' => None,\n        \
    \    '?' => None,\n            '!' => None,\n            _ => {\n            \
    \    None\n            }\n        })\n        .count()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzwhn1xcd.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.chars().filter_map(|c|\n\
    11 | |         match c {\n12 | |             'I' => {\n13 | |                \
    \ Some(true)\n...  |\n21 | |         })\n22 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let boredom = |x: &str| {\n        let mut i = 0;\n        loop {\n \
    \           if x[i] != '.' {\n                if i == 0 {\n                  \
    \  return false\n                } else {\n                    i += 1;\n     \
    \           }\n            } else {\n                i += 1;\n               \
    \ if i == 0 {\n                    return true;\n                } else {\n  \
    \                  i += 1;\n                }\n            }\n        }\n    };\n\
    \    S.chars().all(boredom)\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmp7risd2jf.rs:13:16\n\
    \   |\n13 |             if x[i] != '.' {\n   |                ^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0631]: type mismatch in closure arguments\n    --> /tmp/tmp7risd2jf.rs:29:19\n\
    \     |\n10   |     let boredom = |x: &str| {\n     |                   ---------\
    \ found signature of `for<'r> fn(&'r str) -> _`\n...\n29   |     S.chars().all(boredom)\n\
    \     |               --- ^^^^^^^ expected signature of `fn(char) -> _`\n    \
    \ |               |\n     |               required by a bound introduced by this\
    \ call\n     |\nnote: required by a bound in `all`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7risd2jf.rs:29:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n29 |     S.chars().all(boredom)\n   |     ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0631.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // BEGIN Problem 1\n    let boredom_delimiters = vec![\n        String::from(\"\
    ?\"),\n        String::from(\".\"),\n        String::from(\"!\"),\n    ];\n  \
    \  let mut count = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            count += 1;\n            for d in &boredom_delimiters {\n\
    \                if word.contains(&d) {\n                    count += 1;\n   \
    \             }\n            }\n        }\n    }\n    count\n    // END Problem\
    \ 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `String`\n    -->\
    \ /tmp/tmpl040zs3o.rs:21:34\n     |\n21   |                 if word.contains(&d)\
    \ {\n     |                         -------- ^^\n     |                      \
    \   |        |\n     |                         |        expected an `Fn<(char,)>`\
    \ closure, found `String`\n     |                         |        help: consider\
    \ dereferencing here: `&*d`\n     |                         required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Fn<(char,)>` is not\
    \ implemented for `String`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&String`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&&String`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom: usize = 0;\n    let mut idx: usize = S.len();\n\n  \
    \  while idx > 0 {\n        let mut c: usize = 0;\n        loop {\n          \
    \  match S.chars().nth(idx).unwrap() {\n                chars::BLANK      => {\n\
    \                    break;\n                }\n                chars::ALPHA \
    \     => c = 1;\n                chars::DIGIT      => c = 1;\n               \
    \ chars::PUNCTUATION => c = 1;\n                _ => c = 2\n            }\n\n\
    \            idx -= 1;\n\n            if idx == 0 || !(chars::ALPHA == c  ||\n\
    \                            chars::DIGIT == c ||\n                          \
    \  chars::PUNCTUATION == c) {\n                break;\n            }\n       \
    \ }\n\n        if idx == 0 || chars::ALPHA == c {\n            if idx == 0 ||\
    \ chars::ALPHA == c {\n                if idx == 0 || chars::ALPHA == c {\n  \
    \                  boredom += 1;\n                }\n                idx -= 1;\n\
    \            }\n        }\n\n        idx -= 1;\n    }\n\n    boredom\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: `match` arm body without braces\n  --> /tmp/tmpg7l70wam.rs:20:38\n\
    \   |\n20 |                 chars::ALPHA      => c = 1;\n   |                \
    \                   -- ^^^^^- help: use a comma to end a `match` arm expression:\
    \ `,`\n   |                                   |  |\n   |                     \
    \              |  this statement is not surrounded by a body\n   |           \
    \                        while parsing the `match` arm starting here\n\nerror:\
    \ `match` arm body without braces\n  --> /tmp/tmpg7l70wam.rs:21:38\n   |\n21 |\
    \                 chars::DIGIT      => c = 1;\n   |                          \
    \         -- ^^^^^- help: use a comma to end a `match` arm expression: `,`\n \
    \  |                                   |  |\n   |                            \
    \       |  this statement is not surrounded by a body\n   |                  \
    \                 while parsing the `match` arm starting here\n\nerror: `match`\
    \ arm body without braces\n  --> /tmp/tmpg7l70wam.rs:22:39\n   |\n22 |       \
    \          chars::PUNCTUATION => c = 1;\n   |                                \
    \    -- ^^^^^- help: use a comma to end a `match` arm expression: `,`\n   |  \
    \                                  |  |\n   |                                \
    \    |  this statement is not surrounded by a body\n   |                     \
    \               while parsing the `match` arm starting here\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `chars`\n  --> /tmp/tmpg7l70wam.rs:17:17\n\
    \   |\n17 |                 chars::BLANK      => {\n   |                 ^^^^^\
    \ use of undeclared crate or module `chars`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `chars`\n  --> /tmp/tmpg7l70wam.rs:20:17\n\
    \   |\n20 |                 chars::ALPHA      => c = 1;\n   |                \
    \ ^^^^^ use of undeclared crate or module `chars`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `chars`\n  --> /tmp/tmpg7l70wam.rs:21:17\n\
    \   |\n21 |                 chars::DIGIT      => c = 1;\n   |                \
    \ ^^^^^ use of undeclared crate or module `chars`\n\nerror[E0433]: failed to resol"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.lines().filter(|line| line.starts_with(\"I\")).count() as isize\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpsd_wzy76.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom = false;\n    let mut counter = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word[0] == \"I\" {\n            boredom = true;\n        }\n \
    \       if boredom {\n            counter += 1;\n            boredom = false;\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmp6z7bc0q0.rs:13:12\n\
    \   |\n13 |         if word[0] == \"I\" {\n   |            ^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S.contains(\"I\") {\n        S.split_whitespace().filter(|s| s.starts_with(\"\
    I\")).count();\n    } else if S.contains(\".\") {\n        S.split_whitespace().filter(|s|\
    \ s.starts_with(\".\")).count();\n    } else if S.contains(\"?\") {\n        S.split_whitespace().filter(|s|\
    \ s.starts_with(\"?\")).count();\n    } else if S.contains(\"!\") {\n        S.split_whitespace().filter(|s|\
    \ s.starts_with(\"!\")).count();\n    } else {\n        0\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpozagweot.rs:10:24\n   |\n\
    10 |       if S.contains(\"I\") {\n   |  ________________________^\n11 | |   \
    \      S.split_whitespace().filter(|s| s.starts_with(\"I\")).count();\n12 | |\
    \     } else if S.contains(\".\") {\n   | |_____^ expected `isize`, found `()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpozagweot.rs:12:31\n   |\n12 |\
    \       } else if S.contains(\".\") {\n   |  _______________________________^\n\
    13 | |         S.split_whitespace().filter(|s| s.starts_with(\".\")).count();\n\
    14 | |     } else if S.contains(\"?\") {\n   | |_____^ expected `isize`, found\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpozagweot.rs:14:31\n  \
    \ |\n14 |       } else if S.contains(\"?\") {\n   |  _______________________________^\n\
    15 | |         S.split_whitespace().filter(|s| s.starts_with(\"?\")).count();\n\
    16 | |     } else if S.contains(\"!\") {\n   | |_____^ expected `isize`, found\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpozagweot.rs:16:31\n  \
    \ |\n16 |       } else if S.contains(\"!\") {\n   |  _______________________________^\n\
    17 | |         S.split_whitespace().filter(|s| s.starts_with(\"!\")).count();\n\
    18 | |     } else {\n   | |_____^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S\n        .lines()\n        .filter_map(|line| {\n            let word\
    \ = line.to_lowercase();\n            if word.starts_with(\"i\") {\n         \
    \       Some(word)\n            } else {\n                None\n            }\n\
    \        })\n        .count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdz6zwk6v.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S\n11 | |         .lines()\n\
    12 | |         .filter_map(|line| {\n13 | |             let word = line.to_lowercase();\n\
    ...  |\n19 | |         })\n20 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_counter(S).unwrap()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_counter` in this scope\n  -->\
    \ /tmp/tmpqughqdc2.rs:10:5\n   |\n10 |     boredom_counter(S).unwrap()\n   | \
    \    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.count(|c| c == 'i')\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpei12kgno.rs:10:7\n\
    \    |\n10  |       S.count(|c| c == 'i')\n    |         ^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n\
    \    let mut boredom_string: String;\n    let mut word_iterator: impl Iterator<Item\
    \ = &str>;\n    let mut string_iterator: impl Iterator<Item = &str>;\n    let\
    \ mut word = S.split_whitespace().next();\n    while let Some(w) = (word.as_str())\
    \ {\n        count += 1;\n        word_iterator.push(w);\n        word = S.split_whitespace().next();\n\
    \    }\n    boredom_string = word_iterator.join(\" \");\n    boredom_string.chars().filter_map(|c|\n\
    \        match c {\n            '.' => true,\n            '?' => true,\n     \
    \       '!' => true,\n            _ => false,\n        }).take(10).for_each(|c|\n\
    \            boredom_words.push(c));\n    boredom_string.replace(b'I', b' ');\n\
    \    if boredom_words.contains(boredom_string.trim()) {\n        count += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmpkjfi7zk_.rs:16:25\n   |\n16 |     while let Some(w) = (word.as_str())\
    \ {\n   |                         ^             ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n16 -     while let Some(w)\
    \ = (word.as_str()) {\n16 +     while let Some(w) = word.as_str() {\n   | \n\n\
    error[E0562]: `impl Trait` only allowed in function and inherent method return\
    \ types, not in variable binding\n  --> /tmp/tmpkjfi7zk_.rs:13:28\n   |\n13 |\
    \     let mut word_iterator: impl Iterator<Item = &str>;\n   |               \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0562]: `impl Trait` only allowed\
    \ in function and inherent method return types, not in variable binding\n  -->\
    \ /tmp/tmpkjfi7zk_.rs:14:30\n   |\n14 |     let mut string_iterator: impl Iterator<Item\
    \ = &str>;\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `as_str` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpkjfi7zk_.rs:16:31\n   |\n16 |     while let Some(w) = (word.as_str())\
    \ {\n   |                               ^^^^^^ method not found in `Option<&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkjfi7zk_.rs:24:20\n   |\n24 |\
    \             '.' => true,\n   |                    ^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n24 |       \
    \      '.' => Some(true),\n   |                    +++++    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkjfi7zk_.rs:30:34\n   |\n30 |     boredom_string.replace(b'I',\
    \ b' ');\n   |                                  ^^^^ expected `&str`, found `u8`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `u8`\n   --> /tmp/tmpkjfi7zk_.rs:30:20\n\
    \    |\n30  |     boredom_string.replace(b'I', b' ');\n    |                 \
    \   ^^^^^^^ expected an `FnMut<(char,)>` closure, found `u8`\n    |\n    = help:\
    \ the trait `FnMut<(char,)>` is not implemented for `u8`\n    = help: the following\
    \ other "
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    debug_assert!(S != String::new());\n\n    let mut i = 0;\n    let mut\
    \ c = S.chars();\n\n    while i < S.len() {\n        let c = c.next();\n     \
    \   if c.is_none() {\n            return i;\n        }\n\n        if c == Some('I')\
    \ {\n            i += 1;\n        } else if c == Some('.') {\n            i +=\
    \ 1;\n        } else if c == Some('?') {\n            i += 1;\n        } else\
    \ if c == Some('!') {\n            i += 1;\n        } else {\n            return\
    \ i;\n        }\n    }\n    return i;\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu54nry_e.rs:18:20\n   |\n\
    18 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for word in S.split_whitespace() {\n        if\
    \ word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp6y63wcte.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    S.chars().for_each(|c| {\n        match\
    \ c {\n            '.' | '.' | '!' | '.' | '.' => (),\n            '?' | '.' |\
    \ '.' | '!' | '.' => (),\n            _ => {\n                if c == 'I' {\n\
    \                    boredoms += 1;\n                }\n            }\n      \
    \  }\n    });\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpsln954pj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut s = S;\n    let mut i = 0;\n    loop {\n        if i == 0 {\n\
    \            if let Some(ref mut next) = s.find('?') {\n                s = &s[..next];\n\
    \                i += 1;\n            }\n            if let Some(ref mut next)\
    \ = s.find('!') {\n                s = &s[..next];\n                i += 1;\n\
    \            }\n            if let Some(ref mut next) = s.find('.') {\n      \
    \          s = &s[..next];\n                i += 1;\n            }\n         \
    \   if let Some(ref mut next) = s.find('?') {\n                s = &s[..next];\n\
    \                i += 1;\n            }\n            if let Some(ref mut next)\
    \ = s.find('!') {\n                s = &s[..next];\n                i += 1;\n\
    \            }\n            if let Some(ref mut next) = s.find('.') {\n      \
    \          s = &s[..next];\n                i += 1;\n            }\n         \
    \   if let Some(ref mut next) = s.find('!') {\n                s = &s[..next];\n\
    \                i += 1;\n            }\n            if let Some(ref mut next)\
    \ = s.find('.') {\n                s = &s[..next];\n                i += 1;\n\
    \            }\n            if let Some(ref mut next) = s.find('!') {\n      \
    \          s = &s[..next];\n                i += 1;\n            }\n         \
    \   if let Some(ref mut next) = s.find('.') {\n                s = &s[..next];\n\
    \                i += 1;\n            }\n            if let Some(ref mut next)\
    \ = s.find('!') {\n                s = &s[..next];\n                i += 1;\n\
    \            }\n            if let Some(ref mut next) = s.find('.') {\n      \
    \          s = &s[..next];\n                i += 1;\n            }\n         \
    \   if let Some(ref mut next) = s.find('!') {\n                s = &s[..next];\n\
    \                i += 1;\n            }\n            if let Some(ref mut next)\
    \ = s.find('.') {\n                s = &s[..next];\n                i += 1;\n\
    \            }\n            if let Some(ref mut next) = s.find('!') {\n      \
    \          s = &s[..next];\n                i += 1;\n            }\n         \
    \   if let Some(ref mut next) = s.find('.') {\n                s = &s[..next];\n\
    \                i += 1;\n            }\n            if let Some(ref mut next)\
    \ = s.find('!') {\n                s = &s[..next];\n                i += 1;\n\
    \            }\n            if let Some(ref mut next) = s.find('.') {\n      \
    \          s = &s[..next];\n                i += \n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1_wj4hkw.rs:95:3\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \       - unclosed delimiter\n...\n12 |     loop {\n   |          - unclosed delimiter\n\
    13 |         if i == 0 {\n   |                   - unclosed delimiter\n...\n82\
    \ |             if let Some(ref mut next) = s.find('.') {\n   |              \
    \                                       - this delimiter might not be properly\
    \ closed...\n...\n85 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n95 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmp1_wj4hkw.rs:85:1\n\
    \   |\n85 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `RangeTo<&mut usize>`\n  --> /tmp/tmp1_wj4hkw.rs:15:22\n   |\n\
    15 |                 s = &s[..next];\n   |                      ^^^^^^^^^ `String`\
    \ cannot be indexed by `RangeTo<&mut usize>`\n   |\n   = help: the trait `Index<RangeTo<&mut\
    \ usize>>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_wj4hkw.rs:15:21\n\
    \   |\n10 |     let mut s = S;\n   |                 - expected due to this value\n\
    ...\n15 |                 s = &s[..next];\n   |                     ^^^^^^^^^^\
    \ expected struct `String`, found reference\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\nhelp: consider removing the borrow\n\
    \   |\n15 -                 s = &s[..next];\n15 +                 s = s[..next];\n\
    \   | \n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<&mut usize>`\n\
    \  --> /tmp/tmp1_wj4hkw.rs:19:22\n   |\n19 |                 s = &s[..next];\n\
    \   |                      ^^^^^^^^^ `Strin"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom(S).iter().cloned().filter(|&(_, w)| is_bored(w)).count()\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom` in this scope\n  --> /tmp/tmp6u39a0n3.rs:10:5\n\
    \   |\n10 |     boredom(S).iter().cloned().filter(|&(_, w)| is_bored(w)).count()\n\
    \   |     ^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // BEGIN PURE_LOOPS_SOLUTION\n    // Do not print the solution; modify\
    \ is_bored() to return the correct value\n    // BEGIN RUST\n    let mut boredoms:\
    \ Vec<usize> = S.split_whitespace().filter(|w| w.starts_with(\"I\")).collect();\n\
    \    boredoms.sort();\n    let last_boredom = boredoms.last();\n    let mut i\
    \ = 0;\n    while i < boredoms.len() {\n        if boredoms[i] != last_boredom\
    \ {\n            return i;\n        }\n        i += 1;\n    }\n    boredoms.len()\n\
    \    // END RUST\n    // BEGIN PURE_LOOPS_SOLUTION\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<usize>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp_1tvq8vv.rs:13:88\n     |\n13\
    \   |     let mut boredoms: Vec<usize> = S.split_whitespace().filter(|w| w.starts_with(\"\
    I\")).collect();\n     |                                                     \
    \                                   ^^^^^^^ value of type `Vec<usize>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<usize>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_1tvq8vv.rs:18:27\n\
    \   |\n18 |         if boredoms[i] != last_boredom {\n   |                   \
    \        ^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note:\
    \ expected type `usize`\n              found enum `Option<&usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_1tvq8vv.rs:19:20\n   |\n19 |             return\
    \ i;\n   |                    ^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |             return i.try_into().unwrap();\n   |            \
    \         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_1tvq8vv.rs:23:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n23 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n23 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S\n        .split_whitespace()\n        .filter(|w| !w.starts_with(\"\
    I\"))\n        .count()\n}\n\nfn main() {\n    let candidate = is_bored;\n   \
    \ assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2belf56c.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S\n11 | |         .split_whitespace()\n\
    12 | |         .filter(|w| !w.starts_with(\"I\"))\n13 | |         .count()\n \
    \  | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    13 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c|\n        (c == '.' || c == '?' || c == '!') && c\
    \ != 'I'\n    ).count() > 0\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8irqag3v.rs:11:12\n\
    \   |\n11 |         (c == '.' || c == '?' || c == '!') && c != 'I'\n   |     \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8irqag3v.rs:11:24\n\
    \   |\n11 |         (c == '.' || c == '?' || c == '!') && c != 'I'\n   |     \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp8irqag3v.rs:11:36\n   |\n11 |         (c == '.' ||\
    \ c == '?' || c == '!') && c != 'I'\n   |                                    ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8irqag3v.rs:11:49\n\
    \   |\n11 |         (c == '.' || c == '?' || c == '!') && c != 'I'\n   |     \
    \                                            ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8irqag3v.rs:10:5\n   |\n9  |   fn is_bored(S: String) ->\
    \ isize {\n   |                             ----- expected `isize` because of\
    \ return type\n10 | /     S.chars().filter(|c|\n11 | |         (c == '.' || c\
    \ == '?' || c == '!') && c != 'I'\n12 | |     ).count() > 0\n   | |_________________^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut chars = S.chars();\n    chars.next().unwrap().unwrap();\n   \
    \ let mut bored = 0;\n    while chars.next() && chars.next().unwrap().unwrap().is_ascii_lowercase()\
    \ {\n        bored += 1;\n    }\n    bored\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpupp70c53.rs:11:27\n   |\n11 |     chars.next().unwrap().unwrap();\n\
    \   |                           ^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpupp70c53.rs:13:11\n   |\n13 |     while chars.next()\
    \ && chars.next().unwrap().unwrap().is_ascii_lowercase() {\n   |           ^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<char>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpupp70c53.rs:13:49\n\
    \   |\n13 |     while chars.next() && chars.next().unwrap().unwrap().is_ascii_lowercase()\
    \ {\n   |                                                 ^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let boredom_words = vec![\n        \"I\",\n        \"am\",\n        \"\
    a\",\n        \"bore\",\n        \".\",\n        \"?\",\n        \"!\",\n    \
    \    \".\",\n        \".\",\n        \".\",\n        \".\",\n        \".\",\n\
    \        \".\",\n        \".\",\n        \".\",\n        \".\",\n        \".\"\
    ,\n    ];\n    let mut counter = 0;\n    for word in S.chars() {\n        if boredom_words.contains(&word)\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbawevhvo.rs:31:35\n   |\n\
    31 |         if boredom_words.contains(&word) {\n   |                        \
    \           ^^^^^ expected `&str`, found `char`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_count(S).unwrap_or(0)\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmpvlksfgo7.rs:10:5\n   |\n10 |     boredom_count(S).unwrap_or(0)\n   |\
    \     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = S.chars().filter(|c| *c != '\\n').filter(|c| *c != '.').filter(|c|\
    \ *c != '?').filter(|c| *c != '!').count();\n    count += 1;\n    count\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdhdid7h5.rs:12:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n12 |     count\n   |     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut bored = 0;\n    let mut is_first = true;\n    for word in S.split_whitespace()\
    \ {\n        if is_first && word != \"I\" {\n            bored += 1;\n       \
    \ }\n        bored += !is_bored(word);\n        is_first = false;\n    }\n   \
    \ bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp93jlr0n2.rs:16:28\n   |\n\
    16 |         bored += !is_bored(word);\n   |                            ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // TODO: implement the is_bored function\n    ()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxmub_z6o.rs:11:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     // TODO: implement the is_bored function\n\
    11 |     ()\n   |     ^^ expected `isize`, found `()`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.trim().chars().filter(|c| *c == '.' || *c == '?' || *c == '!').count()\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp778cj53g.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.trim().chars().filter(|c| *c == '.'\
    \ || *c == '?' || *c == '!').count() == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if is_bored(&S) {\n        1\n    } else {\n        0\n    }\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihhx7cwb.rs:10:17\n   |\n\
    10 |     if is_bored(&S) {\n   |                 ^^ expected struct `String`,\
    \ found `&String`\n   |\nhelp: consider removing the borrow\n   |\n10 -     if\
    \ is_bored(&S) {\n10 +     if is_bored(S) {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpihhx7cwb.rs:10:8\n   |\n10 |     if is_bored(&S) {\n  \
    \ |        ^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    let mut sentences = S.split_whitespace();\n \
    \   for sentence in sentences {\n        if sentence[0] != \"I\" {\n         \
    \   continue;\n        }\n        count += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmp2l9p4ddm.rs:13:12\n\
    \   |\n13 |         if sentence[0] != \"I\" {\n   |            ^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n   = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n           for more information, see chapter 8 in The Book:\
    \ <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    loop {\n        match S.chars() {\n            Some(c) if c == '.' ||\
    \ c == '?' || c == '!' | c == ' ' => return 0,\n            _ => S,\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpn9flcs2r.rs:12:50\n\
    \   |\n12 |             Some(c) if c == '.' || c == '?' || c == '!' | c == ' '\
    \ => return 0,\n   |                                                  ^^     \
    \    ^^\n   |\nhelp: split the comparison into two\n   |\n12 |             Some(c)\
    \ if c == '.' || c == '?' || c == '!' | c && '!' | c == ' ' => return 0,\n   |\
    \                                                             ++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn9flcs2r.rs:12:13\n   |\n11 |         match\
    \ S.chars() {\n   |               --------- this expression has type `Chars<'_>`\n\
    12 |             Some(c) if c == '.' || c == '?' || c == '!' | c == ' ' => return\
    \ 0,\n   |             ^^^^^^^ expected struct `Chars`, found enum `Option`\n\
    \   |\n   = note: expected struct `Chars<'_>`\n                found enum `Option<_>`\n\
    \nerror[E0369]: no implementation for `char | _`\n  --> /tmp/tmpn9flcs2r.rs:12:57\n\
    \   |\n12 |             Some(c) if c == '.' || c == '?' || c == '!' | c == ' '\
    \ => return 0,\n   |                                                     --- ^\
    \ - _\n   |                                                     |\n   |      \
    \                                               char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn9flcs2r.rs:12:64\n   |\n12 |             Some(c) if c\
    \ == '.' || c == '?' || c == '!' | c == ' ' => return 0,\n   |               \
    \                                                 ^^^ expected `bool`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn9flcs2r.rs:13:18\n   |\n13 |\
    \             _ => S,\n   |                  ^ expected `()`, found struct `String`\n\
    14 |         }\n   |          - help: consider using a semicolon here: `;`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter_map(is_bored_char).count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `is_bored_char` in this scope\n  --> /tmp/tmpb5oltjry.rs:10:26\n\
    \   |\n10 |     S.chars().filter_map(is_bored_char).count()\n   |            \
    \              ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb5oltjry.rs:10:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n10 |     S.chars().filter_map(is_bored_char).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter_map(is_bored_char).count().try_into().unwrap()\n\
    \   |                                                ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    lazy_static! {\n        static ref B: HashMap<&str, isize> =\n      \
    \      hash_map! {\n                \"I\" => 0,\n                \"a\" => 0,\n\
    \                \"the\" => 0,\n                \"to\" => 0,\n               \
    \ \"of\" => 0,\n                \"or\" => 0,\n                \"is\" => 0,\n \
    \               \"in\" => 0,\n                \"to\" => 0,\n                \"\
    if\" => 0,\n                \"it\" => 0,\n                \"you\" => 0,\n    \
    \            \"my\" => 0,\n                \"we\" => 0,\n                \"to\"\
    \ => 0,\n                \"he\" => 0,\n                \"she\" => 0,\n       \
    \         \"and\" => 0,\n                \"it\" => 0,\n                \"that\"\
    \ => 0,\n                \"with\" => 0,\n                \"it\" => 0,\n      \
    \          \"on\" => 0,\n                \"if\" => 0,\n                \"he\"\
    \ => 0,\n                \"he\" => 0,\n                \"she\" => 0,\n       \
    \         \"she\" => 0,\n                \"her\" => 0,\n                \"her\"\
    \ => 0,\n                \"she\" => 0,\n                \"her\" => 0,\n      \
    \          \"his\" => 0,\n                \"her\" => 0,\n                \"his\"\
    \ => 0,\n                \"him\" => 0,\n                \"she\" => 0,\n      \
    \          \"she\" => 0,\n                \"her\" => 0,\n                \"her\"\
    \ => 0,\n                \"him\" => 0,\n                \"the\" => 0,\n      \
    \          \"the\" => 0,\n                \"they\" => 0,\n                \"she\"\
    \ => 0,\n                \"she\" => 0,\n                \"it\" => 0,\n       \
    \         \"it\" => 0,\n                \"he\" => 0,\n                \"he\" =>\
    \ 0,\n                \"she\" => 0,\n                \"she\" => 0,\n         \
    \       \"you\" => 0,\n                \"you\" => 0,\n                \"we\" =>\
    \ 0,\n                \"we\" => 0,\n                \"he\" => 0,\n           \
    \     \"he\" => 0,\n                \"she\" => 0,\n                \"she\" =>\
    \ 0,\n                \"you\" => 0,\n                \"you\" => 0,\n         \
    \       \"we\" => 0,\n                \"we\" => 0,\n                \"she\" =>\
    \ 0,\n                \"she\" => 0,\n                \"his\" => 0,\n         \
    \       \"his\" => 0,\n                \"him\" => 0,\n                \"her\"\
    \ => 0,\n                \"her\" => 0,\n                \"him\" => 0,\n      \
    \          \"she\" => 0,\n                \"she\" => 0,\n                \"the\"\
    \ => 0,\n                \"the\" => 0,\n                \"they\" => 0,\n     \
    \           \"she\" => 0,\n                \"she\" => 0,\n                \"you\"\
    \ => \n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpydkl03ow.rs:103:3\n\
    \    |\n9   | fn is_bored(S: String) -> isize {\n    |                       \
    \          - unclosed delimiter\n10  |     lazy_static! {\n    |             \
    \     - unclosed delimiter\n11  |         static ref B: HashMap<&str, isize> =\n\
    12  |             hash_map! {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n93  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n103 | }\n    |   ^\n\nerror: cannot find macro\
    \ `lazy_static` in this scope\n  --> /tmp/tmpydkl03ow.rs:10:5\n   |\n10 |    \
    \ lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for word in S {\n        if word.starts_with(\"\
    I\") {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpqpfai1lu.rs:11:17\n\
    \   |\n11 |     for word in S {\n   |                 ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii()).count(|c| c == 'I')\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpi8514f3n.rs:10:40\n    |\n10  |     S.chars().filter(|c| c.is_ascii()).count(|c|\
    \ c == 'I')\n    |                                        ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                        |\n    |          \
    \                              expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi8514f3n.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii()).count(|c| c == 'I').try_into().unwrap()\n   |                \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    debug_assert!(S.contains(\".\"));\n    debug_assert!(S.contains(\"?\"\
    ));\n    debug_assert!(S.contains(\"!\"));\n\n    S.lines()\n        .filter(|line|\
    \ line.contains(\"I\"))\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgthphd7p.rs:14:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n...\n14 | /     S.lines()\n15 | | \
    \        .filter(|line| line.contains(\"I\"))\n16 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    match S.chars().skip(1).find(|c| *c == '.') {\n        None => 0,\n \
    \       Some(index) => 1,\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpxo1c35jn.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| *c != '.' && *c != '?' && *c != '!')\n        .count()\
    \ + is_bored(&S[isize_from_u64(S.len())..])\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `isize_from_u64` in this scope\n  -->\
    \ /tmp/tmp2ya2jjqr.rs:11:32\n   |\n11 |         .count() + is_bored(&S[isize_from_u64(S.len())..])\n\
    \   |                                ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2ya2jjqr.rs:11:29\n   |\n11 |  \
    \       .count() + is_bored(&S[isize_from_u64(S.len())..])\n   |             \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n11 |         .count()\
    \ + is_bored((&S[isize_from_u64(S.len())..]).to_string())\n   |              \
    \               +                             +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ya2jjqr.rs:11:20\n   |\n11 |         .count() + is_bored(&S[isize_from_u64(S.len())..])\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ya2jjqr.rs:10:5\n\
    \   |\n9  |   fn is_bored(S: String) -> isize {\n   |                        \
    \     ----- expected `isize` because of return type\n10 | /     S.chars().filter(|c|\
    \ *c != '.' && *c != '?' && *c != '!')\n11 | |         .count() + is_bored(&S[isize_from_u64(S.len())..])\n\
    \   | |__________________________________________________________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n10 ~     (S.chars().filter(|c| *c\
    \ != '.' && *c != '?' && *c != '!')\n11 ~         .count() + is_bored(&S[isize_from_u64(S.len())..])).try_into().unwrap()\n\
    \   |\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp2ya2jjqr.rs:11:18\n\
    \   |\n11 |         .count() + is_bored(&S[isize_from_u64(S.len())..])\n   | \
    \                 ^ no implementation for `usize + isize`\n   |\n   = help: the\
    \ trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \         "
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    while let Some(s) = sentence.next() {\n        if s == \"I\" {\n        \
    \    counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmptn9rhl9h.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut s = S.clone();\n    let mut boredom = false;\n    for ch in &mut\
    \ s {\n        match ch {\n            '.' | '?' | '!' => {\n                boredom\
    \ = true;\n            }\n            _ => {\n                boredom = false;\n\
    \            }\n        }\n    }\n    if boredom {\n        0\n    } else {\n\
    \        1\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpxn75qtnp.rs:12:15\n\
    \   |\n12 |     for ch in &mut s {\n   |               ^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `Iterator` for `&mut String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&mut String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    borem_count(S, \".\", \"?\", \"!\")\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `borem_count` in this scope\n  --> /tmp/tmpplvc1y30.rs:10:5\n\
    \   |\n10 |     borem_count(S, \".\", \"?\", \"!\")\n   |     ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S\n        .lines()\n        .filter(|line| line.chars().all(|c| c ==\
    \ 'I' || c == '.' || c == '?' || c == '!'))\n        .count() + 1\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp2nynixm.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S\n11 | |         .lines()\n\
    12 | |         .filter(|line| line.chars().all(|c| c == 'I' || c == '.' || c ==\
    \ '?' || c == '!'))\n13 | |         .count() + 1\n   | |____________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 ~     (S\n11\
    \ |         .lines()\n12 |         .filter(|line| line.chars().all(|c| c == 'I'\
    \ || c == '.' || c == '?' || c == '!'))\n13 ~         .count() + 1).try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S.starts_with(\"I \") {\n        0\n    } else {\n        1\n    }\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp77q2hzl4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = 0;\n    for (i, word) in S.split_whitespace().enumerate()\
    \ {\n        if word.to_lowercase().starts_with(\"i\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmphwmfn1o7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().fold(0, |acc, c| acc + if c == '.' || c == '?' || c == '!'\
    \ {1} else {0})\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmppl9or4x3.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut c = 0;\n    for ch in S.chars() {\n        match ch {\n     \
    \       '.' | '?' | '!' => c+= 1,\n            c => continue,\n        }\n   \
    \ }\n    c\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpyk8ondfq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for i in S.chars() {\n        if i.is_bored()\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_bored` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpy2s8ngyf.rs:12:14\n   |\n12 |         if i.is_bored() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().any(|c| c.is_ascii_alphanumeric() || c == ' ' || c == '.' ||\
    \ c == '!' || c == '?')\n}\n\nfn main() {\n    let candidate = is_bored;\n   \
    \ assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68dqx35p.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.chars().any(|c| c.is_ascii_alphanumeric()\
    \ || c == ' ' || c == '.' || c == '!' || c == '?')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    use std::cmp::Ordering;\n    use std::cmp::Ordering::*;\n    use std::cmp::PartialOrd;\n\
    \    use std::cmp::PartialOrd::*;\n\n    let mut words = S.chars().collect::<Vec<_>>();\n\
    \    let mut current_word = String::new();\n    let mut i = 0;\n    let mut boredom_count\
    \ = 0;\n\n    while i < words.len() {\n        if words[i] == 'I' {\n        \
    \    boredom_count++;\n            current_word.clear();\n            i += 1;\n\
    \        }\n\n        if current_word.is_empty() {\n            current_word.push(words[i]);\n\
    \        } else {\n            if current_word == String::from(\"I\") {\n    \
    \            boredom_count++;\n                current_word.clear();\n       \
    \         i += 1;\n            }\n        }\n\n        i += 1;\n    }\n\n    boredom_count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmptct0_th4.rs:22:26\n\
    \   |\n22 |             boredom_count++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |       \
    \      { let tmp = boredom_count; boredom_count += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -             boredom_count++;\n\
    22 +             boredom_count += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmptct0_th4.rs:31:30\n   |\n31 |                 boredom_count++;\n\
    \   |                              ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n31 |                 { let tmp = boredom_count; boredom_count\
    \ += 1; tmp };\n   |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    31 -                 boredom_count++;\n31 +                 boredom_count += 1;\n\
    \   | \n\nerror: items in traits are not importable\n  --> /tmp/tmptct0_th4.rs:13:9\n\
    \   |\n13 |     use std::cmp::PartialOrd::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nwarning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmptct0_th4.rs:10:9\n\
    \   |\n10 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import:\
    \ `std::cmp::Ordering::*`\n  --> /tmp/tmptct0_th4.rs:11:9\n   |\n11 |     use\
    \ std::cmp::Ordering::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^\n\nwarning: the item\
    \ `PartialOrd` is imported redundantly\n   --> /tmp/tmptct0_th4.rs:12:9\n    |\n\
    12  |     use std::cmp::PartialOrd;\n    |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning:\
    \ unused import: `std::cmp::PartialOrd`\n  --> /tmp/tmptct0_th4.rs:12:9\n   |\n\
    12 |     use std::cmp::PartialOrd;\n   |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning:\
    \ unused import: `std::cmp::PartialOrd::*`\n  --> /tmp/tmptct0_th4.rs:13:9\n \
    \  |\n13 |     use std::cmp::PartialOrd::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors; 5 warnings emitted\n\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // TODO:\n    // Count sentences that start with the letter 'I'.\n  \
    \  // Return 0 if the string does not contain any sentences that\n    // start\
    \ with 'I'.\n    // Return 1 otherwise.\n    0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpv6rj2l3x.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if is_bored_helper(S, \"I\")\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpyunue3er.rs:11:1\n   |\n\
    10 |     if is_bored_helper(S, \"I\")\n   |     -- this `if` expression has a\
    \ condition, but no block\n11 | }\n   | ^ expected `{`\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter: isize = 0;\n    let mut last_end = 0;\n    for pos in\
    \ S.char_indices() {\n        if *pos == '.' {\n            if last_end == 0 ||\
    \ *pos == '!' {\n                counter = 1;\n            }\n            last_end\
    \ = pos + 1;\n        } else if *pos == '?' {\n            counter = 1;\n    \
    \        last_end = pos + 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmpkse_kz18.rs:13:12\n\
    \   |\n13 |         if *pos == '.' {\n   |            ^^^^\n\nerror[E0614]: type\
    \ `(usize, char)` cannot be dereferenced\n  --> /tmp/tmpkse_kz18.rs:14:33\n  \
    \ |\n14 |             if last_end == 0 || *pos == '!' {\n   |                \
    \                 ^^^^\n\nerror[E0369]: cannot add `{integer}` to `(usize, char)`\n\
    \  --> /tmp/tmpkse_kz18.rs:17:28\n   |\n17 |             last_end = pos + 1;\n\
    \   |                        --- ^ - {integer}\n   |                        |\n\
    \   |                        (usize, char)\n\nerror[E0614]: type `(usize, char)`\
    \ cannot be dereferenced\n  --> /tmp/tmpkse_kz18.rs:18:19\n   |\n18 |        \
    \ } else if *pos == '?' {\n   |                   ^^^^\n\nerror[E0369]: cannot\
    \ add `{integer}` to `(usize, char)`\n  --> /tmp/tmpkse_kz18.rs:20:28\n   |\n\
    20 |             last_end = pos + 1;\n   |                        --- ^ - {integer}\n\
    \   |                        |\n   |                        (usize, char)\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0614.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    for s in S.split('.') {\n        if s.starts_with(\"\
    I\") {\n            counter += 1;\n        }\n    }\n    counter as isize\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp33nlfb62.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut idx = 0;\n    while idx < S.len() {\n        let c = S.chars().nth(idx).unwrap();\n\
    \        if c == b'.' || c == b'.' || c == b'.' || c == '!' || c == '?' {\n  \
    \          idx++;\n        } else {\n            break;\n        }\n    }\n  \
    \  idx\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp49972tyk.rs:14:16\n\
    \   |\n14 |             idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n14 |             { let tmp = idx; idx +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n14 -         \
    \    idx++;\n14 +             idx += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp49972tyk.rs:13:17\n   |\n13 |         if c == b'.' || c == b'.'\
    \ || c == b'.' || c == '!' || c == '?' {\n   |                 ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp49972tyk.rs:13:30\n\
    \   |\n13 |         if c == b'.' || c == b'.' || c == b'.' || c == '!' || c ==\
    \ '?' {\n   |                              ^^^^ expected `char`, found `u8`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp49972tyk.rs:13:43\n   |\n13 |  \
    \       if c == b'.' || c == b'.' || c == b'.' || c == '!' || c == '?' {\n   |\
    \                                           ^^^^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp49972tyk.rs:19:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     idx\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |     idx.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == ' ' || c == '.' || c == '?' || c == '!').count()\
    \ + 1 // + 1 to count the initial 'I' at the beginning\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpknzidwde.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == ' ' || c == '.' || c == '?' || c ==\
    \ '!').count() + 1 // + 1 to count the initial 'I' at the beginning\n   |    \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpknzidwde.rs:10:40\n   |\n10 |     S.chars().filter(|c|\
    \ c == ' ' || c == '.' || c == '?' || c == '!').count() + 1 // + 1 to count the\
    \ initial 'I' at the beginning\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpknzidwde.rs:10:52\n\
    \   |\n10 |     S.chars().filter(|c| c == ' ' || c == '.' || c == '?' || c ==\
    \ '!').count() + 1 // + 1 to count the initial 'I' at the beginning\n   |    \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpknzidwde.rs:10:64\n   |\n10\
    \ |     S.chars().filter(|c| c == ' ' || c == '.' || c == '?' || c == '!').count()\
    \ + 1 // + 1 to count the initial 'I' at the beginning\n   |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpknzidwde.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == ' ' || c == '.' || c == '?'\
    \ || c == '!"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.split_whitespace().filter(|c| c >= 'I').count()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_r6xvaua.rs:10:42\n   |\n\
    10 |     S.split_whitespace().filter(|c| c >= 'I').count()\n   |             \
    \                             ^^^ expected `&&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_r6xvaua.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.split_whitespace().filter(|c| c >= 'I').count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n10 |     S.split_whitespace().filter(|c|\
    \ c >= 'I').count().try_into().unwrap()\n   |                                \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    let mut last: &str;\n    for s in S.split_whitespace()\
    \ {\n        if s.starts_with(\"I\") {\n            counter = counter + 1;\n \
    \       }\n        last=s;\n    }\n    return counter;\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpza5kp0ac.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut is_bored = 0;\n    let mut buffer = S;\n    let mut index = 0;\n\
    \    while index < buffer.len() {\n        if buffer[index] == '.' {\n       \
    \     if index != 0 {\n                is_bored += 1;\n            }\n       \
    \ }\n        if buffer[index] == '?' || buffer[index] == '!' {\n            if\
    \ index != 0 {\n                is_bored += 1;\n            }\n        }\n   \
    \     index += 1;\n    }\n    is_bored\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo1coad2j.rs:14:12\n\
    \   |\n14 |         if buffer[index] == '.' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo1coad2j.rs:19:12\n   |\n19 |         if buffer[index] == '?' ||\
    \ buffer[index] == '!' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo1coad2j.rs:19:36\n   |\n19 |         if buffer[index] == '?' ||\
    \ buffer[index] == '!' {\n   |                                    ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom = S;\n    boredom.remove_prefix(\"I\".to_string());\n\
    \    boredom.remove_suffix(\".\".to_string());\n    boredom.split_whitespace().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_prefix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpuy_5xsid.rs:11:13\n   |\n11 |     boredom.remove_prefix(\"\
    I\".to_string());\n   |             ^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `remove_suffix` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpuy_5xsid.rs:12:13\n   |\n12 |     boredom.remove_suffix(\"\
    .\".to_string());\n   |             ^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmpuy_5xsid.rs:13:45\n\
    \   |\n13 |     boredom.split_whitespace().filter(|c| c == '.' || c == '?' ||\
    \ c == '!').count() > 0\n   |                                             ^^ no\
    \ implementation for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&&str` with `char`\n \
    \ --> /tmp/tmpuy_5xsid.rs:13:57\n   |\n13 |     boredom.split_whitespace().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() > 0\n   |                        \
    \                                 ^^ no implementation for `&&str == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, st"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.split_whitespace().filter(|s| s.chars().any(|c| c == '.' || c == '?'\
    \ || c == '!')).count() == 3\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95c5inoc.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.split_whitespace().filter(|s| s.chars().any(|c|\
    \ c == '.' || c == '?' || c == '!')).count() == 3\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S.starts_with(\"I\") {\n        0\n    } else {\n        1\n    }\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp16ydeqep.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let s = &S;\n    let mut count = 0;\n    let mut word: String;\n    for\
    \ w in s.split_whitespace() {\n        word.clear();\n        w.to_lowercase();\n\
    \        word.push(w.chars().filter(|c| c == ' ').count());\n        if *word\
    \ == \"i\" {\n            count++;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpow6wt8g5.rs:18:18\n\
    \   |\n18 |             count++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp =\
    \ count; count += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    18 -             count++;\n18 +             count += 1;\n   | \n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpow6wt8g5.rs:16:42\n   |\n16\
    \ |         word.push(w.chars().filter(|c| c == ' ').count());\n   |         \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpow6wt8g5.rs:16:19\n   |\n16 |         word.push(w.chars().filter(|c|\
    \ c == ' ').count());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0277]: can't compare `str` with `&str`\n\
    \  --> /tmp/tmpow6wt8g5.rs:17:18\n   |\n17 |         if *word == \"i\" {\n   |\
    \                  ^^ no implementation for `str == &str`\n   |\n   = help: the\
    \ trait `PartialEq<&str>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut bored_count = 0;\n\n    for s in S.chars() {\n        if s.is_lowercase()\
    \ {\n            if s.starts_with(\"i\") {\n                bored_count += 1;\n\
    \            }\n        }\n    }\n\n    bored_count\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp22lftvwt.rs:14:18\n   |\n14 |             if s.starts_with(\"\
    i\") {\n   |                  ^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom = false;\n    for ch in S.chars() {\n        if ch ==\
    \ ' ' || ch == '.' || ch == '?' || ch == '!' {\n            boredom = true;\n\
    \            break;\n        }\n    }\n    boredom ? 1 : 0;\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n\
    \  --> /tmp/tmpgew5i3ut.rs:17:15\n   |\n17 |     boredom ? 1 : 0;\n   |      \
    \         ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n\n    let mut is_bored = true;\n\n    for c in\
    \ S.chars() {\n        if c.is_alphabetic() {\n            counter = counter +\
    \ 1;\n        } else {\n            is_bored = false;\n        }\n    }\n\n  \
    \  if is_bored {\n        counter\n    } else {\n        0\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp2yu4o4g0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    let mut last_word = String::from(\"\");\n   \
    \ let mut sentence_tokens = S.split_whitespace().collect::<Vec<_>>();\n    let\
    \ mut last_sentence_tokens = Vec::new();\n    let mut bored = true;\n    for word\
    \ in sentence_tokens {\n        if word.starts_with(\"I\") {\n            bored\
    \ = false;\n        }\n        if bored {\n            last_word = word;\n   \
    \     }\n    }\n    for token in last_sentence_tokens {\n        if token.starts_with(\"\
    I\") {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvpk9g3se.rs:20:25\n   |\n\
    11 |     let mut last_word = String::from(\"\");\n   |                       \
    \  ---------------- expected due to this value\n...\n20 |             last_word\
    \ = word;\n   |                         ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                         |\n   |                       \
    \  expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    loop {\n        let mut S = S.to_string();\n        let i = S.find(\"\
    \ \");\n        if i < 0 {\n            break;\n        }\n        let j = S.rfind(\"\
    !\");\n        if j == S.len() - 1 {\n            break;\n        }\n        let\
    \ k = S.rfind(\"?\");\n        if k == S.len() - 1 {\n            break;\n   \
    \     }\n        if S[0..i] == String::from(\"I\") {\n            S += \"!\";\
    \ // change ! to ?\n        }\n        if S[j..k] == String::from(\".\") {\n \
    \           S += \"?\";\n        }\n    }\n    S.len() - 1\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeki847gl.rs:13:16\n   |\n\
    13 |         if i < 0 {\n   |                ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n13 |         if i < Some(0)\
    \ {\n   |                +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeki847gl.rs:17:17\n\
    \   |\n17 |         if j == S.len() - 1 {\n   |                 ^^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |         if j == Some(S.len() - 1) {\n   |                 +++++  \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeki847gl.rs:21:17\n\
    \   |\n21 |         if k == S.len() - 1 {\n   |                 ^^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n21 |         if k == Some(S.len() - 1) {\n   |                 +++++  \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeki847gl.rs:24:17\n\
    \   |\n24 |         if S[0..i] == String::from(\"I\") {\n   |                \
    \ ^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `std::ops::Range<Option<usize>>`\n  --> /tmp/tmpeki847gl.rs:27:12\n\
    \   |\n27 |         if S[j..k] == String::from(\".\") {\n   |            ^^^^^^^\
    \ `String` cannot be indexed by `std::ops::Range<Option<usize>>`\n   |\n   = help:\
    \ the trait `Index<std::ops::Range<Option<usize>>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \         "
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom = false;\n    for (i, word) in S.split_whitespace().enumerate()\n\
    \        .filter(|&(_, w)| w == \"I\" && i > 0)\n    {\n        boredom = true;\n\
    \        break;\n    }\n    if boredom { 0 } else { 1 }\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpjai30hkb.rs:12:39\n\
    \   |\n12 |         .filter(|&(_, w)| w == \"I\" && i > 0)\n   |             \
    \                          ^ help: a local variable with a similar name exists:\
    \ `S`\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0u32;\n\n    let mut boredom = S;\n    loop {\n     \
    \   let mut pos = boredom.find_first_of(\"I\");\n        if pos == S.len() {\n\
    \            return count;\n        }\n        if pos == 0 {\n            boredom\
    \ = boredom.trim_end().trim_start();\n        } else {\n            boredom =\
    \ boredom.split_off(pos).trim_end().trim_start();\n        }\n        count +=\
    \ 1;\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_first_of` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1yvyfjc_.rs:14:31\n   |\n14 |         let\
    \ mut pos = boredom.find_first_of(\"I\");\n   |                              \
    \ ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1yvyfjc_.rs:16:20\n   |\n16 |             return count;\n   | \
    \                   ^^^^^ expected `isize`, found `u32`\n   |\nhelp: you can convert\
    \ a `u32` to an `isize` and panic if the converted value doesn't fit\n   |\n16\
    \ |             return count.try_into().unwrap();\n   |                      \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1yvyfjc_.rs:19:23\n\
    \   |\n12 |     let mut boredom = S;\n   |                       - expected due\
    \ to this value\n...\n19 |             boredom = boredom.trim_end().trim_start();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                       |\n   |      \
    \                 expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1yvyfjc_.rs:21:23\n   |\n12 |     let mut boredom = S;\n\
    \   |                       - expected due to this value\n...\n21 |          \
    \   boredom = boredom.split_off(pos).trim_end().trim_start();\n   |          \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                       |\n   |    \
    \                   expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = 0;\n    S.split(\" \").for_each(|word| {\n        if word.starts_with(\"\
    I\") {\n            i += 1;\n        }\n    });\n    i\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp4f50cz1y.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for c in S.chars() {\n        match c {\n   \
    \         '.' => count += 1,\n            '?' => count += 1,\n            '!'\
    \ => count += 1,\n            _ => (),\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpyo0tztvj.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_count(S).iter().count()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmpok0bmuo2.rs:10:5\n   |\n10 |     boredom_count(S).iter().count()\n \
    \  |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for i in S.chars() {\n        if i == '.' ||\
    \ i == '?' || i == '!' {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpwon9_tsz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S.is_empty() {\n        0\n    } else {\n        let mut bored_idx\
    \ = 1;\n        let mut word_idx = 0;\n        let mut bored_char = S.get(word_idx).unwrap().to_lowercase();\n\
    \        loop {\n            if bored_char == \"i\" {\n                break;\n\
    \            } else if bored_char == \"e\" {\n                bored_idx = 1;\n\
    \            } else {\n                bored_idx = 0;\n            }\n       \
    \     word_idx += 1;\n            bored_char = S.get(word_idx).unwrap().to_lowercase();\n\
    \        }\n        bored_idx\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpzch8grav.rs:15:36\n\
    \    |\n15  |         let mut bored_char = S.get(word_idx).unwrap().to_lowercase();\n\
    \    |                                --- ^^^^^^^^ string indices are ranges of\
    \ `usize`\n    |                                |\n    |                     \
    \           required by a bound introduced by this call\n    |\n    = help: the\
    \ trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you\
    \ can use `.chars().nth()` or `.bytes().nth()`\n            for more information,\
    \ see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `{integer}`\n   --> /tmp/tmpzch8grav.rs:25:32\n    |\n25  |  \
    \           bored_char = S.get(word_idx).unwrap().to_lowercase();\n    |     \
    \                       --- ^^^^^^^^ string indices are ranges of `usize`\n  \
    \  |                            |\n    |                            required by\
    \ a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n    = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n            for more information, see chapter 8 in The\
    \ Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let boredom = S\n        .split_whitespace()\n        .filter(|w| w ==\
    \ String::from(\"I\"))\n        .count();\n    boredom\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `String`\n  --> /tmp/tmp7r9na9r9.rs:12:23\n\
    \   |\n12 |         .filter(|w| w == String::from(\"I\"))\n   |              \
    \         ^^ no implementation for `&&str == String`\n   |\n   = help: the trait\
    \ `PartialEq<String>` is not implemented for `&&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7r9na9r9.rs:14:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n14 |     boredom\n   | \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n14 |     boredom.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = S\n        .split_whitespace()\n        .count();\n \
    \   if S\n        .chars()\n        .find(|&c| c != 'I')\n        .is_none()\n\
    \    {\n        count -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkibab7n.rs:20:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n20 |     count\n   |     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n\n    for (i, word) in S.split_whitespace().into_iter().enumerate()\
    \ {\n        if word != \"I\" {\n            continue;\n        }\n\n        counter\
    \ += 1;\n    }\n\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpa0m897hl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // Complete this function\n    let mut boredoms: usize = 0;\n    S.split_whitespace().filter(|c|\
    \ c.is_ascii()).for_each(|c| {\n        match c {\n            'I' => boredoms\
    \ += 1,\n            _ => (),\n        }\n    });\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf0pbp1d0.rs:14:13\n   |\n\
    13 |         match c {\n   |               - this expression has type `&str`\n\
    14 |             'I' => boredoms += 1,\n   |             ^^^ expected `str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf0pbp1d0.rs:18:5\n \
    \  |\n9  | fn is_bored(S: String) -> isize {\n   |                           -----\
    \ expected `isize` because of return type\n...\n18 |     boredoms\n   |     ^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms.try_into().unwrap()\n\
    \   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut s = S.char_indices().collect::<Vec<_>>();\n    let mut count\
    \ = 0;\n    while s.len() > 0 {\n        if s[0] == &\"I\" {\n            count\
    \ += 1;\n        }\n        if s[0] == &\"!\" {\n            count += 1;\n   \
    \     }\n        if s[0] == &\".\" {\n            count += 1;\n        }\n   \
    \     if s[0] == &\"?\" {\n            count += 1;\n        }\n        s.remove_prefix(1);\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpksmgcupu.rs:13:20\n   |\n\
    13 |         if s[0] == &\"I\" {\n   |                    ^^^^ expected tuple,\
    \ found `&&'static str`\n   |\n   = note:  expected tuple `(usize, char)`\n  \
    \         found reference `&&'static str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpksmgcupu.rs:16:20\n   |\n16 |         if s[0] == &\"!\" {\n   |\
    \                    ^^^^ expected tuple, found `&&'static str`\n   |\n   = note:\
    \  expected tuple `(usize, char)`\n           found reference `&&'static str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpksmgcupu.rs:19:20\n   |\n19 |\
    \         if s[0] == &\".\" {\n   |                    ^^^^ expected tuple, found\
    \ `&&'static str`\n   |\n   = note:  expected tuple `(usize, char)`\n        \
    \   found reference `&&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpksmgcupu.rs:22:20\n\
    \   |\n22 |         if s[0] == &\"?\" {\n   |                    ^^^^ expected\
    \ tuple, found `&&'static str`\n   |\n   = note:  expected tuple `(usize, char)`\n\
    \           found reference `&&'static str`\n\nerror[E0599]: no method named `remove_prefix`\
    \ found for struct `Vec<(usize, char)>` in the current scope\n  --> /tmp/tmpksmgcupu.rs:25:11\n\
    \   |\n25 |         s.remove_prefix(1);\n   |           ^^^^^^^^^^^^^ method not\
    \ found in `Vec<(usize, char)>`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    count_boredoms(S, \"\").0\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_boredoms` in this scope\n  -->\
    \ /tmp/tmpzbgerkzx.rs:10:5\n   |\n10 |     count_boredoms(S, \"\").0\n   |   \
    \  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut cnt = 0;\n    for c in S {\n        match c {\n            '.'\
    \ | '.?' | '.!' | '*' | '?' | '!' => (),\n            'I' => {\n             \
    \   cnt += 1;\n            }\n            _ => (),\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpmzvtwj0t.rs:13:19\n\
    \   |\n13 |             '.' | '.?' | '.!' | '*' | '?' | '!' => (),\n   |     \
    \              ^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n13 |             '.' | \".?\" | '.!' | '*' | '?' | '!' => (),\n\
    \   |                   ~~~~\n\nerror: character literal may only contain one\
    \ codepoint\n  --> /tmp/tmpmzvtwj0t.rs:13:26\n   |\n13 |             '.' | '.?'\
    \ | '.!' | '*' | '?' | '!' => (),\n   |                          ^^^^\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n13 |   \
    \          '.' | '.?' | \".!\" | '*' | '?' | '!' => (),\n   |                \
    \          ~~~~\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpmzvtwj0t.rs:11:14\n\
    \   |\n11 |     for c in S {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_count(&S.split_whitespace())\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmpt_pk654n.rs:10:5\n   |\n10 |     boredom_count(&S.split_whitespace())\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    match S {\n        &\".\" | \"!\" | \"?\" => 0,\n        _ => 1,\n  \
    \  }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnj_rspce.rs:11:9\n   |\n\
    10 |     match S {\n   |           - this expression has type `String`\n11 | \
    \        &\".\" | \"!\" | \"?\" => 0,\n   |         ^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnj_rspce.rs:11:16\n\
    \   |\n10 |     match S {\n   |           - this expression has type `String`\n\
    11 |         &\".\" | \"!\" | \"?\" => 0,\n   |                ^^^ expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnj_rspce.rs:11:22\n\
    \   |\n10 |     match S {\n   |           - this expression has type `String`\n\
    11 |         &\".\" | \"!\" | \"?\" => 0,\n   |                      ^^^ expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let words = S.split_whitespace();\n    words.iter().filter_map(|s| {\n\
    \        match s {\n            \"I\".to_string() => 1,\n            _ => 0,\n\
    \        }\n    }).count() as isize\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `.`\n\
    \  --> /tmp/tmp_os7tb1m.rs:13:16\n   |\n13 |             \"I\".to_string() =>\
    \ 1,\n   |                ^ expected one of `...`, `..=`, `..`, `=>`, `if`, or\
    \ `|`\n\nerror[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp_os7tb1m.rs:11:11\n   |\n11 |     words.iter().filter_map(|s|\
    \ {\n   |           ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    for c in S.chars() {\n        if !(\"I\" ==\
    \ c) {\n            counter = counter + 1;\n        }\n    }\n    counter\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpo_p0puyp.rs:12:18\n\
    \   |\n12 |         if !(\"I\" == c) {\n   |                  ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0usize;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if !word.is_bored() {\n            counter +=\
    \ 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_bored` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpx2vs1m9y.rs:13:18\n   |\n13 |         if !word.is_bored()\
    \ {\n   |                  ^^^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx2vs1m9y.rs:17:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n...\n17 |     counter\n   |     ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     counter.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.split(|x| match x {\n        '.' => true,\n        '?' => true,\n \
    \       '!' => true,\n        _ => false\n    }).count()\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsim81itf.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.split(|x| match x {\n\
    11 | |         '.' => true,\n12 | |         '?' => true,\n13 | |         '!' =>\
    \ true,\n14 | |         _ => false\n15 | |     }).count()\n   | |______________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    count_boredoms(&S[..])\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_boredoms` in this scope\n  -->\
    \ /tmp/tmpznfx0vxc.rs:10:5\n   |\n10 |     count_boredoms(&S[..])\n   |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().count(|c| c == 'I')\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp5nl8taz8.rs:10:15\n    |\n10  |     S.chars().count(|c| c == 'I')\n\
    \    |               ^^^^^ ------------ supplied 1 argument\n    |           \
    \    |\n    |               expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5nl8taz8.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().count(|c|\
    \ c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n10 |     S.chars().count(|c| c == 'I').try_into().unwrap()\n\
    \   |                                  ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii()).filter(|c| c == 'I')\n        .count()\
    \ + S.chars().filter(|c| c.is_ascii()).filter(|c| c != '.')\n        .count()\
    \ + S.chars().filter(|c| c.is_ascii()).filter(|c| c != '?')\n        .count()\
    \ + S.chars().filter(|c| c.is_ascii()).filter(|c| c != '!')\n        .count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpegbbv9yc.rs:10:53\n\
    \   |\n10 |     S.chars().filter(|c| c.is_ascii()).filter(|c| c == 'I')\n   |\
    \                                                     ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpegbbv9yc.rs:11:68\n\
    \   |\n11 |         .count() + S.chars().filter(|c| c.is_ascii()).filter(|c| c\
    \ != '.')\n   |                                                              \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpegbbv9yc.rs:12:68\n\
    \   |\n12 |         .count() + S.chars().filter(|c| c.is_ascii()).filter(|c| c\
    \ != '?')\n   |                                                              \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpegbbv9yc.rs:13:68\n\
    \   |\n13 |         .count() + S.chars().filter(|c| c.is_ascii()).filter(|c| c\
    \ != '!')\n   |                                                              \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegbbv9yc.rs:10:5\n\
    \   |\n9  |   fn is_bored(S: String) -> isize {\n   |                        \
    \     ----- expected `isize` because of return type\n10 | /     S.chars().filter(|c|\
    \ c.is_ascii()).filter(|c| c == 'I')\n11 | |         .count() + S.chars().filter(|c|\
    \ c.is_ascii()).filter(|c| c != '.')\n12 | |         .count() + S.chars().filter(|c|\
    \ c.is_ascii()).filter(|c| c != '?')\n13 | |  "
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    for c in S.chars() {\n        if c.to_string()\
    \ == \"I\" {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpchpqkufv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = 0;\n    let mut j = 0;\n    while i < S.len() {\n       \
    \ if S[i] == \".\" && S[j] != \"?\" && S[j] != \"!\" {\n            i += 1;\n\
    \        } else {\n            i += 1;\n            j += 1\n        }\n    }\n\
    \    return i;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf_a7r3l1.rs:13:12\n\
    \   |\n13 |         if S[i] == \".\" && S[j] != \"?\" && S[j] != \"!\" {\n   |\
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpf_a7r3l1.rs:13:27\n   |\n13 |         if S[i] == \".\" && S[j]\
    \ != \"?\" && S[j] != \"!\" {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpf_a7r3l1.rs:13:42\n   |\n13 |         if S[i] == \".\" && S[j]\
    \ != \"?\" && S[j] != \"!\" {\n   |                                          ^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    let mut k: usize\
    \ = 0;\n    for c in S.chars() {\n        if c != '.' {\n            i += 1;\n\
    \        }\n        if c == '.' || c == '?' || c == '!' {\n            j += 1;\n\
    \        }\n        if c == '?' {\n            k += 1;\n        }\n    }\n   \
    \ if i == 0 {\n        if j == 0 {\n            if k == 0 {\n                return\
    \ 0;\n            }\n            return 1;\n        }\n        return 0;\n   \
    \ }\n    if j == 0 {\n        if k == 0 {\n            return i;\n        }\n\
    \        return 1;\n    }\n    if k == 0 {\n        return i + j;\n    }\n   \
    \ return i + j + k;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6d8i7efi.rs:35:20\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n35 |             return i;\n   |      \
    \              ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    35 |             return i.try_into().unwrap();\n   |                     ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut is_bored = false;\n    S.split_whitespace().for_each(|x|\
    \ {\n        if x == \"I\" {\n            boredoms.push(String::from(x));\n  \
    \          is_bored = true;\n        } else {\n            boredoms.push(String::from(\"\
    \"));\n        }\n    });\n\n    if is_bored {\n        boredoms.iter().filter(|x|\
    \ !x.starts_with(\"I\")).count()\n    } else {\n        0\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6msj1y_4.rs:22:9\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n22 |         boredoms.iter().filter(|x|\
    \ !x.starts_with(\"I\")).count()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |         boredoms.iter().filter(|x|\
    \ !x.starts_with(\"I\")).count().try_into().unwrap()\n   |                   \
    \                                             ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    for (i, word) in S.chars().enumerate().filter(|c|\
    \ c.is_ascii()).enumerate() {\n        match word.as_str() {\n            \"I\"\
    \ => {\n                if i <= S.len() - 3 {\n                    counter = counter\
    \ + 1;\n                }\n            }\n            \".\" | \"?\" | \"!\" =>\
    \ {},\n            _ => {},\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii` found for reference `&(usize,\
    \ char)` in the current scope\n  --> /tmp/tmpbdokf6fo.rs:11:57\n   |\n11 |   \
    \  for (i, word) in S.chars().enumerate().filter(|c| c.is_ascii()).enumerate()\
    \ {\n   |                                                         ^^^^^^^^ method\
    \ not found in `&(usize, char)`\n\nerror[E0599]: no method named `as_str` found\
    \ for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpbdokf6fo.rs:12:20\n\
    \   |\n12 |         match word.as_str() {\n   |                    ^^^^^^ method\
    \ not found in `(usize, char)`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S == \"I\" {\n        0\n    } else {\n        S.find(\"I\").unwrap().to_string().len()\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpobjwp2tx.rs:13:9\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n13 |         S.find(\"I\").unwrap().to_string().len()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         S.find(\"I\").unwrap().to_string().len().try_into().unwrap()\n\
    \   |                                               ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if is_bored(&S.as_bytes()) {\n        0\n    } else {\n        1\n  \
    \  }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwzbozlv6.rs:10:17\n   |\n\
    10 |     if is_bored(&S.as_bytes()) {\n   |                 ^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&&[u8]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwzbozlv6.rs:10:8\n\
    \   |\n10 |     if is_bored(&S.as_bytes()) {\n   |        ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut n = 0;\n    for &s in S.split_whitespace() {\n        if s.starts_with(\"\
    I\") {\n            n += 1;\n        }\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmppq538v8v.rs:11:10\n   |\n11 |     for &s in S.split_whitespace()\
    \ {\n   |          ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredoms_count(S).unwrap_or(0)\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredoms_count` in this scope\n  -->\
    \ /tmp/tmptgqmwim4.rs:10:5\n   |\n10 |     boredoms_count(S).unwrap_or(0)\n  \
    \ |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut pos = S.find(\"I\", S.len());\n    while pos != S.len() {\n \
    \       if S[2..pos] == \"!\"..\"!\" {\n            return 1;\n        }\n   \
    \     if S[2..pos] == \"?\"..\"?\" {\n            return 0;\n        }\n     \
    \   if S[2..pos] == \".\"..\".\" {\n            pos = S.find(\"I\", pos+1);\n\
    \        } else {\n            break;\n        }\n    }\n    0\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmph2ww409s.rs:10:21\n     |\n10   |     let mut pos = S.find(\"\
    I\", S.len());\n     |                     ^^^^ ---  ------- supplied 2 arguments\n\
    \     |                     |\n     |                     expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph2ww409s.rs:11:18\n   |\n11 |     while pos != S.len() {\n   |\
    \                  ^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n11 |     while pos != Some(S.len()) {\n   |\
    \                  +++++       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph2ww409s.rs:12:17\n\
    \   |\n12 |         if S[2..pos] == \"!\"..\"!\" {\n   |                 ^^^ expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<usize>`\n\nerror[E0277]: can't compare `str`\
    \ with `&str`\n  --> /tmp/tmph2ww409s.rs:12:22\n   |\n12 |         if S[2..pos]\
    \ == \"!\"..\"!\" {\n   |                      ^^ no implementation for `str ==\
    \ &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph2ww409s.rs:12:30\n   |\n12 |         if S[2..pos] == \"\
    !\"..\"!\" {\n   |                              ^^^ expected `bool`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph2ww409s.rs:12:12\n   |\n12 |\
    \         if S[2..pos] == \"!\"..\"!\" {\n   |            ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found struct `std::"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars()\n        .filter(|c| c == 'I' || c == '.' || c == '?' || c\
    \ == '!')\n        .count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxegpdj0o.rs:11:23\n\
    \   |\n11 |         .filter(|c| c == 'I' || c == '.' || c == '?' || c == '!')\n\
    \   |                       ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpxegpdj0o.rs:11:35\n   |\n11 |         .filter(|c|\
    \ c == 'I' || c == '.' || c == '?' || c == '!')\n   |                        \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpxegpdj0o.rs:11:47\n   |\n11 |         .filter(|c| c == 'I' || c\
    \ == '.' || c == '?' || c == '!')\n   |                                      \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpxegpdj0o.rs:11:59\n   |\n11 |         .filter(|c| c == 'I' || c\
    \ == '.' || c == '?' || c == '!')\n   |                                      \
    \                     ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxegpdj0o.rs:10:5\n   |\n9  |   fn is_bored(S: String) -> isize {\n \
    \  |                             ----- expected `isize` because of return type\n\
    10 | /     S.chars()\n11 | |         .filter(|c| c == 'I' || c == '.' || c ==\
    \ '?' || c == '!')\n12 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 +++++++++++++++"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0;\n    let mut words = S\n        .split_whitespace()\n\
    \        .filter::<String::Chars>(|c| c.is_ascii_letter())\n        .collect::<Vec<_>>();\n\
    \    while !words.is_empty() {\n        if let Some(w) = words.last() {\n    \
    \        if w == \"I\" {\n                count += 1;\n            }\n       \
    \     words.pop();\n        } else {\n            break;\n        }\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0223]: ambiguous associated type\n  --> /tmp/tmpgm9884mb.rs:13:19\n\
    \   |\n13 |         .filter::<String::Chars>(|c| c.is_ascii_letter())\n   |  \
    \                 ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<String as\
    \ Trait>::Chars`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0223`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S == \"I\" {\n        0\n    } else if S.contains(\".\") || S.contains(\"\
    ?\") || S.contains(\"!\") {\n        1\n    } else {\n        0\n    }\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpuop_4ge3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let words = S.split_whitespace();\n    let mut boredoms = 0;\n    for\
    \ word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp3enkwmj6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut I = 0;\n    for w in S.split_whitespace() {\n        if w !=\
    \ \"I\".to_string() {\n            I++;\n        }\n    }\n    I\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpxem0gw3z.rs:13:14\n\
    \   |\n13 |             I++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n13 |             { let tmp = I; I += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n13 -             I++;\n\
    13 +             I += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_count(S.chars().map(|c| *c).collect())\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmp445h5qt8.rs:10:5\n   |\n10 |     boredom_count(S.chars().map(|c| *c).collect())\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp445h5qt8.rs:10:37\n   |\n10 |     boredom_count(S.chars().map(|c|\
    \ *c).collect())\n   |                                     ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0614.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.contains(\"I\", true).count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp3ku2wx77.rs:10:7\n     |\n10   |     S.contains(\"I\", true).count()\
    \ as isize\n     |       ^^^^^^^^ ---  ---- supplied 2 arguments\n     |     \
    \  |\n     |       expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: `bool` is not an iterator\n  --> /tmp/tmp3ku2wx77.rs:10:27\n\
    \   |\n10 |     S.contains(\"I\", true).count() as isize\n   |               \
    \            ^^^^^ `bool` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `bool: Iterator`\n           which is\
    \ required by `&mut bool: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if is_bored_str(&S) != 0 { return 1 }\n\n    // split into lines\n  \
    \  let mut lines = S.lines();\n\n    // look for bored lines\n    for line in\
    \ lines {\n        if let Some(word) = line.split_whitespace().next() {\n    \
    \        if word.is_bored() {\n                return 1;\n            }\n    \
    \    }\n    }\n\n    0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_bored_str` in this scope\n  -->\
    \ /tmp/tmp621smpax.rs:10:8\n   |\n10 |     if is_bored_str(&S) != 0 { return 1\
    \ }\n   |        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_bored` found for reference `&str` in the current scope\n  --> /tmp/tmp621smpax.rs:18:21\n\
    \   |\n18 |             if word.is_bored() {\n   |                     ^^^^^^^^\
    \ method not found in `&str`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut current: &str = S.as_str();\n\
    \    while current.is_ok() && (current != \"I\") {\n        boredoms += 1;\n \
    \       current = current.as_str();\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp0pu_91ar.rs:12:19\n   |\n12 |     while current.is_ok()\
    \ && (current != \"I\") {\n   |                   ^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `as_str` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmp0pu_91ar.rs:14:27\n   |\n14 |         current = current.as_str();\n\
    \   |                          -^^^^^^-- help: remove this method call\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_count(S).iter().filter(|e| e == \"I\").count()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmp06rgrc6f.rs:10:5\n   |\n10 |     boredom_count(S).iter().filter(|e|\
    \ e == \"I\").count()\n   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut count = 0;\n    for i in S.split_whitespace()\
    \ {\n        let word = String::from(i);\n        match word.chars().next()\n\
    \            .filter(|c| !c.is_whitespace())\n            .filter(|c| !c.is_ascii_uppercase())\n\
    \            .filter(|c| !c.is_ascii_lowercase())\n            .filter(|c| !c.is_digit())\n\
    \            .filter(|c| !c.is_ascii_letter()) {\n            Some('!') => boredoms.push(i),\n\
    \            Some('?') => boredoms.push(i),\n            Some('.') => boredoms.push(i),\n\
    \            _ => boredoms.push(i),\n        }\n        count += 1;\n    }\n \
    \   count + boredoms.iter().filter(|s| s.chars().next().is_some()).count()\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpgzvgt0i8.rs:18:28\n    |\n18  |             .filter(|c| !c.is_digit())\n\
    \    |                            ^^^^^^^^- supplied 0 arguments\n    |      \
    \                      |\n    |                            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `is_ascii_letter` found for reference `&char` in the current scope\n  --> /tmp/tmpgzvgt0i8.rs:19:28\n\
    \   |\n19 |             .filter(|c| !c.is_ascii_letter()) {\n   |            \
    \                ^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgzvgt0i8.rs:27:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n27 |     count + boredoms.iter().filter(|s|\
    \ s.chars().next().is_some()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n27 |     (count\
    \ + boredoms.iter().filter(|s| s.chars().next().is_some()).count()).try_into().unwrap()\n\
    \   |     +                                                                  \
    \    +++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut count = 0usize;\n    let mut boredom = String::from(\"I\");\n\
    \    for s in S.split() {\n        if s == boredom {\n            count += 1;\n\
    \        }\n        boredom = s;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpcvpjtcas.rs:12:16\n     |\n12   |     for s in S.split() {\n\
    \     |                ^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvpjtcas.rs:16:19\n\
    \   |\n11 |     let mut boredom = String::from(\"I\");\n   |                 \
    \      ----------------- expected due to this value\n...\n16 |         boredom\
    \ = s;\n   |                   ^- help: try using a conversion method: `.to_string()`\n\
    \   |                   |\n   |                   expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvpjtcas.rs:18:5\n \
    \  |\n9  | fn is_bored(S: String) -> isize {\n   |                           -----\
    \ expected `isize` because of return type\n...\n18 |     count\n   |     ^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars()\n        .enumerate()\n        .filter(|&(i, _)| {\n      \
    \      matches!(&S[i], _, '.', '?', '!')\n        })\n        .count()\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: no rules expected the token `'.'`\n  --> /tmp/tmp3irxqspw.rs:13:32\n\
    \   |\n13 |             matches!(&S[i], _, '.', '?', '!')\n   |              \
    \                  ^^^ no rules expected this token in macro call\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3irxqspw.rs:10:5\n   |\n9  |   fn is_bored(S:\
    \ String) -> isize {\n   |                             ----- expected `isize`\
    \ because of return type\n10 | /     S.chars()\n11 | |         .enumerate()\n\
    12 | |         .filter(|&(i, _)| {\n13 | |             matches!(&S[i], _, '.',\
    \ '?', '!')\n14 | |         })\n15 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.split_whitespace().count(|&x| match x {\n        x if x.is_char('I')\
    \ => true,\n        _ => false,\n    })\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&_`\n  --> /tmp/tmpmn9cpmxt.rs:10:33\n\
    \   |\n10 |     S.split_whitespace().count(|&x| match x {\n   |              \
    \                   ^^ consider giving this closure parameter the explicit type\
    \ `&_`, with the type parameters specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpmn9cpmxt.rs:10:26\n    |\n10  |       S.split_whitespace().count(|&x|\
    \ match x {\n    |  __________________________^^^^^_-\n    | |               \
    \           |\n    | |                          expected 0 arguments\n11  | |\
    \         x if x.is_char('I') => true,\n12  | |         _ => false,\n13  | | \
    \    })\n    | |_____- supplied 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmn9cpmxt.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.split_whitespace().count(|&x|\
    \ match x {\n11 | |         x if x.is_char('I') => true,\n12 | |         _ =>\
    \ false,\n13 | |     })\n   | |______^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n13 |     }).try_into().unwrap()\n   |       ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_count(S.as_bytes()) == S.len()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmpr3lsycrz.rs:10:5\n   |\n10 |     boredom_count(S.as_bytes()) == S.len()\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr3lsycrz.rs:10:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    10 |     boredom_count(S.as_bytes()) == S.len()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut ibored = 0;\n\n    for s in S.split() {\n        if s == \"I\"\
    \ {\n            ibored += 1;\n        }\n    }\n\n    ibored\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpys3elj5q.rs:12:16\n     |\n12   |     for s in S.split() {\n\
    \     |                ^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    loop {\n        let mut current = S.clone();\n        loop {\n      \
    \      if current == \".\" {\n                break;\n            }\n        \
    \    if current == \"?\" || current == \"!\" {\n                return 0;\n  \
    \          }\n            current = &current.chars().next().unwrap();\n      \
    \  }\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpje8zle7q.rs:19:23\n   |\n\
    11 |         let mut current = S.clone();\n   |                           ---------\
    \ expected due to this value\n...\n19 |             current = &current.chars().next().unwrap();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&char`\n   |\nhelp: try using a conversion method\n   |\n19 |       \
    \      current = (&current.chars().next().unwrap()).to_string();\n   |       \
    \                +                                +++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().any(|c| c == '.' || c == '?' || c == '!')\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ywej6wa.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.chars().any(|c| c == '.' || c ==\
    \ '?' || c == '!')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = 0;\n\n    // We loop through the sentence and count\
    \ the number of boredoms\n    for pos in S.split_whitespace().rposition(|&x| x.is_ascii())\
    \ {\n        if S.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `SplitWhitespace<'_>: ExactSizeIterator`\
    \ is not satisfied\n    --> /tmp/tmpuh43jazm.rs:13:37\n     |\n13   |     for\
    \ pos in S.split_whitespace().rposition(|&x| x.is_ascii()) {\n     |         \
    \                            ^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `SplitWhitespace<'_>`\n     |\n     = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n               &mut I\n               Args\n   \
    \            ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\nnote: required by a bound\
    \ in `rposition`\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n  --> /tmp/tmpuh43jazm.rs:13:49\n   |\n13 |     for\
    \ pos in S.split_whitespace().rposition(|&x| x.is_ascii()) {\n   |           \
    \                                      ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    debug_assert!(\n        S.chars().count(|c| c == '.') > 0 || S.chars().count(|c|\
    \ c == '?') > 0 || S.chars().count(|c| c == '!')\n    );\n    S.chars().count(|c|\
    \ c == 'I')\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpkx6_rc9o.rs:11:19\n    |\n11  |         S.chars().count(|c| c\
    \ == '.') > 0 || S.chars().count(|c| c == '?') > 0 || S.chars().count(|c| c ==\
    \ '!')\n    |                   ^^^^^ ------------ supplied 1 argument\n    |\
    \                   |\n    |                   expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpkx6_rc9o.rs:11:56\n    |\n11  |\
    \         S.chars().count(|c| c == '.') > 0 || S.chars().count(|c| c == '?') >\
    \ 0 || S.chars().count(|c| c == '!')\n    |                                  \
    \                      ^^^^^ ------------ supplied 1 argument\n    |         \
    \                                               |\n    |                     \
    \                                   expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpkx6_rc9o.rs:11:93\n    |\n11  |      \
    \   S.chars().count(|c| c == '.') > 0 || S.chars().count(|c| c == '?') > 0 ||\
    \ S.chars().count(|c| c == '!')\n    |                                       \
    \                                                      ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                                          \
    \                                   |\n    |                                 \
    \                                                            expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkx6_rc9o.rs:11:83\n   |\n11 |         S.chars().count(|c| c ==\
    \ '.') > 0 || S.chars().count(|c| c == '?') > 0 || S.chars().count(|c| c == '!')\n\
    \   |                                                                        \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `usize`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpkx6_rc9o.rs:13:15\n\
    \    |\n13  |     S.chars().count(|c| c == "
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut bored_count = 0;\n    let mut sentence: Vec<&str> = S.chars().collect();\n\
    \n    for c in sentence.iter() {\n        if c.is_whitespace() {\n           \
    \ continue;\n        }\n\n        if let Some(idx) = sentence.find(|x| x.is_whitespace()\
    \ && x.starts_with('I')) {\n            bored_count += 1;\n            let mut\
    \ end_idx = idx;\n            for _ in 0..(end_idx - 1) {\n                sentence.next();\n\
    \            }\n            sentence.truncate(idx);\n            break;\n    \
    \    }\n    }\n\n    bored_count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpf8z3z4nu.rs:11:45\n     |\n11\
    \   |     let mut sentence: Vec<&str> = S.chars().collect();\n     |         \
    \                                    ^^^^^^^ value of type `Vec<&str>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0599]: no method named `is_whitespace` found for reference\
    \ `&&str` in the current scope\n  --> /tmp/tmpf8z3z4nu.rs:14:14\n   |\n14 |  \
    \       if c.is_whitespace() {\n   |              ^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split_ascii_whitespace`\n\nerror[E0599]:\
    \ no method named `find` found for struct `Vec<&str>` in the current scope\n \
    \ --> /tmp/tmpf8z3z4nu.rs:18:37\n   |\n18 |         if let Some(idx) = sentence.find(|x|\
    \ x.is_whitespace() && x.starts_with('I')) {\n   |                           \
    \          ^^^^ method not found in `Vec<&str>`\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmpf8z3z4nu.rs:22:26\n\
    \   |\n22 |                 sentence.next();\n   |                          ^^^^\
    \ method not found in `Vec<&str>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S.len() <= 1 {\n        return 0;\n    }\n    if S.starts_with(\"\
    I\") {\n        return 1;\n    }\n    let mut count = 0;\n    let mut end = S.len();\n\
    \    let mut start = 0;\n    while start < end {\n        match S.charAt(start)\
    \ {\n            '.' => start += 1,\n            '?' => start += 1,\n        \
    \    '!' => start += 1,\n            _ => start,\n        }\n        match S.charAt(end)\
    \ {\n            '.' => end -= 1,\n            '?' => end -= 1,\n            '!'\
    \ => end -= 1,\n            _ => end,\n        }\n        count += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `charAt` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpi4qba7fl.rs:20:17\n   |\n20 |         match S.charAt(start)\
    \ {\n   |                 ^^^^^^ help: there is an associated function with a\
    \ similar name: `chars`\n\nerror[E0308]: `match` arms have incompatible types\n\
    \  --> /tmp/tmpi4qba7fl.rs:24:18\n   |\n20 | /         match S.charAt(start) {\n\
    21 | |             '.' => start += 1,\n   | |                    ---------- this\
    \ is found to be of type `()`\n22 | |             '?' => start += 1,\n   | | \
    \                   ---------- this is found to be of type `()`\n23 | |      \
    \       '!' => start += 1,\n   | |                    ---------- this is found\
    \ to be of type `()`\n24 | |             _ => start,\n   | |                 \
    \ ^^^^^ expected `()`, found `usize`\n25 | |         }\n   | |_________- `match`\
    \ arms have incompatible types\n\nerror[E0599]: no method named `charAt` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpi4qba7fl.rs:26:17\n\
    \   |\n26 |         match S.charAt(end) {\n   |                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `chars`\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpi4qba7fl.rs:30:18\n   |\n26 | /\
    \         match S.charAt(end) {\n27 | |             '.' => end -= 1,\n   | | \
    \                   -------- this is found to be of type `()`\n28 | |        \
    \     '?' => end -= 1,\n   | |                    -------- this is found to be\
    \ of type `()`\n29 | |             '!' => end -= 1,\n   | |                  \
    \  -------- this is found to be of type `()`\n30 | |             _ => end,\n \
    \  | |                  ^^^ expected `()`, found `usize`\n31 | |         }\n \
    \  | |_________- `match` arms have incompatible types\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom_cnt = 0;\n    let mut boredoms = Vec::new();\n\n    for\
    \ x in S.chars() {\n        if x.is_ascii_alphanumeric() {\n            if let\
    \ Some((start, end)) = is_boredom_span(x) {\n                boredom_cnt += end\
    \ - start;\n                boredoms.push(start as usize);\n            }\n  \
    \      }\n    }\n\n    boredom_cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_boredom_span` in this scope\n  -->\
    \ /tmp/tmp7rwz_0n1.rs:15:41\n   |\n15 |             if let Some((start, end))\
    \ = is_boredom_span(x) {\n   |                                         ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut bored: isize = 0;\n    let mut boredom = false;\n    let mut\
    \ i = 0;\n    for c in S.chars() {\n        if bored > 0 && c == ' ' && i > 0\
    \ && S[i-1] == c {\n            bored += 1;\n        } else if c == 'I' {\n  \
    \          bored = 1;\n            boredom = true;\n        } else {\n       \
    \     bored = 0;\n            boredom = false;\n        }\n        i += 1;\n \
    \   }\n    if bored == 0 && !boredom { bored = 1 }\n    else if bored > 1 { bored\
    \ = 1 }\n    else { bored = 0 }\n    bored\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp_ngfoja3.rs:14:46\n   |\n14 |         if bored > 0 && c == ' ' && i\
    \ > 0 && S[i-1] == c {\n   |                                              ^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    for s in S.chars().filter(|&c| c\
    \ != 'I') {\n        let pos = s.find_first_not_of(\". ! ?\");\n        if pos\
    \ == 0 {\n            // No more non-punctuation.\n            break;\n      \
    \  }\n        let len = s.len();\n        if s[pos - 1] == '.' || s[pos - 1] ==\
    \ '?' || s[pos - 1] == '!' {\n            boredoms.push(len);\n        }\n   \
    \ }\n    boredoms.iter().fold(0, |a, &b| a + b)\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_first_not_of` found for type `char`\
    \ in the current scope\n  --> /tmp/tmphns7bsq0.rs:12:21\n   |\n12 |         let\
    \ pos = s.find_first_not_of(\". ! ?\");\n   |                     ^^^^^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `len` found for\
    \ type `char` in the current scope\n  --> /tmp/tmphns7bsq0.rs:17:21\n   |\n17\
    \ |         let len = s.len();\n   |                     ^^^ method not found\
    \ in `char`\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmphns7bsq0.rs:18:12\n\
    \   |\n18 |         if s[pos - 1] == '.' || s[pos - 1] == '?' || s[pos - 1] ==\
    \ '!' {\n   |            ^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `char`\n  --> /tmp/tmphns7bsq0.rs:18:33\n   |\n18 |         if s[pos\
    \ - 1] == '.' || s[pos - 1] == '?' || s[pos - 1] == '!' {\n   |              \
    \                   ^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `char`\n  --> /tmp/tmphns7bsq0.rs:18:54\n   |\n18 |         if s[pos - 1] ==\
    \ '.' || s[pos - 1] == '?' || s[pos - 1] == '!' {\n   |                      \
    \                                ^^^^^^^^^^\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // TODO: write some code\n    return 0;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpl69hdj6o.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars()\n        .filter(|c| {\n            let v = match c {\n   \
    \             '.' => true,\n                '?' => true,\n                '!'\
    \ => true,\n                c => false,\n            };\n            v\n     \
    \   })\n        .count() == 3\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph4dmq8xz.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.chars()\n11 | |      \
    \   .filter(|c| {\n12 | |             let v = match c {\n13 | |              \
    \   '.' => true,\n...  |\n19 | |         })\n20 | |         .count() == 3\n  \
    \ | |_____________________^ expected `isize`, found `bool`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = 0;\n    let mut j = 0;\n    for i in S.chars() {\n      \
    \  if i == ' ' || i == '\\n' || i == '.' || i == '?' || i == '!' || i == 'I' {\n\
    \            continue;\n        }\n        else {\n            let x = i - j;\n\
    \            if x > 0 {\n                return x;\n            }\n          \
    \  j = i;\n        }\n    }\n    0;\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpe0l1069l.rs:17:23\n\
    \   |\n17 |             let x = i - j;\n   |                     - ^ - {integer}\n\
    \   |                     |\n   |                     char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe0l1069l.rs:21:17\n   |\n11 |     let mut j = 0;\n   |\
    \                 - expected due to this value\n...\n21 |             j = i;\n\
    \   |                 ^ expected integer, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe0l1069l.rs:9:27\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |    --------               ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n...\n24 |     0;\n   |      - help: remove this semicolon\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut is_bored = 0;\n    let mut s = String::from(S);\n    while !s.is_empty()\
    \ {\n        if s.starts_with(\"I\") {\n            s.replace(\"I\".to_string(),\
    \ \"I\".to_string());\n            is_bored += 1;\n        } else {\n        \
    \    s.replace(\".\".to_string(), \"I\".to_string());\n            s.replace(\"\
    ?\".to_string(), \"I\".to_string());\n            s.replace(\"!\".to_string(),\
    \ \"I\".to_string());\n        }\n    }\n    is_bored\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   -->\
    \ /tmp/tmpjzasy1m2.rs:14:15\n    |\n14  |             s.replace(\"I\".to_string(),\
    \ \"I\".to_string());\n    |               ^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `String`\n    |\n    = help: the trait `FnMut<(char,)>` is not\
    \ implemented for `String`\n    = help: the following other types implement trait\
    \ `Pattern<'a>`:\n              &'b String\n              &'b str\n          \
    \    &'c &'b str\n    = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `str::<impl str>::replace`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjzasy1m2.rs:14:40\n   |\n14 |\
    \             s.replace(\"I\".to_string(), \"I\".to_string());\n   |         \
    \                               ^^^^^^^^^^^^^^^\n   |                        \
    \                |\n   |                                        expected `&str`,\
    \ found struct `String`\n   |                                        help: consider\
    \ borrowing here: `&\"I\".to_string()`\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n   --> /tmp/tmpjzasy1m2.rs:17:15\n    |\n17  |    \
    \         s.replace(\".\".to_string(), \"I\".to_string());\n    |            \
    \   ^^^^^^^ expected an `FnMut<(char,)>` closure, found `String`\n    |\n    =\
    \ help: the trait `FnMut<(char,)>` is not implemented for `String`\n    = help:\
    \ the following other types implement trait `Pattern<'a>`:\n              &'b\
    \ String\n              &'b str\n              &'c &'b str\n    = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `str::<impl str>::replace`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjzasy1m2.rs:17:40\n   |\n17 |             s.replace(\"\
    .\".to_string(), \"I\".to_string());\n   |                                   \
    \     ^^^^^^^^^^^^^^^\n   |                                        |\n   |   \
    \                                     expected `&str`, found struct `String`\n\
    \   |                                        help: consider borrowing here: `&\"\
    I\".to"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredoms_count(S)\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredoms_count` in this scope\n  -->\
    \ /tmp/tmpn6ddmehe.rs:10:5\n   |\n10 |     boredoms_count(S)\n   |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c|\n        (c == '.' || c == '?' || c == '!') && c.to_lowercase()\
    \ == c\n    ).count() == S\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnwjj494g.rs:11:12\n\
    \   |\n11 |         (c == '.' || c == '?' || c == '!') && c.to_lowercase() ==\
    \ c\n   |            ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpnwjj494g.rs:11:24\n   |\n11 |         (c == '.' ||\
    \ c == '?' || c == '!') && c.to_lowercase() == c\n   |                       \
    \ ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnwjj494g.rs:11:36\n\
    \   |\n11 |         (c == '.' || c == '?' || c == '!') && c.to_lowercase() ==\
    \ c\n   |                                    ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0369]: binary\
    \ operation `==` cannot be applied to type `ToLowercase`\n  --> /tmp/tmpnwjj494g.rs:11:64\n\
    \   |\n11 |         (c == '.' || c == '?' || c == '!') && c.to_lowercase() ==\
    \ c\n   |                                               ---------------- ^^ -\
    \ &char\n   |                                               |\n   |          \
    \                                     ToLowercase\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnwjj494g.rs:12:18\n   |\n12 |     ).count() == S\n   |\
    \                  ^ expected `usize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnwjj494g.rs:10:5\n   |\n9  |   fn is_bored(S:\
    \ String) -> isize {\n   |                             ----- expected `isize`\
    \ because of return type\n10 | /     S.chars().filter(|c|\n11 | |         (c ==\
    \ '.' || c == '?' || c == '!') && c.to_lowercase() == c\n12 | |     ).count()\
    \ == S\n   | |__________________^ expected `isize`, found `bool`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSom"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    is_bored(S, vec![])\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpvumhgx8e.rs:10:5\n   |\n10 |     is_bored(S, vec![])\n   |    \
    \ ^^^^^^^^ -  ------ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpvumhgx8e.rs:9:4\n   |\n9  |\
    \ fn is_bored(S: String) -> isize {\n   |    ^^^^^^^^ ---------\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars()\n        .filter(|c| *c != '.' && *c != '?' && *c != '!')\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpojil1v21.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.chars()\n11 | |      \
    \   .filter(|c| *c != '.' && *c != '?' && *c != '!')\n12 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n12 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredoms(S, |s| s.contains(\"I\"))\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredoms` in this scope\n  --> /tmp/tmpucajslet.rs:10:5\n\
    \   |\n10 |     boredoms(S, |s| s.contains(\"I\"))\n   |     ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom(S).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom` in this scope\n  --> /tmp/tmpatsbu11a.rs:10:5\n\
    \   |\n10 |     boredom(S).count()\n   |     ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut cnt = 0;\n    for w in S.split_whitespace() {\n        if w ==\
    \ \"I\".to_string() {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpnl0hxge3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    S.chars().enumerate().for_each(|(s,\
    \ ix)| {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n    \
    \    }\n    });\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp0x5nn6v1.rs:12:14\n   |\n12 |         if s.starts_with(\"\
    I\") {\n   |              ^^^^^^^^^^^ method not found in `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut is_boreded = 0;\n    for (i, word) in S.chars().enumerate().skip(1).filter_map(|(_,\
    \ word)| {\n        if word != \"I\" {\n            Some(word)\n        } else\
    \ {\n            None\n        }\n    }) {\n        if let Some(word) = word {\n\
    \            is_boreded += 1;\n        }\n    }\n    is_boreded\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnptk_ugd.rs:12:20\n   |\n\
    12 |         if word != \"I\" {\n   |                    ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n12 |         if word != 'I' {\n   |                    ~~~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnptk_ugd.rs:11:9\n   |\n11 |   \
    \    for (i, word) in S.chars().enumerate().skip(1).filter_map(|(_, word)| {\n\
    \   |  _________^^^^^^^^^____-\n   | |         |\n   | |         expected `char`,\
    \ found tuple\n12 | |         if word != \"I\" {\n13 | |             Some(word)\n\
    14 | |         } else {\n15 | |             None\n16 | |         }\n17 | |   \
    \  }) {\n   | |______- this expression has type `Option<char>`\n   |\n   = note:\
    \ expected type `char`\n             found tuple `(_, _)`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009185
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom = String::new();\n    boredom.push_str(\"I\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\".\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"\
    ?\");\n    boredom.push_str(\"!\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"\
    !\");\n    boredom.push_str(\"?\");\n    boredom.push_str(\"!\");\n    boredom.push_\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `push_` on type `String`\n  --> /tmp/tmpkm42kux7.rs:66:13\n\
    \   |\n66 |     boredom.push_\n   |             ^^^^^ unknown field\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom: isize = 0;\n    for c in S.chars() {\n        if c ==\
    \ '.' || c == '?' || c == '!' {\n            boredom = boredom + 1;\n        }\n\
    \    }\n    boredom\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayrnrurk.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    debug_assert!(S == \"I\" || S == \"I..\" || S == \"I.\" || S == \"I.!\"\
    \ || S == \"I?\" || S == \"?\" || S == \"!\" || S == \"\");\n    let mut is_bored:\
    \ isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        match S[i]\
    \ {\n            '.' | '?' | '!' => i += 1,\n            _ => {\n            \
    \    if S[i] == 'I' {\n                    is_bored += 1;\n                  \
    \  i += 1;\n                } else if S[i] == '?' || S[i] == '!' {\n         \
    \           i += 1;\n                } else {\n                    i += 1;\n \
    \               }\n            }\n        }\n    }\n    return is_bored;\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwsmmm5i2.rs:14:15\n\
    \   |\n14 |         match S[i] {\n   |               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwsmmm5i2.rs:17:20\n   |\n17 |                 if S[i] == 'I' {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwsmmm5i2.rs:20:27\n\
    \   |\n20 |                 } else if S[i] == '?' || S[i] == '!' {\n   |     \
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\ner"
  stdout: ''
  timestamp: 1660009186
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = 0;\n\n    for _ in S.split_whitespace() {\n      \
    \  boredoms += 1;\n    }\n\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `0`', /tmp/tmpfadxvkt6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut i = 0;\n    while i < S.len() {\n        let s = S[i];\n    \
    \    match s.as_str() {\n            \".\" | \"?\" | \"!\" => i += 1,\n      \
    \      _ => continue,\n        }\n    }\n    i + 1\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpex2u8ejn.rs:12:17\n\
    \   |\n12 |         let s = S[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpex2u8ejn.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     i + 1\n   |   \
    \  ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n18 |     (i\
    \ + 1).try_into().unwrap()\n   |     +     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_counter(S).0.count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_counter` in this scope\n  -->\
    \ /tmp/tmpmj7sh7ow.rs:10:5\n   |\n10 |     boredom_counter(S).0.count\n   |  \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    count_boredoms(S, 0, S.len())\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_boredoms` in this scope\n  -->\
    \ /tmp/tmpdy8v9bfk.rs:10:5\n   |\n10 |     count_boredoms(S, 0, S.len())\n   |\
    \     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c != '?' && c != '!').count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn_peb5dp.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c != '?' && c != '!').count(|c| c == 'I')\n\
    \   |                            ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpn_peb5dp.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c != '?' && c != '!').count(|c| c == 'I')\n   |      \
    \                                  ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpn_peb5dp.rs:10:48\n\
    \    |\n10  |     S.chars().filter(|c| c != '?' && c != '!').count(|c| c == 'I')\n\
    \    |                                                ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                                |\n    |  \
    \                                              expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_peb5dp.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c != '?' && c != '!').count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c != '?' && c != '!').count(|c| c == 'I').try_into().unwrap()\n   |        \
    \                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut seen = HashSet::new();\n    for (i, word) in S.char_indices().filter(|&(_,\
    \ x)| !x.is_ascii()).enumerate() {\n        if let Some(next) = i + word.len()\
    \ {\n            if let Some(next) = S.get(next) {\n                if let Some(next)\
    \ = next.as_bytes() {\n                    if let Some(b'I') = next {\n      \
    \                  if !seen.insert(b'I') {\n                            return\
    \ i;\n                        }\n                    } else if let Some(b'!')\
    \ != next {\n                        return i;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    0\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=` or `|`, found `!=`\n  --> /tmp/tmpsnoopuup.rs:19:46\n\
    \   |\n19 |                     } else if let Some(b'!') != next {\n   |     \
    \                                         ^^ expected one of `=` or `|`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpsnoopuup.rs:10:20\n\
    \   |\n10 |     let mut seen = HashSet::new();\n   |                    ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0599]: no method named `len`\
    \ found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpsnoopuup.rs:12:38\n\
    \   |\n12 |         if let Some(next) = i + word.len() {\n   |               \
    \                       ^^^ method not found in `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsnoopuup.rs:12:16\n   |\n12 |         if let\
    \ Some(next) = i + word.len() {\n   |                ^^^^^^^^^^   --------------\
    \ this expression has type `usize`\n   |                |\n   |              \
    \  expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<_>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n\n    for i in S.chars() {\n        match i {\n\
    \            '.' => {\n                counter += 1;\n            }\n        \
    \    '?' => {\n                counter += 1;\n            }\n            '!' =>\
    \ {\n                counter += 1;\n            }\n            c => (),\n    \
    \    }\n    }\n\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpv7gpcizq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| {\n        c != '?'\n            && c != '.'\n \
    \           && c != '!'\n    }).count() == S.len()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxvzwrjrk.rs:11:11\n\
    \   |\n11 |         c != '?'\n   |           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpxvzwrjrk.rs:12:18\n   |\n12 |   \
    \          && c != '.'\n   |                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpxvzwrjrk.rs:13:18\n   |\n13\
    \ |             && c != '!'\n   |                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxvzwrjrk.rs:10:5\n   |\n9  |   fn is_bored(S:\
    \ String) -> isize {\n   |                             ----- expected `isize`\
    \ because of return type\n10 | /     S.chars().filter(|c| {\n11 | |         c\
    \ != '?'\n12 | |             && c != '.'\n13 | |             && c != '!'\n14 |\
    \ |     }).count() == S.len()\n   | |_________________________^ expected `isize`,\
    \ found `bool`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut pos = 0;\n\n    while pos <\
    \ S.len() {\n        let mut current = S[pos];\n\n        // ignore punctuation\n\
    \        if current != '?' &&\n            current != '!' &&\n            current\
    \ != '.' {\n            boredoms += 1;\n        }\n\n        pos += 1;\n    }\n\
    \n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx7voqryk.rs:14:27\n\
    \   |\n14 |         let mut current = S[pos];\n   |                          \
    \ ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredom_count(S) > 0\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmp0v5ifj1p.rs:10:5\n   |\n10 |     boredom_count(S) > 0\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0v5ifj1p.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     boredom_count(S) > 0\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut bored = 0;\n    for (i, ch) in S.chars().enumerate() {\n    \
    \    if let Some(ch) = ch == '.' || ch == '?' || ch == '!' {\n            bored\
    \ += 1;\n            let start = S.char_indices(0, i, &ch).unwrap();\n       \
    \     let end = S.char_indices(i + 1, S.len(), &ch).unwrap();\n            let\
    \ (start, end) = start.max(end);\n            bored += end - start;\n        }\n\
    \    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found statement (`let`)\n  --> /tmp/tmp9q1xu_aq.rs:12:12\n\
    \   |\n12 |         if let Some(ch) = ch == '.' || ch == '?' || ch == '!' {\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: variable declaration\
    \ using `let` is a statement\n\nerror[E0658]: `let` expressions in this position\
    \ are unstable\n  --> /tmp/tmp9q1xu_aq.rs:12:12\n   |\n12 |         if let Some(ch)\
    \ = ch == '.' || ch == '?' || ch == '!' {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q1xu_aq.rs:12:16\n\
    \   |\n12 |         if let Some(ch) = ch == '.' || ch == '?' || ch == '!' {\n\
    \   |                ^^^^^^^^   --------- this expression has type `bool`\n  \
    \ |                |\n   |                expected `bool`, found enum `Option`\n\
    \   |\n   = note: expected type `bool`\n              found enum `Option<_>`\n\
    \nerror[E0061]: this function takes 0 arguments but 3 arguments were supplied\n\
    \   --> /tmp/tmp9q1xu_aq.rs:14:27\n    |\n14  |             let start = S.char_indices(0,\
    \ i, &ch).unwrap();\n    |                           ^^^^^^^^^^^^ -  -  --- supplied\
    \ 3 arguments\n    |                           |\n    |                      \
    \     expected 0 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0599]: no method named `unwrap` found for struct `CharIndices` in the current\
    \ scope\n  --> /tmp/tmp9q1xu_aq.rs:14:51\n   |\n14 |             let start = S.char_indices(0,\
    \ i, &ch).unwrap();\n   |                                                   ^^^^^^\
    \ method not found in `CharIndices<'_>`\n\nerror[E0061]: this function takes 0\
    \ arguments but 3 arguments were supplied\n   --> /tmp/tmp9q1xu_aq.rs:15:25\n\
    \    |\n15  |             let end = S.char_indices(i + 1, S.len(), &ch).unwrap();\n\
    \    |                         ^^^^^^^^^^^^ -----  -------  --- supplied 3 arguments\n\
    \    |                         |\n    |                         expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: no meth"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    // Loop through the string and count the boredom of every word you find.\n\
    \    S.chars().filter(|c|\n        (c == '.' || c == '?' || c == '!')\n    ).count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1e2rfo3s.rs:12:12\n\
    \   |\n12 |         (c == '.' || c == '?' || c == '!')\n   |            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1e2rfo3s.rs:12:24\n\
    \   |\n12 |         (c == '.' || c == '?' || c == '!')\n   |                 \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1e2rfo3s.rs:12:36\n\
    \   |\n12 |         (c == '.' || c == '?' || c == '!')\n   |                 \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1e2rfo3s.rs:11:5\n   |\n9  |   fn is_bored(S: String) -> isize {\n \
    \  |                             ----- expected `isize` because of return type\n\
    10 |       // Loop through the string and count the boredom of every word you\
    \ find.\n11 | /     S.chars().filter(|c|\n12 | |         (c == '.' || c == '?'\
    \ || c == '!')\n13 | |     ).count()\n   | |_____________^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |     ).count().try_into().unwrap()\n\
    \   |              ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    boredoms(S).iter().filter(|&b| b).count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `boredoms` in this scope\n  --> /tmp/tmp2_84oj2l.rs:10:5\n\
    \   |\n10 |     boredoms(S).iter().filter(|&b| b).count()\n   |     ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut counter = 0;\n    for (i, s) in S.chars().enumerate() {\n   \
    \     if s != \".\" && s != \"?\" && s != \"!\" && s.is_uppercase() {\n      \
    \      counter = i;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgsrbjtji.rs:12:17\n   |\n\
    12 |         if s != \".\" && s != \"?\" && s != \"!\" && s.is_uppercase() {\n\
    \   |                 ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant\
    \ to write a `char` literal, use single quotes\n   |\n12 |         if s != '.'\
    \ && s != \"?\" && s != \"!\" && s.is_uppercase() {\n   |                 ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgsrbjtji.rs:12:29\n   |\n12 |\
    \         if s != \".\" && s != \"?\" && s != \"!\" && s.is_uppercase() {\n  \
    \ |                             ^^^ expected `char`, found `&str`\n   |\nhelp:\
    \ if you meant to write a `char` literal, use single quotes\n   |\n12 |      \
    \   if s != \".\" && s != '?' && s != \"!\" && s.is_uppercase() {\n   |      \
    \                       ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgsrbjtji.rs:12:41\n\
    \   |\n12 |         if s != \".\" && s != \"?\" && s != \"!\" && s.is_uppercase()\
    \ {\n   |                                         ^^^ expected `char`, found `&str`\n\
    \   |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    12 |         if s != \".\" && s != \"?\" && s != '!' && s.is_uppercase() {\n \
    \  |                                         ~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgsrbjtji.rs:16:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n16 |     counter\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |     counter.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut n = 0;\n    for ch in S.chars() {\n        match ch {\n     \
    \       '.' | '!' | '?' | ' ' as c => {},\n            _ => {\n              \
    \  let s = ch;\n                let mut i = 0;\n                while i < s.len()\
    \ {\n                    if s[i] == 'I' {\n                        i += 1;\n \
    \                   } else if s[i] == ' ' || s[i] == '!' || s[i] == '.' {\n  \
    \                      i += 1;\n                    } else {\n               \
    \         break;\n                    }\n                }\n                n\
    \ += 1;\n            }\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpz16n67_i.rs:13:35\n   |\n13 |             '.' | '!' | '?'\
    \ | ' ' as c => {},\n   |                                   ^^ expected one of\
    \ `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.split('.').filter(|word| word.starts_with(\"I\")).count() as isize\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp4v7r3h2m.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    count_boredoms(S, vec![\"I\"]) == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_boredoms` in this scope\n  -->\
    \ /tmp/tmpk8unw348.rs:10:5\n   |\n10 |     count_boredoms(S, vec![\"I\"]) == 0\n\
    \   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk8unw348.rs:10:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    10 |     count_boredoms(S, vec![\"I\"]) == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut num = 0;\n    let mut has_boredom = false;\n    for word in S\
    \ {\n        if word.to_ascii_lowercase() == \"i\" {\n            has_boredom\
    \ = true;\n        } else if word.to_ascii_lowercase() != \"i\" && !has_boredom\
    \ {\n            num += 1;\n        }\n    }\n    num\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp3sqixds9.rs:12:17\n\
    \   |\n12 |     for word in S {\n   |                 ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: usize = 0;\n    let mut iter = S.chars().enumerate();\n\
    \    let mut boredom_word = String::from(\"I\");\n\n    for &(idx, item) in iter\
    \ {\n        let word = (*item).unwrap();\n        if word == boredom_word {\n\
    \            boredoms += 1;\n        }\n        boredom_word = word;\n    }\n\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpimw_ejc5.rs:14:9\n   |\n\
    14 |     for &(idx, item) in iter {\n   |         ^^^^^^^^^^^^    ---- this expression\
    \ has type `Option<(usize, char)>`\n   |         |\n   |         expected tuple,\
    \ found reference\n   |\n   = note:  expected tuple `(usize, char)`\n        \
    \   found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpimw_ejc5.rs:22:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n22 |     boredoms\n   |\
    \     ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n22\
    \ |     boredoms.try_into().unwrap()\n   |             ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| {\n        match c {\n            '.' => true,\n\
    \            '?' => true,\n            '!' => true,\n            _ => false\n\
    \        }\n    }).count() == 3\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3gu8t1vc.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.chars().filter(|c| {\n\
    11 | |         match c {\n12 | |             '.' => true,\n13 | |            \
    \ '?' => true,\n...  |\n16 | |         }\n17 | |     }).count() == 3\n   | |___________________^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    if S == \"I\".to_string() || S == \"i\".to_string() {\n        0\n  \
    \  } else {\n        1\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmplaqqut6p.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut n = 0;\n    let mut boredom = false;\n    let mut end = S.chars().enumerate().find(|&(ref\
    \ i, _)| {\n        boredom = i.unwrap().starts_with('I');\n        boredom\n\
    \    });\n\n    while let Some((ref i, _)) = end {\n        n += 1;\n        end\
    \ = S.chars().enumerate().find(|&(ref i, _)| {\n            boredom = i.unwrap().starts_with('I');\n\
    \            boredom\n        });\n    }\n\n    n\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&usize` in\
    \ the current scope\n  --> /tmp/tmpmfoks_h_.rs:13:21\n   |\n13 |         boredom\
    \ = i.unwrap().starts_with('I');\n   |                     ^^^^^^ method not found\
    \ in `&usize`\n\nerror[E0599]: no method named `unwrap` found for reference `&usize`\
    \ in the current scope\n  --> /tmp/tmpmfoks_h_.rs:20:25\n   |\n20 |          \
    \   boredom = i.unwrap().starts_with('I');\n   |                         ^^^^^^\
    \ method not found in `&usize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredom = S.chars().filter(|c| c == '.' || c == '?' || c == '!').count();\n\
    \    if boredom > 0 {\n        boredom += S.chars().filter(|c| c == 'I').count();\n\
    \    }\n    boredom\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9d8xplag.rs:10:46\n\
    \   |\n10 |     let mut boredom = S.chars().filter(|c| c == '.' || c == '?' ||\
    \ c == '!').count();\n   |                                              ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9d8xplag.rs:10:58\n\
    \   |\n10 |     let mut boredom = S.chars().filter(|c| c == '.' || c == '?' ||\
    \ c == '!').count();\n   |                                                   \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9d8xplag.rs:10:70\n\
    \   |\n10 |     let mut boredom = S.chars().filter(|c| c == '.' || c == '?' ||\
    \ c == '!').count();\n   |                                                   \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp9d8xplag.rs:12:43\n   |\n12 |         boredom +=\
    \ S.chars().filter(|c| c == 'I').count();\n   |                              \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9d8xplag.rs:14:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n14 |     boredom\n   | \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n14 |     boredom.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror"
  stdout: ''
  timestamp: 1660009186
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut n = 0;\n    let mut boredom = S.split_whitespace();\n\n    for\
    \ i in 0..S\n        .split_whitespace()\n        .len() - 1\n    {\n        if\
    \ boredom[i] == \"I\" {\n            n += 1;\n        }\n    }\n    n\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpl4z4ourt.rs:15:10\n   |\n15 |         .len()\
    \ - 1\n   |          ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpl4z4ourt.rs:17:12\n\
    \   |\n17 |         if boredom[i] == \"I\" {\n   |            ^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009186
