name: HumanEval_98_count_upper
language: rs
prompt: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
  /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
  \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
  dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
  aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
  dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
  U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
  EEEE\")), 2);\n}\n"
completions: ["    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c & 0b100\
    \ != 0).count()", "    s.chars().count(|&c| c >= 'A' && c <= 'Z' && c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u')", "    let mut count = s.chars().filter_map(|c|\
    \ match c {\n        c if c.is_uppercase() => Some(1),\n        _ => None,\n \
    \   })\n    .count();\n    count.checked_add(1, |&a| a.is_some())", "    s.chars().filter_map(|c|\
    \ match c {\n        'a' => Some(1),\n        'b' => Some(2),\n        'c' =>\
    \ Some(3),\n        'd' => Some(4),\n        'e' => Some(5),\n        'f' => Some(6),\n\
    \        'g' => Some(7),\n        _ => None,\n    }).sum()", "    s.chars().filter_map(|c|\
    \ match c {\n        c if c.is_uppercase() || c.is_lowercase() => (c, 1),\n  \
    \      _ => None,\n    })\n    .count();", "    let mut i = 0;\n    while i <\
    \ s.len() {\n        if s[i].is_upper() {\n            i += 1;\n        } else\
    \ {\n            break;\n        }\n    }\n    i", "    if s.is_empty() {\n  \
    \      return 0;\n    }\n    let mut counter = 0;\n    let mut lower = s.to_lowercase();\n\
    \    for c in &lower[..] {\n        if c.is_uppercase() || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            counter += 1;\n        }\n    }\n   \
    \ counter", "    s.chars().enumerate().filter(|(_, ch)| ch.is_uppercase()).filter(|(_,\
    \ ch)| ch.is_ascii_uppercase())\n        .count();", '    count_upper_inner(&mut
    s.as_bytes())', "    count_by_len(s.as_bytes(), s.len(), |&b| b.iter().any(|&x|\
    \ x == b'A'))", "    s.chars().filter(|c| c == b'A' || c == b'a').count() as isize",
  "    let mut counter = 0;\n    s.chars()\n        .filter_map(|c| match c {\n  \
    \          c if c.is_uppercase() => counter = counter + 1,\n            c => false,\n\
    \        })\n        .count();\n    counter", '    s.chars().filter(|c| !c.is_uppercase()).filter(|c|
    c.is_ascii()).count() as isize', "    fn f(index: usize) -> usize {\n        s[*index..].chars().filter_map(|c|\
    \ c >= 'A' && c <= 'Z').count() + 1\n    }\n\n    s.chars().filter_map(|c| {\n\
    \        c >= 'A' && c <= 'Z'\n    }).fold(0, f)", '    count_upper_in_even_indices(s.as_bytes())',
  "    let mut vowel_count = 0;\n\n    for (i, c) in s.chars().enumerate() {\n   \
    \     if ((i & 1) == 0) && (c >= 'A' && c <= 'Z') {\n            vowel_count +=\
    \ 1;\n        }\n    }\n\n    vowel_count", "    s.chars()\n        .filter(|&c|\
    \ c.is_uppercase())\n        .filter(|&c| {\n            c.is_alphanumeric() ||\
    \ c.is_separator()\n        })\n        .filter(|&c| {\n            c.is_lowercase()\
    \ && c != u'-'\n        })\n        .filter(|&c| {\n            c.is_lowercase()\
    \ && !(c >= u'A' && c <= u'Z')\n        })\n        .count()", "    s.chars().count::<u32>(|c|\
    \ c >= 'a' && c <= 'z' && c != 'A' && c != 'E')", "    s.chars().filter(|c| c\
    \ >= 'a' && c <= 'z').filter(|c| *c != c).count()", "    s.chars().filter_map(|c|\
    \ if c == 'A' || c == 'E' || c == 'I' || c == 'O' {\n        Some(true)\n    }\
    \ else {\n        Some(false)\n    }).count()", "    s.chars()\n        .filter(|c|\
    \ c.is_upper())\n        .filter(|c| c.is_lower())\n        .count()", '    s.chars().enumerate().filter(|(_,
    c)| c.is_uppercase()).count().saturating_sub(1).ok_or(Error::OutOfBound)?', " \
    \   let mut i = 0;\n    while i < s.len() {\n        if i % 2 == 0 {\n       \
    \     if s[i].is_uppercase() {\n                i += 1;\n                continue;\n\
    \            }\n        } else {\n            if s[i].is_lowercase() {\n     \
    \           i += 1;\n                continue;\n            }\n        }\n   \
    \     break;\n    }\n    i", "    s.chars()\n        .filter(|c| c.is_uppercase())\n\
    \        .filter(|c| c.is_ascii_uppercase())\n        .filter(|c| c % 2 == 0)\n\
    \        .filter(|c| c.is_ascii_lowercase())\n        .filter(|c| c.is_ascii_ascii_lowercase())\n\
    \        .count()", "    s.chars().enumerate().filter(|(_, v)| v >= 'A' && v <=\
    \ 'Z').filter(|(_, v)| v % 2 != 0).count()", '    count_upper(s.chars(), 0, s.len())',
  "    let mut i = 0;\n    for (i, c) in s.chars().enumerate() {\n        match c\
    \ {\n            c if c.is_uppercase() => i += 1,\n            _ => continue,\n\
    \        }\n    }\n    i", "    let mut isize = s.len();\n    for i in (0..isize).step_by(2)\
    \ {\n        if s[i].is_uppercase() && s[i+1].is_uppercase() {\n            isize\
    \ -= 1;\n        }\n    }\n    isize", '    s.chars().filter(|c| !c.is_upper()).count()
    // 0 means no uppercase letters.', "    s.chars().enumerate().filter(|(_, v)|\
    \ v == 'A'..='Z').count();", "    iterate_even_indices(s, |index| {\n        if\
    \ index.is_even() {\n            let char = get_char(&s[index]);\n           \
    \ if let Some(&'A'..'Z') = char {\n                return 1;\n            }\n\
    \        }\n        0\n    })", "    s.char_indices().filter_map(|(i, c)| {\n\
    \        if c == 'A' || c == 'a' {\n            Some(i)\n        } else {\n  \
    \          None\n        }\n    }).count()", "    // https://doc.rust-lang.org/std/primitive.str.html#method.find\n\
    \    // https://doc.rust-lang.org/std/primitive.str.html#method.find_last_index\n\
    \    // https://doc.rust-lang.org/std/primitive.str.html#method.find\n\n    let\
    \ mut i = 0;\n    let mut j = s.len() - 1;\n    while i <= j {\n        let c\
    \ = s[i].chars().next().unwrap();\n        if c.is_uppercase() && (i % 2 == 0)\
    \ {\n            return i;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    0", '    count_upper_aux(s, 0, s.len() - 1)', "    s.chars().filter(|c| *c\
    \ >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count()", '    count_uppercase_in_even_indices(s,
    s.char_indices().len())', "    count_sub_range(s, 0, s.len(), 'a', |_, v| v ==\
    \ char::Upper || v == 'A')", "    if let Some(i) = get_index(s, |&x| x >= 'a'\
    \ && x <= 'z') {\n        let mut i = 0;\n        while i < s.len() && s.starts_with(s.as_bytes()[i..]))\
    \ {\n            i += 1;\n        }\n        i += s.len() - i;\n        i\n  \
    \  } else {\n        0\n    }", "    let mut count = 1;\n    for i in 0..s.len()\
    \ {\n        match s.chars().nth(i).unwrap() {\n            'a' .. 'z' => count\
    \ += 1,\n            _ => (),\n        }\n    }\n    count", "    let mut chars\
    \ = s.chars();\n    let mut count = 0;\n    for (i, c) in chars.enumerate() {\n\
    \        if c >= 'A' && c <= 'Z' {\n            count += c as isize - 'A' as isize;\n\
    \        }\n        if i % 2 == 0 {\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut even_indices = 0;\n    for i in s.chars().enumerate().filter(|(_,\
    \ c)| c.is_upper()) {\n        if i.1 % 2 == 0 {\n            even_indices +=\
    \ 1;\n        }\n    }\n    even_indices", '    s.chars().skip_while(|&b| !is_upper(b)).count()',
  "    s.chars().zip(s.chars().skip(1))\n        .skip_while(|(a, b)| a != b && (a\
    \ as u8 & 0xE0) == 0xE0)\n        .count()", "    s.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count() % 2 == 0", "    s.as_bytes()\n        .windows(2)\n   \
    \     .filter(|&b| b >= 'A' && b <= 'Z')\n        .filter(|&b| b != 'A' && b !=\
    \ 'Z')\n        .count()", '    count_upper_helper(s.as_bytes()[0..s.len()/2]).1',
  "    let mut count = 0;\n    for i in 0..s.len() {\n        match s[i] {\n     \
    \       c if c.is_uppercase() => count += 1,\n            _ => {}\n        }\n\
    \    }\n    count", "    let mut count = 0;\n    for i in 0..s.len() {\n     \
    \   if s.chars().any(|c| c.is_upper() && c.is_ascii_letter()) {\n            count\
    \ += 1;\n            if i % 2 == 0 {\n                count += 1;\n          \
    \  }\n        }\n    }\n    count", "    let mut counter = 0;\n\n    for i in\
    \ s.chars() {\n        if i.is_uppercase() {\n            counter += 1;\n\n  \
    \          if i.is_even() {\n                counter += 1;\n            }\n  \
    \      }\n    }\n\n    counter", "    s.char_indices().filter_map(|(i, c)| {\n\
    \        if c.is_uppercase() {\n            if i % 2 == 0 {\n                Some(i)\n\
    \            } else {\n                None\n            }\n        } else {\n\
    \            None\n        }\n    })\n    .count()", '    s.char_indices().filter(|x|
    x.1 % 2 == 0).count(|x| x.2.is_uppercase())', "    let mut isize = 0;\n    for\
    \ (i, c) in s.chars().enumerate() {\n        if !is_vowel(c) {\n            continue;\n\
    \        }\n        if i % 2 == 0 {\n            i += 1;\n        }\n        isize\
    \ += 1;\n    }\n    isize", '    s.chars().filter(|c| c.is_uppercase()).filter(|c|
    c % 2 == 0).count()', '    count_in_even_positions(s, |c| c == c.to_ascii_uppercase())',
  "    s.chars().filter(|c| *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'Z').count()",
  "    s.chars().enumerate().filter(|&(i, c)| {\n        ((i % 2) == 0) && c.is_uppercase()\n\
    \    }).count()", "    s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c\
    \ % 2 == 0).count()", "    if s.len() < 2 {\n        return 0;\n    }\n\n    let\
    \ mut cnt = 0;\n\n    let mut iter = s.char_indices();\n    for i in iter {\n\
    \        if i % 2 == 0 {\n            cnt += 1;\n        }\n    }\n\n    cnt",
  '    count_upper_impl(s, true)', "    s.chars().skip_while(|&c| *c >= 'A' || *c\
    \ <= 'Z').filter(|&c| *c >= 'A' && *c <= 'Z').count() % 2 == 0", '    count_upper_indices2(s,
    0, s.len(), |i| i & 1).0', "    let mut i = 0;\n    let mut upper = 0;\n    let\
    \ mut c = s.chars().filter(|c| c.is_uppercase());\n    while i < c.len() {\n \
    \       if c[i].is_uppercase() {\n            i += 1;\n            if i % 2 ==\
    \ 0 {\n                upper += 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    upper", "    let mut counter = 0;\n    for &i in s.char_indices()\
    \ {\n        match i {\n            0 => break,\n            _ => counter += if\
    \ i % 2 == 0 { 1 } else { 0 },\n        }\n    }\n    counter", "    count_even_indices(s,\
    \ |index| {\n        s[index] == 'A' || s[index] == 'a' || s[index] == 'E' ||\
    \ s[index] == 'e'\n    })", "    match s.chars() {\n        \"\" => 0,\n     \
    \   'a' .. 'z' => 1,\n        'A' .. 'Z' => 1,\n        _ => 0,\n    }", "   \
    \ s.chars().filter_map(|c| match c {\n        c if is_vowel(c) => Some(c + 1),\n\
    \        _ => None,\n    }).sum()", "    s.chars()\n        .filter(|c| c.is_uppercase())\n\
    \        .filter(|c| c.is_ascii_upper())\n        .filter(|c| c.is_ascii_lowercase())\n\
    \        .count()", "    s.chars()\n        .filter(|c| c.is_uppercase())\n  \
    \      .filter(|c| c != 'd')\n        .count(|c| {\n            if c != 'd' {\n\
    \                c.is_odd()\n            } else {\n                false\n   \
    \         }\n        })", "    s.char_indices().filter(|i| i % 2 == 0).filter(|i|\
    \ s.chars().any(|c| c.is_upper()))\n        .count()", '    s.chars().count();',
  '    s.char_indices().filter(|&(ref x, _)| x.is_uppercase()).filter(|&(_, y)| y
    % 2 == 0).count()', "    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            i += 1;\n        } else\
    \ if s[i] >= 'A' && s[i] <= 'Z' {\n            j += 1;\n            i += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    j", "    count_upper_helper(\n\
    \        &s.chars(),\n        0,\n        &s.chars().last().unwrap(),\n      \
    \  |v| match v {\n            Some(c) => c.is_uppercase(),\n            None =>\
    \ false,\n        },\n    )", '    s.char_indices().filter(|c| *c % 2 == 0).count()',
  "    let mut even = s.char_indices().filter(|&(_, c)| c & 1 == 0).count();\n   \
    \ for &(c, _) in s.char_indices() {\n        if c & 1 == 0 {\n            even\
    \ += 1;\n        }\n    }\n    even", "    s.chars().enumerate().filter(|&(i,\
    \ c)| {\n        i % 2 == 0 && c.is_uppercase()\n    }).count()", "    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 != 0).count()", "    let mut lower =\
    \ s.chars().enumerate().filter(|(_, ch)| ch >= 'a' && ch <= 'z');\n    let mut\
    \ upper = lower.skip(1);\n    let mut evens = 0;\n    for (_, ch) in upper {\n\
    \        if ch >= 'A' && ch <= 'Z' {\n            evens += 1;\n        }\n   \
    \ }\n    evens", "    s.chars().filter(|c| c.is_uppercase()).filter(|c| {\n  \
    \      c.is_lowercase() && !c.is_uppercase()\n    }).count()", "    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z' && *c != '_').count() / 2 -\n        1", '    count_with_conditions(s,
    |c| c.is_uppercase() && c.is_even())', "    let mut i = 0;\n    while i < s.len()\
    \ {\n        match s.chars().nth(i).unwrap() {\n            'a' .. 'z' => i +=\
    \ 1,\n            _ => i += 1,\n        }\n    }\n    i", "    let mut num_upper\
    \ = 0;\n    for (i, &ch) in s.chars().enumerate() {\n        if i & 1 == 0 {\n\
    \            if ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U'\
    \ {\n                num_upper += 1;\n            }\n        }\n    }\n    return\
    \ num_upper;", "    s.chars().filter(|c| c > 64).filter(|c| c < 91)\n        .filter_map(|c|\
    \ if c >= 65 && c <= 90 { Some(c - 65) } else { None })\n        .filter(|c| c\
    \ % 2 == 0)\n        .count() as isize", '    s.chars().filter(|c| c.is_uppercase()
    && c.is_ascii()).count();', "    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c|\
    \ c % 2 == 0).count()", '    count_upper_helper(s.as_bytes(), s.len(), 0)', " \
    \   s.char_indices()\n        .filter(|&(idx, _)| idx % 2 == 0)\n        .filter(|&(_,\
    \ c)| char::is_uppercase(c))\n        .count()", '    s.char_indices().filter(|&(idx,
    _)| idx % 2 == 0).map(|(idx, _)| s[idx]).filter(|c| c.is_uppercase()).count()',
  '    count_upper_core(s.as_bytes())', "    if s.len() == 0 {\n        return 0;\n\
    \    }\n    let mut n = 0;\n    for ch in s.chars() {\n        if ch.is_uppercase()\
    \ {\n            n += 1;\n        }\n        if ch.is_lowercase() {\n        \
    \    break;\n        }\n    }\n    n", "    s.chars().filter_map(|c| if c.is_uppercase()\
    \ || c == 'z' { return c }).count()", "    let mut count = 0.;\n    let len =\
    \ s.len();\n\n    for i in (0..len).filter(|&x| x >= 'a' && x <= 'z') {\n    \
    \    if s[i] == s[i..].chars().filter(|&x| x == 'A' || x == 'a').count() {\n \
    \           count += 1.;\n        }\n    }\n\n    count", '    count_chars(s,
    |c| *c == c as u8)', '    s.chars().filter(|&c| c.is_uppercase()).filter(|&c|
    !c.is_ascii()).count()', "    s.chars().enumerate()\n        .filter(|(_, ch)|\
    \ ch.is_uppercase())\n        .filter(|(_, ch)| ch.is_ascii())\n        .filter(|(_,\
    \ ch)| ch != b'z')\n        .count(|(_, ch)| ch.is_uppercase())", "    s.char_indices()\n\
    \        .filter_map(|i| match i.next() {\n            None => None,\n       \
    \     Some(idx) => Some(*idx),\n        })\n        .filter(|idx| {\n        \
    \    if idx % 2 == 0 {\n                let c = s.chars().nth(idx);\n        \
    \        c.is_uppercase()\n            } else {\n                false\n     \
    \       }\n        })\n        .count()", '    count_upper_helper(s.as_bytes())?',
  "    s.chars()\n        .filter(|c| c.is_upper())\n        .filter(|c| c.is_ascii())\n\
    \        .filter(|c| c % 2 == 0)\n        .count()", "    s.chars().enumerate().filter(|(_,\
    \ ch)| ch >= 'A' && ch <= 'Z').count() as isize", "    s.chars().filter(|c| *c\
    \ >= 'a' && *c <= 'z').filter(|c| *c % 2 != 0).count()", "    let mut i = 0;\n\
    \    while i < s.len() {\n        if s[i].is_uppercase() {\n            if i %\
    \ 2 == 0 {\n                i += 1;\n            }\n        } else if s[i].is_lowercase()\
    \ {\n            i += 1;\n        }\n    }\n    i", '    s.char_indices().filter_map(|(i,
    c)| if i % 2 == 0 { Some(c as usize) } else { None }).sum()', "    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'Z').count()", "    count_up_to(s.len(),\
    \ |i| s.chars().any(|c| c >= 'a' && c <= 'z'))", '    s.chars().enumerate().filter(|(_,
    x)| x.is_uppercase()).filter(|(_, x)| x % 2 == 0).count()', "    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count() + 1", "    loop {\n\
    \        if let Some(pos) = s.find('A') {\n            let s = s[..pos + 1];\n\
    \            if s.chars().any(|c| c >= 'A' && c <= 'Z') {\n                return\
    \ 1;\n            }\n        }\n        let mut s = s.chars().collect::<String>();\n\
    \        s.pop();\n        if let Some(pos) = s.find('A') {\n            let s\
    \ = s[..pos + 1];\n            if s.chars().any(|c| c >= 'A' && c <= 'Z') {\n\
    \                return 1;\n            }\n        }\n        s += 'A';\n    }",
  "    s.chars().filter(|c| *c == c).filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 == 0).count()", '    count_upper_impl(s.as_bytes(), 0, s.len())', " \
    \   s.chars().filter(|c| *c >= 'A' && *c <= 'Z' && *c != 'i').count()", "    s.char_indices().filter_map(|i|\
    \ {\n        if i.1 % 2 == 0 {\n            Some(i)\n        } else {\n      \
    \      None\n        }\n    }).count(|&i| s.chars()[i.0 as usize] >= b'A' && s.chars()[i.0\
    \ as usize] <= b'Z')", "    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()", '    s.chars().enumerate().filter(|&(i, _)| i % 2 ==
    0).count().unwrap_or(0)', "    let mut counter = 0;\n    let mut last = 0;\n \
    \   let mut last_upper = 0;\n    for c in s.chars() {\n        if !c.is_uppercase()\
    \ {\n            counter = counter + 1;\n        } else {\n            if last\
    \ < 3 {\n                counter = counter + 2;\n                last = counter;\n\
    \            } else {\n                counter = counter + 2;\n              \
    \  last = counter - 1;\n            }\n            last_upper = counter;\n   \
    \     }\n    }\n    last_upper", "    s.char_indices()\n        .filter_map(|&(i,\
    \ c)| if i % 2 == 0 && c == 'A'; Some(i - 1); None)\n        .count()", "    let\
    \ mut i = 0;\n    for c in s.as_bytes() {\n        if *c >= 'A' && *c <= 'Z' {\n\
    \            i += 1;\n        }\n    }\n    i", "    s.chars().filter(|c| *c >=\
    \ 'A' && *c <= 'Z').count() / 2", '    s.char_indices().filter_map(|i| i.filter(|c|
    c.is_uppercase()).count()).unwrap_or(0)', "    s.chars().filter_map(|c|\n    \
    \    if c.is_upper() {\n            Some(c as u32)\n        } else {\n       \
    \     None\n        }\n        .count() as usize\n    }).sum()", "    if s.is_empty()\
    \ {\n        return 0;\n    }\n    match s.chars().position(|x| x.is_uppercase())\
    \ {\n        Some(pos) => pos.step() / 2,\n        None => 0,\n    }", "    s.chars().filter(|c|\
    \ c > 'z').count() + count_lower(s)", "    let mut count_upper = 0usize;\n   \
    \ let mut last_upper = s.len_utf8();\n    for c in s.chars().iter() {\n      \
    \  count_upper += if is_upper(c) {\n            c as isize - last_upper as isize\n\
    \        } else {\n            0\n        };\n        last_upper = c;\n    }\n\
    \    count_upper", '    count_upper(s.as_bytes())', "    s.char_indices().filter(|&(_,\
    \ c)| {\n        c.is_uppercase()\n    }).filter(|(_, c)| {\n        c.is_vowel()\n\
    \    }).count()", "    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c\
    \ % 2 == 0).count()", "    let mut chars = s.chars();\n    let mut i = 0;\n  \
    \  let mut has_uv = false;\n    while i < chars.len() {\n        match chars[i]\
    \ {\n            c if !c.is_ascii_uppercase() => *i += 1,\n            c if c.is_ascii_uppercase()\
    \ => has_uv = true,\n            _ => i += 1,\n        }\n    }\n    if !has_uv\
    \ {\n        0\n    } else {\n        i\n    }", '    count_upper_impl(s, 0, s.len())',
  "    let mut c = 0;\n    for c in s.chars().filter(|c| *c >= 'A' && *c <= 'Z') {\n\
    \        if *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'a' && *c != 'e' &&\n\
    \             *c != 'i' && *c != 'o' && *c != 'u'\n        {\n            break;\n\
    \        }\n    }\n    c", "    let mut res = 0;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if i % 2 == 0 && c.is_uppercase() {\n            res++;\n       \
    \ }\n    }\n    res", "    let mut vowels = 0;\n    for c in s.as_bytes() {\n\
    \        if *c >= b'a' && *c <= b'z' {\n            vowels += 1;\n        }\n\
    \    }\n    vowels", '    count_upper_helper(&mut s, 0)', "    // `isize` can\
    \ represent signed and unsigned integer numbers, as long as\n    // the number\
    \ is not larger than `isize::MAX`.\n    unsafe { s.chars().skip_while(|&c| c >=\
    \ b'A' && c <= b'Z') }\n        .filter(|c| c >= b'a' && c <= b'z')\n        .count()\
    \ as isize", "    count_chars(s.as_bytes(), |c| match c {\n        b'A' => 0,\n\
    \        b'a' => 0,\n        _ => 1,\n    })", "    s.chars().zip(s.chars().skip(1)).filter(|(c,\
    \ _)| {\n        (c >= 'A' && c <= 'Z') && (c != 'E')\n    }).count()", "    s.char_indices()\n\
    \        .filter_map(|(i,_)| if i % 2 == 0 { Some(true) } else { None })\n   \
    \     .filter(|b| b)\n        .count()", "    s.chars().filter(|c| *c >= 'A' &&\
    \ *c <= 'Z').filter(|c| *c >= 'a' && *c <= 'z').count() as isize", "    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| *c != '\\0').count()", "    let mut count = 0;\
    \ // number of vowels up to the current position\n    let len = s.len();\n   \
    \ for i in 0..len {\n        if s[i].chars().all(|c| *c >= 'A'..'Z' && c <= 'Z')\
    \ {\n            count += 1;\n        }\n        if s[i].is_uppercase() && i +\
    \ 1 < len && s[i + 1].is_uppercase() {\n            count += 1;\n        }\n \
    \       if s[i].is_uppercase() && i == 0 && !s[i + 1].is_uppercase() {\n     \
    \       count += 1;\n        }\n    }\n    count", '    s.chars().filter(|c| c.is_uppercase()).count()
    as isize', '    count_upper_aux(&s, s.length(), 0, 0)', "    let mut cnt = 0;\n\
    \    for &c in self.chars() {\n        if c.is_uppercase() && c < 'A' {\n    \
    \        cnt += 1;\n        }\n    }\n    cnt", "    s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ {\n        c % 2 == 0\n    }).count()", '    s.chars().filter(|c| c.is_uppercase()).count()
    // TODO: handle zero case', "    s.chars().enumerate().filter(|&(i, c)| c >= 'A'\
    \ && c <= 'Z' && i % 2 == 0).count()", "    s.chars().enumerate().filter(|&(_,\
    \ c)| *c >= 'A' && *c <= 'Z').count(|&(c, _)| *c >= 'A' && *c <= 'Z')", "    match\
    \ (0..s.len()).filter(|&x| x >= 'A' && x <= 'Z') {\n        0 => 0,\n        _\
    \ => 1 + match (&s[..]) {\n            'A'..'E' => 1,\n            'a'..'e' =>\
    \ 1,\n            _ => 0,\n        }\n    }", "    let mut cnt = 0;\n    for c\
    \ in s.chars() {\n        match c {\n            b'A'..=b'Z' => cnt += 1,\n  \
    \          b'a'..=b'z' => cnt += 1,\n            _ => continue,\n        }\n \
    \   }\n    cnt", '    count_upper_aux(s.chars(), s.len() as usize)', '    s.chars().count();',
  "    s.into_iter()\n        .filter(|c| *c >= 'a' && *c <= 'z')\n        .filter(|c|\
    \ '*' != c)\n        .filter(|c| 'A' != c)\n        .filter(|c| 'a' != c)\n  \
    \      .filter(|c| '0' != c)\n        .count()", '    count_upper_rec(s, 0, true)',
  "    s.chars()\n        .zip(s.chars().skip(1))\n        .filter(|(c, next)| c ==\
    \ next)\n        .filter(|(c, next)| c <= 'Z' && c >= 'A')\n        .count()",
  "    s.chars().filter_map(|c|\n        if c.is_uppercase() && c.is_ascii() {\n \
    \           Some(c.to_ascii_lowercase())\n        } else {\n            None\n\
    \        }\n    )\n    .count()", '    s.chars().enumerate().filter(|&(idx, _)|
    idx % 2 == 0).filter(|&(_, c)| c == c.to_uppercase()).count()', '    count_upper_helper(s.as_bytes(),
    0, true)', "    s.chars().filter(|c| c.is_uppercase()).filter(|c| *c != '_').count()",
  '    count_upper_inner(s, 0)', '    count_chars(s, |c: char| c == char::Upper)',
  '    s.chars().count(|c| c.is_uppercase() && !c.is_lowercase())', "    s.chars()\n\
    \        .map(|c| if c >= 'A' && c <= 'Z' { c - 'A' + 1 })\n        .filter(|&x|\
    \ x % 2 == 0)\n        .count()", '    s.chars().filter(|c| c.is_uppercase() &&
    c.is_ascii()).count() / s.len()', "    s.chars().filter(|c| *c >= 'A' && *c <=\
    \ 'Z').filter(|c| *c % 2 != 0).count()", '    s.chars().filter(|c| *c == c::Upper).count()',
  "    count_up_down(s, 'A' as u8, 0)", "    count_matches_at(s, |c| {\n        c.is_upper()\
    \ && c.is_ascii_letter() && !c.is_digit()\n    })", "    let mut count = 0;\n\
    \    for &c in s.chars() {\n        if (c == 'A' || c == 'a') {\n            count\
    \ += 1;\n        }\n        if (c == 'E' || c == 'e') {\n            count +=\
    \ 1;\n        }\n        if (c == 'I' || c == 'i') {\n            count += 1;\n\
    \        }\n        if (c == 'O' || c == 'o') {\n            count += 1;\n   \
    \     }\n        if (c == 'U' || c == 'u') {\n            count += 1;\n      \
    \  }\n    }\n    return count;", "    s.as_bytes()\n        .into_iter()\n   \
    \     .map(|&b| b as u8)\n        .filter(|&b| b >= 'A' as u8)\n        .filter(|&b|\
    \ b <= 'Z' as u8)\n        .filter(|&b| b & !(b as u8 == 'A' as u8))\n       \
    \ .count();", '    s.char_indices().filter(|&(i, _)| i % 2 == 0).count()', " \
    \   let mut cnt = 0;\n    for i in s.as_bytes().iter() {\n        if i.is_uppercase()\
    \ {\n            cnt += 1;\n        }\n        if i.is_lowercase() {\n       \
    \     cnt += 1;\n        }\n        if i % 2 == 0 {\n            cnt += 1;\n \
    \       }\n    }\n    cnt", "    s.chars().enumerate().filter(|(i, c)| {\n   \
    \     c.is_uppercase() && i % 2 == 0\n    }).count() as isize", "    match s.as_bytes()\
    \ {\n        None => 0,\n        Some(ref b) => b.iter().enumerate().filter(|(_,\
    \ x)| x % 2 == 0).count(|(_, x)| x == b'A'),\n    }", '    count_upper_bang(s.chars(),
    s.len())', '    count_upper_helper(s.as_bytes())', "    let mut counter = 0;\n\
    \    for i in 0..s.len() {\n        if s[i as usize] == 'A' || s[i as usize] ==\
    \ 'E' || s[i as usize] == 'I' || s[i as usize] == 'O' || s[i as usize] == 'U'\
    \ {\n            counter += 1;\n        }\n    }\n    counter", "    if s.is_empty()\
    \ {\n        return 0;\n    }\n\n    let mut sum = 0;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if i % 2 == 0 && c.is_uppercase() {\n            sum += 1;\n    \
    \    }\n    }\n    sum", "    s.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ / 2", '    count_upper_indices(s, |index| index % 2 == 0)', "    s.chars().filter_map(|c|\
    \ if c == 'A' || c == 'a' { Some(0) } else { None }).sum()", "    count_up_case(s.chars().enumerate().filter_map(|(i,\
    \ c)| {\n        if i % 2 == 0 {\n            Some(c.to_uppercase())\n       \
    \ } else {\n            None\n        }\n    }).collect::<Vec<_>>())", "    s.chars().fold(0,\
    \ |acc, &c| acc + ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))", '    s.chars().enumerate().filter_map(|(_,
    c)| c.is_uppercase()).count()', '    s.chars().filter(|c| c.is_uppercase()).count() ',
  '    count_upper(s.as_bytes()).0', "    if s.is_empty() {\n        return 0;\n \
    \   }\n\n    let mut num_upper = 0;\n    let mut s = s;\n    let mut prev = 0;\n\
    \    while let Some(next) = s.split_last_mut(1) {\n        if prev == 0 {\n  \
    \          prev = next;\n        }\n        if *prev != *next {\n            prev\
    \ = 0;\n            num_upper += 1;\n        }\n        prev = next;\n    }\n\
    \    num_upper", "    s.char_indices()\n        .filter(|&i| i % 2 == 0)\n   \
    \     .filter(|&i| s.chars().any(|c| c.is_uppercase()))\n        .count()", '    count_upto(s,
    |c| c.is_uppercase())', "    s.char_indices().filter_map(|(_, e)| e % 2 == 0).filter(|c|\
    \ c <= 'z').count()", "    let mut vowels = (0..s.len()).filter(|&x| x == 'a'\
    \ || x == 'A' || x == 'e' || x == 'E' || x == 'i' || x == 'I' || x == 'o' || x\
    \ == 'O' || x == 'u' || x == 'U');\n    vowels.cloned().filter(|&x| x % 2 == 0).count()\
    \ as isize", '    count_upper_helper(0, s)', '    count_upper_helper(s.chars(),
    s.len())', "    s.chars().filter(|c| c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U').count() / 4", "    let mut n = 0;\n    for c in s.chars() {\n\
    \        if c >= 'a' && c <= 'z' {\n            n += 1;\n        }\n    }\n  \
    \  n", "    s.chars().count(|&c| c == u::U('A') || c == u::U('E'))", "    let\
    \ mut count = vec![0];\n    let mut c = s.char_indices();\n    for (i, &(c1, c2))\
    \ in c {\n        if ((c1 as usize == 65) && (i % 2 == 0)) {\n            count\
    \ += 1;\n        }\n    }\n    count.0", "    s.chars()\n        .filter(|&c|\
    \ c.is_uppercase())\n        .count(|&c| {\n            c.is_lowercase()\n   \
    \     })", "    s.into_iter().fold(0, |acc, &c| {\n        if c.is_uppercase()\
    \ && (acc.is_even() || acc.is_positive()) {\n            acc + 1\n        } else\
    \ {\n            acc\n        }\n    })", "    s.chars().filter(|c| *c >= 'A'\
    \ && *c <= 'Z').filter(|c| *c % 2 != 0).count()", "    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.as_bytes()[i] >= b'A' && s.as_bytes()[i] <= b'Z'\
    \ {\n            i += 1;\n            continue;\n        }\n        return i;\n\
    \    }\n    s.len()", '    count_upper_helper(s.as_bytes())']
stop_tokens:
- "\n}"
