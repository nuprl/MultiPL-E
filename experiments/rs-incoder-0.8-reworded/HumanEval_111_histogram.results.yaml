language: rs
name: HumanEval_111_histogram
results:
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n\n    for\
    \ letter in test.split(\" \") {\n        let count = histogram.get(letter).unwrap_or_else(||\
    \ 0);\n        histogram.insert(letter, count + 1);\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa75iz5v2.rs:21:61\n   |\n\
    21 |         let count = histogram.get(letter).unwrap_or_else(|| 0);\n   |   \
    \                                                          ^\n   |           \
    \                                                  |\n   |                   \
    \                                          expected `&isize`, found integer\n\
    \   |                                                             help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa75iz5v2.rs:22:26\n\
    \   |\n22 |         histogram.insert(letter, count + 1);\n   |               \
    \           ^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                          |\n   |                          expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    let mut letters = test.chars().collect::<String>();\n\
    \    let mut counts = letters.iter().fold(0, |sum, letter| {\n        if histogram.contains_key(&letter)\
    \ {\n            *histogram.entry(letter).or_insert(0) as isize += 1;\n      \
    \  } else {\n            *histogram.entry(letter).or_insert(1) += 1;\n       \
    \ }\n        sum + counts[letter]\n    });\n\n    histogram.sort_by(|a, b| b.value.cmp(&a.value).reverse());\n\
    \    histogram.iter().collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `counts` in this scope\n  --> /tmp/tmpr5bvcvx3.rs:27:15\n\
    \   |\n27 |         sum + counts[letter]\n   |               ^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpr5bvcvx3.rs:21:30\n   |\n21 |     let mut\
    \ counts = letters.iter().fold(0, |sum, letter| {\n   |                      \
    \        ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n21 |     let mut counts = letters.chars().fold(0,\
    \ |sum, letter| {\n   |                              ~~~~~\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpr5bvcvx3.rs:23:60\n   |\n23 |  \
    \           *histogram.entry(letter).or_insert(0) as isize += 1;\n   |       \
    \      ---------------------------------------------- ^^\n   |             |\n\
    \   |             cannot assign to this expression\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `HashMap` in the current scope\n  --> /tmp/tmpr5bvcvx3.rs:30:15\n\
    \   |\n30 |     histogram.sort_by(|a, b| b.value.cmp(&a.value).reverse());\n \
    \  |               ^^^^^^^ method not found in `HashMap<_, {integer}>`\n\nerror[E0277]:\
    \ a value of type `HashMap<String, isize>` cannot be built from an iterator over\
    \ elements of type `(&_, &{integer})`\n    --> /tmp/tmpr5bvcvx3.rs:31:22\n   \
    \  |\n31   |     histogram.iter().collect()\n     |                      ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=(&_,\
    \ &{integer})>`\n     |\n     = help: the trait `FromIterator<(&_, &{integer})>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut words = test.split_whitespace();\n    while let Some(word) = words.pop()\
    \ {\n        histogram.entry(word).or_insert(0);\n        histogram.entry(word).and_modify(|v|\
    \ *v += 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp6qzx8o_9.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Convert string to lowercase\n    let mut words = test.chars().map(|c|\
    \ c.to_lowercase()).collect();\n    // Convert string to char slice\n    let mut\
    \ chars_slice = words.to_vec();\n    chars_slice.sort();\n\n    // Create a histogram\
    \ of characters with counts\n    let mut histogram = HashMap::new();\n    while\
    \ !chars_slice.is_empty() {\n        // Get the first character\n        let mut\
    \ first: &str = chars_slice.first().unwrap();\n        // Increment count for\
    \ that character\n        histogram.entry(first).or_insert(0) += 1;\n        //\
    \ Remove first character from string\n        chars_slice = chars_slice.remove(0);\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpdffl7jwr.rs:21:27\n\
    \   |\n19 |     let mut words = test.chars().map(|c| c.to_lowercase()).collect();\n\
    \   |         --------- consider giving `words` a type\n20 |     // Convert string\
    \ to char slice\n21 |     let mut chars_slice = words.to_vec();\n   |        \
    \                   ^^^^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmpdffl7jwr.rs:30:9\n   |\n30 |       \
    \  histogram.entry(first).or_insert(0) += 1;\n   |         -----------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(first).or_insert(0)`\n\
    \   |\n30 |         *histogram.entry(first).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdffl7jwr.rs:30:45\n\
    \   |\n30 |         histogram.entry(first).or_insert(0) += 1;\n   |         -----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdffl7jwr.rs:34:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n34 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0282, E0308, E0368.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars()\n        .flat_map(|c| c.chars().map(|c| *c))\n        .group_by(|c|\
    \ c)\n        .map(|(_, count)| count.to_string())\n        .collect::<HashMap<String,\
    \ isize>>()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpd63822qi.rs:19:25\n   |\n19 |         .flat_map(|c| c.chars().map(|c|\
    \ *c))\n   |                         ^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ').iter().cloned().\n        map(|s| s.to_string()).\n \
    \       fold(HashMap::new(), |mut map, s| {\n            let c = s.chars().count(|c|\
    \ c.is_ascii_letter());\n            if map.contains_key(&s) {\n             \
    \   map.entry(s.clone()).or_insert(c).1 += 1;\n            } else {\n        \
    \        map.insert(s.clone(), c);\n            }\n            map\n        })\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp_abwwlpk.rs:18:21\n   |\n18 |     test.split('\
    \ ').iter().cloned().\n   |                     ^^^^ method not found in `std::str::Split<'_,\
    \ char>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test\n        .split(' ')\n        .map(|s| s.to_lowercase())\n     \
    \   .fold(HashMap::new(), |mut map, s| {\n            map.entry(s).and_modify(|e|\
    \ e.into_iter().count() + 1);\n            map\n        })\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for mutable reference `&mut\
    \ isize`, but its trait bounds were not satisfied\n  --> /tmp/tmpo7t89086.rs:22:43\n\
    \   |\n22 |             map.entry(s).and_modify(|e| e.into_iter().count() + 1);\n\
    \   |                                           ^^^^^^^^^\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `&mut isize: Iterator`\n\
    \           which is required by `&mut isize: IntoIterator`\n           `&&mut\
    \ isize: Iterator`\n           which is required by `&&mut isize: IntoIterator`\n\
    \           `&mut &mut isize: Iterator`\n           which is required by `&mut\
    \ &mut isize: IntoIterator`\n           `isize: Iterator`\n           which is\
    \ required by `isize: IntoIterator`\n           `&isize: Iterator`\n         \
    \  which is required by `&isize: IntoIterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counters = HashMap::<String, isize>::new();\n    for letter in\
    \ test.chars() {\n        if let Some((_, count)) = counters.get(&letter) {\n\
    \            counters.insert(letter, count + 1);\n        } else {\n         \
    \   counters.insert(letter, 1);\n        }\n    }\n    counters\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmpufs_rupg.rs:20:44\n    |\n20  |         if let Some((_, count))\
    \ = counters.get(&letter) {\n    |                                           \
    \ ^^^ the trait `Borrow<char>` is not implemented for `String`\n    |\n    = help:\
    \ the trait `Borrow<str>` is implemented for `String`\nnote: required by a bound\
    \ in `HashMap::<K, V, S>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpufs_rupg.rs:20:21\n\
    \   |\n20 |         if let Some((_, count)) = counters.get(&letter) {\n   |  \
    \                   ^^^^^^^^^^    --------------------- this expression has type\
    \ `Option<&isize>`\n   |                     |\n   |                     expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpufs_rupg.rs:21:29\n\
    \   |\n21 |             counters.insert(letter, count + 1);\n   |            \
    \                 ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                             |\n   |                             expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpufs_rupg.rs:23:29\n\
    \   |\n23 |             counters.insert(letter, 1);\n   |                    \
    \         ^^^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \                           |\n   |                             expected struct\
    \ `String`, found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counters = HashMap::<String, isize>::new();\n    for (letter,\
    \ count) in test.chars().filter_map(|c| {\n        if let Some(count) = counters.get(&c)\
    \ {\n            Some((c, count + 1))\n        } else {\n            None\n  \
    \      }\n    }) {\n        counters.insert(*letter, count);\n    }\n    counters\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmp6y4ozb2v.rs:20:39\n    |\n20  |         if let Some(count) = counters.get(&c)\
    \ {\n    |                                       ^^^ the trait `Borrow<char>`\
    \ is not implemented for `String`\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6y4ozb2v.rs:26:25\n\
    \   |\n26 |         counters.insert(*letter, count);\n   |                   \
    \      ^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freqs = HashMap::<String, isize>::new();\n\n    let mut letters\
    \ = test\n        .chars()\n        .filter(|c| !c.is_whitespace())\n        .collect::<Vec<_>>()\n\
    \        .into_iter()\n        .map(|c| c.to_ascii_lowercase())\n        .collect::<Vec<_>>();\n\
    \n    while letters.len() > 0 {\n        let mut letter = letters.remove(0);\n\
    \        freqs.entry(letter).or_insert(0) += 1;\n    }\n    freqs\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk3nx84nl.rs:30:21\n   |\n\
    30 |         freqs.entry(letter).or_insert(0) += 1;\n   |                    \
    \ ^^^^^^- help: try using a conversion method: `.to_string()`\n   |          \
    \           |\n   |                     expected struct `String`, found `char`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ isize`\n  --> /tmp/tmpk3nx84nl.rs:30:9\n   |\n30 |         freqs.entry(letter).or_insert(0)\
    \ += 1;\n   |         --------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used\
    \ on `isize`, you can dereference `freqs.entry(letter).or_insert(0)`\n   |\n30\
    \ |         *freqs.entry(letter).or_insert(0) += 1;\n   |         +\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpk3nx84nl.rs:30:42\n   |\n\
    30 |         freqs.entry(letter).or_insert(0) += 1;\n   |         --------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for ch in test.chars() {\n       \
    \ map.entry(ch).or_insert(0) += 1;\n    }\n    map\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp0xm500zh.rs:20:9\n   |\n20 |         map.entry(ch).or_insert(0)\
    \ += 1;\n   |         --------------------------^^^^^\n   |         |\n   |  \
    \       cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `map.entry(ch).or_insert(0)`\n   |\n20 |\
    \         *map.entry(ch).or_insert(0) += 1;\n   |         +\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp0xm500zh.rs:20:36\n   |\n20 |  \
    \       map.entry(ch).or_insert(0) += 1;\n   |         --------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0xm500zh.rs:22:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n22 |     map\n\
    \   |     ^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    let mut letter_iter = test.chars().enumerate().rev();\n\
    \n    for &(ref letter, ref count) in letter_iter {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \n        histogram.insert(letter.to_string(), count + count);\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp_jcyah02.rs:20:52\n     |\n20   |     let mut letter_iter = test.chars().enumerate().rev();\n\
    \     |                                                    ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp_jcyah02.rs:22:37\n\
    \   |\n22 |     for &(ref letter, ref count) in letter_iter {\n   |          \
    \                           ^^^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n             &mut I\n             Args\n             ArgsOs\n\
    \             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_, T, N>\n \
    \            ArrayWindows<'_, T, N>\n             Box<I, A>\n             Chunks<'_,\
    \ T>\n           and 109 others\n   = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Rev<Enumerate<Chars<'_>>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_jcyah02.rs:22:9\n\
    \   |\n22 |     for &(ref letter, ref count) in letter_iter {\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\
    \    ----------- this expression has type `Option<(usize, char)>`\n   |      \
    \   |\n   |         expected tuple, found reference\n   |\n   = note:  exp"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(\" \").map(|c| {\n        let mut letter = String::new();\n\
    \        letter.reserve(c.len());\n        c.chars().for_each(|&x| {\n       \
    \     letter.push(x);\n        });\n        letter.into()\n    }).reduce(HashMap::new(),\
    \ |mut acc, c| {\n        acc.entry(c).or_insert(0) += 1;\n        acc\n    })\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4eienn_9.rs:21:29\n   |\n\
    21 |         c.chars().for_each(|&x| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             expected `char`, found reference\n\
    \   |                             help: did you mean `x`: `&char`\n   |\n   =\
    \ note:   expected type `char`\n           found reference `&_`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp4eienn_9.rs:26:35\n   |\n\
    26 |         acc.entry(c).or_insert(0) += 1;\n   |         -------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4eienn_9.rs:25:8\n\
    \     |\n25   |       }).reduce(HashMap::new(), |mut acc, c| {\n     |  ________^^^^^^_--------------__-\n\
    \     | |        |\n     | |        expected 1 argument\n26   | |         acc.entry(c).or_insert(0)\
    \ += 1;\n27   | |         acc\n28   | |     })\n     | |_____- supplied 2 arguments\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4eienn_9.rs:18:5\n   |\n17 |   fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                                 ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n18 | /     test.split(\" \"\
    ).map(|c| {\n19 | |         let mut letter = String::new();\n20 | |         letter.reserve(c.len());\n\
    21 | |         c.chars().for_each(|&x| {\n...  |\n27 | |         acc\n28 | | \
    \    })\n   | |______^ expected struct `HashMap`, found enum `Option`\n   |\n\
    \   = note: expected struct `HashMap<String, isize>`\n                found enum\
    \ `Option<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0067, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split_whitespace().map(|s| s.to_string()).collect()\n        .into_iter()\n\
    \        .fold(HashMap::new(), |mut acc, x| {\n            acc.entry(x).or_insert(0)\
    \ += 1;\n            acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpmo2l99se.rs:18:52\n\
    \   |\n18 |     test.split_whitespace().map(|s| s.to_string()).collect()\n   |\
    \                                                    ^^^^^^^ cannot infer type\
    \ for type parameter `B` declared on the associated function `collect`\n   |\n\
    \   = note: type must be known at this point\nhelp: consider specifying the type\
    \ argument in the method call\n   |\n18 |     test.split_whitespace().map(|s|\
    \ s.to_string()).collect::<B>()\n   |                                        \
    \                   +++++\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpmo2l99se.rs:21:39\n   |\n21 |             acc.entry(x).or_insert(0)\
    \ += 1;\n   |             ------------------------- ^^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0282.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Split test by spaces, and convert each token to lowercase\n    let\
    \ mut tokens: Vec<_> = test\n        .split_whitespace()\n        .map(|c| c.to_lowercase())\n\
    \        .collect();\n    let mut mut histogram = HashMap::new();\n    tokens.iter().fold(histogram,\
    \ |mut histogram, token| {\n        // Look up current token and increment its\
    \ occurrence\n        let value = histogram.entry(token).or_default() + 1;\n \
    \       // Update histogram in place\n        histogram.insert(token, value);\n\
    \        value\n    });\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmp07l97ct_.rs:23:13\n\
    \   |\n23 |     let mut mut histogram = HashMap::new();\n   |             ^^^\
    \ help: remove the additional `mut`s\n\nerror[E0369]: cannot add `{integer}` to\
    \ `&mut _`\n  --> /tmp/tmp07l97ct_.rs:26:57\n   |\n26 |         let value = histogram.entry(token).or_default()\
    \ + 1;\n   |                     ----------------------------------- ^ - {integer}\n\
    \   |                     |\n   |                     &mut _\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp07l97ct_.rs:29:9\n   |\n29 |         value\n\
    \   |         ^^^^^ cyclic type of infinite size\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp07l97ct_.rs:31:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n31 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&String,\
    \ _>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ').collect()\n        .map(|l| l.to_string())\n        .iter()\n\
    \        .map(|&s| s.chars().count())\n        .fold(HashMap::new(), |mut acc,\
    \ &c| {\n            *acc.entry(s.to_string()).or_insert(0) += c;\n          \
    \  acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmp8i_8j0d1.rs:23:24\n\
    \   |\n23 |             *acc.entry(s.to_string()).or_insert(0) += c;\n   |   \
    \                     ^ help: a local variable with a similar name exists: `c`\n\
    \nerror[E0282]: type annotations needed\n  --> /tmp/tmp8i_8j0d1.rs:18:21\n   |\n\
    18 |     test.split(' ').collect()\n   |                     ^^^^^^^ cannot infer\
    \ type for type parameter `B` declared on the associated function `collect`\n\
    \   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n18 |     test.split(' ').collect::<B>()\n\
    \   |                            +++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0282, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for letter in test.split(' ').iter().cloned()\
    \ {\n        match map.entry(letter) {\n            hash_map::Entry::Vacant(entry)\
    \ => {\n                entry.insert(0);\n            }\n            hash_map::Entry::Occupied(entry)\
    \ => {\n                *entry.get_mut() += 1;\n            }\n        }\n   \
    \ }\n\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmppoo6u4a1.rs:21:13\n   |\n21 |             hash_map::Entry::Vacant(entry)\
    \ => {\n   |             ^^^^^^^^ use of undeclared crate or module `hash_map`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmppoo6u4a1.rs:24:13\n   |\n24 |             hash_map::Entry::Occupied(entry)\
    \ => {\n   |             ^^^^^^^^ use of undeclared crate or module `hash_map`\n\
    \nerror[E0599]: no method named `iter` found for struct `std::str::Split` in the\
    \ current scope\n  --> /tmp/tmppoo6u4a1.rs:19:35\n   |\n19 |     for letter in\
    \ test.split(' ').iter().cloned() {\n   |                                   ^^^^\
    \ method not found in `std::str::Split<'_, char>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| c.to_lowercase()).group_by(|c| c).max_by_key(|(_,\
    \ v)| v)\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpo612lcuy.rs:18:44\n   |\n18 |     test.chars().map(|c|\
    \ c.to_lowercase()).group_by(|c| c).max_by_key(|(_, v)| v)\n   |             \
    \                               ^^^^^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpo612lcuy.rs:18:22:\
    \ 18:42]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histo: HashMap<String, isize> = HashMap::new();\n    let mut\
    \ counts = HashMap::new();\n    for ch in test.chars().filter_map(|c| c != '\\\
    0') {\n        if let Some(count) = counts.entry(ch).or_insert(0) {\n        \
    \    *count += 1;\n        } else {\n            counts.insert(ch, 1);\n     \
    \   }\n    }\n    for (ch, count) in counts {\n        let mut max_count = count;\n\
    \        let mut max_key = ch;\n        for (_key, val) in histo.iter_mut().filter(|(_,\
    \ count)| count == max_count) {\n            if *val >= *max_count {\n       \
    \         max_count = *val;\n                max_key = *_key;\n            }\n\
    \        }\n        *max_count = count + 1;\n    }\n    histo\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprlns0zfx.rs:20:43\n   |\n\
    20 |     for ch in test.chars().filter_map(|c| c != '\\0') {\n   |           \
    \                                ^^^^^^^^^ expected enum `Option`, found `bool`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `bool`\n\
    help: try wrapping the expression in `Some`\n   |\n20 |     for ch in test.chars().filter_map(|c|\
    \ Some(c != '\\0')) {\n   |                                           +++++  \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprlns0zfx.rs:21:16\n\
    \   |\n21 |         if let Some(count) = counts.entry(ch).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^   ----------------------------- this expression has\
    \ type `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<_>`\n\nerror[E0277]: can't compare `&&mut isize` with\
    \ `{integer}`\n  --> /tmp/tmprlns0zfx.rs:30:71\n   |\n30 |         for (_key,\
    \ val) in histo.iter_mut().filter(|(_, count)| count == max_count) {\n   |   \
    \                                                                    ^^ no implementation\
    \ for `&&mut isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&mut isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0614]: type `{integer}` cannot\
    \ be dereferenced\n  --> /tmp/tmprlns0zfx.rs:31:24\n   |\n31 |             if\
    \ *val >= *max_count {\n   |                        ^^^^^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmprlns0zfx.rs:36:9\n   |\n\
    36 |         *max_count = count + 1;\n   |         ^^^^^^^^^^\n   |\nhelp: parentheses\
    \ are required to parse this as an expression\n   |\n30 ~         (for (_key,\
    \ val) in histo.iter_mut().filter(|(_, count)| count == max_count) {\n31 |   \
    \          if *val >= *max_count {\n32 |           "
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for (letter, count) in test.split_whitespace().chars().group_by(|x|\
    \ x).cloned().collect::<HashMap<_, _>>() {\n        if let Some((_, mut value))\
    \ = map.entry(letter).or_insert(0) {\n            *value += count;\n        }\
    \ else {\n            map.insert(letter, count);\n        }\n    }\n    map\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp13qu1wsv.rs:19:52\n   |\n19 |     for (letter,\
    \ count) in test.split_whitespace().chars().group_by(|x| x).cloned().collect::<HashMap<_,\
    \ _>>() {\n   |                                                    ^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp13qu1wsv.rs:20:16\n   |\n20 |         if let Some((_, mut value)) =\
    \ map.entry(letter).or_insert(0) {\n   |                ^^^^^^^^^^^^^^^^^^^^ \
    \  ------------------------------ this expression has type `&mut {integer}`\n\
    \   |                |\n   |                expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    HashMap::new()\n        .into_iter()\n        .fold(\n            HashMap::new(),\n\
    \            |mut map, character| {\n                let count = map.entry(character).or_insert(0);\n\
    \                *count += 1;\n                map\n            },\n        )\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_kqmjp27.rs:23:39\n   |\n\
    23 |                 let count = map.entry(character).or_insert(0);\n   |    \
    \                                   ^^^^^^^^^ expected struct `String`, found\
    \ tuple\n   |\n   = note: expected struct `String`\n               found tuple\
    \ `(_, _)`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().fold(HashMap::new(), |mut m, c| {\n        m.entry(c.to_string()).or_insert(0);\n\
    \        *m += 1;\n        m\n    })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `HashMap<String, isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpkel1mwnw.rs:20:9\n   |\n20 |         *m += 1;\n   |         ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::with_capacity(test.chars().count());\n \
    \   for c in test.chars() {\n        if let Some(i) = (histogram.entry(c).or_insert(0)).value\
    \ {\n            *i += 1;\n        } else {\n            histogram.insert(c, 1);\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `value` on type `&mut {integer}`\n  --> /tmp/tmpvfduuqq6.rs:20:60\n\
    \   |\n20 |         if let Some(i) = (histogram.entry(c).or_insert(0)).value {\n\
    \   |                                                            ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvfduuqq6.rs:26:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n26 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string());\n    while let Some(key) = letters.next() {\n        if map.contains_key(&key)\
    \ {\n            map.insert(key, map.get(&key).unwrap() + 1);\n        } else\
    \ {\n            map.insert(key, 1);\n        }\n    }\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `key`\n  --> /tmp/tmp5wld4f5y.rs:22:37\n\
    \   |\n20 |     while let Some(key) = letters.next() {\n   |                 \
    \   --- move occurs because `key` has type `String`, which does not implement\
    \ the `Copy` trait\n21 |         if map.contains_key(&key) {\n22 |           \
    \  map.insert(key, map.get(&key).unwrap() + 1);\n   |                        ---\
    \          ^^^^ value borrowed here after move\n   |                        |\n\
    \   |                        value moved here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freq_count = HashMap::new();\n    let mut words = test.chars().fold(vec![],\
    \ |mut a, x| {\n        a.push(x);\n        a\n    });\n    let mut letters =\
    \ words.iter().map(|c| c.to_string());\n    let mut count = letters.count();\n\
    \    letters.sort();\n    let mut previous_count = 1;\n    for elm in letters\
    \ {\n        freq_count.entry(elm).or_insert(0) += 1;\n        let mut new_count\
    \ = count;\n        count -= 1;\n        if count > previous_count {\n       \
    \     new_count = count;\n        }\n        previous_count = new_count;\n   \
    \ }\n    freq_count\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpc7aedml2.rs:25:13\n   |\n25 |     letters.sort();\n   |\
    \             ^^^^ method not found in `Map<std::slice::Iter<'_, char>, [closure@/tmp/tmpc7aedml2.rs:23:40:\
    \ 23:57]>`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmpc7aedml2.rs:28:9\n   |\n28 |       \
    \  freq_count.entry(elm).or_insert(0) += 1;\n   |         ----------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `freq_count.entry(elm).or_insert(0)`\n\
    \   |\n28 |         *freq_count.entry(elm).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpc7aedml2.rs:28:44\n\
    \   |\n28 |         freq_count.entry(elm).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \n    while let Some(letter) = letters.pop() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpy9igcc6a.rs:21:38\n   |\n21 |     while\
    \ let Some(letter) = letters.pop() {\n   |                                   \
    \   ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpy9igcc6a.rs:23:13\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpy9igcc6a.rs:23:50\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n\n    for &s in test.split() {\n     \
    \   if let Ok(s) = String::from(s) {\n            map.entry(s).or_default() +=\
    \ 1;\n        }\n    }\n\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp8f0hlvpc.rs:20:20\n     |\n20   |     for &s in test.split()\
    \ {\n     |                    ^^^^^- supplied 0 arguments\n     |           \
    \         |\n     |                    expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmp8f0hlvpc.rs:20:10\n   |\n20 |  \
    \   for &s in test.split() {\n   |          ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmp8f0hlvpc.rs:21:37\n\
    \    |\n21  |         if let Ok(s) = String::from(s) {\n    |                \
    \        ------------ ^ doesn't have a size known at compile-time\n    |     \
    \                   |\n    |                        required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `from`\n\nerror[E0277]: the trait bound `String:\
    \ From<str>` is not satisfied\n  --> /tmp/tmp8f0hlvpc.rs:21:24\n   |\n21 |   \
    \      if let Ok(s) = String::from(s) {\n   |                        ^^^^^^^^^^^^\
    \ the trait `From<str>` is not implemented for `String`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8f0hlvpc.rs:21:16\n   |\n21 |         if let Ok(s) = String::from(s)\
    \ {\n   |                ^^^^^   --------------- this expression has type `String`\n\
    \   |                |\n   |                expected struct `String`, found enum\
    \ `Result`\n   |\n   = note: expected str"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut result: HashMap<String, isize> = HashMap::new();\n    let mut\
    \ letters: Vec<String> = test.chars().map(|c| c.to_string()).collect();\n    let\
    \ mut seen = HashMap::new();\n\n    while let Some(letter) = letters.pop() {\n\
    \        if seen.contains_key(&letter) {\n            result.insert(*letter, seen.get(&letter)\
    \ + 1);\n            seen.insert(*letter, 1);\n        } else {\n            seen.insert(*letter,\
    \ 1);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppvyebjye.rs:24:27\n   |\n\
    24 |             result.insert(*letter, seen.get(&letter) + 1);\n   |        \
    \                   ^^^^^^^ expected struct `String`, found `str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n24 |             result.insert((*letter).to_string(),\
    \ seen.get(&letter) + 1);\n   |                           +       +++++++++++++\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<&_>`\n  --> /tmp/tmppvyebjye.rs:24:54\n\
    \   |\n24 |             result.insert(*letter, seen.get(&letter) + 1);\n   | \
    \                                   ----------------- ^ - {integer}\n   |    \
    \                                |\n   |                                    Option<&_>\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmppvyebjye.rs:23:17\n    |\n23  |         if seen.contains_key(&letter)\
    \ {\n    |                 ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `HashMap::<K, V, S>::contains_key`\n\nerror[E0277]: the trait\
    \ bound `str: Borrow<String>` is not satisfied\n   --> /tmp/tmppvyebjye.rs:23:17\n\
    \    |\n23  |         if seen.contains_key(&letter) {\n    |                 ^^^^^^^^^^^^\
    \ the trait `Borrow<String>` is not implemented for `str`\n    |\n    = help:\
    \ the trait `Borrow<str>` is implemented for `String`\nnote: required by a bound\
    \ in `HashMap::<K, V, S>::contains_key`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n   --> /tmp/tmppvyebjye.rs:24:41\n\
    \    |\n24  |             result.insert(*letter, seen.get(&letter) + 1);\n   \
    \ |                                         ^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `HashMap::<K, V, S>::get`\n\nerror[E0277]: the trait bound `str:\
    \ Borrow<String>` is not satisfied\n   --> /tmp/tmppvyebjye.rs:24:41\n    |\n\
    24  |             result.insert(*letter, seen.get(&letter) + 1);\n    |      "
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freq = HashMap::new();\n    for (index, elem) in test.chars().enumerate()\
    \ {\n        freq.entry(elem).or_insert(0) += 1;\n    }\n    freq\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp8_h4r_ty.rs:20:9\n   |\n20 |         freq.entry(elem).or_insert(0)\
    \ += 1;\n   |         -----------------------------^^^^^\n   |         |\n   |\
    \         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `freq.entry(elem).or_insert(0)`\n   |\n\
    20 |         *freq.entry(elem).or_insert(0) += 1;\n   |         +\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp8_h4r_ty.rs:20:39\n   |\n\
    20 |         freq.entry(elem).or_insert(0) += 1;\n   |         -----------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8_h4r_ty.rs:22:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n22 |     freq\n\
    \   |     ^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histo = HashMap::new();\n    for elem in test.chars().map(String::from).collect::<Vec<_>>()\
    \ {\n        histo[elem] = histo.entry(elem).or_insert(0);\n        *histo[elem]\
    \ += 1;\n    }\n    histo\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0p61eu0g.rs:20:15\n   |\n\
    20 |         histo[elem] = histo.entry(elem).or_insert(0);\n   |             \
    \  ^^^^\n   |               |\n   |               expected reference, found struct\
    \ `String`\n   |               help: consider borrowing here: `&elem`\n   |\n\
    \   = note: expected reference `&_`\n                 found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0p61eu0g.rs:20:23\n   |\n20 |  \
    \       histo[elem] = histo.entry(elem).or_insert(0);\n   |         -----------\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `&mut {integer}`\n\
    \   |         |\n   |         expected due to the type of this binding\n   |\n\
    help: consider dereferencing the borrow\n   |\n20 |         histo[elem] = *histo.entry(elem).or_insert(0);\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0p61eu0g.rs:21:16\n\
    \   |\n21 |         *histo[elem] += 1;\n   |                ^^^^\n   |       \
    \         |\n   |                expected reference, found struct `String`\n \
    \  |                help: consider borrowing here: `&elem`\n   |\n   = note: expected\
    \ reference `&_`\n                 found struct `String`\n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmp0p61eu0g.rs:21:9\n   |\n21\
    \ |         *histo[elem] += 1;\n   |         ^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for word in test.split(\" \") {\n\
    \        let word = word.to_lowercase();\n        if map.contains_key(&word) {\n\
    \            map.entry(word.clone()).or_insert(0) += 1;\n        } else {\n  \
    \          map.insert(word, 1);\n        }\n    }\n    map\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp_s048hjn.rs:22:13\n   |\n22 |             map.entry(word.clone()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `map.entry(word.clone()).or_insert(0)`\n\
    \   |\n22 |             *map.entry(word.clone()).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp_s048hjn.rs:22:50\n\
    \   |\n22 |             map.entry(word.clone()).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Create a map with empty entries.\n    let mut histogram = HashMap::<String,\
    \ isize>::new();\n    // Split the string into a list of single characters.\n\
    \    let mut chars = test.chars().collect::<Vec<_>>();\n    while !chars.is_empty()\
    \ {\n        // For each single character remove duplicates.\n        let mut\
    \ chars_ = chars.clone();\n        chars_.sort();\n        let mut curr = &chars_[0];\n\
    \        histogram.insert(curr.clone(), 0);\n        // Remove single character\
    \ from original list.\n        let rem = chars.iter().enumerate().filter(|(_,\
    \ v)| *v != curr).collect::<Vec<_>>();\n        if !rem.is_empty() {\n       \
    \     histogram.insert(rem[0], rem[1].unwrap() + 1);\n            chars = rem.into_iter().collect::<Vec<_>>();\n\
    \        }\n    }\n    // All unique letters encountered should be in the map.\n\
    \    for v in histogram.keys() {\n        if histogram.get(v) == 0 {\n       \
    \     println!(\"Found letter {} that occured 0 times \", v);\n        }\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4rwczitg.rs:27:26\n   |\n\
    27 |         histogram.insert(curr.clone(), 0);\n   |                        \
    \  ^^^^^^^^^^^^\n   |                          |\n   |                       \
    \   expected struct `String`, found `char`\n   |                          help:\
    \ try using a conversion method: `curr.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4rwczitg.rs:31:30\n   |\n31 |             histogram.insert(rem[0],\
    \ rem[1].unwrap() + 1);\n   |                              ^^^^^^ expected struct\
    \ `String`, found tuple\n   |\n   = note: expected struct `String`\n         \
    \      found tuple `(usize, &char)`\n\nerror[E0599]: no method named `unwrap`\
    \ found for tuple `(usize, &char)` in the current scope\n  --> /tmp/tmp4rwczitg.rs:31:45\n\
    \   |\n31 |             histogram.insert(rem[0], rem[1].unwrap() + 1);\n   | \
    \                                            ^^^^^^ method not found in `(usize,\
    \ &char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4rwczitg.rs:32:21\n\
    \   |\n21 |     let mut chars = test.chars().collect::<Vec<_>>();\n   |      \
    \               -------------------------------- expected due to this value\n\
    ...\n32 |             chars = rem.into_iter().collect::<Vec<_>>();\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found tuple\n\
    \   |\n   = note: expected struct `Vec<char>`\n              found struct `Vec<(usize,\
    \ &char)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4rwczitg.rs:37:32\n\
    \   |\n37 |         if histogram.get(v) == 0 {\n   |                         \
    \       ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<&isize>`\n              found type `{integer}`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = test.chars().map(|c| c.to_string()).collect();\n  \
    \  letters.sort_unstable();\n    let mut occurrences = HashMap::new();\n    let\
    \ mut prev_letters = HashMap::new();\n\n    // Keep track of which letters we\
    \ have already seen\n    let mut seen_letters = HashMap::new();\n\n    for i in\
    \ 0..letters.len() {\n        let letter = &letters[i..i + 1];\n        if seen_letters.contains_key(&letter)\
    \ {\n            occurrences[letter] += 1;\n        }\n        else {\n      \
    \      seen_letters.insert(letter);\n            occurrences.insert(letter, 0);\n\
    \        }\n    }\n\n    for x in occurrences.keys() {\n        if prev_letters.contains_key(&x)\
    \ {\n            occurrences[x] += occurrences[&prev_letters[x]];\n        }\n\
    \    }\n\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpdwx8w1ln.rs:19:5\n\
    \   |\n18 |     let mut letters = test.chars().map(|c| c.to_string()).collect();\n\
    \   |         ----------- consider giving `letters` a type\n19 |     letters.sort_unstable();\n\
    \   |     ^^^^^^^ cannot infer type\n   |\n   = note: type must be known at this\
    \ point\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpdwx8w1ln.rs:32:26\n    |\n32  |             seen_letters.insert(letter);\n\
    \    |                          ^^^^^^ ------ supplied 1 argument\n    |     \
    \                     |\n    |                          expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdwx8w1ln.rs:43:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n43 |     occurrences\n\
    \   |     ^^^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&_,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0282, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = test.chars().collect::<Vec<String>>();\n    letters.sort();\n\
    \    letters.dedup();\n\n    let mut map = HashMap::new();\n    for (letter, count)\
    \ in letters.iter().cloned().windows(2) {\n        map.insert(letter, count);\n\
    \    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmptw5kl13d.rs:18:36\n     |\n18\
    \   |     let mut letters = test.chars().collect::<Vec<String>>();\n     |   \
    \                                 ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0599]: no method named `windows` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmptw5kl13d.rs:23:52\n   |\n23 |     for (letter,\
    \ count) in letters.iter().cloned().windows(2) {\n   |                       \
    \                             ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let mut count = 0;\n    for ch in\
    \ test.chars() {\n        map.entry(ch.to_string()).or_insert(0) as usize + 1;\n\
    \        count += 1;\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&mut isize` as `usize` is invalid\n  --> /tmp/tmpycrkzgmc.rs:21:9\n\
    \   |\n21 |         map.entry(ch.to_string()).or_insert(0) as usize + 1;\n   |\
    \         --------------------------------------^^^^^^^^^\n   |         |\n  \
    \ |         cannot cast `&mut isize` as `usize`\n   |         help: dereference\
    \ the expression: `*map.entry(ch.to_string()).or_insert(0)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ').group_by(|x| x.to_string()).map(|(_, v)| {\n        let\
    \ mut hm = HashMap::new();\n        hm.insert(String::from(\"\"), v.len());\n\
    \        hm\n    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpxxhoaitq.rs:18:21\n   |\n18 |     test.split('\
    \ ').group_by(|x| x.to_string()).map(|(_, v)| {\n   |                     ^^^^^^^^\
    \ method not found in `std::str::Split<'_, char>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    for c in test.chars() {\n\
    \        let mut count = 0;\n        let mut letter = String::from(*c);\n    \
    \    let mut max_count = histogram.entry(letter).or_insert(0);\n\n        if *max_count\
    \ < count {\n            *max_count = count;\n        }\n\n        *max_count\
    \ += 1;\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp5t_ictgg.rs:22:39\n\
    \   |\n22 |         let mut letter = String::from(*c);\n   |                 \
    \                      ^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().filter_map(|c| {\n        if c.is_whitespace() {\n     \
    \       return None;\n        }\n        let key = String::from(c.to_string());\n\
    \        let mut count = 0;\n        // Keep track of the letter seen with the\
    \ highest count\n        if let Some(count) = histogram.get(&key) {\n        \
    \    if count > count {\n                // Keep the highest count\n         \
    \       histogram = histogram.insert(key, count);\n            }\n        }\n\
    \        // If no letter has seen the highest count, keep track of it\n      \
    \  else {\n            histogram = histogram.insert(key, 1);\n        }\n    \
    \    Some(histogram)\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get` found for fn item `fn(String) -> HashMap<String,\
    \ isize> {histogram}` in the current scope\n  --> /tmp/tmpdm1rh5wc.rs:25:40\n\
    \   |\n25 |         if let Some(count) = histogram.get(&key) {\n   |         \
    \                     --------- ^^^ method not found in `fn(String) -> HashMap<String,\
    \ isize> {histogram}`\n   |                              |\n   |             \
    \                 this is a function, perhaps you wish to call it\n\nerror[E0070]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpdm1rh5wc.rs:28:27\n   |\n\
    28 |                 histogram = histogram.insert(key, count);\n   |         \
    \        --------- ^\n   |                 |\n   |                 cannot assign\
    \ to this expression\n\nerror[E0599]: no method named `insert` found for fn item\
    \ `fn(String) -> HashMap<String, isize> {histogram}` in the current scope\n  -->\
    \ /tmp/tmpdm1rh5wc.rs:28:39\n   |\n28 |                 histogram = histogram.insert(key,\
    \ count);\n   |                             --------- ^^^^^^ method not found\
    \ in `fn(String) -> HashMap<String, isize> {histogram}`\n   |                \
    \             |\n   |                             this is a function, perhaps\
    \ you wish to call it\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpdm1rh5wc.rs:33:23\n   |\n33 |             histogram = histogram.insert(key,\
    \ 1);\n   |             --------- ^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0599]: no method named `insert` found for\
    \ fn item `fn(String) -> HashMap<String, isize> {histogram}` in the current scope\n\
    \  --> /tmp/tmpdm1rh5wc.rs:33:35\n   |\n33 |             histogram = histogram.insert(key,\
    \ 1);\n   |                         --------- ^^^^^^ method not found in `fn(String)\
    \ -> HashMap<String, isize> {histogram}`\n   |                         |\n   |\
    \                         this is a function, perhaps you wish to call it\n\n\
    error[E0277]: a value of type `HashMap<String, isize>` cannot be built from an\
    \ iterator over elements of type `fn(String) -> HashMap<String, isize> {histogram}`\n\
    \    --> /tmp"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.split(' ')\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.get_mut(&letter).unwrap().1\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `HashMap<K, V>`\n  --> /tmp/tmp8ciylay4.rs:21:23\n\
    \   |\n18 |     let mut histogram = HashMap::new();\n   |         -------------\
    \ consider giving `histogram` the explicit type `HashMap<K, V>`, where the type\
    \ parameter `V` is specified\n...\n21 |             histogram.get_mut(&letter).unwrap().1\
    \ += 1;\n   |                       ^^^^^^^ cannot infer type for type parameter\
    \ `V`\n   |\n   = note: type must be known at this point\n\nerror[E0609]: no field\
    \ `1` on type `&mut _`\n  --> /tmp/tmp8ciylay4.rs:21:49\n   |\n21 |          \
    \   histogram.get_mut(&letter).unwrap().1 += 1;\n   |                        \
    \                         ^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0282, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut m = HashMap::new();\n    for letter in test.split(\" \") {\n\
    \        if let Some(count) = m.entry(letter).or_insert(0) {\n            *count\
    \ += 1;\n        }\n    }\n    m\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj8apazz3.rs:20:16\n   |\n\
    20 |         if let Some(count) = m.entry(letter).or_insert(0) {\n   |       \
    \         ^^^^^^^^^^^   ---------------------------- this expression has type\
    \ `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj8apazz3.rs:24:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n24 |     m\n   |     ^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<&str, {integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let letters = test.split(' ').collect::<Vec<_>>();\n\
    \    for letter in letters {\n        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwjln1pad.rs:21:34\n   |\n\
    21 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpwjln1pad.rs:23:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n23 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ').collect()\n        .map(|x| x.to_string())\n        .count();\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpv7lcrnd4.rs:18:21\n\
    \   |\n18 |     test.split(' ').collect()\n   |                     ^^^^^^^ cannot\
    \ infer type for type parameter `B` declared on the associated function `collect`\n\
    \   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n18 |     test.split(' ').collect::<B>()\n\
    \   |                            +++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv7lcrnd4.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Remove non-alphabetic characters from the test string and lowercase\
    \ it\n    // and convert it to an iterator\n    let mut iter = test.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').map(|c| c.to_lowercase()).collect::<String>();\n\n   \
    \ // Sort the iterator and create a HashMap\n    let mut count: HashMap<String,\
    \ isize> = HashMap::new();\n    iter.sort_by_key(|&c| count.entry(c).or_insert(0));\n\
    \    count\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvmgwuzdg.rs:20:49\n   |\n\
    20 |     let mut iter = test.chars().filter(|c| c >= 'a' && c <= 'z').map(|c|\
    \ c.to_lowercase()).collect::<String>();\n   |                               \
    \                  ^^^\n   |                                                 |\n\
    \   |                                                 expected `&char`, found\
    \ `char`\n   |                                                 help: consider\
    \ borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmgwuzdg.rs:20:61\n\
    \   |\n20 |     let mut iter = test.chars().filter(|c| c >= 'a' && c <= 'z').map(|c|\
    \ c.to_lowercase()).collect::<String>();\n   |                               \
    \                              ^^^\n   |                                     \
    \                        |\n   |                                             \
    \                expected `&char`, found `char`\n   |                        \
    \                                     help: consider borrowing here: `&'z'`\n\n\
    error[E0277]: a value of type `String` cannot be built from an iterator over elements\
    \ of type `ToLowercase`\n    --> /tmp/tmpvmgwuzdg.rs:20:92\n     |\n20   |   \
    \  let mut iter = test.chars().filter(|c| c >= 'a' && c <= 'z').map(|c| c.to_lowercase()).collect::<String>();\n\
    \     |                                                                      \
    \                      ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=ToLowercase>`\n\
    \     |\n     = help: the trait `FromIterator<ToLowercase>` is not implemented\
    \ for `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `String` in the current scope\n  --"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test.splitn(2, |c| c.to_lowercase()).map(|l| l.parse().unwrap()))\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpktao523h.rs:18:31\n\
    \   |\n18 |     histogram(test.splitn(2, |c| c.to_lowercase()).map(|l| l.parse().unwrap()))\n\
    \   |                               ^ consider giving this closure parameter a\
    \ type\n   |\n   = note: type must be known at this point\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpktao523h.rs:18:15\n   |\n18 |     histogram(test.splitn(2,\
    \ |c| c.to_lowercase()).map(|l| l.parse().unwrap()))\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Map`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Map<std::str::SplitN<'_, _>, [closure@/tmp/tmpktao523h.rs:18:56:\
    \ 18:78]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0282, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::<String, isize>::new();\n    let mut letters\
    \ = test.chars();\n    let mut letter = String::new();\n    while let Some(letter)\
    \ = letters.next() {\n        histogram.entry(letter.to_ascii_lowercase()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq31k8bmc.rs:22:25\n   |\n\
    22 |         histogram.entry(letter.to_ascii_lowercase()).or_insert(0) += 1;\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                         |\n   |               \
    \          expected struct `String`, found `char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut isize`\n  --> /tmp/tmpq31k8bmc.rs:22:9\n\
    \   |\n22 |         histogram.entry(letter.to_ascii_lowercase()).or_insert(0)\
    \ += 1;\n   |         ---------------------------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp:\
    \ `+=` can be used on `isize`, you can dereference `histogram.entry(letter.to_ascii_lowercase()).or_insert(0)`\n\
    \   |\n22 |         *histogram.entry(letter.to_ascii_lowercase()).or_insert(0)\
    \ += 1;\n   |         +\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpq31k8bmc.rs:22:67\n   |\n22 |         histogram.entry(letter.to_ascii_lowercase()).or_insert(0)\
    \ += 1;\n   |         ---------------------------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freqs = HashMap::new();\n    let mut word_lengths: Vec<String>\
    \ = test.split_whitespace().collect();\n    word_lengths.sort_by_key(|x| x.len());\n\
    \    for w in word_lengths {\n        let len = w.len();\n        freqs.entry(w)\n\
    \            .or_insert(0) // If it does not exist\n            += 1;\n    }\n\
    \    freqs\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp458bb95_.rs:19:65\n     |\n19\
    \   |     let mut word_lengths: Vec<String> = test.split_whitespace().collect();\n\
    \     |                                                                 ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut {integer}`\n  --> /tmp/tmp458bb95_.rs:23:9\n   |\n\
    23 |            freqs.entry(w)\n   |   _________^\n   |  |_________|\n   | ||\n\
    24 | ||             .or_insert(0) // If it does not exist\n   | ||_________________________-\
    \ cannot use `+=` on type `&mut {integer}`\n25 | |              += 1;\n   | |_________________^\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `freqs.entry(w)\n\
    \   |                         .or_insert(0)`\n23 |         *freqs.entry(w)\n \
    \  |         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp458bb95_.rs:25:13\n\
    \   |\n23 | /         freqs.entry(w)\n24 | |             .or_insert(0) // If it\
    \ does not exist\n   | |_________________________- cannot assign to this expression\n\
    25 |               += 1;\n   |               ^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0277, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    Histogram::from_str(test)\n        .into_iter()\n        .map(|(_, count)|\
    \ {\n            (String::from(String::from(&test.chars().max())), count)\n  \
    \      })\n        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Histogram`\n \
    \ --> /tmp/tmpzmprh287.rs:18:5\n   |\n18 |     Histogram::from_str(test)\n   |\
    \     ^^^^^^^^^ use of undeclared type `Histogram`\n\nerror[E0277]: the trait\
    \ bound `String: From<&Option<char>>` is not satisfied\n  --> /tmp/tmpzmprh287.rs:21:27\n\
    \   |\n21 |             (String::from(String::from(&test.chars().max())), count)\n\
    \   |                           ^^^^^^^^^^^^ the trait `From<&Option<char>>` is\
    \ not implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters: HashMap<String, isize> = HashMap::new();\n    for l\
    \ in test.chars().map(|c| c.to_string()) {\n        if let Some(count) = letters.get(&l)\
    \ {\n            letters.insert(l, (*count) + 1);\n        } else {\n        \
    \    letters.insert(l, 1);\n        }\n    }\n    letters\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp1jw9ug_o.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars()\n        .map(|c| c.to_ascii_lowercase())\n        .fold(HashMap::new(),\
    \ |mut acc, x| {\n            let y = acc.entry(x).or_insert(0);\n           \
    \ *y += 1;\n            acc\n        })\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6_7ewpi.rs:21:31\n   |\n\
    21 |             let y = acc.entry(x).or_insert(0);\n   |                    \
    \           ^- help: try using a conversion method: `.to_string()`\n   |     \
    \                          |\n   |                               expected struct\
    \ `String`, found `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ').group_by_ref().max_by(|&(_, a)| a).unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by_ref` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmppp89j_9e.rs:18:21\n   |\n18 |     test.split('\
    \ ').group_by_ref().max_by(|&(_, a)| a).unwrap()\n   |                     ^^^^^^^^^^^^\
    \ method not found in `std::str::Split<'_, char>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| *c).enumerate().map(|(i, (_, count))| {\n \
    \       (String::from(*i) as String, count)\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpmxxqd3ap.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ *c).enumerate().map(|(i, (_, count))| {\n   |                  ^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    for (letter, count) in test\n\
    \        .chars()\n        .map(|c| c.to_string())\n        .fold(HashMap::new(),\
    \ |mut a, c| {\n            a.entry(c).or_insert(0)\n                .and_modify(|c|\
    \ c += 1);\n            a\n        })\n    {\n        if let Some(count) = &letters.get(&letter)\
    \ {\n            letters.insert(letter, (*count).max(count));\n        } else\
    \ {\n            letters.insert(letter, 1);\n        }\n    }\n    letters\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `and_modify` found for mutable reference\
    \ `&mut {integer}` in the current scope\n  --> /tmp/tmpjckfi07a.rs:24:18\n   |\n\
    24 |                 .and_modify(|c| c += 1);\n   |                  ^^^^^^^^^^\
    \ method not found in `&mut {integer}`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test.chars().collect::<Vec<char>>())\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkzr8y6w.rs:18:15\n   |\n\
    18 |     histogram(test.chars().collect::<Vec<char>>())\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<char>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ')\n        .filter_map(|s| s.chars().filter_map(|c| match\
    \ c {\n            'a' => Some(1),\n            'b' => Some(1),\n            'c'\
    \ => Some(1),\n            _ => None,\n        }))\n        .fold(HashMap::new(),\
    \ |mut acc, cur| {\n            let mut cur = cur.to_string();\n            let\
    \ count = acc.entry(cur).or_insert(0);\n            *count += 1;\n           \
    \ acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_0do72sw.rs:19:25\n   |\n\
    19 |           .filter_map(|s| s.chars().filter_map(|c| match c {\n   |  _________________________^\n\
    20 | |             'a' => Some(1),\n21 | |             'b' => Some(1),\n22 | |\
    \             'c' => Some(1),\n23 | |             _ => None,\n24 | |         }))\n\
    \   | |__________^ expected enum `Option`, found struct `FilterMap`\n   |\n  \
    \ = note: expected enum `Option<_>`\n            found struct `FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp_0do72sw.rs:19:46: 24:10]>`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n19 ~         .filter_map(|s| Some(s.chars().filter_map(|c|\
    \ match c {\n20 |             'a' => Some(1),\n21 |             'b' => Some(1),\n\
    22 |             'c' => Some(1),\n23 |             _ => None,\n24 ~         })))\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ')\n        .map(|element| element.to_lowercase())\n   \
    \     .collect::<HashMap<_, _>>()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `HashMap<_, _>` cannot be built from an iterator\
    \ over elements of type `String`\n    --> /tmp/tmpkjhtbwwj.rs:20:10\n     |\n\
    20   |         .collect::<HashMap<_, _>>()\n     |          ^^^^^^^ value of type\
    \ `HashMap<_, _>` cannot be built from `std::iter::Iterator<Item=String>`\n  \
    \   |\n     = help: the trait `FromIterator<String>` is not implemented for `HashMap<_,\
    \ _>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test, HashMap::new(), 0)\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmpzsz163cv.rs:18:5\n   |\n18 |     histogram(test, HashMap::new(),\
    \ 0)\n   |     ^^^^^^^^^ ----  --------------  - supplied 3 arguments\n   |  \
    \   |\n   |     expected 1 argument\n   |\nnote: function defined here\n  -->\
    \ /tmp/tmpzsz163cv.rs:17:4\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ^^^^^^^^^ ------------\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ').map(|letter| {\n        let mut occurrences = 0;\n  \
    \      let mut max_occurrences = 0;\n        let mut letter = letter.to_lowercase();\n\
    \        let mut bucket = letters.entry(letter).or_default();\n\n        match\
    \ bucket {\n            Occupied::Vacant(b) => {\n                b.insert(1);\n\
    \            }\n            Occupied::Occupied(mut occurence) => {\n         \
    \       occurrences += 1;\n                if occurrences > max_occurrences {\n\
    \                    max_occurrences = occurrences;\n                }\n     \
    \       }\n        }\n        HashMap::from((letter, max_occurrences))\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Occupied`\n  -->\
    \ /tmp/tmpw9n7_wwz.rs:25:13\n   |\n25 |             Occupied::Vacant(b) => {\n\
    \   |             ^^^^^^^^ use of undeclared type `Occupied`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Occupied`\n  --> /tmp/tmpw9n7_wwz.rs:28:13\n\
    \   |\n28 |             Occupied::Occupied(mut occurence) => {\n   |         \
    \    ^^^^^^^^ use of undeclared type `Occupied`\n\nerror[E0425]: cannot find value\
    \ `letters` in this scope\n  --> /tmp/tmpw9n7_wwz.rs:22:26\n   |\n22 |       \
    \  let mut bucket = letters.entry(letter).or_default();\n   |                \
    \          ^^^^^^^ help: a local variable with a similar name exists: `letter`\n\
    \nerror[E0277]: the trait bound `HashMap<_, _, _>: From<(String, {integer})>`\
    \ is not satisfied\n  --> /tmp/tmpw9n7_wwz.rs:35:9\n   |\n35 |         HashMap::from((letter,\
    \ max_occurrences))\n   |         ^^^^^^^^^^^^^ the trait `From<(String, {integer})>`\
    \ is not implemented for `HashMap<_, _, _>`\n   |\n   = help: the trait `From<[(K,\
    \ V); N]>` is implemented for `HashMap<K, V>`\n\nerror[E0277]: a value of type\
    \ `HashMap<String, isize>` cannot be built from an iterator over elements of type\
    \ `HashMap<_, _, _>`\n    --> /tmp/tmpw9n7_wwz.rs:36:8\n     |\n36   |     }).collect()\n\
    \     |        ^^^^^^^ value of type `HashMap<String, isize>` cannot be built\
    \ from `std::iter::Iterator<Item=HashMap<_, _, _>>`\n     |\n     = help: the\
    \ trait `FromIterator<HashMap<_, _, _>>` is not implemented for `HashMap<String,\
    \ isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test.split_whitespace().collect::<Vec<_>>())\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe67pfgx5.rs:18:15\n   |\n\
    18 |     histogram(test.split_whitespace().collect::<Vec<_>>())\n   |        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counts = HashMap::new();\n    for (i, ch) in test.chars().enumerate()\
    \ {\n        if !counts.contains_key(&ch.to_string()) {\n            counts.insert(ch.to_string(),\
    \ 1);\n        } else {\n            counts.entry(*counts.entry(ch.to_string()).or_insert(0)).unwrap()\n\
    \                += 1;\n        }\n    }\n    counts.iter()\n        .map(|(&key,\
    \ count)| { HashMap::from((key, count)) })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjpvlqj88.rs:23:26\n   |\n\
    23 |             counts.entry(*counts.entry(ch.to_string()).or_insert(0)).unwrap()\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found integer\n   |\nhelp: try using a conversion method\n\
    \   |\n23 |             counts.entry((*counts.entry(ch.to_string()).or_insert(0)).to_string()).unwrap()\n\
    \   |                          +                                          +++++++++++++\n\
    \nerror[E0599]: no method named `unwrap` found for enum `std::collections::hash_map::Entry`\
    \ in the current scope\n  --> /tmp/tmpjpvlqj88.rs:23:70\n   |\n23 |          \
    \   counts.entry(*counts.entry(ch.to_string()).or_insert(0)).unwrap()\n   |  \
    \                                                                    ^^^^^^ method\
    \ not found in `std::collections::hash_map::Entry<'_, String, {integer}>`\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjpvlqj88.rs:24:17\n\
    \   |\n23 |             counts.entry(*counts.entry(ch.to_string()).or_insert(0)).unwrap()\n\
    \   |             -----------------------------------------------------------------\
    \ cannot assign to this expression\n24 |                 += 1;\n   |         \
    \        ^^\n\nerror[E0277]: the trait bound `HashMap<_, _, _>: From<(String,\
    \ &{integer})>` is not satisfied\n  --> /tmp/tmpjpvlqj88.rs:28:32\n   |\n28 |\
    \         .map(|(&key, count)| { HashMap::from((key, count)) })\n   |        \
    \                        ^^^^^^^^^^^^^ the trait `From<(String, &{integer})>`\
    \ is not implemented for `HashMap<_, _, _>`\n   |\n   = help: the trait `From<[(K,\
    \ V); N]>` is implemented for `HashMap<K, V>`\n\nerror[E0277]: a value of type\
    \ `HashMap<String, isize>` cannot be built from an iterator over elements of type\
    \ `HashMap<_, _, _>`\n    --> /tmp/tmpjpvlqj88.rs:29:10\n     |\n29   |      \
    \   .collect()\n     |          ^^^^^^^ value of type `HashMap<String, isize>`\
    \ cannot be built from `std::iter::Iterator<Item=HashMap<_, _, _>>`\n     |\n\
    \     = help: the trait `FromIterator<HashMap<_, _, _>>` is not implemented for "
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counts = HashMap::new();\n    let mut letters = HashMap::new();\n\
    \    let mut splits = test.split_whitespace();\n    splits.sort_by_key(|&b| b.len()\
    \ as isize);\n    for i in splits.iter().rev() {\n        let char = i.to_string();\n\
    \        if !letters.contains_key(&char) {\n            letters.insert(char, 1);\n\
    \        } else {\n            let count = letters.get(&char).unwrap();\n    \
    \        letters.insert(char, count + 1);\n        }\n    }\n    for (_, count)\
    \ in letters.iter() {\n        if !counts.contains_key(&count) {\n           \
    \ counts.insert(count, 1);\n        } else {\n            let count = counts.get(&count).unwrap();\n\
    \            counts.insert(count, count + 1);\n        }\n    }\n    counts\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp0y08fnzv.rs:21:12\n   |\n21 |     splits.sort_by_key(|&b|\
    \ b.len() as isize);\n   |            ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `iter` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmp0y08fnzv.rs:22:21\n   |\n22 |     for i in splits.iter().rev()\
    \ {\n   |                     ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0y08fnzv.rs:39:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n39 |     counts\n   |     ^^^^^^ expected struct `String`,\
    \ found `&{integer}`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&{integer}, {integer}>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split_whitespace().flat_map(|c| c.chars().count())\n        .group_by(|c|\
    \ c)\n        .counting()\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `usize` is not an iterator\n    --> /tmp/tmpr2nzr77u.rs:18:38\n\
    \     |\n18   |     test.split_whitespace().flat_map(|c| c.chars().count())\n\
    \     |                             -------- ^^^^^^^^^^^^^^^^^^^^^ `usize` is\
    \ not an iterator\n     |                             |\n     |              \
    \               required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Iterator` is not implemented for `usize`\n     = note: if you want\
    \ to iterate between `start` until a value `end`, use the exclusive range syntax\
    \ `start..end` or the inclusive range syntax `start..=end`\n     = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `usize`\nnote:\
    \ required by a bound in `flat_map`\n\nerror[E0599]: no method named `group_by`\
    \ found for struct `FlatMap` in the current scope\n  --> /tmp/tmpr2nzr77u.rs:19:10\n\
    \   |\n19 |         .group_by(|c| c)\n   |          ^^^^^^^^ method not found\
    \ in `FlatMap<SplitWhitespace<'_>, usize, [closure@/tmp/tmpr2nzr77u.rs:18:38:\
    \ 18:59]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    for letter in test.chars().flat_map(|letter|\
    \ {\n        // If letter isn't in histogram, put in histogram with initial value\
    \ 1.\n        histogram.entry(letter).or_insert(1) // Or insert with initial value\
    \ 1 if key doesn't exist\n    })\n    {\n        // Iterate over the histogram\
    \ to find the letter with the highest count.\n        // If we find multiple letters\
    \ with the same count, choose the one with the greatest index.\n        let mut\
    \ index = 0;\n        let mut letter_count = histogram.entry(letter).or_insert(0);\
    \ // Or insert with initial value 1 if key doesn't exist\n        for &(letter,\
    \ count) in histogram.iter() {\n            if count > letter_count {\n      \
    \          letter_count = count;\n                index = histogram.keys().index(&letter);\n\
    \            }\n        }\n\n        // Add the new letter to the histogram.\n\
    \        histogram.insert(letter, index + 1);\n    }\n\n    histogram\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `{integer}` is not an iterator\n    --> /tmp/tmp7teg3wgw.rs:20:32\n\
    \     |\n20   |     for letter in test.chars().flat_map(|letter| {\n     |   \
    \                             ^^^^^^^^ `{integer}` is not an iterator\n     |\n\
    \     = help: the trait `Iterator` is not implemented for `{integer}`\n     =\
    \ note: if you want to iterate between `start` until a value `end`, use the exclusive\
    \ range syntax `start..end` or the inclusive range syntax `start..=end`\n    \
    \ = note: required because of the requirements on the impl of `Iterator` for `&mut\
    \ {integer}`\n     = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&mut {integer}`\nnote: required by a bound in `flat_map`\n\
    \nerror[E0277]: `{integer}` is not an iterator\n  --> /tmp/tmp7teg3wgw.rs:20:19\n\
    \   |\n20 |       for letter in test.chars().flat_map(|letter| {\n   |  ___________________^\n\
    21 | |         // If letter isn't in histogram, put in histogram with initial\
    \ value 1.\n22 | |         histogram.entry(letter).or_insert(1) // Or insert with\
    \ initial value 1 if key doesn't exist\n23 | |     })\n   | |______^ `{integer}`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `{integer}`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `Iterator` for `&mut {integer}`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&mut {integer}`\nnote: required by a bound\
    \ in `FlatMap`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7teg3wgw.rs:29:13\n\
    \   |\n29 |         for &(letter, count) in histogram.iter() {\n   |         \
    \    ^^^^^^^^^^^^^^^^    ---------------- this expression has type `Option<(&char,\
    \ &{integer})>`\n   |             |\n   |             expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(&char, &{integer})`\n           found reference\
    \ `&_`\n\nerror[E0599]: no method named `index` found for struct `std::collections::has"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histo = HashMap::<String, isize>::new();\n    let mut words =\
    \ test.split_whitespace();\n    let mut count = test.chars().count();\n    let\
    \ mut letter = String::new();\n    while let Some(_) = words.next() {\n      \
    \  let mut c = count.clone();\n        histo[letter] = c;\n        count = c.clone();\n\
    \        letter = String::new();\n    }\n    histo\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpedj89u3a.rs:24:15\n   |\n\
    24 |         histo[letter] = c;\n   |               ^^^^^^\n   |             \
    \  |\n   |               expected reference, found struct `String`\n   |     \
    \          help: consider borrowing here: `&letter`\n   |\n   = note: expected\
    \ reference `&_`\n                 found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpedj89u3a.rs:24:25\n   |\n24 |         histo[letter] = c;\n\
    \   |         -------------   ^ expected `isize`, found `usize`\n   |        \
    \ |\n   |         expected due to the type of this binding\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Build a HashMap with letters and frequencies\n    let mut letter_count:\
    \ HashMap<String, isize> = HashMap::new();\n    let mut test: Vec<String> = test.split('\
    \ ').collect();\n\n    // Build frequency HashMap\n    for i in test {\n     \
    \   let letter: String = String::from(*i);\n        if let Some(freq) = letter_count.get(letter)\
    \ {\n            letter_count.entry(letter).or_insert(freq + 1)\n        } else\
    \ {\n            letter_count.entry(letter).or_insert(1)\n        }\n    }\n\n\
    \    // Return letters with most frequency\n    letter_count.iter().max_by_key(|&letter,\
    \ _| letter).map(|&letter, count| {\n        let freq = *count;\n        HashMap::from([(String::from(letter),\
    \ freq)])\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp84hdtx_u.rs:20:49\n     |\n20\
    \   |     let mut test: Vec<String> = test.split(' ').collect();\n     |     \
    \                                            ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp84hdtx_u.rs:24:43\n    |\n24  |\
    \         let letter: String = String::from(*i);\n    |                      \
    \        ------------ ^^ doesn't have a size known at compile-time\n    |    \
    \                          |\n    |                              required by a\
    \ bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `from`\n\nerror[E0277]: the trait bound\
    \ `String: From<str>` is not satisfied\n  --> /tmp/tmp84hdtx_u.rs:24:30\n   |\n\
    24 |         let letter: String = String::from(*i);\n   |                    \
    \          ^^^^^^^^^^^^ the trait `From<str>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp84hdtx_u.rs:25:46\n   |\n25 |\
    \         if let Some(freq) = letter_count.get(letter) {\n   |               \
    \                               ^^^^^^\n   |                                 \
    \             |\n   |                                              expected reference,\
    \ found struct `String`\n   |                                              help:\
    \ consider borrowing here: `&letter`\n   |\n   = note: expected"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::<String, isize>::new();\n    for letter\
    \ in test.chars() {\n        if let Some(count) = histogram.entry(letter.to_string()).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq502pmzw.rs:20:16\n   |\n\
    20 |         if let Some(count) = histogram.entry(letter.to_string()).or_insert(0)\
    \ {\n   |                ^^^^^^^^^^^   ------------------------------------------------\
    \ this expression has type `&mut isize`\n   |                |\n   |         \
    \       expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars()\n        .filter_map(|c| {\n            if c.is_whitespace()\
    \ {\n                Some(\"\")\n            } else {\n                let mut\
    \ letter = c.to_ascii_lowercase().to_string();\n                let count = test.chars().filter(|c|\
    \ c == letter).count();\n                Some((letter, count))\n            }\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n  --> /tmp/tmpdo_afr48.rs:24:55\n\
    \   |\n24 |                 let count = test.chars().filter(|c| c == letter).count();\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&char`\n   = help: the trait `PartialEq` is implemented for\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdo_afr48.rs:25:22\n\
    \   |\n25 |                 Some((letter, count))\n   |                      ^^^^^^^^^^^^^^^\
    \ expected `&str`, found tuple\n   |\n   = note: expected reference `&str`\n \
    \                 found tuple `(String, usize)`\n\nerror[E0277]: a value of type\
    \ `HashMap<String, isize>` cannot be built from an iterator over elements of type\
    \ `&str`\n    --> /tmp/tmpdo_afr48.rs:28:10\n     |\n28   |         .collect()\n\
    \     |          ^^^^^^^ value of type `HashMap<String, isize>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait `FromIterator<&str>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      histogram.entry(c.to_string()).or_insert(0) += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpd2jsbki1.rs:20:9\n   |\n20 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpd2jsbki1.rs:20:53\n\
    \   |\n20 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|&c| c.to_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpl6pxm75_.rs:18:18\n   |\n18 |     test.chars().group_by(|&c|\
    \ c.to_lowercase()).count()\n   |                  ^^^^^^^^ method not found in\
    \ `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    test.chars().filter_map(|c|\
    \ *c != '\\0').for_each(|c| histogram.insert(String::from(*c), histogram.entry(*c).or_insert(0)));\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpczhgtcee.rs:19:33\n\
    \   |\n19 |     test.chars().filter_map(|c| *c != '\\0').for_each(|c| histogram.insert(String::from(*c),\
    \ histogram.entry(*c).or_insert(0)));\n   |                                 ^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpczhgtcee.rs:19:33\n   |\n19 |\
    \     test.chars().filter_map(|c| *c != '\\0').for_each(|c| histogram.insert(String::from(*c),\
    \ histogram.entry(*c).or_insert(0)));\n   |                                 ^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |     test.chars().filter_map(|c| Some(*c != '\\0')).for_each(|c| histogram.insert(String::from(*c),\
    \ histogram.entry(*c).or_insert(0)));\n   |                                 +++++\
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczhgtcee.rs:19:93\n\
    \   |\n19 |     test.chars().filter_map(|c| *c != '\\0').for_each(|c| histogram.insert(String::from(*c),\
    \ histogram.entry(*c).or_insert(0)));\n   |                                  \
    \                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n19 |     test.chars().filter_map(|c| *c != '\\0').for_each(|c|\
    \ histogram.insert(String::from(*c), *histogram.entry(*c).or_insert(0)));\n  \
    \ |                                                                          \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczhgtcee.rs:19:58\n\
    \   |\n19 |     test.chars().filter_map(|c| *c != '\\0').for_each(|c| histogram.insert(String::from(*c),\
    \ histogram.entry(*c).or_insert(0)));\n   |                                  \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found enum `Option`\n   |\n   = note: expected unit type `()`\n\
    \                   found enum `Option<{integer}>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed exp"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram::helper(test.splitn(2, ' '))\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `histogram`\n\
    \  --> /tmp/tmpapo9juoh.rs:18:5\n   |\n18 |     histogram::helper(test.splitn(2,\
    \ ' '))\n   |     ^^^^^^^^^ use of undeclared crate or module `histogram`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters: HashMap<String, isize> = HashMap::new();\n\n    for\
    \ (index, letter) in test.chars().enumerate().rev() {\n        letters.insert(String::from(letter),\
    \ index + 1);\n    }\n\n    letters\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpxh4fftc9.rs:20:53\n     |\n20   |     for (index, letter) in\
    \ test.chars().enumerate().rev() {\n     |                                   \
    \                  ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmpxh4fftc9.rs:20:28\n   |\n20 |     for (index,\
    \ letter) in test.chars().enumerate().rev() {\n   |                          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n             &mut I\n             Args\n             ArgsOs\n\
    \             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_, T, N>\n \
    \            ArrayWindows<'_, T, N>\n             Box<I, A>\n             Chunks<'_,\
    \ T>\n           and 109 others\n   = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Rev<Enumerate<Chars<'_>>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxh4fftc9.rs:21:46\n\
    \   |\n21 |         letters.insert(String::from(letter), index + 1);\n   |   \
    \                                           ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and pani"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::<String, isize>::new();\n    let mut chars = test.chars().collect::<Vec<&str>>();\n\
    \    let mut count = 0;\n    while count < chars.len() {\n        map.entry(chars[count].to_string()).or_insert(0)\
    \ += 1;\n        count += 1;\n    }\n    map\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpa8x7wf_s.rs:19:34\n     |\n19\
    \   |     let mut chars = test.chars().collect::<Vec<&str>>();\n     |       \
    \                           ^^^^^^^ value of type `Vec<&str>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<&str>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut isize`\n  -->\
    \ /tmp/tmpa8x7wf_s.rs:22:9\n   |\n22 |         map.entry(chars[count].to_string()).or_insert(0)\
    \ += 1;\n   |         ------------------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp:\
    \ `+=` can be used on `isize`, you can dereference `map.entry(chars[count].to_string()).or_insert(0)`\n\
    \   |\n22 |         *map.entry(chars[count].to_string()).or_insert(0) += 1;\n\
    \   |         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpa8x7wf_s.rs:22:58\n\
    \   |\n22 |         map.entry(chars[count].to_string()).or_insert(0) += 1;\n \
    \  |         ------------------------------------------------ ^^\n   |       \
    \  |\n   |         cannot assign to this expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0067, E0277, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(\" \")\n        .map(|&letter| {\n            (letter, test\n\
    \                .chars()\n                .filter(|c| *c != ' ')\n          \
    \      .count() as isize)\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpu9dkhstq.rs:19:16\n   |\n19 |         .map(|&letter| {\n\
    \   |                ^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpu9dkhstq.rs:18:5\n   |\n18 | / \
    \    test.split(\" \")\n19 | |         .map(|&letter| {\n20 | |             (letter,\
    \ test\n21 | |                 .chars()\n22 | |                 .filter(|c| *c\
    \ != ' ')\n23 | |                 .count() as isize)\n24 | |         })\n   |\
    \ |__________^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `str`\n   = note: only the last element\
    \ of a tuple may have a dynamically sized type\n\nerror[E0277]: a value of type\
    \ `HashMap<String, isize>` cannot be built from an iterator over elements of type\
    \ `(str, isize)`\n    --> /tmp/tmpu9dkhstq.rs:25:10\n     |\n25   |         .collect()\n\
    \     |          ^^^^^^^ value of type `HashMap<String, isize>` cannot be built\
    \ from `std::iter::Iterator<Item=(str, isize)>`\n     |\n     = help: the trait\
    \ `FromIterator<(str, isize)>` is not implemented for `HashMap<String, isize>`\n\
    \     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| c.to_lowercase()).collect()\n        .group_by(|&c|\
    \ c).into_iter()\n        .map(|(_, count)| {\n            let mut letter = String::from(\"\
    \");\n            for (_, value) in count {\n                letter += value.to_string();\n\
    \            }\n            letter\n        })\n        .count();\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp9xl3lqo8.rs:18:44\n\
    \   |\n18 |     test.chars().map(|c| c.to_lowercase()).collect()\n   |       \
    \                                     ^^^^^^^ cannot infer type for type parameter\
    \ `B` declared on the associated function `collect`\n   |\n   = note: type must\
    \ be known at this point\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n18 |     test.chars().map(|c| c.to_lowercase()).collect::<B>()\n\
    \   |                                                   +++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9xl3lqo8.rs:17:31\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // TODO(rst): Better algorithm for splitting words\n    // TODO(rst):\
    \ Better algorithm for sorting by count\n    // TODO(rst): Better algorithm for\
    \ sorting by alphabetical order\n    let mut words: Vec<String> = test.split_whitespace().collect();\n\
    \    let mut count: HashMap<String, isize> = HashMap::new();\n\n    // Compute\
    \ histogram\n    for (i, w) in words.into_iter().enumerate() {\n        if let\
    \ Some(prev) = count.get_mut(&w) {\n            *prev += 1;\n        } else {\n\
    \            count.insert(w, 1);\n        }\n    }\n\n    count\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpea_w7i2m.rs:21:58\n     |\n21\
    \   |     let mut words: Vec<String> = test.split_whitespace().collect();\n  \
    \   |                                                          ^^^^^^^ value of\
    \ type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n \
    \    |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // TODO(piscisaureu): Implement a more efficient algorithm\n    let mut\
    \ map = HashMap::new();\n    let mut count = 0;\n    for c in test.chars() {\n\
    \        let s = map.entry(c.to_ascii_lowercase()).or_insert(0);\n        *s +=\
    \ 1;\n        count += 1;\n    }\n    map.insert(\"\".to_ascii_lowercase(), count);\n\
    \    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu1mgulqr.rs:26:16\n   |\n\
    26 |     map.insert(\"\".to_ascii_lowercase(), count);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpu1mgulqr.rs:27:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n27 |     map\n   |   \
    \  ^^^ expected struct `String`, found `char`\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.split(' ').iter().map(|&letter|\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n    }).collect::<HashMap<String,\
    \ isize>>() {\n        histogram.entry(letter).or_insert(0) as isize,\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `.`, `::`, `;`, `<`, `?`, or `}`, found\
    \ `,`\n  --> /tmp/tmpjmdazu0i.rs:22:54\n   |\n22 |         histogram.entry(letter).or_insert(0)\
    \ as isize,\n   |                                                      ^ expected\
    \ one of 8 possible tokens\n\nerror[E0599]: no method named `iter` found for struct\
    \ `std::str::Split` in the current scope\n  --> /tmp/tmpjmdazu0i.rs:19:35\n  \
    \ |\n19 |     for letter in test.split(' ').iter().map(|&letter| {\n   |     \
    \                              ^^^^ method not found in `std::str::Split<'_, char>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmpjmdazu0i.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjmdazu0i.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let words = test.split_whitespace().collect::<Vec<_>>();\n\
    \    for word in words {\n        if let Some(count) = map.get(&word.as_str())\
    \ {\n            map.insert(word.as_str(), count + 1);\n        } else {\n   \
    \         map.insert(word.as_str(), 1);\n        }\n    }\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_str` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp9srjszf6.rs:21:44\n   |\n21 |         if let Some(count)\
    \ = map.get(&word.as_str()) {\n   |                                          \
    \ -^^^^^^-- help: remove this method call\n\nerror[E0599]: no method named `as_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmp9srjszf6.rs:22:29\n\
    \   |\n22 |             map.insert(word.as_str(), count + 1);\n   |          \
    \                  -^^^^^^-- help: remove this method call\n\nerror[E0599]: no\
    \ method named `as_str` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmp9srjszf6.rs:24:29\n   |\n24 |             map.insert(word.as_str(),\
    \ 1);\n   |                            -^^^^^^-- help: remove this method call\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freqs = HashMap::new();\n    test.chars().for_each(|c| {\n  \
    \      freqs.entry(c.to_string()).or_insert(0) += 1;\n    });\n    freqs\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmphwxa3vp0.rs:20:9\n   |\n20 |         freqs.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         ---------------------------------------^^^^^\n   |     \
    \    |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `freqs.entry(c.to_string()).or_insert(0)`\n\
    \   |\n20 |         *freqs.entry(c.to_string()).or_insert(0) += 1;\n   |     \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmphwxa3vp0.rs:20:49\n\
    \   |\n20 |         freqs.entry(c.to_string()).or_insert(0) += 1;\n   |      \
    \   --------------------------------------- ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for (i, c) in test.chars().enumerate().skip(1).take(test.chars().len()\
    \ - 1).enumerate() {\n        let letter = test.chars().nth(i).unwrap();\n   \
    \     if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp2nqkzn99.rs:19:70\n   |\n19 |     for (i, c) in test.chars().enumerate().skip(1).take(test.chars().len()\
    \ - 1).enumerate() {\n   |                                                   \
    \                   ^^^ method not found in `Chars<'_>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&mut {integer}`\n  -->\
    \ /tmp/tmp2nqkzn99.rs:22:13\n   |\n22 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n22 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2nqkzn99.rs:22:51\n\
    \   |\n22 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2nqkzn99.rs:24:30\n   |\n24 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2nqkzn99.rs:27:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368, E0599.\nFor more information about an error, try `rustc"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Split the string into individual words\n    let mut words = test\n\
    \        .split(\" \")\n        .map(|x| x.to_string().to_lowercase().collect::<Vec<_>>())\n\
    \        .collect::<HashMap<String, isize>>();\n\n    // Iterate through the letters\
    \ of the string\n    for letter in test.chars() {\n        // Check if the current\
    \ letter is already in the hashmap\n        if let Some(count) = words.get(&letter)\
    \ {\n            // Update its count by 1\n            words.entry(letter).and_modify(|x|\
    \ x.value += 1);\n        } else {\n            // Add the new letter if it isn't\
    \ in the hashmap\n            words.entry(letter).and_modify(|x| x.value += 1);\n\
    \        }\n    }\n\n    // Return the hashmap\n    words\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpuj4r78vw.rs:21:47\n\
    \    |\n21  |           .map(|x| x.to_string().to_lowercase().collect::<Vec<_>>())\n\
    \    |                                                 ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0277]: the trait\
    \ bound `String: Borrow<char>` is not satisfied\n   --> /tmp/tmpuj4r78vw.rs:27:36\n\
    \    |\n27  |         if let Some(count) = words.get(&letter) {\n    |       \
    \                             ^^^ the trait `Borrow<char>` is not implemented\
    \ for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashMap::<K, V, S>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuj4r78vw.rs:29:25\n   |\n29 |             words.entry(letter).and_modify(|x|\
    \ x.value += 1);\n   |                         ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                         |\n   |               \
    \          expected struct `String`, found `char`\n\nerror[E0609]: no field `value`\
    \ on type `&mut isize`\n  --> /tmp/tmpuj4r78vw.rs:29:50\n   |\n29 |          \
    \   words.entry(letter).and_modify(|x| x.value += 1);\n   |                  \
    \                                ^^^^^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpuj4r78vw.rs:32:25\n   |\n32 |             words.entry(letter).and_modify(|x|\
    \ x.value += 1);\n   |                         ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                         |\n   |               \
    \          expected struct `String`, found `char`\n\nerror[E0609]: no field `value`\
    \ on type `&mut isize`\n  --> /tmp/tmpuj4r78vw.rs:32:50\n   |\n32 |          \
    \   words.entry(letter).and_modify(|x| x.value += 1);\n   |                  \
    \                                ^^^^^\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    use std::collections::HashMap;\n\n    let mut histogram = HashMap::new();\n\
    \    for (letter, count) in test.split_whitespace().chars().fold(0, |acc, c| {\n\
    \        histogram.insert(c.to_string(), acc + 1);\n        acc\n    }) {\n  \
    \      histogram.insert(letter.to_string(), count);\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmp9spi49my.rs:18:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n18 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp9spi49my.rs:21:52\n   |\n21 |     for (letter,\
    \ count) in test.split_whitespace().chars().fold(0, |acc, c| {\n   |         \
    \                                           ^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().\n        filter(|c| c.is_whitespace()).\n        group_by(|c|\
    \ c).\n        flat_map(|(k, vs)| vs.into_iter().map(|v| (k, v)).collect()).\n\
    \        fold(HashMap::new(), |mut acc, (k, vs)| {\n            acc.entry(k).or_insert(0)\
    \ += vs.len();\n            acc\n        });\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmpo8mq0fgb.rs:20:9\n   |\n20 |         group_by(|c|\
    \ c).\n   |         ^^^^^^^^ method not found in `Filter<Chars<'_>, [closure@/tmp/tmpo8mq0fgb.rs:19:16:\
    \ 19:37]>`\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpo8mq0fgb.rs:23:39\n\
    \   |\n23 |             acc.entry(k).or_insert(0) += vs.len();\n   |         \
    \    ------------------------- ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo8mq0fgb.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars()\n        .flat_map(|c| c.chars())\n        .fold(HashMap::new(),\
    \ |mut acc, c| {\n            let count = acc.entry(c).or_insert(0);\n       \
    \     *count += 1;\n            acc\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpamjiuo5e.rs:19:25\n   |\n19 |         .flat_map(|c| c.chars())\n\
    \   |                         ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n\n    for letter in test.split() {\n \
    \       if let Some((letter, count)) = map.entry(letter) {\n            *count\
    \ += 1;\n        } else {\n            map.insert(letter, 1);\n        }\n   \
    \ }\n\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp7uhaw6d2.rs:20:24\n     |\n20   |     for letter in test.split()\
    \ {\n     |                        ^^^^^- supplied 0 arguments\n     |       \
    \                 |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7uhaw6d2.rs:21:16\n   |\n21 |         if let Some((letter, count)) =\
    \ map.entry(letter) {\n   |                ^^^^^^^^^^^^^^^^^^^^^   -----------------\
    \ this expression has type `std::collections::hash_map::Entry<'_, &str, _>`\n\
    \   |                |\n   |                expected enum `std::collections::hash_map::Entry`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::collections::hash_map::Entry<'_,\
    \ &str, _>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7uhaw6d2.rs:28:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n28 |     map\n\
    \   |     ^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut res = HashMap::new();\n    let mut string = test.split_whitespace();\n\
    \    while let Some(letter) = string.next() {\n        let occurrence = res.entry(letter).or_insert(0);\n\
    \        *occurrence += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphydmdzv3.rs:24:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     res\n   |     ^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n        \
    \      found struct `HashMap<&str, {integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace().collect::<Vec<_>>();\n\
    \n    for letter in letters.iter() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.get_mut(&letter).unwrap() += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut _`\n  --> /tmp/tmp2m8v9wyu.rs:23:13\n   |\n23 |             histogram.get_mut(&letter).unwrap()\
    \ += 1;\n   |             -----------------------------------^^^^^\n   |     \
    \        |\n   |             cannot use `+=` on type `&mut _`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp2m8v9wyu.rs:23:49\n   |\n\
    23 |             histogram.get_mut(&letter).unwrap() += 1;\n   |             -----------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2m8v9wyu.rs:29:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n29 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&&str, {integer}>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // split the input string on space and convert to lowercase.\n    let\
    \ mut letters = test.split_whitespace().map(|x| x.to_lowercase());\n    let mut\
    \ counter = HashMap::new();\n    // iterate over the letters and update a counter\
    \ if the letter is already in\n    // the map.\n    for letter in letters.into_iter()\
    \ {\n        if let Some(_) = counter.entry(letter).or_insert(0) {\n         \
    \   *counter += 1;\n        }\n    }\n    // sort the map to make sure that the\
    \ most frequent letters come first and\n    // the letters listed alphabetically\
    \ come after it.\n    let mut sorted_counter = counter.iter().sort_by_key(|&(_,\
    \ count)| count).collect::<Vec<_>>();\n    // return the map with the most frequent\
    \ letters first.\n    sorted_counter.into_iter().map(|(_, count)| {\n        HashMap::from(\n\
    \            letters.enumerate().map(|(_, letter)| (letter, count)).collect::<Vec<_>>(),\n\
    \        )\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcwf3u_5y.rs:24:16\n   |\n\
    24 |         if let Some(_) = counter.entry(letter).or_insert(0) {\n   |     \
    \           ^^^^^^^   ---------------------------------- this expression has type\
    \ `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<_>`\n\nerror[E0614]: type `HashMap<String, {integer}>`\
    \ cannot be dereferenced\n  --> /tmp/tmpcwf3u_5y.rs:25:13\n   |\n25 |        \
    \     *counter += 1;\n   |             ^^^^^^^^\n\nerror[E0599]: no method named\
    \ `sort_by_key` found for struct `std::collections::hash_map::Iter` in the current\
    \ scope\n  --> /tmp/tmpcwf3u_5y.rs:30:45\n   |\n30 |     let mut sorted_counter\
    \ = counter.iter().sort_by_key(|&(_, count)| count).collect::<Vec<_>>();\n   |\
    \                                             ^^^^^^^^^^^ method not found in\
    \ `std::collections::hash_map::Iter<'_, String, {integer}>`\n\nerror[E0277]: the\
    \ trait bound `HashMap<_, _, _>: From<Vec<(String, _)>>` is not satisfied\n  -->\
    \ /tmp/tmpcwf3u_5y.rs:33:9\n   |\n33 |         HashMap::from(\n   |         ^^^^^^^^^^^^^\
    \ the trait `From<Vec<(String, _)>>` is not implemented for `HashMap<_, _, _>`\n\
    \   |\n   = help: the trait `From<[(K, V); N]>` is implemented for `HashMap<K,\
    \ V>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test\n        .chars()\n        .cloned()\n        .collect()\n     \
    \   .into_iter()\n        .map(|c| (c.to_string(), 1))\n        .fold(HashMap::new(),\
    \ |mut map, (a, b)| {\n            map.entry(a).and_modify(|x| *x = *x + b).or_insert(b)\n\
    \        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpn85822v9.rs:20:10\n     |\n20   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpn85822v9.rs:21:10\n\
    \   |\n21 |           .collect()\n   |            ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        histogram.entry(word.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpi1vukrud.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpi1vukrud.rs:21:9\n\
    \   |\n21 |         histogram.entry(word.to_string()).or_insert(0) += 1;\n   |\
    \         ----------------------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(word.to_string()).or_insert(0)`\n\
    \   |\n21 |         *histogram.entry(word.to_string()).or_insert(0) += 1;\n  \
    \ |         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpi1vukrud.rs:21:56\n\
    \   |\n21 |         histogram.entry(word.to_string()).or_insert(0) += 1;\n   |\
    \         ---------------------------------------------- ^^\n   |         |\n\
    \   |         cannot assign to this expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut current_letter = \"\"\
    ;\n    for letter in test.split_whitespace() {\n        if !histogram.contains_key(&letter)\
    \ {\n            histogram.insert(letter, 0);\n        }\n        histogram.entry(letter).and_modify(|count|\
    \ count += 1);\n        if letter != current_letter {\n            current_letter\
    \ = letter;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpctjykivp.rs:24:52\n   |\n24 |         histogram.entry(letter).and_modify(|count|\
    \ count += 1);\n   |                                                    -----^^^^^\n\
    \   |                                                    |\n   |             \
    \                                       cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `count`\n  \
    \ |\n24 |         histogram.entry(letter).and_modify(|count| *count += 1);\n \
    \  |                                                    +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpctjykivp.rs:29:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n29 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counts = HashMap::new();\n    let mut letters: Vec<String> =\
    \ test.chars().map(|c| String::from(*c))\n        .collect();\n    while letters.len()\
    \ > 0 {\n        let mut key_val: Vec<isize> = Vec::with_capacity(letters.len());\n\
    \        let mut key: String;\n        let mut idx: usize = 0;\n        for &letter\
    \ in &letters {\n            if let Some(count) = self.map.get(&letter) {\n  \
    \              key_val.push(count as isize);\n            } else {\n         \
    \       key_val.push(0);\n            }\n            if key_val[idx] > key_val.last().unwrap()\
    \ {\n                key = letter;\n            }\n            idx += 1;\n   \
    \     }\n        counts[key] = key_val.len();\n        letters = &key_val.into_iter().skip(idx).take(letters.len()\
    \ - idx).collect();\n    }\n    counts\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0424]: expected value, found module `self`\n  --> /tmp/tmpksixgt88.rs:26:34\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \ this function can't have a `self` parameter\n...\n26 |             if let Some(count)\
    \ = self.map.get(&letter) {\n   |                                  ^^^^ `self`\
    \ value is a keyword only available in methods with a `self` parameter\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpksixgt88.rs:19:70\n   |\n\
    19 |     let mut letters: Vec<String> = test.chars().map(|c| String::from(*c))\n\
    \   |                                                                      ^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpksixgt88.rs:31:31\n   |\n31 |\
    \             if key_val[idx] > key_val.last().unwrap() {\n   |              \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n31 |             if key_val[idx]\
    \ > *key_val.last().unwrap() {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpksixgt88.rs:36:16\n   |\n36 |         counts[key]\
    \ = key_val.len();\n   |                ^^^\n   |                |\n   |     \
    \           expected reference, found struct `String`\n   |                help:\
    \ consider borrowing here: `&key`\n   |\n   = note: expected reference `&_`\n\
    \                 found struct `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpksixgt88.rs:37:19\n   |\n19 |     let mut letters: Vec<String> = test.chars().map(|c|\
    \ String::from(*c))\n   |                      ----------- expected due to this\
    \ type\n...\n37 |         letters = &key_val.into_iter().skip(idx).take(letters.len()\
    \ - idx).collect();\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found reference\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n37\
    \ -         letters = &key_val.into_iter().skip(idx).take(letters.len() - idx).collect();\n\
    37 +         letters = key_val.into_ite"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    use std::collections::HashMap;\n\n    test.split(' ').collect::<Vec<_>>()\n\
    \        .into_iter()\n        .map(|&c| c.to_string())\n        .fold(HashMap::new(),\
    \ |mut acc, &x| {\n            acc.entry(x).or_insert(0) += 1;\n            acc\n\
    \        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmp4youmqfw.rs:18:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n18 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmp4youmqfw.rs:22:16\n   |\n22 |         .map(|&c|\
    \ c.to_string())\n   |                ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4youmqfw.rs:23:41\n\
    \   |\n23 |         .fold(HashMap::new(), |mut acc, &x| {\n   |              \
    \                           ^--\n   |                                        \
    \ ||\n   |                                         |expected due to this\n   |\
    \                                         expected struct `String`, found reference\n\
    \   |                                         help: did you mean `x`: `&String`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ isize`\n  --> /tmp/tmp4youmqfw.rs:24:13\n   |\n24 |             acc.entry(x).or_insert(0)\
    \ += 1;\n   |             -------------------------^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be\
    \ used on `isize`, you can dereference `acc.entry(x).or_insert(0)`\n   |\n24 |\
    \             *acc.entry(x).or_insert(0) += 1;\n   |             +\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp4youmqfw.rs:24:39\n   |\n\
    24 |             acc.entry(x).or_insert(0) += 1;\n   |             -------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 4 previous errors; 1 warning emitted\n\nS"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freqs: HashMap<String, isize> = HashMap::new();\n    let mut\
    \ words = test\n        .lines()\n        .filter_map(|line| {\n            line.chars()\n\
    \                .filter(|c| c.is_whitespace() || c.is_ascii_letter())\n     \
    \           .map(|c| c.to_ascii_lowercase())\n                .collect::<Vec<_>>()\n\
    \        })\n        .collect::<Vec<_>>();\n    for c in words {\n        if let\
    \ Some(i) = freqs.get_mut(&c) {\n            *i += 1;\n        } else {\n    \
    \        freqs.insert(c, 1);\n        }\n    }\n    freqs\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpo2s73itz.rs:23:52\n   |\n23 |          \
    \       .filter(|c| c.is_whitespace() || c.is_ascii_letter())\n   |          \
    \                                          ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo2s73itz.rs:22:13\n   |\n22 | /             line.chars()\n23 |\
    \ |                 .filter(|c| c.is_whitespace() || c.is_ascii_letter())\n24\
    \ | |                 .map(|c| c.to_ascii_lowercase())\n25 | |               \
    \  .collect::<Vec<_>>()\n   | |____________________________________^ expected\
    \ enum `Option`, found struct `Vec`\n   |\n   = note: expected enum `Option<_>`\n\
    \            found struct `Vec<char>`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 ~             Some(line.chars()\n23 |                 .filter(|c| c.is_whitespace()\
    \ || c.is_ascii_letter())\n24 |                 .map(|c| c.to_ascii_lowercase())\n\
    25 ~                 .collect::<Vec<_>>())\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(\" \").map(|s| {\n        s.chars().group_by(|c| c.to_ascii_lowercase()).max_by_key(|(_,\
    \ count)| count)\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpzj8dyi5h.rs:19:19\n   |\n19 |         s.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).max_by_key(|(_, count)| count)\n   |               \
    \    ^^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test, |v| v.to_string()).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmppd1ywr1d.rs:18:22\n\
    \   |\n18 |     histogram(test, |v| v.to_string()).unwrap()\n   |            \
    \          ^ consider giving this closure parameter a type\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n  --> /tmp/tmppd1ywr1d.rs:18:5\n   |\n18 |  \
    \   histogram(test, |v| v.to_string()).unwrap()\n   |     ^^^^^^^^^ ----  -----------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmppd1ywr1d.rs:17:4\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |    ^^^^^^^^^ ------------\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `HashMap` in the current scope\n \
    \ --> /tmp/tmppd1ywr1d.rs:18:40\n   |\n18 |     histogram(test, |v| v.to_string()).unwrap()\n\
    \   |                                        ^^^^^^ method not found in `HashMap<String,\
    \ isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0282, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    test.split_whitespace().for_each(|&x|\
    \ histogram.entry(x).or_default(0)).collect();\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpxonj8uwf.rs:19:40\n   |\n19 |     test.split_whitespace().for_each(|&x|\
    \ histogram.entry(x).or_default(0)).collect();\n   |                         \
    \               ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmpxonj8uwf.rs:19:59\n    |\n19  |  \
    \   test.split_whitespace().for_each(|&x| histogram.entry(x).or_default(0)).collect();\n\
    \    |                                                     ----- ^ doesn't have\
    \ a size known at compile-time\n    |                                        \
    \             |\n    |                                                     required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `str`\nnote: required by a bound in `HashMap::<K, V, S>::entry`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpxonj8uwf.rs:18:25\n    |\n18  |     let mut histogram =\
    \ HashMap::new();\n    |                         ^^^^^^^^^^^^ doesn't have a size\
    \ known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `HashMap::<K, V>::new`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpxonj8uwf.rs:18:25\n    |\n18  |     let mut histogram = HashMap::new();\n\
    \    |                         ^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `HashMap`\n\nerror[E0599]: the method `or_default` exists for\
    \ enum `std::collections::hash_map::Entry<'_, str, _>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpxonj8uwf.rs:19:62\n   |\n19 |     test.split_whitespace().for_each(|&"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letter_counts: HashMap<String, isize> = HashMap::new();\n\n \
    \   let mut current_letter = String::from(\"\");\n    for (i, letter) in test.chars().enumerate()\
    \ {\n        if letter == ' ' {\n            current_letter = String::from(\"\"\
    );\n        } else {\n            if let Some(count) = letter_counts.get(&current_letter)\
    \ {\n                letter_counts.insert(String::from(&letter), count + 1);\n\
    \            } else {\n                letter_counts.insert(String::from(&letter),\
    \ 1);\n            }\n            current_letter = String::from(&letter);\n  \
    \      }\n    }\n\n    letter_counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&char>` is not satisfied\n\
    \  --> /tmp/tmpxuwnm8hz.rs:26:38\n   |\n26 |                 letter_counts.insert(String::from(&letter),\
    \ count + 1);\n   |                                      ^^^^^^^^^^^^ the trait\
    \ `From<&char>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0277]: the trait bound\
    \ `String: From<&char>` is not satisfied\n  --> /tmp/tmpxuwnm8hz.rs:28:38\n  \
    \ |\n28 |                 letter_counts.insert(String::from(&letter), 1);\n  \
    \ |                                      ^^^^^^^^^^^^ the trait `From<&char>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror[E0277]: the trait bound `String:\
    \ From<&char>` is not satisfied\n  --> /tmp/tmpxuwnm8hz.rs:30:30\n   |\n30 | \
    \            current_letter = String::from(&letter);\n   |                   \
    \           ^^^^^^^^^^^^ the trait `From<&char>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.to_string().split_whitespace().map(|l| l.to_lowercase()).group_by(|l|\
    \ l).count().collect()\n}\n\nfn main() {\n    let candidate = histogram;\n   \
    \ assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmps9g444cu.rs:18:67\n   |\n18 |     test.to_string().split_whitespace().map(|l|\
    \ l.to_lowercase()).group_by(|l| l).count().collect()\n   |                  \
    \                                                 ^^^^^^^^ method not found in\
    \ `Map<SplitWhitespace<'_>, [closure@/tmp/tmps9g444cu.rs:18:45: 18:65]>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    use std::collections::HashMap;\n\n    let mut map: HashMap<String, isize>\
    \ = HashMap::new();\n\n    for letter in test.split(\" \") {\n        let count\
    \ = map.entry(letter).or_insert(0);\n        *count += 1;\n    }\n\n    map\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmp9u5wzjor.rs:18:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n18 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9u5wzjor.rs:23:31\n\
    \   |\n23 |         let count = map.entry(letter).or_insert(0);\n   |        \
    \                       ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |\n   |                               expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test.as_slice(), HashMap::new())\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_slice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfaky49aj.rs:18:20\n   |\n18 |     histogram(test.as_slice(),\
    \ HashMap::new())\n   |                    ^^^^^^^^ method not found in `String`\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpfaky49aj.rs:18:5\n   |\n18 |     histogram(test.as_slice(), HashMap::new())\n\
    \   |     ^^^^^^^^^ ---------------  -------------- supplied 2 arguments\n   |\
    \     |\n   |     expected 1 argument\n   |\nnote: function defined here\n  -->\
    \ /tmp/tmpfaky49aj.rs:17:4\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ^^^^^^^^^ ------------\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut current_count = 0;\n\n\
    \    for c in test.chars() {\n        match letters.get(&c.to_string()) {\n  \
    \          Some(&mut i) => {\n                let count = *i;\n              \
    \  *i += 1;\n                current_count = *i;\n            }\n            None\
    \ => {\n                letters.insert(c.to_string(), 1);\n            }\n   \
    \     }\n    }\n\n    let mut histogram = HashMap::new();\n    histogram.insert(String::from(\"\
    a\"), 1);\n    histogram.insert(String::from(\"b\"), 1);\n    histogram.insert(String::from(\"\
    c\"), 1);\n\n    for k in &letters {\n        if k.1 > current_count {\n     \
    \       continue;\n        }\n\n        histogram.insert(k.0, k.1);\n    }\n\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpff835s97.rs:23:18\n   |\n\
    22 |         match letters.get(&c.to_string()) {\n   |               ---------------------------\
    \ this expression has type `Option<&_>`\n23 |             Some(&mut i) => {\n\
    \   |                  ^^^^^^\n   |                  |\n   |                 \
    \ types differ in mutability\n   |                  help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:      expected reference `&_`\n  \
    \         found mutable reference `&mut _`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpff835s97.rs:40:18\n   |\n40 |         if k.1 > current_count {\n\
    \   |                  ^^^^^^^^^^^^^\n   |                  |\n   |          \
    \        expected reference, found integer\n   |                  help: consider\
    \ borrowing here: `&current_count`\n   |\n   = note: expected reference `&_`\n\
    \                   found type `{integer}`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpff835s97.rs:44:26\n   |\n44 |         histogram.insert(k.0, k.1);\n\
    \   |                          ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                          |\n   |                          expected struct\
    \ `String`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpff835s97.rs:44:31\n\
    \   |\n44 |         histogram.insert(k.0, k.1);\n   |                        \
    \       ^^^ expected integer, found `&{integer}`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n44 |         histogram.insert(k.0, *k.1);\n   |          \
    \                     +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    let mut words = test.split_whitespace();\n\
    \n    for word in words {\n        histogram.entry(word).or_insert(0) += 1;\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpl7p9yvpk.rs:23:9\n   |\n23 |         histogram.entry(word).or_insert(0)\
    \ += 1;\n   |         ----------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(word).or_insert(0)`\n\
    \   |\n23 |         *histogram.entry(word).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpl7p9yvpk.rs:23:44\n\
    \   |\n23 |         histogram.entry(word).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl7p9yvpk.rs:26:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n26 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counter = HashMap::<String, isize>::new();\n    let mut splits\
    \ = test.split_whitespace();\n    for s in splits {\n        counter.entry(s.to_string()).or_insert(0)\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut isize`\n  --> /tmp/tmp2wf8qzd0.rs:21:9\n   |\n21 |         counter.entry(s.to_string()).or_insert(0)\
    \ += 1;\n   |         -----------------------------------------^^^^^\n   |   \
    \      |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=`\
    \ can be used on `isize`, you can dereference `counter.entry(s.to_string()).or_insert(0)`\n\
    \   |\n21 |         *counter.entry(s.to_string()).or_insert(0) += 1;\n   |   \
    \      +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2wf8qzd0.rs:21:51\n\
    \   |\n21 |         counter.entry(s.to_string()).or_insert(0) += 1;\n   |    \
    \     ----------------------------------------- ^^\n   |         |\n   |     \
    \    cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n\n    for letter in test.split(\" \")\
    \ {\n        let letter = String::from(letter);\n        if map.contains_key(&letter)\
    \ {\n            map.entry(*map.get_mut(&letter))\n                .or_insert(map.get(&letter).unwrap().checked_add(1).unwrap());\n\
    \        } else {\n            map.insert(letter, 1);\n        }\n    }\n\n  \
    \  map.into_iter().collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&mut _>` cannot be dereferenced\n  --> /tmp/tmpyq12ssmm.rs:23:23\n\
    \   |\n23 |             map.entry(*map.get_mut(&letter))\n   |               \
    \        ^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map: HashMap<String, isize> = HashMap::new();\n    let mut current_char_count:\
    \ usize = 0;\n\n    for c in test.chars() {\n        map.entry(c.to_string()).or_insert(0)\
    \ += 1;\n        if *map.entry(c.to_string()).or_insert(0) > current_char_count\
    \ {\n            map.entry(c.to_string()).or_insert(0) = current_char_count;\n\
    \        }\n        current_char_count += 1;\n    }\n\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut isize`\n  --> /tmp/tmpp1ukjwbx.rs:22:9\n   |\n22 |         map.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------^^^^^\n   |       \
    \  |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can\
    \ be used on `isize`, you can dereference `map.entry(c.to_string()).or_insert(0)`\n\
    \   |\n22 |         *map.entry(c.to_string()).or_insert(0) += 1;\n   |       \
    \  +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpp1ukjwbx.rs:22:47\n\
    \   |\n22 |         map.entry(c.to_string()).or_insert(0) += 1;\n   |        \
    \ ------------------------------------- ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1ukjwbx.rs:23:53\n\
    \   |\n23 |         if *map.entry(c.to_string()).or_insert(0) > current_char_count\
    \ {\n   |                                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n23 |         if\
    \ *map.entry(c.to_string()).or_insert(0) > current_char_count.try_into().unwrap()\
    \ {\n   |                                                                    \
    \   ++++++++++++++++++++\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpp1ukjwbx.rs:24:51\n   |\n24 |             map.entry(c.to_string()).or_insert(0)\
    \ = current_char_count;\n   |             -------------------------------------\
    \ ^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0070, E0308, E0368.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut result: HashMap<String, isize> = HashMap::new();\n    let mut\
    \ letters = test.chars().map(|c| c.to_string());\n    while let Some(letter) =\
    \ letters.next() {\n        let count = result.entry(letter).or_insert(0);\n \
    \       *count += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp0lu0sy4b.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut char_counts = HashMap::new();\n    for (char, count) in test.chars().filter_map(|c|\
    \ c.is_alphabetic()).group_by(|c| c).cloned().value_cloned().map(|c| {\n     \
    \   char_counts.insert(char, c.clone());\n        Ok(c)\n    }).collect::<HashMap<String,\
    \ isize>>() {\n        println!(\"{}\", char_counts);\n    }\n    char_counts\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `char`\n  --> /tmp/tmpuld58v5w.rs:20:28\n\
    \   |\n20 |         char_counts.insert(char, c.clone());\n   |               \
    \             ^^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuld58v5w.rs:19:54\n\
    \   |\n19 |     for (char, count) in test.chars().filter_map(|c| c.is_alphabetic()).group_by(|c|\
    \ c).cloned().value_cloned().map(|c| {\n   |                                 \
    \                     ^^^^^^^^^^^^^^^^^ expected enum `Option`, found `bool`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `bool`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |     for (char, count)\
    \ in test.chars().filter_map(|c| Some(c.is_alphabetic())).group_by(|c| c).cloned().value_cloned().map(|c|\
    \ {\n   |                                                      +++++         \
    \        +\n\nerror[E0599]: no method named `group_by` found for struct `FilterMap`\
    \ in the current scope\n  --> /tmp/tmpuld58v5w.rs:19:73\n   |\n19 |     for (char,\
    \ count) in test.chars().filter_map(|c| c.is_alphabetic()).group_by(|c| c).cloned().value_cloned().map(|c|\
    \ {\n   |                                                                    \
    \     ^^^^^^^^ method not found in `FilterMap<Chars<'_>, [closure@/tmp/tmpuld58v5w.rs:19:50:\
    \ 19:71]>`\n\nerror[E0277]: `HashMap<_, _>` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmpuld58v5w.rs:23:24\n   |\n23 |         println!(\"{}\", char_counts);\n\
    \   |                        ^^^^^^^^^^^ `HashMap<_, _>` cannot be formatted with\
    \ the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not\
    \ implemented for `HashMap<_, _>`\n   = note: in format strings you may be able\
    \ to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates\
    \ in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut occurrences = HashMap::new();\n    let mut letter_counts = HashMap::new();\n\
    \    for letter in test.split() {\n        occurrences.entry(letter).or_insert(0)\
    \ as usize += 1;\n        letter_counts.entry(letter).or_insert(0) as usize +=\
    \ 1;\n    }\n    letter_counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpj90apd0b.rs:20:24\n     |\n20   |     for letter in test.split()\
    \ {\n     |                        ^^^^^- supplied 0 arguments\n     |       \
    \                 |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0067]: invalid left-hand side\
    \ of assignment\n  --> /tmp/tmpj90apd0b.rs:21:57\n   |\n21 |         occurrences.entry(letter).or_insert(0)\
    \ as usize += 1;\n   |         -----------------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpj90apd0b.rs:22:59\n   |\n\
    22 |         letter_counts.entry(letter).or_insert(0) as usize += 1;\n   |   \
    \      ------------------------------------------------- ^^\n   |         |\n\
    \   |         cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj90apd0b.rs:24:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n24 |     letter_counts\n\
    \   |     ^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&str,\
    \ {integer}>`\n\nerror[E0606]: casting `&mut {integer}` as `usize` is invalid\n\
    \  --> /tmp/tmpj90apd0b.rs:21:9\n   |\n21 |         occurrences.entry(letter).or_insert(0)\
    \ as usize += 1;\n   |         --------------------------------------^^^^^^^^^\n\
    \   |         |\n   |         cannot cast `&mut {integer}` as `usize`\n   |  \
    \       help: dereference the expression: `*occurrences.entry(letter).or_insert(0)`\n\
    \nerror[E0606]: casting `&mut {integer}` as `usize` is invalid\n  --> /tmp/tmpj90apd0b.rs:22:9\n\
    \   |\n22 |         letter_counts.entry(letter).or_insert(0) as usize += 1;\n\
    \   |         ----------------------------------------^^^^^^^^^\n   |        \
    \ |\n   |         cannot cast `&mut {integer}` as `usize`\n   |         hel"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Split test by spaces and sort alphabetically.\n    let mut letters\
    \ = test.split_whitespace().collect::<Vec<_>>().sort_unstable();\n\n    // Store\
    \ each letter in a hashmap.\n    let mut histogram = HashMap::new();\n    for\
    \ i in 0..letters.len() {\n        // If the current letter isn't in the hash,\
    \ add it with a count of 1.\n        if histogram.contains_key(&letters[i].as_str())\
    \ {\n            // Increment the count of what the current letter has by 1.\n\
    \            histogram.entry(letters[i].as_str()).or_insert(0) += 1;\n       \
    \ } else {\n            // If the current letter isn't in the hash, add it with\
    \ a count of 1.\n            histogram.insert(letters[i].as_str(), 1);\n     \
    \   }\n    }\n\n    // Return the histogram as a HashMap.\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpwunzfiwb.rs:23:25\n   |\n23 |     for i in 0..letters.len()\
    \ {\n   |                         ^^^ method not found in `()`\n\nerror[E0608]:\
    \ cannot index into a value of type `()`\n  --> /tmp/tmpwunzfiwb.rs:25:36\n  \
    \ |\n25 |         if histogram.contains_key(&letters[i].as_str()) {\n   |    \
    \                                ^^^^^^^^^^\n   |\n   = help: to access tuple\
    \ elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot\
    \ index into a value of type `()`\n  --> /tmp/tmpwunzfiwb.rs:27:29\n   |\n27 |\
    \             histogram.entry(letters[i].as_str()).or_insert(0) += 1;\n   |  \
    \                           ^^^^^^^^^^\n   |\n   = help: to access tuple elements,\
    \ use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpwunzfiwb.rs:27:13\n\
    \   |\n27 |             histogram.entry(letters[i].as_str()).or_insert(0) += 1;\n\
    \   |             -------------------------------------------------^^^^^\n   |\
    \             |\n   |             cannot use `+=` on type `&mut {integer}`\n \
    \  |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letters[i].as_str()).or_insert(0)`\n\
    \   |\n27 |             *histogram.entry(letters[i].as_str()).or_insert(0) +=\
    \ 1;\n   |             +\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpwunzfiwb.rs:27:63\n   |\n27 |             histogram.entry(letters[i].as_str()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------------- ^^\n\
    \   |             |\n   |             cannot assign to this expression\n\nerror[E0608]:\
    \ cannot index into a value of type `()`\n  --> /tmp/tmpwunzfiwb.rs:30:30\n  \
    \ |\n30 |             histogram.insert(letters[i].as_str(), 1);\n   |        \
    \                      ^^^^^^^^^^\n   |\n   = help: to access tuple elements,\
    \ use tuple indexing syntax (e.g., `tuple.0`)\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368, E0599,"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ')\n        .map(|c| c.to_string())\n        .group_by(|c|\
    \ c)\n        .map(|c| c.into_iter().max().unwrap())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp_s9feggp.rs:20:10\n   |\n20 |         .group_by(|c|\
    \ c)\n   |          ^^^^^^^^ method not found in `Map<std::str::Split<'_, char>,\
    \ [closure@/tmp/tmp_s9feggp.rs:19:14: 19:31]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut result = HashMap::new();\n    for letter in test.split_whitespace().iter()\
    \ {\n        result.entry(letter).or_default()\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmptnay8_ve.rs:19:43\n   |\n19 |     for letter\
    \ in test.split_whitespace().iter() {\n   |                                  \
    \         ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptnay8_ve.rs:20:9\n   |\n20 |         result.entry(letter).or_default()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `&mut _`\n\
    \   |\n   = note:      expected unit type `()`\n           found mutable reference\
    \ `&mut _`\nhelp: consider using a semicolon here\n   |\n20 |         result.entry(letter).or_default();\n\
    \   |                                          +\nhelp: consider dereferencing\
    \ the borrow\n   |\n20 |         *result.entry(letter).or_default()\n   |    \
    \     +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut words = test\n        .split_whitespace()\n        .map(|c| c.to_lowercase())\n\
    \        .collect::<Vec<_>>();\n    let mut counts = HashMap::new();\n    for\
    \ word in words {\n        if counts.contains_key(&word) {\n            counts.entry(word).and_modify(|c|\
    \ *c += 1).or_insert(0);\n        } else {\n            counts.insert(word, 1);\n\
    \        }\n    }\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"b\": 2, \"a\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp8ngvhbdr.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.to_string().chars().group_by(|c| c.to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpn5oe40vv.rs:18:30\n   |\n18 |     test.to_string().chars().group_by(|c|\
    \ c.to_string()).collect()\n   |                              ^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut letters_count = HashMap::new();\n\
    \    for (letter, i) in test.chars().filter_map(|c| {\n        if let Some(ref\
    \ mut c) = c.as_ref() {\n            match letters_count.entry(c) {\n        \
    \        Occupied(mut occu) => {\n                    occu.into_mut().unwrap().1\
    \ += 1;\n                }\n                Vacant(_) => letters.entry(c).and_modify(|mut\
    \ l| l.insert(letter)),\n            }\n        } else {\n            None\n \
    \       }\n    }) {\n        letters_count.entry(letter.clone()).and_modify(|&mut\
    \ i| i += 1).or_insert(i);\n    }\n    letters.clone()\n}\n\nfn main() {\n   \
    \ let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Occupied` in this\
    \ scope\n  --> /tmp/tmp8lksp8x8.rs:23:17\n   |\n23 |                 Occupied(mut\
    \ occu) => {\n   |                 ^^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing one of these items\n   |\n1  | use std::collections::btree_map::Entry::Occupied;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Occupied;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Occupied;\n\
    \   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Vacant` in this\
    \ scope\n  --> /tmp/tmp8lksp8x8.rs:26:17\n   |\n26 |                 Vacant(_)\
    \ => letters.entry(c).and_modify(|mut l| l.insert(letter)),\n   |            \
    \     ^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::collections::btree_map::Entry::Vacant;\n   |\n1 \
    \ | use std::collections::hash_map::Entry::Vacant;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Vacant;\n\
    \   |\n\nerror[E0425]: cannot find value `letter` in this scope\n  --> /tmp/tmp8lksp8x8.rs:26:75\n\
    \   |\n26 |                 Vacant(_) => letters.entry(c).and_modify(|mut l| l.insert(letter)),\n\
    \   |                                                                        \
    \   ^^^^^^ help: a local variable with a similar name exists: `letters`\n\nerror[E0599]:\
    \ no method named `as_ref` found for type `char` in the current scope\n  --> /tmp/tmp8lksp8x8.rs:21:36\n\
    \   |\n21 |         if let Some(ref mut c) = c.as_ref() {\n   |              \
    \                      ^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8lksp8x8.rs:23:39\n   |\n23 |                   Occupied(mut\
    \ occu) => {\n   |  _______________________________________^\n24 | |         \
    \            occu.into_mut().unwrap().1 += 1;\n25 | |                 }\n   |\
    \ |_________________^ expected enum `Option`, found `()`\n   |\n   = note:   expected\
    \ enum `Option<_>`\n           found unit type `()`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0531,\
    \ E0599.\nFor more information about an erro"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().filter_map(|c|\
    \ *c > 'a' && *c < 'z').map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp5mk335z_.rs:19:47\n\
    \   |\n19 |     for letter in test.chars().filter_map(|c| *c > 'a' && *c < 'z').map(|c|\
    \ c.to_string()) {\n   |                                               ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp5mk335z_.rs:19:59\n\
    \   |\n19 |     for letter in test.chars().filter_map(|c| *c > 'a' && *c < 'z').map(|c|\
    \ c.to_string()) {\n   |                                                     \
    \      ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5mk335z_.rs:19:47\n\
    \   |\n19 |     for letter in test.chars().filter_map(|c| *c > 'a' && *c < 'z').map(|c|\
    \ c.to_string()) {\n   |                                               ^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |     for letter in test.chars().filter_map(|c| Some(*c > 'a' && *c\
    \ < 'z')).map(|c| c.to_string()) {\n   |                                     \
    \          +++++                    +\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp5mk335z_.rs:20:9\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp5mk335z_.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut occurrences = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = (words.next(), words.next()) {\n        if let Ok(count)\
    \ = (occurrences.entry(word).or_default(), occurrences.entry(word).or_default().clone())\
    \ {\n            count.1 += 1;\n        } else {\n            occurrences.insert(word,\
    \ 1);\n        }\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkdut1rjx.rs:20:15\n   |\n\
    20 |     while let Some(word) = (words.next(), words.next()) {\n   |         \
    \      ^^^^^^^^^^   ---------------------------- this expression has type `(Option<&str>,\
    \ Option<&str>)`\n   |               |\n   |               expected tuple, found\
    \ enum `Option`\n   |\n   = note: expected tuple `(Option<&str>, Option<&str>)`\n\
    \               found enum `Option<_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut chars = test.chars().collect::<Vec<_>>();\n    let mut freqs\
    \ = chars.iter().fold(HashMap::new(), |mut acc, c| {\n        acc.entry(c.to_string()).or_default()\
    \ += 1;\n        acc\n    });\n    freqs\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut _`\n  --> /tmp/tmpvp9zt9lm.rs:20:9\n   |\n20 |         acc.entry(c.to_string()).or_default()\
    \ += 1;\n   |         -------------------------------------^^^^^\n   |       \
    \  |\n   |         cannot use `+=` on type `&mut _`\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpvp9zt9lm.rs:20:47\n   |\n20 |         acc.entry(c.to_string()).or_default()\
    \ += 1;\n   |         ------------------------------------- ^^\n   |         |\n\
    \   |         cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::<String, isize>::new();\n    let mut letters\
    \ = test.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n    let mut occurrences\
    \ = vec![];\n\n    while !letters.is_empty() {\n        let char = letters.remove(0);\n\
    \        let count = histogram.get(char).unwrap();\n        histogram.insert(char,\
    \ count + 1);\n        occurrences.push(count);\n    }\n\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg7852l5o.rs:24:35\n   |\n\
    24 |         let count = histogram.get(char).unwrap();\n   |                 \
    \                  ^^^^\n   |                                   |\n   |      \
    \                             expected reference, found struct `String`\n   |\
    \                                   help: consider borrowing here: `&char`\n \
    \  |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counts = HashMap::<String, isize>::new();\n    for ch in test.chars()\
    \ {\n        let count = counts.entry(ch.to_string()).or_insert(0);\n        *count\
    \ += 1;\n    }\n    counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp0m0fvg5j.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freqs = HashMap::new();\n    let mut chars = test.chars();\n\n\
    \    for c in chars {\n        if let Some((key, _)) = freqs.get_mut(c) {\n  \
    \          *key += 1;\n        } else {\n            freqs.insert(c, 1);\n   \
    \     }\n    }\n    freqs\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp123auzqx.rs:22:47\n   |\n\
    22 |         if let Some((key, _)) = freqs.get_mut(c) {\n   |                \
    \                               ^\n   |                                      \
    \         |\n   |                                               expected reference,\
    \ found `char`\n   |                                               help: consider\
    \ borrowing here: `&c`\n   |\n   = note: expected reference `&_`\n           \
    \        found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp123auzqx.rs:25:29\n\
    \   |\n25 |             freqs.insert(c, 1);\n   |                            \
    \ ^ expected tuple, found integer\n   |\n   = note: expected tuple `(_, _)`\n\
    \               found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp123auzqx.rs:28:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n28 |     freqs\n   | \
    \    ^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n              found struct `HashMap<char, (_, _)>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut current_letter = 0;\n\
    \    let mut count = 1;\n    for c in test.chars() {\n        letters.entry(c.to_string()).or_insert(current_letter).and_modify(|x|\
    \ *x += *count);\n        current_letter += 1;\n        count += 1;\n    }\n \
    \   letters\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `and_modify` found for mutable reference\
    \ `&mut {integer}` in the current scope\n  --> /tmp/tmpkj1tk0kf.rs:22:64\n   |\n\
    22 |         letters.entry(c.to_string()).or_insert(current_letter).and_modify(|x|\
    \ *x += *count);\n   |                                                       \
    \         ^^^^^^^^^^ method not found in `&mut {integer}`\n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmpkj1tk0kf.rs:22:85\n   |\n\
    22 |         letters.entry(c.to_string()).or_insert(current_letter).and_modify(|x|\
    \ *x += *count);\n   |                                                       \
    \                              ^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    use std::collections::HashMap;\n\n    let mut letters = String::new();\n\
    \    let mut counts = HashMap::new();\n\n    for ch in test.chars() {\n      \
    \  letters.push_str(&ch.to_string());\n        counts.push(counts.entry(ch.to_string()).or_insert(0));\n\
    \    }\n\n    for (key, value) in counts {\n        if value == letters.chars().count()\
    \ {\n            counts.remove(&key);\n        }\n    }\n\n    counts\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmpcxzir9oh.rs:18:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n18 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0599]: no method named `push` found for struct `HashMap`\
    \ in the current scope\n  --> /tmp/tmpcxzir9oh.rs:25:16\n   |\n25 |         counts.push(counts.entry(ch.to_string()).or_insert(0));\n\
    \   |                ^^^^ method not found in `HashMap<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcxzir9oh.rs:34:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n34 |     counts\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `HashMap<_, isize>`\n              found struct `HashMap<_, usize>`\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n    for\
    \ c in test.chars().cloned() {\n        histogram.entry(c).or_insert(0);\n   \
    \     *histogram.entry(c).get_mut() += 1;\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmppu9wjtu4.rs:19:27\n     |\n19   |     for c in test.chars().cloned()\
    \ {\n     |                           ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmppu9wjtu4.rs:19:14\n\
    \   |\n19 |     for c in test.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmppu9wjtu4.rs:19:14\n   |\n19 |     for c in test.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `get_mut` found for enum `std::collections::hash_map::Entry`\
    \ in the current scope\n   --> /tmp/tmppu9wjtu4.rs:21:29\n    |\n21  |       \
    \  *histogram.entry(c).get_mut() += 1;\n    |                             ^^^^^^^\
    \ method not found in `std::collections::hash_map::Entry<'_, String, isize>`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n21  |         *Pin::new(&mut histogram.entry(c)).get_mut() += 1;\n   \
    \ |          +++++++++++++                   +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ String::from(c));\n    letters.cloned().for_each(|letter| histogram.entry(letter).and_modify(|e|\
    \ e.inc(1)));\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpumy1bcfe.rs:19:40:\
    \ 19:59] as FnOnce<(char,)>>::Output == &_`\n    --> /tmp/tmpumy1bcfe.rs:20:13\n\
    \     |\n20   |     letters.cloned().for_each(|letter| histogram.entry(letter).and_modify(|e|\
    \ e.inc(1)));\n     |             ^^^^^^ expected reference, found struct `String`\n\
    \     |\n     = note: expected reference `&_`\n                   found struct\
    \ `String`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Map<Chars<'_>, [closure@/tmp/tmpumy1bcfe.rs:19:40: 19:59]>`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `for_each` exists for struct\
    \ `Cloned<Map<Chars<'_>, [closure@/tmp/tmpumy1bcfe.rs:19:40: 19:59]>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpumy1bcfe.rs:20:22\n   |\n20 |\
    \       letters.cloned().for_each(|letter| histogram.entry(letter).and_modify(|e|\
    \ e.inc(1)));\n   |                        ^^^^^^^^ method cannot be called on\
    \ `Cloned<Map<Chars<'_>, [closure@/tmp/tmpumy1bcfe.rs:19:40: 19:59]>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<Map<Chars<'_>, [closure@/tmp/tmpumy1bcfe.rs:19:40:\
    \ 19:59]> as Iterator>::Item = &_`\n           which is required by `Cloned<Map<Chars<'_>,\
    \ [closure@/tmp/tmpumy1bcfe.rs:19:40: 19:59]>>: Iterator`\n           `Cloned<Map<Chars<'_>,\
    \ [closure@/tmp/tmpumy1bcfe.rs:19:40: 19:59]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<Map<Chars<'_>, [closure@/tmp/tmpumy1bcfe.rs:19:40:\
    \ 19:59]>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let mut split = test.split(' ').collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < split.len() {\n        let letter = split[i];\n\
    \        let count = map.entry(letter).or_insert(0);\n        *count += 1;\n \
    \       i += 1;\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp20bxcuu7.rs:27:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n27 |     map\n   |     ^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n        \
    \      found struct `HashMap<&str, {integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letter_count: HashMap<String, isize> = HashMap::new();\n    for\
    \ letter in test.chars().skip_while(|c| *c != ' '){\n        let letter_count:\
    \ isize = letter_count.entry(letter).or_insert(0);\n        *letter_count += 1;\n\
    \    }\n    letter_count\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp48dvqf_b.rs:20:54\n   |\n\
    20 |         let letter_count: isize = letter_count.entry(letter).or_insert(0);\n\
    \   |                                                      ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \                    |\n   |                                                 \
    \     expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp48dvqf_b.rs:20:35\n   |\n20 |         let letter_count: isize =\
    \ letter_count.entry(letter).or_insert(0);\n   |                           -----\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&mut isize`\n\
    \   |                           |\n   |                           expected due\
    \ to this\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |         let\
    \ letter_count: isize = *letter_count.entry(letter).or_insert(0);\n   |      \
    \                             +\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp48dvqf_b.rs:21:9\n   |\n21 |         *letter_count += 1;\n   |\
    \         ^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test, HashMap::new())\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp1yx07iz4.rs:18:5\n   |\n18 |     histogram(test, HashMap::new())\n\
    \   |     ^^^^^^^^^ ----  -------------- supplied 2 arguments\n   |     |\n  \
    \ |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp1yx07iz4.rs:17:4\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ^^^^^^^^^\
    \ ------------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976509
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::with_capacity(test.chars().count() as usize);\n\
    \    let mut occurrences = HashMap::new();\n    for c in test.chars() {\n    \
    \    let count = occurrences.entry(c).or_insert(0);\n        *count += 1;\n  \
    \      histogram.insert(String::from(c), *count as isize);\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"b\": 2, \"a\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp0erbok6q.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut char_counts = HashMap::<String, isize>::new();\n    let mut words\
    \ = test\n        .chars()\n        .map(|c| c.to_ascii_lowercase().to_string())\n\
    \        .collect::<Vec<_>>();\n    words.sort_unstable();\n    words.extend(words.iter().cloned());\n\
    \    words.dedup();\n\n    let mut char_count_max = 0;\n    for c in words {\n\
    \        if let Some(&count) = (&char_counts).entry(c) {\n            char_count_max\
    \ = if count > char_count_max { count } else { char_count_max };\n        }\n\
    \    }\n\n    char_counts\n        .iter()\n        .map(|(_, count)| (count.clone(),\
    \ c.to_string()))\n        .for_each(|(count, name)| {\n            if count >\
    \ char_count_max { char_counts.entry(name).and_modify(|(_, count)| { count +=\
    \ 1 }); }\n        });\n    char_counts\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpaav3e5sm.rs:36:43\n\
    \   |\n36 |         .map(|(_, count)| (count.clone(), c.to_string()))\n   |  \
    \                                         ^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaav3e5sm.rs:29:16\n   |\n29 |         if let\
    \ Some(&count) = (&char_counts).entry(c) {\n   |                ^^^^^^^^^^^^ \
    \  ----------------------- this expression has type `std::collections::hash_map::Entry<'_,\
    \ String, isize>`\n   |                |\n   |                expected enum `std::collections::hash_map::Entry`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::collections::hash_map::Entry<'_,\
    \ String, isize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaav3e5sm.rs:38:77\n   |\n38 |             if count > char_count_max\
    \ { char_counts.entry(name).and_modify(|(_, count)| { count += 1 }); }\n   | \
    \                                                                            ^^^^^^^^^-\n\
    \   |                                                                        \
    \     |        |\n   |                                                       \
    \                      |        expected due to this\n   |                   \
    \                                                          expected `isize`, found\
    \ tuple\n   |\n   = note: expected type `isize`\n             found tuple `(_,\
    \ _)`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::<String, isize>::new();\n\n    for x in\
    \ test.split(' ').filter(|&x| !x.is_empty()) {\n        let count = histogram.entry(x).or_insert(0);\n\
    \        *count += 1;\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7rbyjs1v.rs:21:37\n   |\n\
    21 |         let count = histogram.entry(x).or_insert(0);\n   |              \
    \                       ^- help: try using a conversion method: `.to_string()`\n\
    \   |                                     |\n   |                            \
    \         expected struct `String`, found `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut count_map = HashMap::<String, isize>::new();\n    let mut tests\
    \ = test.split_whitespace();\n    for test in tests {\n        if !test.is_empty()\
    \ {\n            let test_char = test.chars().collect::<String>().to_string();\n\
    \            count_map.entry(test_char.clone()).or_insert(0) += 1;\n        }\n\
    \    }\n    count_map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut isize`\n  --> /tmp/tmp_ci4h3ai.rs:23:13\n   |\n23 |             count_map.entry(test_char.clone()).or_insert(0)\
    \ += 1;\n   |             -----------------------------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut isize`\n \
    \  |\nhelp: `+=` can be used on `isize`, you can dereference `count_map.entry(test_char.clone()).or_insert(0)`\n\
    \   |\n23 |             *count_map.entry(test_char.clone()).or_insert(0) += 1;\n\
    \   |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmp_ci4h3ai.rs:23:61\n   |\n23 |             count_map.entry(test_char.clone()).or_insert(0)\
    \ += 1;\n   |             ----------------------------------------------- ^^\n\
    \   |             |\n   |             cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for char in test.chars() {\n     \
    \   if let Ok(_) = map.entry(char.clone()).and_then(|e| e.is_none()) {\n     \
    \       map.insert(char.clone(), 1);\n        } else {\n            map.entry(char.clone()).or_insert(0)\
    \ += 1;\n        }\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `and_then` found for enum `std::collections::hash_map::Entry`\
    \ in the current scope\n  --> /tmp/tmp3lak0v4o.rs:20:48\n   |\n20 |         if\
    \ let Ok(_) = map.entry(char.clone()).and_then(|e| e.is_none()) {\n   |      \
    \                                          ^^^^^^^^ method not found in `std::collections::hash_map::Entry<'_,\
    \ char, _>`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmp3lak0v4o.rs:23:13\n   |\n23 |      \
    \       map.entry(char.clone()).or_insert(0) += 1;\n   |             ------------------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `map.entry(char.clone()).or_insert(0)`\n\
    \   |\n23 |             *map.entry(char.clone()).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp3lak0v4o.rs:23:50\n\
    \   |\n23 |             map.entry(char.clone()).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3lak0v4o.rs:26:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n26 |     map\n   |   \
    \  ^^^ expected struct `String`, found `char`\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letter_count: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut test: Vec<char> = test.chars().collect();\n\n    for (i, char) in test.into_iter().enumerate()\
    \ {\n        letter_count.entry(char.clone()).or_insert(0) += 1;\n        test.remove(i);\n\
    \    }\n    letter_count\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbilawz_r.rs:22:28\n   |\n\
    22 |         letter_count.entry(char.clone()).or_insert(0) += 1;\n   |       \
    \                     ^^^^^^^^^^^^\n   |                            |\n   |  \
    \                          expected struct `String`, found `char`\n   |      \
    \                      help: try using a conversion method: `char.to_string()`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ isize`\n  --> /tmp/tmpbilawz_r.rs:22:9\n   |\n22 |         letter_count.entry(char.clone()).or_insert(0)\
    \ += 1;\n   |         ---------------------------------------------^^^^^\n   |\
    \         |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=`\
    \ can be used on `isize`, you can dereference `letter_count.entry(char.clone()).or_insert(0)`\n\
    \   |\n22 |         *letter_count.entry(char.clone()).or_insert(0) += 1;\n   |\
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpbilawz_r.rs:22:55\n\
    \   |\n22 |         letter_count.entry(char.clone()).or_insert(0) += 1;\n   |\
    \         --------------------------------------------- ^^\n   |         |\n \
    \  |         cannot assign to this expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().filter(|c| c.is_whitespace()).map(|c| c.to_string()).collect()\n\
    \        .into_iter()\n        .fold(HashMap::new(), |mut map, _| {\n        \
    \    map.entry(c.to_string()).or_insert(0) as i32\n                += 1;\n   \
    \         map\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmphzeqcobk.rs:21:23\n\
    \   |\n21 |             map.entry(c.to_string()).or_insert(0) as i32\n   |   \
    \                    ^ not found in this scope\n\nerror[E0282]: type annotations\
    \ needed\n  --> /tmp/tmphzeqcobk.rs:18:71\n   |\n18 |     test.chars().filter(|c|\
    \ c.is_whitespace()).map(|c| c.to_string()).collect()\n   |                  \
    \                                                     ^^^^^^^ cannot infer type\
    \ for type parameter `B` declared on the associated function `collect`\n   |\n\
    \   = note: type must be known at this point\nhelp: consider specifying the type\
    \ argument in the method call\n   |\n18 |     test.chars().filter(|c| c.is_whitespace()).map(|c|\
    \ c.to_string()).collect::<B>()\n   |                                        \
    \                                      +++++\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmphzeqcobk.rs:22:17\n   |\n21 |            \
    \ map.entry(c.to_string()).or_insert(0) as i32\n   |             --------------------------------------------\
    \ cannot assign to this expression\n22 |                 += 1;\n   |         \
    \        ^^\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0282, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map: HashMap<String, isize> = HashMap::new();\n    for c in test.chars()\
    \ {\n        let count = map.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbiywl77n.rs:20:31\n   |\n\
    20 |         let count = map.entry(c).or_insert(0);\n   |                    \
    \           ^- help: try using a conversion method: `.to_string()`\n   |     \
    \                          |\n   |                               expected struct\
    \ `String`, found `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for letter in test.chars().flat_map(|x|\
    \ x.to_lowercase().chars()) {\n        if let Some(count) = map.get(&letter) {\n\
    \            *count += 1;\n        } else {\n            map.insert(letter, 1);\n\
    \        }\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmpu9p3ya87.rs:19:62\n   |\n19 |     for letter\
    \ in test.chars().flat_map(|x| x.to_lowercase().chars()) {\n   |             \
    \                                                 ^^^^^ method not found in `ToLowercase`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = test.split_whitespace();\n    let mut occurrences =\
    \ HashMap::with_capacity(letters.len());\n    for letter in letters.iter() {\n\
    \        if let Some(ref mut count) = get_occurrence(&mut occurrences, letter)\
    \ {\n            *count += 1;\n        } else {\n            occurrences.insert(letter,\
    \ 1);\n        }\n    }\n\n    occurrences\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_occurrence` in this scope\n  -->\
    \ /tmp/tmplp8hll0c.rs:21:38\n   |\n21 |         if let Some(ref mut count) = get_occurrence(&mut\
    \ occurrences, letter) {\n   |                                      ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `len` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmplp8hll0c.rs:19:58\n  \
    \ |\n19 |     let mut occurrences = HashMap::with_capacity(letters.len());\n \
    \  |                                                          ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmplp8hll0c.rs:20:27\n  \
    \ |\n20 |     for letter in letters.iter() {\n   |                           ^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ {\n        let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n\
    \        (c, count)\n    }) {\n        let (_, count) = letter;\n        if *count\
    \ == 1 {\n            continue;\n        }\n        histogram.entry(count).or_insert(0)\
    \ as isize\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpux9kwts6.rs:28:25\n   |\n\
    28 |         histogram.entry(count).or_insert(0) as isize\n   |              \
    \           ^^^^^ expected `char`, found `&mut {integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpux9kwts6.rs:28:9\n   |\n28 |         histogram.entry(count).or_insert(0)\
    \ as isize\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `()`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpux9kwts6.rs:30:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror[E0606]:\
    \ casting `&mut {integer}` as `isize` is invalid\n  --> /tmp/tmpux9kwts6.rs:28:9\n\
    \   |\n28 |         histogram.entry(count).or_insert(0) as isize\n   |       \
    \  -----------------------------------^^^^^^^^^\n   |         |\n   |        \
    \ cannot cast `&mut {integer}` as `isize`\n   |         help: dereference the\
    \ expression: `*histogram.entry(count).or_insert(0)`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0606.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test\n        .split_whitespace()\n        .into_iter()\n        .fold(HashMap::new(),\
    \ |mut acc, x| {\n            let mut count = acc.entry(x).or_insert(0);\n   \
    \         *count += 1;\n            acc\n        })\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjrbs2y4k.rs:22:39\n   |\n\
    22 |             let mut count = acc.entry(x).or_insert(0);\n   |            \
    \                           ^- help: try using a conversion method: `.to_string()`\n\
    \   |                                       |\n   |                          \
    \             expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Split the string into a char array.\n    let chars = test.chars().collect::<Vec<char>>();\n\
    \n    // Count each occurrence of each char by looping over the char array\n \
    \   let mut counter = HashMap::new();\n    for &c in chars {\n        // Increment\
    \ each counter by 1\n        counter.entry(c).or_default() + 1;\n    }\n\n   \
    \ // Return the histogram as a map\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_hq4edcq.rs:23:9\n   |\n\
    23 |     for &c in chars {\n   |         ^^    ----- this expression has type\
    \ `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `&mut _`\n  --> /tmp/tmp_hq4edcq.rs:25:39\n   |\n\
    25 |         counter.entry(c).or_default() + 1;\n   |         -----------------------------\
    \ ^ - {integer}\n   |         |\n   |         &mut _\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ')\n        .map(|item| item.to_lowercase())\n        .group_by(|item|\
    \ item)\n        .count();\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmps05_gq_q.rs:20:10\n   |\n20 |         .group_by(|item|\
    \ item)\n   |          ^^^^^^^^ method not found in `Map<std::str::Split<'_, char>,\
    \ [closure@/tmp/tmps05_gq_q.rs:19:14: 19:40]>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps05_gq_q.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut char_count = HashMap::new();\n    for letter in test.split('\
    \ ').iter().map(|l| l.to_lowercase()) {\n        if let Some(&v) = char_count.entry(letter)\
    \ {\n            v += 1;\n        } else {\n            char_count.insert(letter,\
    \ 1);\n        }\n    }\n    char_count\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpdcq57kjb.rs:19:35\n   |\n19 |     for letter\
    \ in test.split(' ').iter().map(|l| l.to_lowercase()) {\n   |                \
    \                   ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdcq57kjb.rs:20:16\n   |\n20 |         if let\
    \ Some(&v) = char_count.entry(letter) {\n   |                ^^^^^^^^   ------------------------\
    \ this expression has type `std::collections::hash_map::Entry<'_, _, _>`\n   |\
    \                |\n   |                expected enum `std::collections::hash_map::Entry`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::collections::hash_map::Entry<'_,\
    \ _, _>`\n              found enum `Option<_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::with_capacity(test.len());\n    for c in test.chars()\
    \ {\n        if map.contains_key(&c.to_string()) {\n            map.insert(c.to_string(),\
    \ map.get(&c.to_string()) + 1);\n        } else {\n            map.insert(c.to_string(),\
    \ 1);\n        }\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&_>`\n  --> /tmp/tmp1w_zrt9r.rs:21:63\n\
    \   |\n21 |             map.insert(c.to_string(), map.get(&c.to_string()) + 1);\n\
    \   |                                       ----------------------- ^ - {integer}\n\
    \   |                                       |\n   |                          \
    \             Option<&_>\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| *c).collect()\n        .iter()\n        .group_by(|&c|\
    \ c) // group_by into buckets\n        .cloned()\n        .max_by(|(_, bucket)|\
    \ bucket) // max_by in buckets\n        .unwrap()\n        .into_iter()\n    \
    \    .map(|(k, v)| (k, v.len()))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp_tgi74yy.rs:18:26\n\
    \   |\n18 |     test.chars().map(|c| *c).collect()\n   |                     \
    \     ^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().fold(HashMap::new(), |acc, c| {\n        let (key, val)\
    \ = (c.to_string(), 1);\n        if acc.contains_key(&key) {\n            *acc.entry(key).or_insert(0)\
    \ = *acc.entry(key).or_insert(0) + val;\n        } else {\n            *acc.entry(key).or_insert(0)\
    \ = val;\n        }\n        acc\n    })\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `acc` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpo8u5vq_s.rs:21:14\n   |\n18 |     test.chars().fold(HashMap::new(),\
    \ |acc, c| {\n   |                                        --- help: consider changing\
    \ this to be mutable: `mut acc`\n...\n21 |             *acc.entry(key).or_insert(0)\
    \ = *acc.entry(key).or_insert(0) + val;\n   |              ^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0382]: use of moved value: `key`\n  --> /tmp/tmpo8u5vq_s.rs:21:24\n\
    \   |\n19 |         let (key, val) = (c.to_string(), 1);\n   |              ---\
    \ move occurs because `key` has type `String`, which does not implement the `Copy`\
    \ trait\n20 |         if acc.contains_key(&key) {\n21 |             *acc.entry(key).or_insert(0)\
    \ = *acc.entry(key).or_insert(0) + val;\n   |                        ^^^ value\
    \ used here after move --- value moved here\n\nerror[E0596]: cannot borrow `acc`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpo8u5vq_s.rs:21:45\n\
    \   |\n18 |     test.chars().fold(HashMap::new(), |acc, c| {\n   |           \
    \                             --- help: consider changing this to be mutable:\
    \ `mut acc`\n...\n21 |             *acc.entry(key).or_insert(0) = *acc.entry(key).or_insert(0)\
    \ + val;\n   |                                             ^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `acc` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmpo8u5vq_s.rs:23:14\n   |\n18 |     test.chars().fold(HashMap::new(),\
    \ |acc, c| {\n   |                                        --- help: consider changing\
    \ this to be mutable: `mut acc`\n...\n23 |             *acc.entry(key).or_insert(0)\
    \ = val;\n   |              ^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0596.\nFor more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counts: HashMap<String, isize> = HashMap::new();\n    let mut\
    \ words = test.split(\" \").collect::<Vec<_>>();\n    for word in words {\n  \
    \      let letter = String::from(word[0]);\n        if counts.contains_key(&letter)\
    \ {\n            counts.entry(letter).and_modify(|x| x.1 += 1).or_insert(1);\n\
    \        } else {\n            counts.insert(letter, 1);\n        }\n    }\n \
    \   counts\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpk61rdm7c.rs:21:35\n\
    \   |\n21 |         let letter = String::from(word[0]);\n   |                \
    \                   ^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you\
    \ can use `.chars().nth()` or `.bytes().nth()`\n           for more information,\
    \ see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0609]: no field `1` on type `&mut isize`\n  --> /tmp/tmpk61rdm7c.rs:23:51\n\
    \   |\n23 |             counts.entry(letter).and_modify(|x| x.1 += 1).or_insert(1);\n\
    \   |                                                   ^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0609.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut occurrences = HashMap::new();\n    for c in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = occurrences.get(c);\n        if let Some(count)\
    \ = count {\n            occurrences.entry(c.clone()).or_insert(count).push(isize::from(c));\n\
    \        } else {\n            occurrences.entry(c.clone()).or_insert(1);\n  \
    \      }\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplj86qi73.rs:20:37\n   |\n\
    20 |         let count = occurrences.get(c);\n   |                           \
    \          ^\n   |                                     |\n   |               \
    \                      expected reference, found struct `String`\n   |       \
    \                              help: consider borrowing here: `&c`\n   |\n   =\
    \ note: expected reference `&_`\n                 found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplj86qi73.rs:22:52\n   |\n22 |             occurrences.entry(c.clone()).or_insert(count).push(isize::from(c));\n\
    \   |                                                    ^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \                  |\n   |                                                   \
    \ cyclic type of infinite size\n\nerror[E0277]: the trait bound `isize: From<String>`\
    \ is not satisfied\n  --> /tmp/tmplj86qi73.rs:22:64\n   |\n22 |             occurrences.entry(c.clone()).or_insert(count).push(isize::from(c));\n\
    \   |                                                                ^^^^^^^^^^^\
    \ the trait `From<String>` is not implemented for `isize`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <f32 as From<i16>>\n\
    \             <f32 as From<i8>>\n             <f32 as From<u16>>\n           \
    \  <f32 as From<u8>>\n             <f64 as From<f32>>\n             <f64 as From<i16>>\n\
    \             <f64 as From<i32>>\n             <f64 as From<i8>>\n           and\
    \ 67 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counter = HashMap::new();\n    for c in test.chars() {\n    \
    \    counter.entry(c.to_string()).or_insert(0) += 1;\n    }\n    counter\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmptq5lr7ww.rs:20:9\n   |\n20 |         counter.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -----------------------------------------^^^^^\n   |   \
    \      |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `counter.entry(c.to_string()).or_insert(0)`\n\
    \   |\n20 |         *counter.entry(c.to_string()).or_insert(0) += 1;\n   |   \
    \      +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmptq5lr7ww.rs:20:51\n\
    \   |\n20 |         counter.entry(c.to_string()).or_insert(0) += 1;\n   |    \
    \     ----------------------------------------- ^^\n   |         |\n   |     \
    \    cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let mut letters = test.chars().filter_map(|c|\
    \ c.to_ascii_lowercase()).collect::<Vec<_>>();\n    letters.sort_by_key(|c| c.to_ascii_lowercase());\n\
    \    for letter in letters {\n        let count = map.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi9uwsned.rs:19:51\n   |\n\
    19 |     let mut letters = test.chars().filter_map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \   |                                                   ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |     let mut letters = test.chars().filter_map(|c| Some(c.to_ascii_lowercase())).collect::<Vec<_>>();\n\
    \   |                                                   +++++                \
    \      +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for (letter, count) in test\n\
    \        .trim()\n        .split_whitespace()\n        .chars()\n        .group_by(|&c|\
    \ c)\n        .into_iter()\n    {\n        *histogram.entry(letter).or_insert(0)\
    \ += count;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpyb0_7ry9.rs:22:10\n   |\n22 |         .chars()\n\
    \   |          ^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map: HashMap<String, isize> = HashMap::new();\n    for letter\
    \ in test.split_whitespace() {\n        map.entry(letter).or_insert(0) += 1;\n\
    \    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9uk8844l.rs:20:19\n   |\n\
    20 |         map.entry(letter).or_insert(0) += 1;\n   |                   ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \ |\n   |                   expected struct `String`, found `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut isize`\n  -->\
    \ /tmp/tmp9uk8844l.rs:20:9\n   |\n20 |         map.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------^^^^^\n   |         |\n  \
    \ |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used\
    \ on `isize`, you can dereference `map.entry(letter).or_insert(0)`\n   |\n20 |\
    \         *map.entry(letter).or_insert(0) += 1;\n   |         +\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp9uk8844l.rs:20:40\n   |\n\
    20 |         map.entry(letter).or_insert(0) += 1;\n   |         ------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut letters = String::from(test);\n    letters.push_str(\"a\".to_string());\n\
    \    letters.push_str(\"b\".to_string());\n    letters.push_str(\"c\".to_string());\n\
    \    while !letters.is_empty() {\n        let mut letter = letters.split_whitespace().nth(0).unwrap();\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n        letters.push_str(letter.to_string());\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5px2frb_.rs:20:22\n   |\n\
    20 |     letters.push_str(\"a\".to_string());\n   |                      ^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&\"\
    a\".to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5px2frb_.rs:21:22\n\
    \   |\n21 |     letters.push_str(\"b\".to_string());\n   |                   \
    \   ^^^^^^^^^^^^^^^\n   |                      |\n   |                      expected\
    \ `&str`, found struct `String`\n   |                      help: consider borrowing\
    \ here: `&\"b\".to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5px2frb_.rs:22:22\n\
    \   |\n22 |     letters.push_str(\"c\".to_string());\n   |                   \
    \   ^^^^^^^^^^^^^^^\n   |                      |\n   |                      expected\
    \ `&str`, found struct `String`\n   |                      help: consider borrowing\
    \ here: `&\"c\".to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5px2frb_.rs:25:25\n\
    \   |\n25 |         histogram.entry(letter).or_insert(0) += 1;\n   |         \
    \                ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut isize`\n  --> /tmp/tmp5px2frb_.rs:25:9\n   |\n25 |\
    \         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp:\
    \ `+=` can be used on `isize`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp5px2frb_.rs:25:46\n\
    \   |\n25 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched type"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = String::from(test);\n    let mut count = HashMap::new();\n\
    \n    while let Some(letter) = letters.chars().next() {\n        let letter =\
    \ letters.chars().next().unwrap();\n\n        if let Some(count) = count.get(&letter)\
    \ {\n            count.1 += 1;\n        } else {\n            count.1 = 1;\n \
    \           count.insert(String::from(letter), 0);\n        }\n\n        let mut\
    \ letters = letters.remove(letter);\n    }\n\n    count\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `HashMap<K, V>`\n  --> /tmp/tmp7uy8kvtc.rs:24:36\n\
    \   |\n19 |     let mut count = HashMap::new();\n   |         --------- consider\
    \ giving `count` the explicit type `HashMap<K, V>`, where the type parameter `V`\
    \ is specified\n...\n24 |         if let Some(count) = count.get(&letter) {\n\
    \   |                                    ^^^ cannot infer type for type parameter\
    \ `V`\n   |\n   = note: type must be known at this point\n\nerror[E0609]: no field\
    \ `1` on type `&_`\n  --> /tmp/tmp7uy8kvtc.rs:25:19\n   |\n25 |             count.1\
    \ += 1;\n   |                   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7uy8kvtc.rs:31:42\n\
    \   |\n31 |         let mut letters = letters.remove(letter);\n   |          \
    \                                ^^^^^^ expected `usize`, found `char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut result = HashMap::from(vec![]);\n    let mut letters = test.chars();\n\
    \    while let Some(letter) = letters.next() {\n        if let Some(count) = result.get(&letter)\
    \ {\n            *count += 1;\n        } else {\n            result.insert(letter,\
    \ 1);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `HashMap<_, _, _>: From<Vec<_>>` is not satisfied\n\
    \  --> /tmp/tmpfeo3bwyo.rs:18:22\n   |\n18 |     let mut result = HashMap::from(vec![]);\n\
    \   |                      ^^^^^^^^^^^^^ the trait `From<Vec<_>>` is not implemented\
    \ for `HashMap<_, _, _>`\n   |\n   = help: the trait `From<[(K, V); N]>` is implemented\
    \ for `HashMap<K, V>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfeo3bwyo.rs:27:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n27 |     result\n   |     ^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize,\
    \ RandomState>`\n              found struct `HashMap<char, {integer}, _>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram1(test, String::new())\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `histogram1` in this scope\n  --> /tmp/tmpt1v3yovc.rs:18:5\n\
    \   |\n18 |     histogram1(test, String::new())\n   |     ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Split test string by spaces and convert to lowercase\n    let mut\
    \ letters = test.chars().map(|c| c.to_lowercase()).collect::<Vec<_>>();\n    //\
    \ Add space to empty string\n    letters.push(' ');\n\n    // Build HashMap\n\
    \    let mut histogram = HashMap::new();\n    let mut count = 1;\n    for letter\
    \ in letters {\n        // Check if the letter already exists in histogram\n \
    \       if histogram.contains_key(&letter) {\n            // Increment its counter\n\
    \            histogram.entry(letter).and_modify(|x| *x = *x + count);\n      \
    \  } else {\n            // Add letter to histogram and set its counter to 1\n\
    \            histogram.insert(letter, 1);\n        }\n\n        // Set counter\
    \ to 1 again\n        count += 1;\n    }\n\n    histogram\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptowinurt.rs:21:18\n   |\n\
    21 |     letters.push(' ');\n   |                  ^^^ expected struct `ToLowercase`,\
    \ found `char`\n\nerror[E0277]: the trait bound `ToLowercase: Hash` is not satisfied\n\
    \   --> /tmp/tmptowinurt.rs:28:35\n    |\n28  |         if histogram.contains_key(&letter)\
    \ {\n    |                      ------------ ^^^^^^^ the trait `Hash` is not implemented\
    \ for `ToLowercase`\n    |                      |\n    |                     \
    \ required by a bound introduced by this call\n    |\nnote: required by a bound\
    \ in `HashMap::<K, V, S>::contains_key`\n\nerror[E0277]: the trait bound `ToLowercase:\
    \ Eq` is not satisfied\n   --> /tmp/tmptowinurt.rs:28:35\n    |\n28  |       \
    \  if histogram.contains_key(&letter) {\n    |                      ------------\
    \ ^^^^^^^ the trait `Eq` is not implemented for `ToLowercase`\n    |         \
    \             |\n    |                      required by a bound introduced by\
    \ this call\n    |\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\
    \nerror[E0277]: the trait bound `ToLowercase: Eq` is not satisfied\n   --> /tmp/tmptowinurt.rs:28:22\n\
    \    |\n28  |         if histogram.contains_key(&letter) {\n    |            \
    \          ^^^^^^^^^^^^ the trait `Eq` is not implemented for `ToLowercase`\n\
    \    |\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\nerror[E0277]:\
    \ the trait bound `ToLowercase: Hash` is not satisfied\n   --> /tmp/tmptowinurt.rs:28:22\n\
    \    |\n28  |         if histogram.contains_key(&letter) {\n    |            \
    \          ^^^^^^^^^^^^ the trait `Hash` is not implemented for `ToLowercase`\n\
    \    |\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\nerror[E0277]:\
    \ the trait bound `ToLowercase: Eq` is not satisfied\n   --> /tmp/tmptowinurt.rs:30:29\n\
    \    |\n30  |             histogram.entry(letter).and_modify(|x| *x = *x + count);\n\
    \    |                       ----- ^^^^^^ the trait `Eq` is not implemented for\
    \ `ToLowercase`\n    |                       |\n    |                       required\
    \ by a bound introduced by this call\n    |\nnote:"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    for c in test.chars() {\n\
    \        let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk440fdbf.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counter: HashMap<String, isize> = HashMap::new();\n    let mut\
    \ letters: Vec<String> = test.split(\" \").map(|x| x.to_string()).collect();\n\
    \    let mut letter: String;\n    for &letter in letters {\n        if let Some(&count)\
    \ = counter.get(&letter) {\n            counter.insert(letter, count + 1);\n \
    \       } else {\n            counter.insert(letter, 1);\n        }\n    }\n \
    \   counter.into_iter().max_by_key(|&(letter, count)| count).map(|(letter, count)|\
    \ letter).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp212r1syv.rs:21:9\n   |\n\
    21 |     for &letter in letters {\n   |         ^^^^^^^    ------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `letter`\n   |\n   = note: expected struct `String`\n           found reference\
    \ `&_`\n\nerror[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp212r1syv.rs:28:92\n\
    \    |\n28  |       counter.into_iter().max_by_key(|&(letter, count)| count).map(|(letter,\
    \ count)| letter).collect()\n    |                                           \
    \                                                   ^^^^^^^ `Option<String>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for c in test.chars() {\n        if\
    \ !map.contains_key(c.to_string()) {\n            map.insert(c.to_string(), 1);\n\
    \        } else {\n            map.entry(c.to_string()).and_modify(|x| {\n   \
    \             *x += 1;\n            }).or_insert(1);\n        }\n    }\n    map\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsfubg66p.rs:20:30\n   |\n\
    20 |         if !map.contains_key(c.to_string()) {\n   |                     \
    \         ^^^^^^^^^^^^^\n   |                              |\n   |           \
    \                   expected reference, found struct `String`\n   |          \
    \                    help: consider borrowing here: `&c.to_string()`\n   |\n \
    \  = note: expected reference `&_`\n                 found struct `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ')\n        .filter(|&s| !s.is_empty())\n        .map(|&s|\
    \ s.to_lowercase())\n        .group_by(|&s| s)\n        .max_by(|a, b| b.1)\n\
    \        .unwrap()\n        .clone()\n        .iter()\n        .map(|&(k, _)|\
    \ k)\n        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpfeo07_ay.rs:20:16\n   |\n20 |         .map(|&s| s.to_lowercase())\n\
    \   |                ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0599]: no method named `group_by` found for struct\
    \ `Map` in the current scope\n  --> /tmp/tmpfeo07_ay.rs:21:10\n   |\n21 |    \
    \     .group_by(|&s| s)\n   |          ^^^^^^^^ method not found in `Map<Filter<std::str::Split<'_,\
    \ char>, [closure@/tmp/tmpfeo07_ay.rs:19:17: 19:35]>, [closure@/tmp/tmpfeo07_ay.rs:20:14:\
    \ 20:35]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ').map(|c| {\n        let mut key = c.to_string();\n   \
    \     let count = test.chars().filter(|c| c == c as char).count() as isize;\n\
    \        (key, count)\n    }).fold(HashMap::new(), |mut res, (c, count)| {\n \
    \       match res.entry(c) {\n            hash_map::Entry::Occupied(mut oe) =>\
    \ {\n                oe.value = oe.value + count;\n            },\n          \
    \  hash_map::Entry::Vacant(ve) => {\n                ve.insert(count);\n     \
    \       }\n        }\n        res\n    })\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmp1ydvc61t.rs:24:13\n   |\n24 |             hash_map::Entry::Occupied(mut\
    \ oe) => {\n   |             ^^^^^^^^ use of undeclared crate or module `hash_map`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmp1ydvc61t.rs:27:13\n   |\n27 |             hash_map::Entry::Vacant(ve)\
    \ => {\n   |             ^^^^^^^^ use of undeclared crate or module `hash_map`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1ydvc61t.rs:20:47\n\
    \   |\n20 |         let count = test.chars().filter(|c| c == c as char).count()\
    \ as isize;\n   |                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmp1ydvc61t.rs:20:50\n\
    \   |\n20 |         let count = test.chars().filter(|c| c == c as char).count()\
    \ as isize;\n   |                                                  ^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    test.split(\" \").map(|word| {\n \
    \       let mut repetitions = map.entry(word).or_insert(0);\n        *repetitions\
    \ += 1;\n    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi3w1a9wy.rs:19:5\n   |\n\
    17 |   fn histogram(test: String) -> HashMap<String, isize> {\n   |          \
    \                       ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n18 |       let mut map = HashMap::new();\n19 | /   \
    \  test.split(\" \").map(|word| {\n20 | |         let mut repetitions = map.entry(word).or_insert(0);\n\
    21 | |         *repetitions += 1;\n22 | |     })\n   | |______^ expected struct\
    \ `HashMap`, found struct `Map`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `Map<std::str::Split<'_, &str>, [closure@/tmp/tmpi3w1a9wy.rs:19:25:\
    \ 22:6]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Split test string into a vector\n    let mut splitted = test.chars().map(|c|\
    \ c.to_ascii_lowercase()).collect::<Vec<_>>();\n    // Build a histogram of the\
    \ splitted letters.\n    splitted\n        .iter()\n        .fold(HashMap::new(),\
    \ |mut histogram, c| {\n            if let Some(count) = (histogram.get(c).cloned().unwrap_or_else(||\
    \ 0)) {\n                histogram.insert(c, *count + 1);\n            } else\
    \ {\n                histogram.insert(c, 1);\n            }\n            histogram\n\
    \        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmp2udz6oe0.rs:24:34\n   |\n24 |             if let Some(count) = (histogram.get(c).cloned().unwrap_or_else(||\
    \ 0)) {\n   |                                  ^                             \
    \                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n24 -             if let Some(count) = (histogram.get(c).cloned().unwrap_or_else(||\
    \ 0)) {\n24 +             if let Some(count) = histogram.get(c).cloned().unwrap_or_else(||\
    \ 0) {\n   | \n\nerror[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmp2udz6oe0.rs:24:45\n    |\n24  |             if let Some(count)\
    \ = (histogram.get(c).cloned().unwrap_or_else(|| 0)) {\n    |                \
    \                             ^^^ the trait `Borrow<char>` is not implemented\
    \ for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashMap::<K, V, S>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2udz6oe0.rs:24:20\n   |\n24 |             if\
    \ let Some(count) = (histogram.get(c).cloned().unwrap_or_else(|| 0)) {\n   | \
    \                   ^^^^^^^^^^^   ------------------------------------------------\
    \ this expression has type `isize`\n   |                    |\n   |          \
    \          expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2udz6oe0.rs:25:34\n   |\n25 |                 histogram.insert(c,\
    \ *count + 1);\n   |                                  ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                  |\n   |      \
    \                            expected struct `String`, found `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2udz6oe0.rs:27:34\n   |\n27 |              \
    \   histogram.insert(c, 1);\n   |                                  ^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \      |\n   |                                 "
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| c as char).collect()\n        .sort_by(|a, b| b.cmp(a))\n\
    \        .collect()\n        .map(|c| {\n            let i = test.chars().filter(|c|\
    \ c as char == c).count() as isize;\n            (c, c * i)\n        })\n    \
    \    .collect()\n        .into_iter()\n        .map(|(key, val)| {\n         \
    \   let mut s = key.to_string();\n            if s.len() > 1 {\n             \
    \   s.truncate(s.len() - 1);\n            }\n            (s, val)\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpalu0yv7x.rs:18:37\n\
    \   |\n18 |     test.chars().map(|c| c as char).collect()\n   |              \
    \                       ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n   |\n   = note: type must be known at\
    \ this point\nhelp: consider specifying the type argument in the method call\n\
    \   |\n18 |     test.chars().map(|c| c as char).collect::<B>()\n   |         \
    \                                   +++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpalu0yv7x.rs:22:58\n   |\n22 |             let i = test.chars().filter(|c|\
    \ c as char == c).count() as isize;\n   |                                    \
    \                      ^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |             let i = test.chars().filter(|c|\
    \ c as char == *c).count() as isize;\n   |                                   \
    \                       +\n\nerror[E0606]: casting `&char` as `char` is invalid\n\
    \  --> /tmp/tmpalu0yv7x.rs:22:45\n   |\n22 |             let i = test.chars().filter(|c|\
    \ c as char == c).count() as isize;\n   |                                    \
    \         ^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0282, E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let mut s = String::new();\n    s.push_str(test);\n\
    \    for ch in s.chars() {\n        map.entry(ch).or_insert(0);\n    }\n    map\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8wo0g8qo.rs:20:16\n   |\n\
    20 |     s.push_str(test);\n   |                ^^^^\n   |                |\n\
    \   |                expected `&str`, found struct `String`\n   |            \
    \    help: consider borrowing here: `&test`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8wo0g8qo.rs:24:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n24 |     map\n   |   \
    \  ^^^ expected struct `String`, found `char`\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: -1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    histogram(test.chars().collect())\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976515
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ')\n        .into_iter()\n        .fold(HashMap::new(),\
    \ |mut map, (letter, count)| {\n            map.entry(letter).or_insert(count).cloned()\n\
    \        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbsur4eq.rs:20:41\n   |\n\
    20 |         .fold(HashMap::new(), |mut map, (letter, count)| {\n   |        \
    \                                 ^^^^^^^^^^^^^^-\n   |                      \
    \                   |             |\n   |                                    \
    \     |             expected due to this\n   |                               \
    \          expected `str`, found tuple\n   |\n   = note: expected type `str`\n\
    \             found tuple `(_, _)`\n\nerror[E0599]: `&mut isize` is not an iterator\n\
    \  --> /tmp/tmpkbsur4eq.rs:21:48\n   |\n21 |             map.entry(letter).or_insert(count).cloned()\n\
    \   |                                                ^^^^^^ `&mut isize` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `isize: Iterator`\n           which is required by `&mut isize: Iterator`\n\
    \           `&mut isize: Iterator`\n           which is required by `&mut &mut\
    \ isize: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut counters = HashMap::new();\n\n    for c in test.chars() {\n \
    \       let count = counters.entry(c.to_string()).or_insert(0);\n\n        *count\
    \ += 1;\n    }\n\n    counters\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmplocta9s3.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(' ')\n        .into_iter()\n        .fold(HashMap::new(),\
    \ |mut map, letter| {\n            if map.contains_key(&letter) {\n          \
    \      (*map)[letter] += 1;\n            } else {\n                map.insert(letter,\
    \ 1);\n            }\n            map\n        })\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Borrow<&str>` is not satisfied\n\
    \   --> /tmp/tmp1wmuawt8.rs:21:20\n    |\n21  |             if map.contains_key(&letter)\
    \ {\n    |                    ^^^^^^^^^^^^ the trait `Borrow<&str>` is not implemented\
    \ for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\n\
    error[E0614]: type `HashMap<String, isize>` cannot be dereferenced\n  --> /tmp/tmp1wmuawt8.rs:22:17\n\
    \   |\n22 |                 (*map)[letter] += 1;\n   |                 ^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1wmuawt8.rs:24:28\n   |\n24 |\
    \                 map.insert(letter, 1);\n   |                            ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Get a vector of all characters in the string\n    let mut char_vec\
    \ = Vec::with_capacity(test.chars().count());\n    for ch in test.chars() {\n\
    \        char_vec.push(ch.to_string());\n    }\n\n    // Sort the vector from\
    \ most to least repetition\n    char_vec.sort_by(|a, b| a.cmp(b));\n\n    // Convert\
    \ the sorted vector into a HashMap\n    HashMap::from_iter(char_vec.into_iter().cloned().enumerate().map(|(i,\
    \ ch)| (ch.to_string(), i + 1)).collect())\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `HashMap` in the current scope\n  --> /tmp/tmpiv4hq2l6.rs:28:14\n   |\n\
    28 |     HashMap::from_iter(char_vec.into_iter().cloned().enumerate().map(|(i,\
    \ ch)| (ch.to_string(), i + 1)).collect())\n   |              ^^^^^^^^^ function\
    \ or associated item not found in `HashMap<_, _, _>`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::iter::FromIterator;\n   |\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<String>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpiv4hq2l6.rs:28:45\n     |\n28   |\
    \     HashMap::from_iter(char_vec.into_iter().cloned().enumerate().map(|(i, ch)|\
    \ (ch.to_string(), i + 1)).collect())\n     |                                \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `enumerate` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpiv4hq2l6.rs:28:54\n   |\n28 |       HashMap::from_iter(char_vec.into_iter().cloned().enumerate().map(|(i,\
    \ ch)| (ch.to_string(), i + 1)).collect())\n   |                             \
    \                           ^^^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut hashmap = HashMap::new();\n    let mut words = test\n       \
    \ .lines()\n        .map(|s| s.to_string().to_lowercase().chars().count())\n \
    \       .collect()\n        .unwrap();\n    words.sort_by_key(|x| x.clone());\n\
    \    for (i, val) in words.iter().enumerate() {\n        hashmap.insert(String::from(&(i.to_string()[..])),\n\
    \                      (val.clone(), 1));\n    }\n    hashmap\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpw05_6f2r.rs:22:10\n\
    \   |\n22 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n22 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map: HashMap<String, isize> = HashMap::new();\n    for letter\
    \ in test.split(' ').map(String::from) {\n        match map.entry(letter) {\n\
    \            Occupied(mut e) => {\n                e.value += 1;\n           \
    \ }\n            Vacant(e) => {\n                e.insert(0);\n            }\n\
    \        }\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Occupied` in this\
    \ scope\n  --> /tmp/tmp5jqqfkgm.rs:21:13\n   |\n21 |             Occupied(mut\
    \ e) => {\n   |             ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::collections::btree_map::Entry::Occupied;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Occupied;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Occupied;\n\
    \   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Vacant` in this\
    \ scope\n  --> /tmp/tmp5jqqfkgm.rs:24:13\n   |\n24 |             Vacant(e) =>\
    \ {\n   |             ^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ one of these items\n   |\n1  | use std::collections::btree_map::Entry::Vacant;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Vacant;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Vacant;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0531`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut res = HashMap::new();\n    let mut counter = 0;\n    test.split(\"\
    \ \").map(|word| {\n        counter = res.entry(*word).or_insert(0);\n       \
    \ res.entry(*word).and_modify(|x| {\n            *x += 1;\n        });\n     \
    \   counter\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp43j3kn9g.rs:21:29\n    |\n21  |         counter = res.entry(*word).or_insert(0);\n\
    \    |                       ----- ^^^^^ doesn't have a size known at compile-time\n\
    \    |                       |\n    |                       required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `HashMap::<K, V, S>::entry`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp43j3kn9g.rs:18:19\n    |\n18  |     let mut res = HashMap::new();\n\
    \    |                   ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `HashMap::<K, V>::new`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n   --> /tmp/tmp43j3kn9g.rs:18:19\n\
    \    |\n18  |     let mut res = HashMap::new();\n    |                   ^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `HashMap`\n\nerror[E0599]:\
    \ the method `or_insert` exists for enum `std::collections::hash_map::Entry<'_,\
    \ str, _>`, but its trait bounds were not satisfied\n  --> /tmp/tmp43j3kn9g.rs:21:36\n\
    \   |\n21 |         counter = res.entry(*word).or_insert(0);\n   |           \
    \                         ^^^^^^^^^ method cannot be called on `std::collections::hash_map::Entry<'_,\
    \ str, _>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `str: Sized`\n\nerror[E0599]: the method\
    \ `entry` exists for struct `HashMap<str, _>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp43j3kn9g.rs:22:13\n   |\n22 |         res.entry(*word).and_modify(|x|\
    \ {\n   |             ^^^^^ method cannot be called on `HashMap<str, _>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `str: Sized`\n\ne"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(\" \")\n        .map(|x| x.to_string())\n        .map(|x|\
    \ x.to_lowercase())\n        .group_by(|x| x)\n        .map(|x| (x.key(), x.count()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp5sdw5wka.rs:21:10\n   |\n21 |         .group_by(|x|\
    \ x)\n   |          ^^^^^^^^ method not found in `Map<Map<std::str::Split<'_,\
    \ &str>, [closure@/tmp/tmp5sdw5wka.rs:19:14: 19:31]>, [closure@/tmp/tmp5sdw5wka.rs:20:14:\
    \ 20:34]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    use std::collections::HashMap;\n    histogram_inner(test, HashMap::new())\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `histogram_inner` in this scope\n  -->\
    \ /tmp/tmpwzqyeex0.rs:19:5\n   |\n19 |     histogram_inner(test, HashMap::new())\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: the item `HashMap`\
    \ is imported redundantly\n  --> /tmp/tmpwzqyeex0.rs:18:9\n   |\n1  | use std::collections::HashMap;\n\
    \   |     ------------------------- the item `HashMap` is already imported here\n\
    ...\n18 |     use std::collections::HashMap;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split_whitespace().map(|x| x.chars().map(|y| y.to_string()).collect()).fold(\n\
    \        HashMap::new(),\n        |mut acc, x| {\n            let mut count =\
    \ acc\n                .entry(x.to_string())\n                .or_insert(0);\n\
    \n            *count += 1;\n\n            acc\n        },\n    )\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4565xsh8.rs:20:19\n\
    \   |\n20 |         |mut acc, x| {\n   |                   ^ consider giving this\
    \ closure parameter a type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters: Vec<String>\
    \ = test.split_whitespace().collect();\n    let mut occurrences: Vec<usize> =\
    \ letters.iter().map(|&l| histogram.entry(l).or_insert(0))\n        .collect();\n\
    \n    while occurrences.len() > 0 {\n        histogram.entry(occurrences[0]).or_insert(occurrences[0]);\n\
    \        occurrences = occurrences.iter().filter(|&e| e != occurrences[0]).collect();\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpt1hip23s.rs:19:60\n     |\n19\
    \   |     let mut letters: Vec<String> = test.split_whitespace().collect();\n\
    \     |                                                            ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<usize>` cannot\
    \ be built from an iterator over elements of type `&mut {integer}`\n    --> /tmp/tmpt1hip23s.rs:21:10\n\
    \     |\n21   |         .collect();\n     |          ^^^^^^^ value of type `Vec<usize>`\
    \ cannot be built from `std::iter::Iterator<Item=&mut {integer}>`\n     |\n  \
    \   = help: the trait `FromIterator<&mut {integer}>` is not implemented for `Vec<usize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt1hip23s.rs:24:25\n\
    \   |\n24 |         histogram.entry(occurrences[0]).or_insert(occurrences[0]);\n\
    \   |                         ^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                         |\n   |                       \
    \  expected struct `String`, found `usize`\n\nerror[E0277]: can't compare `&usize`\
    \ with `usize`\n  --> /tmp/tmpt1hip23s.rs:25:56\n   |\n25 |         occurrences\
    \ = occurrences.iter().filter(|&e| e != occurrences[0]).collect();\n   |     \
    \                                                   ^^ no implementation for `&usize\
    \ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    use std::collections::HashMap;\n\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = String::from(test);\n    let mut count = 1;\n\n    while\
    \ letters.len() > 0 {\n        let mut new_letters = String::from(letters);\n\
    \        if histogram.contains_key(&new_letters) {\n            for (k, v) in\
    \ histogram.iter().cloned().max_by_key(|&(k, _)| k.chars().count(|c| c.unwrap()\
    \ == k.chars().nth(0).unwrap())) {\n                histogram.remove(&k);\n  \
    \          }\n        }\n\n        let mut new_count = count + 1;\n\n        if\
    \ histogram.contains_key(&new_letters) {\n            histogram\n            \
    \    .entry(new_letters)\n                .and_modify(|e| e.1 += new_count);\n\
    \        } else {\n            histogram.insert(new_letters, new_count);\n   \
    \     }\n\n        letters = new_letters;\n        count += 1;\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "warning: the item `HashMap` is imported redundantly\n  --> /tmp/tmpmf2804ey.rs:18:9\n\
    \   |\n1  | use std::collections::HashMap;\n   |     -------------------------\
    \ the item `HashMap` is already imported here\n...\n18 |     use std::collections::HashMap;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_,\
    \ _, _> as Iterator>::Item == &_`\n    --> /tmp/tmpmf2804ey.rs:27:44\n     |\n\
    27   |             for (k, v) in histogram.iter().cloned().max_by_key(|&(k, _)|\
    \ k.chars().count(|c| c.unwrap() == k.chars().nth(0).unwrap())) {\n     |    \
    \                                        ^^^^^^ expected reference, found tuple\n\
    \     |\n     = note: expected reference `&_`\n                    found tuple\
    \ `(&_, &_)`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `max_by_key` exists for struct `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, _>>`, but its trait bounds were not satisfied\n    --> /tmp/tmpmf2804ey.rs:27:53\n\
    \     |\n27   |               for (k, v) in histogram.iter().cloned().max_by_key(|&(k,\
    \ _)| k.chars().count(|c| c.unwrap() == k.chars().nth(0).unwrap())) {\n     |\
    \                                                       ^^^^^^^^^^ method cannot\
    \ be called on `Cloned<std::collections::hash_map::Iter<'_, _, _>>` due to unsatisfied\
    \ trait bounds\n     |\n     = note: the following trait bounds were not satisfied:\n\
    \             `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item\
    \ = &_`\n             which is required by `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, _>>: Iterator`\n             `Cloned<std::collections::hash_map::Iter<'_,\
    \ _, _>>: Iterator`\n             which is required by `&mut Cloned<std::collections::hash_map::Iter<'_,\
    \ _, _>>: Iterator`\n\nerror[E0609]: no field `1` on type `&mut _`\n  --> /tmp/tmpmf2804ey.rs:37:35\n\
    \   |\n37 |                 .and_modify(|e| e.1 += new_count);\n   |         \
    \                          ^\n\nerror: aborting due to 3 previous errors; 1 warning\
    \ emitted\n\nSome erro"
  stdout: ''
  timestamp: 1659976510
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    for character in test.chars()\
    \ {\n        if let Some(count) = histogram.get(&character.to_string()) {\n  \
    \          histogram.insert(character.to_string(), count + 1);\n        } else\
    \ {\n            histogram.insert(character.to_string(), 1);\n        }\n    }\n\
    \n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"b\": 2, \"a\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpe1s29m8k.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letter_count = HashMap::new();\n    for c in test.chars().fold(String::new(),\
    \ |mut acc, c| {\n        acc.push_str(&c.to_string());\n        acc.len()\n \
    \   }) {\n        if let Ok(count) = letter_count.entry(c).or_insert(0) {\n  \
    \          letter_count.entry(c).and_modify(|count| *count += 1);\n        }\n\
    \    }\n    letter_count\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3uud5hn6.rs:21:9\n   |\n\
    21 |         acc.len()\n   |         ^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |         |\n   |         expected struct `String`, found\
    \ `usize`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp3uud5hn6.rs:19:14\n\
    \   |\n19 |       for c in test.chars().fold(String::new(), |mut acc, c| {\n \
    \  |  ______________^\n20 | |         acc.push_str(&c.to_string());\n21 | |  \
    \       acc.len()\n22 | |     }) {\n   | |______^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3uud5hn6.rs:23:16\n   |\n23 |         if let Ok(count) = letter_count.entry(c).or_insert(0)\
    \ {\n   |                ^^^^^^^^^   ---------------------------------- this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Result`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Result<_, _>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut occurrences: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut words = test.split_whitespace();\n    while let Some(word) = words.next()\
    \ {\n        occurrences.entry(word).or_insert(0) += 1;\n    }\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoxpv8obh.rs:21:27\n   |\n\
    21 |         occurrences.entry(word).or_insert(0) += 1;\n   |                \
    \           ^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \                         |\n   |                           expected struct `String`,\
    \ found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut isize`\n  --> /tmp/tmpoxpv8obh.rs:21:9\n   |\n21 |         occurrences.entry(word).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be\
    \ used on `isize`, you can dereference `occurrences.entry(word).or_insert(0)`\n\
    \   |\n21 |         *occurrences.entry(word).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpoxpv8obh.rs:21:46\n\
    \   |\n21 |         occurrences.entry(word).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().\n        map(|c| {\n            c.to_string().\n      \
    \      chars().\n            count().\n            max(|a, b| b.cmp(a)).\n   \
    \         to_string()\n        }).\n        collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpmi621evn.rs:23:21\n\
    \   |\n23 |             max(|a, b| b.cmp(a)).\n   |                     ^ consider\
    \ giving this closure parameter a type\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0277]: a value of type `HashMap<String, isize>` cannot\
    \ be built from an iterator over elements of type `String`\n    --> /tmp/tmpmi621evn.rs:26:9\n\
    \     |\n26   |         collect()\n     |         ^^^^^^^ value of type `HashMap<String,\
    \ isize>` cannot be built from `std::iter::Iterator<Item=String>`\n     |\n  \
    \   = help: the trait `FromIterator<String>` is not implemented for `HashMap<String,\
    \ isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0282.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_string()).into_iter().map(|(letter, count)|\
    \ {\n        (letter, count).into()\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpkb552cid.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_string()).into_iter().map(|(letter, count)| {\n   |                  ^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // TODO: Improve perf for non-ASCII input\n    // let mut result = HashMap::new();\n\
    \    // let mut counter = HashMap::new();\n    // test.chars().filter(|c| c.is_lowercase()).for_each(|c|\
    \ {\n    //     result.entry(c).or_default() += 1;\n    //     counter.entry(c).or_default()\
    \ += 1;\n    // });\n\n    // use std::collections::HashSet;\n    // let mut result\
    \ = HashMap::new();\n    // let mut counter = HashMap::new();\n    // let mut\
    \ chars = test.chars();\n    // let mut letters = HashSet::new();\n    // for\
    \ (i, c) in chars.into_iter().enumerate() {\n    //     if c.is_lowercase() {\n\
    \    //         letters.push(i);\n    //     }\n    //     if letters.contains(i)\
    \ {\n    //         result.entry(c).or_default() += 1;\n    //         counter.entry(c).or_default()\
    \ += 1;\n    //     }\n    // }\n    let mut result = HashMap::new();\n    let\
    \ mut counter = HashMap::new();\n    let mut chars = test.chars();\n    let mut\
    \ letters = HashSet::new();\n    while let Some(i) = chars.iter().position(|&c|\
    \ c.is_lowercase()) {\n        // letters.push(i);\n        chars.remove(i);\n\
    \        letters.insert(i);\n        result.entry(chars.last().unwrap()).or_default()\
    \ += 1;\n        counter.entry(chars.last().unwrap()).or_default() += 1;\n   \
    \ }\n\n    // Reverse order of the entries if letters are sorted\n    if let Some(mut\
    \ i) = letters.iter().rev() {\n        result.entry(i).or_default() += 1;\n  \
    \      counter.entry(i).or_default() += 1;\n    }\n\n    // Reverse order of the\
    \ entries if letters are not sorted\n    // if let Some(mut i) = letters.iter().rev()\
    \ {\n    //     result.entry(i).or_default() += 1;\n    //     counter.entry(i).or_default()\
    \ += 1;\n    // }\n\n    // Reverse order of the entries if letters are not sorted,\
    \ but letters are sorted\n    // if let Some(mut i) = letters.iter().rev() {\n\
    \    //     result.entry(i).or_default() += 1;\n    //     counter.entry(i).or_default()\
    \ += 1;\n    // }\n\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpg46cvaq4.rs:43:23\n   |\n43 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `iter` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpg46cvaq4.rs:44:31\n   |\n44 |     while let Some(i) = chars.iter().position(|&c|\
    \ c.is_lowercase()) {\n   |                               ^^^^ private field,\
    \ not a method\n\nerror[E0599]: no method named `remove` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpg46cvaq4.rs:46:15\n   |\n46 |         chars.remove(i);\n\
    \   |               ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&mut _`\n  --> /tmp/tmpg46cvaq4.rs:48:9\n\
    \   |\n48 |         result.entry(chars.last().unwrap()).or_default() += 1;\n \
    \  |         ------------------------------------------------^^^^^\n   |     \
    \    |\n   |         cannot use `+=` on type `&mut _`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpg46cvaq4.rs:48:58\n   |\n48 |  \
    \       result.entry(chars.last().unwrap()).or_default() += 1;\n   |         ------------------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut _`\n  --> /tmp/tmpg46cvaq4.rs:49:9\n\
    \   |\n49 |         counter.entry(chars.last().unwrap()).or_default() += 1;\n\
    \   |         -------------------------------------------------^^^^^\n   |   \
    \      |\n   |         cannot use `+=` on type `&mut _`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpg46cvaq4.rs:49:59\n   |\n49 |  \
    \       counter.entry(chars.last().unwrap()).or_default() += 1;\n   |        \
    \ ------------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut letter_counts = HashMap::new();\n\
    \    let mut words = test\n        .split_whitespace()\n        .map(|x| x.chars().collect::<Vec<_>>())\n\
    \        .filter(|x| !x.is_empty());\n\n    while let Some(word) = words.pop()\
    \ {\n        let mut letter = String::from(\"\");\n\n        let mut count = 0;\n\
    \        for c in word {\n            if !letters.contains_key(&c) {\n       \
    \         letter += c;\n                letters.insert(c, 1);\n              \
    \  letter_counts.entry(c).or_insert(0) += 1;\n            }\n            else\
    \ {\n                let old_count = &mut letters[&c];\n                letters[&c]\
    \ += 1;\n                letter_counts[&c] += 1;\n                if old_count\
    \ > count {\n                    count = old_count;\n                }\n     \
    \       }\n        }\n    }\n\n    letters.into_iter().map(|&(k, _)| {\n     \
    \   let count = letter_counts[k];\n        let letter = k.to_string();\n     \
    \   (letter, count)\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpwr3ywieh.rs:25:34\n   |\n25 |     while let Some(word)\
    \ = words.pop() {\n   |                                  ^^^ method not found\
    \ in `Filter<Map<SplitWhitespace<'_>, [closure@/tmp/tmpwr3ywieh.rs:22:14: 22:47]>,\
    \ [closure@/tmp/tmpwr3ywieh.rs:23:17: 23:34]>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpwr3ywieh.rs:33:17\n\
    \   |\n33 |                 letter_counts.entry(c).or_insert(0) += 1;\n   |  \
    \               -----------------------------------^^^^^\n   |               \
    \  |\n   |                 cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `letter_counts.entry(c).or_insert(0)`\n\
    \   |\n33 |                 *letter_counts.entry(c).or_insert(0) += 1;\n   | \
    \                +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpwr3ywieh.rs:33:53\n   |\n33 |                 letter_counts.entry(c).or_insert(0)\
    \ += 1;\n   |                 ----------------------------------- ^^\n   |   \
    \              |\n   |                 cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwr3ywieh.rs:39:32\n   |\n39 |              \
    \   if old_count > count {\n   |                                ^^^^^\n   |  \
    \                              |\n   |                                expected\
    \ `&mut _`, found integer\n   |                                help: consider\
    \ mutably borrowing here: `&mut count`\n   |\n   = note: expected mutable reference\
    \ `&mut _`\n                           found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwr3ywieh.rs:40:29\n   |\n28 |         let mut\
    \ count = 0;\n   |                         - expected due to this value\n...\n\
    40 |                     count = old_count;\n   |                            \
    \ ^^^^^^^^^ expected integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n40 |                     count = *old_count;\n   |       \
    \                      +\n\ner"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::<String, isize>::new();\n    for letter\
    \ in test.split(' ') {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprd0dl458.rs:20:37\n   |\n\
    20 |         let count = histogram.entry(letter).or_insert(0);\n   |         \
    \                            ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                     |\n   |                            \
    \         expected struct `String`, found `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut chars = words.iter().cloned().collect::<HashSet<_>>();\n\
    \    while let Some(k) = chars.next_key() {\n        let count = chars.count(&k);\n\
    \        *histogram.entry(k).or_insert(count).cloned() = count;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpa2dukzy6.rs:20:53\n\
    \   |\n20 |     let mut chars = words.iter().cloned().collect::<HashSet<_>>();\n\
    \   |                                                     ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // We use itertools::groupby instead of std::collections::HashMap::group_by\
    \ because\n    // it preserves order. std::collections::HashMap::group_by does\
    \ not.\n    let mut occurrences = HashMap::new();\n\n    for pair in test\n  \
    \      .chars()\n        .flat_map(|c| c.chars().map(|c| (c, 1)))\n        .iter()\n\
    \        .group_by(|&(_, &count)| c)\n    {\n        occurrences.insert(\n   \
    \         pair.1.to_string(),\n            pair.iter().fold(0, |acc, e| acc +\
    \ e.1).clone(),\n        );\n    }\n\n    occurrences\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp7_0fgeib.rs:26:34\n\
    \   |\n26 |         .group_by(|&(_, &count)| c)\n   |                        \
    \          ^ not found in this scope\n\nerror[E0599]: no method named `chars`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp7_0fgeib.rs:24:25\n\
    \   |\n24 |         .flat_map(|c| c.chars().map(|c| (c, 1)))\n   |           \
    \              ^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::<String, isize>::new();\n\n    for ch in test.chars()\
    \ {\n        let count = letters.entry(ch.to_string()).or_insert(0);\n       \
    \ *count += 1;\n    }\n\n    letters.clone()\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"b\": 2, \"a\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp17ujra_3.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    HashMap::from_iter(test.split(' ').map(|x| x.to_string()).group_by(|x|\
    \ x).count().cloned().collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmplj254t2p.rs:18:23\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                                                 - closing delimiter possibly\
    \ meant for this\n18 |     HashMap::from_iter(test.split(' ').map(|x| x.to_string()).group_by(|x|\
    \ x).count().cloned().collect()\n   |                       ^ unclosed delimiter\n\
    19 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no function or associated\
    \ item named `from_iter` found for struct `HashMap` in the current scope\n  -->\
    \ /tmp/tmplj254t2p.rs:18:14\n   |\n18 |     HashMap::from_iter(test.split(' ').map(|x|\
    \ x.to_string()).group_by(|x| x).count().cloned().collect()\n   |            \
    \  ^^^^^^^^^ function or associated item not found in `HashMap<_, _, _>`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method\
    \ named `group_by` found for struct `Map` in the current scope\n  --> /tmp/tmplj254t2p.rs:18:63\n\
    \   |\n18 |     HashMap::from_iter(test.split(' ').map(|x| x.to_string()).group_by(|x|\
    \ x).count().cloned().collect()\n   |                                        \
    \                       ^^^^^^^^ method not found in `Map<std::str::Split<'_,\
    \ char>, [closure@/tmp/tmplj254t2p.rs:18:44: 18:61]>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split_whitespace().map(|s| s.to_lowercase()).group_by(|s| s)\n \
    \       .cloned()\n        .max_by_key(|(_, v)| v)\n        .map(|(_, v)| HashMap::from(vec![(String::from(&*k),\
    \ v) as (String, isize)]))\n        .unwrap_or_else(HashMap::new)\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `k` in this scope\n   --> /tmp/tmpcnarsz9r.rs:21:58\n\
    \    |\n21  |         .map(|(_, v)| HashMap::from(vec![(String::from(&*k), v)\
    \ as (String, isize)]))\n    |                                               \
    \           ^ help: a tuple variant with a similar name exists: `Ok`\n\nerror[E0599]:\
    \ no method named `group_by` found for struct `Map` in the current scope\n  -->\
    \ /tmp/tmpcnarsz9r.rs:18:55\n   |\n18 |     test.split_whitespace().map(|s| s.to_lowercase()).group_by(|s|\
    \ s)\n   |                                                       ^^^^^^^^ method\
    \ not found in `Map<SplitWhitespace<'_>, [closure@/tmp/tmpcnarsz9r.rs:18:33: 18:53]>`\n\
    \nerror[E0277]: the trait bound `HashMap<_, _, _>: From<Vec<(String, isize)>>`\
    \ is not satisfied\n  --> /tmp/tmpcnarsz9r.rs:21:23\n   |\n21 |         .map(|(_,\
    \ v)| HashMap::from(vec![(String::from(&*k), v) as (String, isize)]))\n   |  \
    \                     ^^^^^^^^^^^^^ the trait `From<Vec<(String, isize)>>` is\
    \ not implemented for `HashMap<_, _, _>`\n   |\n   = help: the trait `From<[(K,\
    \ V); N]>` is implemented for `HashMap<K, V>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::<String, isize>::new();\n    let mut input\
    \ = test.split_whitespace();\n    while !input.is_empty() {\n        for letter\
    \ in input.iter() {\n            match letters.get(&letter) {\n              \
    \  Some(count) => (letters.insert(letter, count + 1),),\n                None\
    \ => (letters.insert(letter, 1),),\n            }\n        }\n        input.pop();\n\
    \    }\n    letters\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpctw3gpu7.rs:20:18\n   |\n20 |     while\
    \ !input.is_empty() {\n   |                  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `iter` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpctw3gpu7.rs:21:29\n   |\n21 |         for letter\
    \ in input.iter() {\n   |                             ^^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpctw3gpu7.rs:22:13\n\
    \   |\n22 | /             match letters.get(&letter) {\n23 | |               \
    \  Some(count) => (letters.insert(letter, count + 1),),\n24 | |              \
    \   None => (letters.insert(letter, 1),),\n25 | |             }\n   | |      \
    \       ^- help: consider using a semicolon here: `;`\n   | |_____________|\n\
    \   |               expected `()`, found tuple\n   |\n   = note: expected unit\
    \ type `()`\n                  found tuple `(Option<isize>,)`\n\nerror[E0599]:\
    \ no method named `pop` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpctw3gpu7.rs:27:15\n   |\n27 |         input.pop();\n   |      \
    \         ^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    HashMap::from(test.chars().group_by(|&c| c.to_string()).collect())\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp12oj0ano.rs:18:32\n   |\n18 |     HashMap::from(test.chars().group_by(|&c|\
    \ c.to_string()).collect())\n   |                                ^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split(\" \")\n        .map(|x| x.to_lowercase())\n        .fold(HashMap::new(),\
    \ |mut map, x| {\n            map.entry(x).and_modify(|e| e.inc(1));\n       \
    \     map\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `inc` found for mutable reference `&mut isize`\
    \ in the current scope\n  --> /tmp/tmpdyakq0w6.rs:21:43\n   |\n21 |          \
    \   map.entry(x).and_modify(|e| e.inc(1));\n   |                             \
    \              ^^^ method not found in `&mut isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::<String, isize>::new();\n    let mut letters\
    \ = test.chars();\n    let mut count = 1;\n    while let Some(char) = letters.next()\
    \ {\n        if histogram.contains_key(&char) {\n            histogram.entry(char).or_insert(count).value\
    \ += 1;\n        } else {\n            histogram.insert(char.to_string(), count);\n\
    \            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Borrow<char>` is not satisfied\n\
    \   --> /tmp/tmpomlmvjdu.rs:22:22\n    |\n22  |         if histogram.contains_key(&char)\
    \ {\n    |                      ^^^^^^^^^^^^ the trait `Borrow<char>` is not implemented\
    \ for `String`\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashMap::<K, V, S>::contains_key`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpomlmvjdu.rs:23:29\n   |\n23 |  \
    \           histogram.entry(char).or_insert(count).value += 1;\n   |         \
    \                    ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                             |\n   |                             expected\
    \ struct `String`, found `char`\n\nerror[E0609]: no field `value` on type `&mut\
    \ isize`\n  --> /tmp/tmpomlmvjdu.rs:23:52\n   |\n23 |             histogram.entry(char).or_insert(count).value\
    \ += 1;\n   |                                                    ^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n\n    for letter in test.chars()\
    \ {\n        if let Some(count) = histogram.entry(letter).or_insert(0) {\n   \
    \         *count += 1;\n        }\n    }\n\n    histogram\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_g7ai1xe.rs:21:16\n   |\n\
    21 |         if let Some(count) = histogram.entry(letter).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^   ------------------------------------ this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_g7ai1xe.rs:26:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n26 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().fold(HashMap::new(), |mut map, c| {\n        let (letter,\
    \ repetitions) = c.splitn(2, \" \").unwrap();\n        map.entry(letter).or_insert(0)\
    \ += repetitions as isize;\n        map\n    })\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `splitn` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpn6o7rljc.rs:19:39\n   |\n19 |         let (letter, repetitions)\
    \ = c.splitn(2, \" \").unwrap();\n   |                                       ^^^^^^\
    \ method not found in `char`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&mut isize`\n  --> /tmp/tmpn6o7rljc.rs:20:9\n   |\n\
    20 |         map.entry(letter).or_insert(0) += repetitions as isize;\n   |   \
    \      ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut isize`\n   |\nhelp: `+=` can be used\
    \ on `isize`, you can dereference `map.entry(letter).or_insert(0)`\n   |\n20 |\
    \         *map.entry(letter).or_insert(0) += repetitions as isize;\n   |     \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpn6o7rljc.rs:20:40\n\
    \   |\n20 |         map.entry(letter).or_insert(0) += repetitions as isize;\n\
    \   |         ------------------------------ ^^\n   |         |\n   |        \
    \ cannot assign to this expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.split_whitespace().map(|s| s.to_lowercase()).fold(HashMap::new(),\
    \ |mut acc, s| {\n        match acc.get(&s) {\n            Some(a) => {\n    \
    \            *a += 1;\n                acc\n            }\n            None =>\
    \ {\n                acc.insert(s, 1);\n                acc\n            }\n \
    \       }\n    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*a`, which is behind a `&` reference\n\
    \  --> /tmp/tmp437h3sl_.rs:21:17\n   |\n20 |             Some(a) => {\n   |  \
    \                - help: consider changing this to be a mutable reference: `&mut\
    \ isize`\n21 |                 *a += 1;\n   |                 ^^^^^^^ `a` is a\
    \ `&` reference, so the data it refers to cannot be written\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0594`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letter_counts: HashMap<String, isize> = HashMap::new();\n   \
    \ let mut words = test.chars().filter(|c| !c.is_whitespace()).collect::<Vec<_>>();\n\
    \    for &c in words {\n        letter_counts.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    letter_counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoonnu26b.rs:20:9\n   |\n\
    20 |     for &c in words {\n   |         ^^    ----- this expression has type\
    \ `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut isize`\n  -->\
    \ /tmp/tmpoonnu26b.rs:21:9\n   |\n21 |         letter_counts.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -----------------------------------------------^^^^^\n \
    \  |         |\n   |         cannot use `+=` on type `&mut isize`\n   |\nhelp:\
    \ `+=` can be used on `isize`, you can dereference `letter_counts.entry(c.to_string()).or_insert(0)`\n\
    \   |\n21 |         *letter_counts.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpoonnu26b.rs:21:57\n\
    \   |\n21 |         letter_counts.entry(c.to_string()).or_insert(0) += 1;\n  \
    \ |         ----------------------------------------------- ^^\n   |         |\n\
    \   |         cannot assign to this expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976510
