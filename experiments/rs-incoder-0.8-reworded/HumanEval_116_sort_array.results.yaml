language: rs
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // write your solution here\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2p0rkklf.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| {\n        let mut sum\
    \ = 0;\n        let mut num_bits = 0;\n        for x in &x {\n            sum\
    \ += *x;\n            num_bits += *x;\n        }\n        num_bits\n    });\n\
    \    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&&isize` is not an iterator\n  --> /tmp/tmp4rbsys08.rs:15:18\n\
    \   |\n15 |         for x in &x {\n   |                  ^^ `&&isize` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&&isize`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.into_iter().sorted().collect()\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpyxr23v1y.rs:12:21\n   |\n12 |     arr.into_iter().sorted().collect()\n\
    \   |                     ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // TODO: Write your code here\n    return vec![];\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpmpwxyzuv.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut temp = arr;\n    temp.sort_by_key(|x|\
    \ {\n        x.to_bin().count() as isize // count the number of 1\n    })\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmph77ce8v3.rs:14:11\n   |\n14 |         x.to_bin().count()\
    \ as isize // count the number of 1\n   |           ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmph77ce8v3.rs:13:5\n   |\n11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                     ---------- expected `Vec<isize>`\
    \ because of return type\n12 |       let mut temp = arr;\n13 | /     temp.sort_by_key(|x|\
    \ {\n14 | |         x.to_bin().count() as isize // count the number of 1\n15 |\
    \ |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| one_in_base(b).cmp(&one_in_base(a)));\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `one_in_base` in this scope\n  --> /tmp/tmpdq4y6crr.rs:12:24\n\
    \   |\n12 |     arr.sort_by(|a, b| one_in_base(b).cmp(&one_in_base(a)));\n   |\
    \                        ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `one_in_base` in this scope\n  --> /tmp/tmpdq4y6crr.rs:12:44\n\
    \   |\n12 |     arr.sort_by(|a, b| one_in_base(b).cmp(&one_in_base(a)));\n   |\
    \                                            ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdq4y6crr.rs:11:35\n   |\n11 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by_key(|&x|\
    \ {\n        let x = binary_to_decimal(x);\n        let y = binary_to_decimal(vec![x\
    \ | 1]);\n        y.cmp(&x)\n    });\n    sorted_arr.clone()\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_to_decimal` in this scope\n\
    \  --> /tmp/tmp5jsnchd6.rs:14:17\n   |\n14 |         let x = binary_to_decimal(x);\n\
    \   |                 ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `binary_to_decimal` in this scope\n  --> /tmp/tmp5jsnchd6.rs:15:17\n\
    \   |\n15 |         let y = binary_to_decimal(vec![x | 1]);\n   |            \
    \     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min {\n            min = arr[i];\n        }\n    }\n\
    \    let mut pos = 0;\n    let mut max = -1;\n    for num in arr.iter() {\n  \
    \      if num >= min {\n            arr[pos] = num;\n            pos += 1;\n \
    \       }\n        if num > max {\n            max = num;\n        }\n    }\n\
    \    arr.drain(..pos);\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ouwumf6.rs:21:19\n   |\n\
    21 |         if num >= min {\n   |                   ^^^\n   |               \
    \    |\n   |                   expected `&isize`, found `isize`\n   |        \
    \           help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6ouwumf6.rs:22:24\n   |\n22 |             arr[pos] = num;\n\
    \   |             --------   ^^^ expected `isize`, found `&isize`\n   |      \
    \       |\n   |             expected due to the type of this binding\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n22 |             arr[pos] = *num;\n\
    \   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6ouwumf6.rs:25:18\n\
    \   |\n25 |         if num > max {\n   |                  ^^^\n   |          \
    \        |\n   |                  expected `&isize`, found integer\n   |     \
    \             help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6ouwumf6.rs:26:19\n   |\n19 |     let mut max = -1;\n \
    \  |                   -- expected due to this value\n...\n26 |             max\
    \ = num;\n   |                   ^^^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n26 |             max = *num;\n\
    \   |                   +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() < 2 {\n        return arr;\n \
    \   }\n\n    let mut num_ones = 0;\n    let mut num_dec = 0;\n\n    for i in arr\
    \ {\n        let j = i / 2;\n\n        // check which of i & j has more than 1\
    \ one\n        // for similar number of ones, sort based on decimal value\n  \
    \      if j % 2 == 1 {\n            if i & 1 == 0 {\n                // swap\n\
    \                num_ones = i + num_ones;\n                num_dec = num_dec +\
    \ 1;\n                i = j;\n            } else {\n                i = j;\n \
    \           }\n        } else {\n            if i & 1 == 1 {\n               \
    \ // swap\n                num_ones = i + num_ones;\n                num_dec =\
    \ num_dec + 1;\n                i = j;\n            } else {\n               \
    \ i = j;\n            }\n        }\n    }\n\n    if num_dec == 0 {\n        //\
    \ sort by number of ones\n        arr.sort_by_key(|x| num_ones);\n    } else {\n\
    \        // sort by decimal value\n        arr.sort_by_key(|x| {\n           \
    \ if x < 0 {\n                -num_dec < 0 ? 0 : -num_dec\n            } else\
    \ {\n                num_dec\n            }\n        });\n    }\n\n    arr\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `0`\n\
    \  --> /tmp/tmpesr6s4v4.rs:52:32\n   |\n52 |                 -num_dec < 0 ? 0\
    \ : -num_dec\n   |                                ^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpesr6s4v4.rs:51:20\n\
    \   |\n51 |             if x < 0 {\n   |                    ^\n   |          \
    \          |\n   |                    expected `&isize`, found integer\n   | \
    \                   help: consider borrowing here: `&0`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| {\n        // binary number\
    \ representation of x\n        let mut xbin = x.to_bin();\n        let mut ones\
    \ = Vec::new();\n        xbin.into_iter().for_each(|&b| {\n            if b ==\
    \ '1' {\n                ones.push(b);\n            }\n        });\n        //\
    \ sort according to number of ones\n        ones\n    }).collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmptcki2f5o.rs:14:26\n   |\n14 |         let mut\
    \ xbin = x.to_bin();\n   |                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0599]: `()` is not an iterator\n\
    \  --> /tmp/tmptcki2f5o.rs:23:8\n   |\n23 |     }).collect::<Vec<isize>>()\n \
    \  |        ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Write your code here.\n    let mut result\
    \ = vec![];\n    for i in 0..arr.len() {\n        if arr[i] == 0 {\n         \
    \   continue;\n        }\n        let ones = if arr.len() >= i + 1 {\n       \
    \     &arr[i + 1] - &arr[i]\n        } else {\n            0\n        };\n   \
    \     result.push((ones, i));\n    }\n    let mut min_value = 10000;\n    let\
    \ mut max_value = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n   \
    \ for i in 0..result.len() {\n        let (ones, i) = &result[i];\n        if\
    \ ones < min_value {\n            min_value = ones;\n            min_pos = i;\n\
    \        }\n        if ones > max_value {\n            max_value = ones;\n   \
    \         max_pos = i;\n        }\n    }\n    if min_value < max_value {\n   \
    \     for i in min_pos..max_pos {\n            result.swap(min_pos, i);\n    \
    \    }\n    }\n    for i in 0..result.len() {\n        let (ones, i) = &result[i];\n\
    \        if ones == min_value {\n            result.swap(min_pos, i);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt4m0i29.rs:31:19\n   |\n\
    31 |         if ones < min_value {\n   |                   ^^^^^^^^^\n   |   \
    \                |\n   |                   expected `&isize`, found integer\n\
    \   |                   help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqt4m0i29.rs:32:25\n   |\n25 |     let mut min_value\
    \ = 10000;\n   |                         ----- expected due to this value\n...\n\
    32 |             min_value = ones;\n   |                         ^^^^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             min_value = *ones;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqt4m0i29.rs:33:23\n   |\n27 |     let mut min_pos\
    \ = 0;\n   |                       - expected due to this value\n...\n33 |   \
    \          min_pos = i;\n   |                       ^ expected integer, found\
    \ `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \     min_pos = *i;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqt4m0i29.rs:35:19\n   |\n35 |         if ones > max_value\
    \ {\n   |                   ^^^^^^^^^\n   |                   |\n   |        \
    \           expected `&isize`, found integer\n   |                   help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqt4m0i29.rs:36:25\n\
    \   |\n26 |     let mut max_value = 0;\n   |                         - expected\
    \ due to this value\n...\n36 |             max_value = ones;\n   |           \
    \              ^^^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n36 |             max_value = *ones;\n   |                \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqt4m0i29.rs:37:23\n\
    \   |\n28 |     let mut max_pos = 0;\n   |                       - expected due\
    \ to this value\n...\n37 |             max_pos = i;\n   |                    \
    \   ^ expected integer, found `&usize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n37 |             max_pos = *i;\n   |          "
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Your code here\n    let mut ones = arr.len()\
    \ as isize;\n    loop {\n        if ones == 0 { break; }\n        let mut pos\
    \ = 0;\n        for v in arr {\n            if v == 1 {\n                ones\
    \ = ones - 1;\n                pos = pos + 1;\n            }\n        }\n    \
    \    let swap = arr[pos];\n        arr[pos] = arr[ones];\n        arr[ones] =\
    \ swap;\n    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps_tv99bk.rs:24:20\n\
    \   |\n24 |         arr[pos] = arr[ones];\n   |                    ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmps_tv99bk.rs:25:9\n   |\n25 |   \
    \      arr[ones] = swap;\n   |         ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().collect::<Vec<_>>().sort_by(|a,\
    \ b| {\n        let a_bin = a.to_bin();\n        let b_bin = b.to_bin();\n   \
    \     let a_ones = a_bin.count();\n        let b_ones = b_bin.count();\n     \
    \   if a_ones == b_ones {\n            // Sort by decimal value\n            let\
    \ a_int = a_ones * 10 + a_one.to_dec_value(b.to_dec());\n            let b_int\
    \ = a_ones * 10 + b_one.to_dec_value(b.to_dec());\n            a_int.cmp(b_int)\n\
    \        } else {\n            // Sort by number of ones\n            a_ones\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `a_one` in this scope\n  --> /tmp/tmpub_jz_ec.rs:19:39\n\
    \   |\n19 |             let a_int = a_ones * 10 + a_one.to_dec_value(b.to_dec());\n\
    \   |                                       ^^^^^ help: a local variable with\
    \ a similar name exists: `a_ones`\n\nerror[E0425]: cannot find value `b_one` in\
    \ this scope\n  --> /tmp/tmpub_jz_ec.rs:20:39\n   |\n20 |             let b_int\
    \ = a_ones * 10 + b_one.to_dec_value(b.to_dec());\n   |                      \
    \                 ^^^^^ help: a local variable with a similar name exists: `b_ones`\n\
    \nerror[E0599]: no method named `to_bin` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpub_jz_ec.rs:13:23\n   |\n13 |         let a_bin = a.to_bin();\n\
    \   |                       ^^^^^^ help: there is an associated function with\
    \ a similar name: `to_be`\n\nerror[E0599]: no method named `to_bin` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpub_jz_ec.rs:14:23\n \
    \  |\n14 |         let b_bin = b.to_bin();\n   |                       ^^^^^^\
    \ help: there is an associated function with a similar name: `to_be`\n\nerror[E0599]:\
    \ no method named `to_dec` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpub_jz_ec.rs:19:60\n   |\n19 |             let a_int = a_ones *\
    \ 10 + a_one.to_dec_value(b.to_dec());\n   |                                 \
    \                           ^^^^^^ help: there is an associated function with\
    \ a similar name: `to_be`\n\nerror[E0599]: no method named `to_dec` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpub_jz_ec.rs:20:60\n \
    \  |\n20 |             let b_int = a_ones * 10 + b_one.to_dec_value(b.to_dec());\n\
    \   |                                                            ^^^^^^ help:\
    \ there is an associated function with a similar name: `to_be`\n\nerror[E0277]:\
    \ cannot multiply `std::cmp::Ordering` by `{integer}`\n  --> /tmp/tmpub_jz_ec.rs:19:32\n\
    \   |\n19 |             let a_int = a_ones * 10 + a_one.to_dec_value(b.to_dec());\n\
    \   |                                ^ no implementation for `std::cmp::Ordering\
    \ * {integer}`\n   |\n   = help:"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter = HashMap::new();\n    for\
    \ i in arr {\n        let mut tmp = 0;\n        while i && tmp > 0 {\n       \
    \     if i & 1 == 1 {\n                counter.insert((i >> 1) as isize, 1);\n\
    \            }\n            i = i >> 1;\n            tmp = tmp + 1;\n        }\n\
    \    }\n    arr.sort_by_key(|a| counter.get(&a).unwrap());\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5iji75or.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5iji75or.rs:15:15\n   |\n15 |         while\
    \ i && tmp > 0 {\n   |               ^ expected `bool`, found `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // 1. Sort arr using selection sort\n    let\
    \ mut i = 0;\n    let mut j = 0;\n\n    while i < arr.len() {\n        // Find\
    \ the position of minimum value in arr\n        while j < (arr.len() - i) && arr[j]\
    \ == arr[j + 1] {\n            j += 1; // Move to the next index position\n  \
    \      }\n\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j]\
    \ = temp;\n\n        i += 1;\n        j += 1;\n    }\n\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpf6k5vjy9.rs:23:9\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n23 |         arr[i] = arr[j];\n   |         ^^^ cannot borrow\
    \ as mutable\n\nerror[E0596]: cannot borrow `arr` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpf6k5vjy9.rs:24:9\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n24 |         arr[j] = temp;\n   |         ^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut n = arr.len();\n    r.sort_by_key(\n\
    \        &arr[..n].iter().map(|&x| if x == 0 {0} else {1}).collect::<Vec<_>>(),\n\
    \        |&(k1, k2)| if k1 < k2 {-1} else {1},\n    );\n    r.sort_by_key(\n \
    \       &arr[..n].iter().map(|&x| if x == 0 {0} else {(x as usize)}).collect::<Vec<_>>(),\n\
    \        |&(k1, k2)| if k1 < k2 {1} else {-1},\n    );\n    r.rev()\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `r` in this scope\n  --> /tmp/tmpwit1fce9.rs:13:5\n\
    \   |\n13 |     r.sort_by_key(\n   |     ^ help: a local variable with a similar\
    \ name exists: `n`\n\nerror[E0425]: cannot find value `r` in this scope\n  -->\
    \ /tmp/tmpwit1fce9.rs:17:5\n   |\n17 |     r.sort_by_key(\n   |     ^ help: a\
    \ local variable with a similar name exists: `n`\n\nerror[E0425]: cannot find\
    \ value `r` in this scope\n  --> /tmp/tmpwit1fce9.rs:21:5\n   |\n21 |     r.rev()\n\
    \   |     ^ help: a local variable with a similar name exists: `n`\n\nwarning:\
    \ unnecessary parentheses around block return value\n  --> /tmp/tmpwit1fce9.rs:18:55\n\
    \   |\n18 |         &arr[..n].iter().map(|&x| if x == 0 {0} else {(x as usize)}).collect::<Vec<_>>(),\n\
    \   |                                                       ^          ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n18 -         &arr[..n].iter().map(|&x| if x == 0 {0} else {(x as usize)}).collect::<Vec<_>>(),\n\
    18 +         &arr[..n].iter().map(|&x| if x == 0 {0} else {x as usize}).collect::<Vec<_>>(),\n\
    \   | \n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Write your code here.\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcebkxva2.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut sort_index = 0;\n    let mut sort_vec: Vec<_> = Vec::new();\n\
    \    let mut ones: Vec<isize> = Vec::new();\n    let mut decimal: Vec<isize> =\
    \ Vec::new();\n    for idx in 0..arr.len() {\n        if arr[idx] == 1 {\n   \
    \         sort_vec.push(idx);\n            sort_index.push(sort_vec.len() - 1);\n\
    \            ones.push_back(idx);\n        } else {\n            decimal.push(idx);\n\
    \        }\n    }\n    for i in ones.iter() {\n        for j in sort_index.iter_mut()\
    \ {\n            if j == i {\n                sort_vec[j + 1] = sort_vec[j];\n\
    \            }\n        }\n    }\n    for i in decimal.iter() {\n        for j\
    \ in sort_index.iter_mut() {\n            if j == i {\n                sort_vec[j\
    \ + 1] = decimal[j];\n            }\n        }\n    }\n    sort_vec.reverse();\n\
    \    sort_vec\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmpdexgs_a_.rs:22:24\n   |\n22 |             sort_index.push(sort_vec.len()\
    \ - 1);\n   |                        ^^^^ method not found in `{integer}`\n\n\
    error[E0599]: no method named `push_back` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpdexgs_a_.rs:23:18\n   |\n23 |             ones.push_back(idx);\n\
    \   |                  ^^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdexgs_a_.rs:25:26\n   |\n25 |             decimal.push(idx);\n\
    \   |                          ^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |             decimal.push(idx.try_into().unwrap());\n   |   \
    \                          ++++++++++++++++++++\n\nerror[E0599]: no method named\
    \ `iter_mut` found for type `{integer}` in the current scope\n  --> /tmp/tmpdexgs_a_.rs:29:29\n\
    \   |\n29 |         for j in sort_index.iter_mut() {\n   |                   \
    \          ^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method\
    \ named `iter_mut` found for type `{integer}` in the current scope\n  --> /tmp/tmpdexgs_a_.rs:36:29\n\
    \   |\n36 |         for j in sort_index.iter_mut() {\n   |                   \
    \          ^^^^^^^^ method not found in `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdexgs_a_.rs:43:5\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                   ---------- expected\
    \ `Vec<isize>` because of return type\n...\n43 |     sort_vec\n   |     ^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = vec![];\n    for i in arr {\n\
    \        if i == 1:\n            vec.push(i);\n        }\n    }\n    let mut sorted_arr\
    \ = vec![];\n    for i in vec.iter().rev() {\n        sorted_arr.push(vec![i]);\n\
    \    }\n    sorted_arr.sort();\n    sorted_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpetnoxkv9.rs:24:1\n\
    \   |\n19 |     for i in vec.iter().rev() {\n   |                            \
    \   - this opening brace...\n20 |         sorted_arr.push(vec![i]);\n21 |    \
    \ }\n   |     - ...matches this closing brace\n...\n24 | }\n   | ^ unexpected\
    \ closing delimiter\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by_key(|x|\
    \ {\n        if x % 2 == 0 {\n            x.to_bin().count().from_dec().unwrap()\n\
    \        } else {\n            x.to_dec().unwrap()\n        }\n    });\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpn47u54gv.rs:15:15\n   |\n15 |             x.to_bin().count().from_dec().unwrap()\n\
    \   |               ^^^^^^ help: there is an associated function with a similar\
    \ name: `to_be`\n\nerror[E0599]: no method named `to_dec` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpn47u54gv.rs:17:15\n   |\n17 | \
    \            x.to_dec().unwrap()\n   |               ^^^^^^ help: there is an\
    \ associated function with a similar name: `to_be`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort_by(|a, b| a.leading_zeros().cmp(b.leading_zeros()))\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp6cckitj_.rs:12:25\n   |\n12 |     arr.iter().cloned().sort_by(|a,\
    \ b| a.leading_zeros().cmp(b.leading_zeros()))\n   |                         ^^^^^^^\
    \ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.to_owned();\n    let mut\
    \ i = 0;\n    let mut num = 0;\n    while i < arr.len() {\n        let mut x =\
    \ arr[i];\n        if x != 0 {\n            arr[num] = x;\n            num +=1;\n\
    \        }\n        i += 1;\n    }\n    arr.swap(0, num);\n    arr.to_owned()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmp5v28vsyh.rs:23:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut s = Vec::with_capacity(arr.len());\n    let mut n = arr.len();\n\
    \    for v in arr.iter() {\n        let mut m = v as usize;\n        while m >\
    \ 0 {\n            s << m & 1;\n            n -= 1;\n            m >>= 1;\n  \
    \      }\n    }\n    s.sort_unstable();\n    for i in 0..n {\n        arr[i] =\
    \ s[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `Vec<_> << usize`\n  --> /tmp/tmp_3lc6j8r.rs:20:15\n\
    \   |\n20 |             s << m & 1;\n   |             - ^^ - usize\n   |     \
    \        |\n   |             Vec<_>\n\nerror[E0606]: casting `&isize` as `usize`\
    \ is invalid\n  --> /tmp/tmp_3lc6j8r.rs:18:21\n   |\n18 |         let mut m =\
    \ v as usize;\n   |                     -^^^^^^^^^\n   |                     |\n\
    \   |                     cannot cast `&isize` as `usize`\n   |              \
    \       help: dereference the expression: `*v`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort_by_key(|&x| {\n  \
    \      match x {\n            0 => -1,\n            _ => x.count_ones() as isize,\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpm71ppcel.rs:12:25\n   |\n12 |     arr.iter().cloned().sort_by_key(|&x|\
    \ {\n   |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0689]: can't call method `count_ones` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmpm71ppcel.rs:15:20\n   |\n12 |     arr.iter().cloned().sort_by_key(|&x|\
    \ {\n   |                                       - you must specify a type for\
    \ this binding, like `i32`\n...\n15 |             _ => x.count_ones() as isize,\n\
    \   |                    ^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable_by(|a,\
    \ b| {\n        let ones_count = count_ones(arr);\n        ones_count.binary_search(&b).unwrap()\n\
    \    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_ones` in this scope\n  --> /tmp/tmp9z2gq_mu.rs:14:26\n\
    \   |\n14 |         let ones_count = count_ones(arr);\n   |                  \
    \        ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return arr;\n\
    \    }\n    let mut counts = vec![];\n    for i in arr {\n        if i > 0 {\n\
    \            counts.push(i);\n        }\n    }\n    let mut sorted_arr = vec![];\n\
    \    for i in counts {\n        sorted_arr.push(i);\n    }\n    sorted_arr.sort();\n\
    \    for i in sorted_arr {\n        arr.swap(i, sorted_arr.iter().find(|&x| x\
    \ == i).unwrap());\n    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpld_jumfl.rs:27:18\n   |\n\
    27 |         arr.swap(i, sorted_arr.iter().find(|&x| x == i).unwrap());\n   |\
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    27 |         arr.swap(i.try_into().unwrap(), sorted_arr.iter().find(|&x| x ==\
    \ i).unwrap());\n   |                   ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpld_jumfl.rs:27:51\n   |\n\
    27 |         arr.swap(i, sorted_arr.iter().find(|&x| x == i).unwrap());\n   |\
    \                                                   ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpld_jumfl.rs:27:21\n\
    \   |\n27 |         arr.swap(i, sorted_arr.iter().find(|&x| x == i).unwrap());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut bins = vec![];\n    let mut ones = vec![];\n    for (i, &b)\
    \ in arr.iter().enumerate() {\n        if *b == 1 {\n            ones.push(i);\n\
    \        } else {\n            bins.push(*b);\n        }\n    }\n    if ones.len()\
    \ > 0 {\n        sort_array(&mut bins, &mut ones);\n    }\n    if bins.len() ==\
    \ 0 {\n        return arr;\n    }\n    let mut min = 0;\n    let mut max = bins.len();\n\
    \    while min < max {\n        let mid = (min + max) / 2;\n        let midval\
    \ = bins[mid];\n        let midones = ones[mid];\n        if midval == 0 {\n \
    \           min = mid + 1;\n        } else if (midval > 0) {\n            min\
    \ = mid + 1;\n        } else {\n            max = mid - 1;\n        }\n    }\n\
    \    let mut newarr = vec![];\n    for (i, &b) in arr.iter().enumerate() {\n \
    \       if i < min {\n            newarr.push(*b);\n        }\n        if i >\
    \ max {\n            newarr.push(*b);\n        }\n    }\n    if newarr.is_empty()\
    \ {\n        return arr;\n    }\n    sort_array(newarr, &ones);\n    newarr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp33c146yf.rs:38:19\n\
    \   |\n38 |         } else if (midval > 0) {\n   |                   ^       \
    \   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n38 -         } else if (midval > 0) {\n38 +         } else\
    \ if midval > 0 {\n   | \n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp33c146yf.rs:18:12\n   |\n18 |         if *b == 1 {\n   |      \
    \      ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp33c146yf.rs:21:23\n\
    \   |\n21 |             bins.push(*b);\n   |                       ^^\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmp33c146yf.rs:25:9\n\
    \   |\n25 |         sort_array(&mut bins, &mut ones);\n   |         ^^^^^^^^^^\
    \ ---------  --------- supplied 2 arguments\n   |         |\n   |         expected\
    \ 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp33c146yf.rs:11:4\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ^^^^^^^^^^\
    \ ---------------\n\nerror[E0614]: type `isize` cannot be dereferenced\n  -->\
    \ /tmp/tmp33c146yf.rs:47:25\n   |\n47 |             newarr.push(*b);\n   |   \
    \                      ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp33c146yf.rs:50:25\n   |\n50 |             newarr.push(*b);\n  \
    \ |                         ^^\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n  --> /tmp/tmp33c146yf.rs:56:5\n   |\n56 |  \
    \   sort_array(newarr, &ones);\n   |     ^^^^^^^^^^ ------  ----- supplied 2 arguments\n\
    \   |     |\n   |     expected 1 argument\n   |\nnote: function defined here\n\
    \  --> /tmp/tmp33c146yf.rs:11:4\n   |\n11 | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |    ^^^^^^^^^^ ---------------\n\nerror: aborting due to 6\
    \ previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0061, E0614.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n\n    for i in arr\
    \ {\n        if i % 2 == 0 {\n            result.push(i);\n        } else {\n\
    \            let index = arr.iter().position(|&x| x % 2 == 0).unwrap();\n    \
    \        result.push(arr.swap_remove(index));\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp_5xc4hjx.rs:18:25\n\
    \    |\n11  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \     --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |             let\
    \ index = arr.iter().position(|&x| x % 2 == 0).unwrap();\n    |              \
    \           ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\n    = note: borrow\
    \ occurs due to deref coercion to `[isize]`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14\
    \  |     for i in &arr {\n    |              +\n\nerror[E0596]: cannot borrow\
    \ `arr` as mutable, as it is not declared as mutable\n  --> /tmp/tmp_5xc4hjx.rs:19:25\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \  --- help: consider changing this to be mutable: `mut arr`\n...\n19 |      \
    \       result.push(arr.swap_remove(index));\n   |                         ^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut num_ones = arr.len();\n    let mut\
    \ decimal_val = num_ones;\n    let mut current_ones = 0;\n    let mut i = 0;\n\
    \    while i < num_ones {\n        if arr[i] > 0 {\n            current_ones +=\
    \ 1;\n        }\n\n        if current_ones == 2 {\n            i += 1;\n     \
    \       num_ones = i;\n            decimal_val = 0;\n            current_ones\
    \ = 1;\n        } else {\n            decimal_val += 1;\n            current_ones\
    \ = 0;\n        }\n    }\n\n    arr[..num_ones].iter().cloned().sort();\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmp2ab8hex8.rs:32:37\n   |\n32 |     arr[..num_ones].iter().cloned().sort();\n\
    \   |                                     ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut arr2 = arr.iter().cloned().collect::<Vec<isize>>();\n    let\
    \ mut max = 0;\n    for i in arr2 {\n        if max < i {\n            max = i;\n\
    \        }\n    }\n    for i in arr2 {\n        if max > i {\n            swap(&mut\
    \ arr2, i, max);\n        }\n    }\n    arr2\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp05rd7dgh.rs:24:13\n\
    \   |\n24 |             swap(&mut arr2, i, max);\n   |             ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter = HashMap::new();\n    for\
    \ &i in arr {\n        let mut v = counter.entry(i).or_insert(0);\n        *v\
    \ += 1;\n    }\n    let mut result = vec![];\n    for (i, v) in counter.into_iter().sorted_by(|a,\
    \ b| a.cmp(&b)) {\n        result.push(i);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpz6dwandz.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz6dwandz.rs:13:9\n   |\n13 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        if a > b {\n\
    \            1\n        } else if a < b {\n            -1\n        } else {\n\
    \            0\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpttwjym9j.rs:14:13\n   |\n\
    14 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpttwjym9j.rs:16:13\n\
    \   |\n16 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpttwjym9j.rs:18:13\n\
    \   |\n18 |             0\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr2 = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    arr2.sort_by(|a, b| {\n        if a == 0 || b == 0 {\n            return\
    \ a.cmp(b);\n        }\n\n        let mut a = *a;\n        let mut b = *b;\n \
    \       if a > b {\n            return 1;\n        }\n        if b > a {\n   \
    \         return -1;\n        }\n        a.cmp(b)\n    });\n    arr2.collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpc1swv9kp.rs:14:14\n\
    \   |\n14 |         if a == 0 || b == 0 {\n   |              ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpc1swv9kp.rs:14:24\n   |\n14 |         if a ==\
    \ 0 || b == 0 {\n   |                        ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1swv9kp.rs:21:20\n\
    \   |\n21 |             return 1;\n   |                    ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1swv9kp.rs:26:15\n\
    \   |\n26 |         a.cmp(b)\n   |               ^\n   |               |\n   |\
    \               expected `&isize`, found `isize`\n   |               help: consider\
    \ borrowing here: `&b`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   -->\
    \ /tmp/tmpc1swv9kp.rs:28:10\n    |\n28  |       arr2.collect()\n    |        \
    \    ^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut bins = vec![];\n    for i in arr.iter()\
    \ {\n        bins.push(i);\n    }\n    let mut max = 0;\n    for i in bins.iter()\
    \ {\n        if *i >= max {\n            max = *i;\n        }\n    }\n    let\
    \ mut arr2 = vec![];\n    for i in arr.iter() {\n        if *i >= max {\n    \
    \        arr2.push(*i);\n        }\n    }\n    arr2.sort();\n    for i in 0..max-1\
    \ {\n        arr2.push(arr2[i]);\n    }\n    for i in arr2.iter() {\n        arr2.push(i);\n\
    \    }\n    return arr2\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphqhw3tj7.rs:18:18\n   |\n\
    18 |         if *i >= max {\n   |                  ^^^\n   |                 \
    \ |\n   |                  expected `&isize`, found integer\n   |            \
    \      help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphqhw3tj7.rs:19:19\n   |\n16 |     let mut max = 0;\n   |      \
    \             - expected due to this value\n...\n19 |             max = *i;\n\
    \   |                   ^^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |             max = **i;\n   |          \
    \         +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmphqhw3tj7.rs:30:19\n   |\n30 |         arr2.push(arr2[i]);\n   |\
    \                   ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphqhw3tj7.rs:33:19\n   |\n33 |\
    \         arr2.push(i);\n   |                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |         arr2.push(*i);\n\
    \   |                   +\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| x.count()).reverse().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&isize` is not an iterator\n  --> /tmp/tmp6gd_w31n.rs:12:27\n\
    \   |\n12 |     arr.sort_by_key(|x| x.count()).reverse().collect()\n   |     \
    \                      ^^^^^ `&isize` is not an iterator\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `&isize: Iterator`\n\
    \           which is required by `&mut &isize: Iterator`\n           `isize: Iterator`\n\
    \           which is required by `&mut isize: Iterator`\n\nerror[E0599]: no method\
    \ named `reverse` found for unit type `()` in the current scope\n  --> /tmp/tmp6gd_w31n.rs:12:36\n\
    \   |\n12 |     arr.sort_by_key(|x| x.count()).reverse().collect()\n   |     \
    \                               ^^^^^^^ method not found in `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().enumerate().sorted().for_each(|(i,\
    \ el)| {\n        if *el != i {\n            *el = i;\n        }\n    });\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp68uxmos6.rs:12:28\n   |\n12 |     arr.iter().enumerate().sorted().for_each(|(i,\
    \ el)| {\n   |                            ^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return arr;\n\
    \    }\n\n    let mut arr = arr.to_owned();\n    arr.sort();\n    arr\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpzvqds_qd.rs:23:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().rev().chain(arr.iter().enumerate().rev()).\n\
    \        sort_by(|(&i, &j)| {\n            match i.to_binary() {\n           \
    \     None => Some(j.to_dec()),\n                Some(\"1\") => Some(j.to_dec()),\n\
    \                Some(\"0\") => Some(i.to_dec()),\n            }\n        }).\n\
    \        map(|i| i.1).\n        collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Rev<Enumerate<std::slice::Iter<'_,\
    \ isize>>> as IntoIterator>::Item == &isize`\n   --> /tmp/tmp6rwevw9d.rs:12:22\n\
    \    |\n12  |     arr.iter().rev().chain(arr.iter().enumerate().rev()).\n    |\
    \                      ^^^^^ expected `&isize`, found tuple\n    |\n    = note:\
    \ expected reference `&isize`\n                   found tuple `(usize, &isize)`\n\
    note: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]: no\
    \ method named `sort_by` found for struct `std::iter::Chain` in the current scope\n\
    \  --> /tmp/tmp6rwevw9d.rs:13:9\n   |\n13 |         sort_by(|(&i, &j)| {\n   |\
    \         ^^^^^^^ method not found in `std::iter::Chain<Rev<std::slice::Iter<'_,\
    \ isize>>, Rev<Enumerate<std::slice::Iter<'_, isize>>>>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter()\n        .enumerate()\n        .sorted()\n\
    \        .map(|(i, count)| if count == 1 {\n            -i - 1\n        } else\
    \ {\n            -i.to_dec()\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmph0zuzkic.rs:14:10\n   |\n14 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // TODO: implement your solution here\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_vilt6c.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = arr;\n    let mut num_ones =\
    \ 1;\n\n    for i in arr.iter().rev() {\n        if *i & 1 != 1 {\n          \
    \  swap(&mut num_ones, &mut res.last());\n        }\n    }\n\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpktzijl3p.rs:17:13\n\
    \   |\n17 |             swap(&mut num_ones, &mut res.last());\n   |          \
    \   ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    arr\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp9a9tr1of.rs:12:5\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n12 |     arr.sort();\n   |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // The first two numbers are the two numbers\
    \ with largest number of ones.\n    let (a, b) = if arr.len() > 2 {\n        std::cmp::max(a,\
    \ b)\n    } else {\n        std::cmp::max(a, b)\n    };\n    // If the number\
    \ of ones is different, we need to sort the array using decimal value.\n    if\
    \ a.count_ones() != b.count_ones() {\n        sort_array_by_decimal(arr)\n   \
    \ } else {\n        vec![a]\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmpoks2tmpd.rs:14:23\n\
    \   |\n14 |         std::cmp::max(a, b)\n   |                       ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpoks2tmpd.rs:14:26\n\
    \   |\n14 |         std::cmp::max(a, b)\n   |                          ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmpoks2tmpd.rs:16:23\n\
    \   |\n16 |         std::cmp::max(a, b)\n   |                       ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpoks2tmpd.rs:16:26\n\
    \   |\n16 |         std::cmp::max(a, b)\n   |                          ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `sort_array_by_decimal`\
    \ in this scope\n  --> /tmp/tmpoks2tmpd.rs:20:9\n   |\n20 |         sort_array_by_decimal(arr)\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    for i in (0..arr.len()).rev() {\n        arr.swap(i,\
    \ sort_array(arr[i..].iter().cloned().rev().cloned()).rev().iter().cloned().rev().index());\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmpqv_fdho7.rs:13:63\n     |\n13   | \
    \        arr.swap(i, sort_array(arr[i..].iter().cloned().rev().cloned()).rev().iter().cloned().rev().index());\n\
    \     |                                                               ^^^^^^ expected\
    \ reference, found `isize`\n     |\n     = note: expected reference `&&_`\n  \
    \              found reference `&isize`\n     = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, isize>>`\n\
    note: required by a bound in `cloned`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqv_fdho7.rs:13:32\n   |\n13 |         arr.swap(i, sort_array(arr[i..].iter().cloned().rev().cloned()).rev().iter().cloned().rev().index());\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Cloned<Rev<Cloned<std::slice::Iter<'_, isize>>>>`\n\
    \nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpqv_fdho7.rs:13:73\n\
    \    |\n13  |           arr.swap(i, sort_array(arr[i..].iter().cloned().rev().cloned()).rev().iter().cloned().rev().index());\n\
    \    |                                                                       \
    \    ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<isize>: Iterator`\n           \
    \ which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n\
    \            which is required by `&mut [isize]: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), arr.iter().filter(|&x|\
    \ x > 0).count());\n    let mut res = vec![0; arr.len()];\n    for i in 0..res.len()\
    \ {\n        let mut bin = String::new();\n        for &x in arr {\n         \
    \   if x != 0 {\n                bin.push((x % 2) as char);\n            }\n \
    \       }\n        bin.trim().to_string().parse().unwrap()\n            .to_string()\
    \ + i\n            .to_string() + bin\n            .to_string()\n            .parse()\n\
    \            .unwrap()\n            .to_string()\n            .chars()\n     \
    \       .enumerate()\n            .map(|(i, c)| if c.1 == 1 { c.0 } else { None\
    \ })\n            .max()\n            .unwrap_or_else(|| 0);\n        res[i] =\
    \ bin.parse().unwrap();\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdk0872n1.rs:12:54\n   |\n\
    12 |     assert_eq!(arr.len(), arr.iter().filter(|&x| x > 0).count());\n   | \
    \                                                     ^\n   |                \
    \                                      |\n   |                               \
    \                       expected `&isize`, found integer\n   |               \
    \                                       help: consider borrowing here: `&0`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdk0872n1.rs:16:13\n   |\n16 |  \
    \       for &x in arr {\n   |             ^^    --- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Use binary search algorithm to find the\
    \ right position of ones and put the value there\n    let mut l = arr[0];\n  \
    \  let mut r = arr[arr.len() - 1];\n    let mut pos = 0;\n    while l < r {\n\
    \        let m = (l + r) / 2;\n        if arr[m] % 2 == 1 {\n            pos =\
    \ m;\n            l = m;\n        } else {\n            r = m;\n        }\n  \
    \  }\n\n    arr.swap(0, pos);\n\n    for i in 0..(arr.len() - 1) {\n        if\
    \ arr[i + 1] - arr[i] != 1 {\n            arr.swap(i + 1, i + 2);\n        }\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwa3th7vf.rs:18:12\n\
    \   |\n18 |         if arr[m] % 2 == 1 {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwa3th7vf.rs:26:17\n\
    \   |\n26 |     arr.swap(0, pos);\n   |                 ^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n26 |     arr.swap(0, pos.try_into().unwrap());\n\
    \   |                    ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_val = std::i32::MAX;\n    let mut\
    \ max_val = std::i32::MIN;\n    for elem in &arr {\n        let val = elem.checked_mul(2).unwrap();\n\
    \        if min_val > val {\n            min_val = val;\n        }\n        if\
    \ max_val < val {\n            max_val = val;\n        }\n    }\n    let mut arr2\
    \ = vec![];\n    for i in 0..arr.len() {\n        if arr[i] > max_val {\n    \
    \        arr2.push(arr[max_val.to_i64()]);\n            max_val = max_val + std::i32::MAX;\n\
    \        }\n        if arr[i] < min_val {\n            arr2.push(arr[min_val.to_i64()]);\n\
    \            min_val = min_val - std::i32::MIN;\n        }\n    }\n    arr2\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ja89r7y.rs:16:22\n   |\n\
    16 |         if min_val > val {\n   |                      ^^^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n16 |         if min_val > val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5ja89r7y.rs:17:23\n   |\n12 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = val;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ja89r7y.rs:19:22\n\
    \   |\n19 |         if max_val < val {\n   |                      ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n19 |         if max_val < val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5ja89r7y.rs:20:23\n   |\n13 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = val;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ja89r7y.rs:25:21\n\
    \   |\n25 |         if arr[i] > max_val {\n   |                     ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         if arr[i] > max_val.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `to_i64` found for type `i32` in the current scope\n  --> /tmp/tmp5ja89r7y.rs:26:35\n\
    \   |\n26 |             arr2.push(arr[max_val.to_i64()]);\n   |              \
    \                     ^^^^^^ method not found in `i32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5ja89r7y.rs:29:21\n   |\n29 |         if arr[i] < min_val\
    \ {\n   |                     ^^^^^^^ expected `isize`,"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() < 2 {\n        return arr;\n \
    \   }\n\n    let mut arr: Vec<isize> = arr;\n\n    for i in 0..(arr.len() - 1)\
    \ {\n        let mut temp = isize::from(arr.get_unchecked(0));\n        for j\
    \ in 1..arr.len() {\n            if isize::from(arr.get_unchecked(j - 1)) > temp\
    \ {\n                temp = isize::from(arr.get_unchecked(j - 1));\n         \
    \   }\n        }\n\n        arr.swap(0, i);\n        arr.swap(i, arr.len() - 1);\n\
    \        arr.swap(i, i);\n    }\n\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `isize: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp_oi6nswi.rs:19:36\n   |\n19 |         let mut temp = isize::from(arr.get_unchecked(0));\n\
    \   |                        ----------- ^^^^^^^^^^^^^^^^^^^^ expected an implementor\
    \ of trait `From<&isize>`\n   |                        |\n   |               \
    \         required by a bound introduced by this call\n   |\nhelp: consider borrowing\
    \ here\n   |\n19 |         let mut temp = isize::from(&arr.get_unchecked(0));\n\
    \   |                                    +\n\nerror[E0277]: the trait bound `isize:\
    \ From<&isize>` is not satisfied\n  --> /tmp/tmp_oi6nswi.rs:21:28\n   |\n21 |\
    \             if isize::from(arr.get_unchecked(j - 1)) > temp {\n   |        \
    \        ----------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait\
    \ `From<&isize>`\n   |                |\n   |                required by a bound\
    \ introduced by this call\n   |\nhelp: consider borrowing here\n   |\n21 |   \
    \          if isize::from(&arr.get_unchecked(j - 1)) > temp {\n   |          \
    \                  +\n\nerror[E0277]: the trait bound `isize: From<&isize>` is\
    \ not satisfied\n  --> /tmp/tmp_oi6nswi.rs:22:36\n   |\n22 |                 temp\
    \ = isize::from(arr.get_unchecked(j - 1));\n   |                        -----------\
    \ ^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `From<&isize>`\n \
    \  |                        |\n   |                        required by a bound\
    \ introduced by this call\n   |\nhelp: consider borrowing here\n   |\n22 |   \
    \              temp = isize::from(&arr.get_unchecked(j - 1));\n   |          \
    \                          +\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![];\n    let mut count\
    \ = 0;\n    let mut nums_ones = 0;\n\n    for &n in arr {\n        if n != 0 {\n\
    \            sorted.push(nums_ones);\n            sorted.push(n);\n          \
    \  count += 1;\n            nums_ones += 1;\n        } else {\n            sorted.push(0);\n\
    \            sorted.push(0);\n        }\n    }\n    sorted.sort_by_key(|x| x.cmp(&count));\n\
    \    sorted\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3gfmj7ks.rs:16:9\n   |\n\
    16 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ones = vec![];\n    let mut zeros =\
    \ vec![];\n    for num in arr {\n        if num == 1 {\n            ones.push(num);\n\
    \        } else {\n            zeros.push(num);\n        }\n    }\n    let mut\
    \ ones_count = ones[0].to_bigint().unwrap();\n    let mut zeros_count = zeros[0].to_bigint().unwrap();\n\
    \    for i in 1..arr.len() {\n        if arr[i] == ones_count {\n            ones_count\
    \ += 1;\n        } else {\n            zeros_count += 1;\n        }\n    }\n\n\
    \    let mut result = vec![];\n    for i in 0..ones_count {\n        result.push(zeros.remove(&i).unwrap());\n\
    \    }\n    for i in 0..(ones_count + zeros_count - 1) {\n        result.push(ones.remove(&i).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_bigint` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpmfuf9qdh.rs:21:34\n   |\n21 |     let mut ones_count\
    \ = ones[0].to_bigint().unwrap();\n   |                                  ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_be`\n\nerror[E0599]:\
    \ no method named `to_bigint` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpmfuf9qdh.rs:22:36\n   |\n22 |     let mut zeros_count = zeros[0].to_bigint().unwrap();\n\
    \   |                                    ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmfuf9qdh.rs:33:34\n   |\n33 |         result.push(zeros.remove(&i).unwrap());\n\
    \   |                                  ^^ expected `usize`, found `&isize`\n\n\
    error[E0599]: no method named `unwrap` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpmfuf9qdh.rs:33:38\n   |\n33 |         result.push(zeros.remove(&i).unwrap());\n\
    \   |                                      ^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmfuf9qdh.rs:36:33\n   |\n36 |\
    \         result.push(ones.remove(&i).unwrap());\n   |                       \
    \          ^^ expected `usize`, found `&{integer}`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n36 -         result.push(ones.remove(&i).unwrap());\n36 +\
    \         result.push(ones.remove(i).unwrap());\n   | \n\nerror[E0599]: no method\
    \ named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpmfuf9qdh.rs:36:37\n\
    \   |\n36 |         result.push(ones.remove(&i).unwrap());\n   |             \
    \                        ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut a = arr.clone();\n    let mut cnt =\
    \ 0;\n    let mut sorted_arr = Vec::new();\n\n    for i in a.iter() {\n      \
    \  let mut num = 1;\n        while i >> num != 0 {\n            cnt += 1;\n  \
    \          num += 1;\n        }\n\n        if cnt != 1 {\n            sorted_arr.push(i);\n\
    \        } else {\n            if a[i] > 0 {\n                sorted_arr.push(a[i]);\n\
    \            }\n        }\n\n        cnt -= 1;\n    }\n\n    sorted_arr\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmppmhk6sfm.rs:26:16\n\
    \   |\n26 |             if a[i] > 0 {\n   |                ^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmppmhk6sfm.rs:27:33\n   |\n27 |        \
    \         sorted_arr.push(a[i]);\n   |                                 ^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppmhk6sfm.rs:34:5\n   |\n11 | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                   ----------\
    \ expected `Vec<isize>` because of return type\n...\n34 |     sorted_arr\n   |\
    \     ^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut n = arr.len();\n    let mut s = Vec::<isize>::with_capacity(n);\n\
    \    let mut v = 0;\n    for i in arr {\n        if i & 1 == 1 {\n           \
    \ s.push(v);\n            v /= 2;\n        } else {\n            v += 1;\n   \
    \     }\n    }\n    for i in (0..n).rev() {\n        s.push(v);\n        v /=\
    \ 2;\n    }\n    for i in (0..n).rev() {\n        s.push(i);\n    }\n    for i\
    \ in s.iter_mut().rev() {\n        *i %= n;\n    }\n    return s;\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxwf4ld_t.rs:28:16\n   |\n\
    28 |         s.push(i);\n   |                ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n28 |         s.push(i.try_into().unwrap());\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxwf4ld_t.rs:31:15\n   |\n31 |         *i %= n;\n   |               ^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod-assign `isize` by\
    \ `usize``\n  --> /tmp/tmpxwf4ld_t.rs:31:12\n   |\n31 |         *i %= n;\n   |\
    \            ^^ no implementation for `isize %= usize`\n   |\n   = help: the trait\
    \ `RemAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `RemAssign<Rhs>`:\n             <f32 as RemAssign<&f32>>\n\
    \             <f32 as RemAssign>\n             <f64 as RemAssign<&f64>>\n    \
    \         <f64 as RemAssign>\n             <i128 as RemAssign<&i128>>\n      \
    \       <i128 as RemAssign>\n             <i16 as RemAssign<&i16>>\n         \
    \    <i16 as RemAssign>\n           and 20 others\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x|\n        arr.iter().rev().filter(|&i|\
    \ i & 1).count() == x\n    )\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4k1dio8i.rs:13:38\n   |\n\
    13 |         arr.iter().rev().filter(|&i| i & 1).count() == x\n   |          \
    \                            ^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4k1dio8i.rs:13:56\n   |\n13 |         arr.iter().rev().filter(|&i|\
    \ i & 1).count() == x\n   |                                                  \
    \      ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4k1dio8i.rs:12:5\n   |\n11 |   fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                     ---------- expected `Vec<isize>`\
    \ because of return type\n12 | /     arr.sort_by_key(|x|\n13 | |         arr.iter().rev().filter(|&i|\
    \ i & 1).count() == x\n14 | |     )\n   | |_____^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| {\n        // binary representation\
    \ of x is of length (x.len() - 1) with one\n        // bit at the end.\n     \
    \   // For x = 10, the binary representation of x is 000000000000000000000000010\n\
    \        // To convert this binary representation to decimal, we use\n       \
    \ // repeat_string(\"\", 5) (where 5 is the length of the binary representation).\n\
    \        // For x = 10, repeat_string(\"\", 5) is \"000000000\"\n        // Therefore,\
    \ the number of ones in x is (10 - repeat_string(\"\", 5)).\n        x.len() -\
    \ repeat_string(\"\", x).len()\n    })\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `repeat_string` in this scope\n  -->\
    \ /tmp/tmp_myb_3uk.rs:20:19\n   |\n20 |         x.len() - repeat_string(\"\",\
    \ x).len()\n   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `len` found for reference `&isize` in the current scope\n  -->\
    \ /tmp/tmp_myb_3uk.rs:20:11\n   |\n20 |         x.len() - repeat_string(\"\",\
    \ x).len()\n   |           ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_myb_3uk.rs:12:5\n   |\n11 |   fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                     ---------- expected\
    \ `Vec<isize>` because of return type\n12 | /     arr.sort_by_key(|x| {\n13 |\
    \ |         // binary representation of x is of length (x.len() - 1) with one\n\
    14 | |         // bit at the end.\n15 | |         // For x = 10, the binary representation\
    \ of x is 000000000000000000000000010\n...  |\n20 | |         x.len() - repeat_string(\"\
    \", x).len()\n21 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.to_vec();\n    arr.sort();\n\
    \    arr.into_iter().collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp2z_z3__e.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return arr;\n\
    \    }\n    arr.sort_unstable_by(|a, b| {\n        let mut res = 0;\n        if\
    \ a > b {\n            res = -1;\n        }\n        if a < b {\n            res\
    \ += 1;\n        }\n        res\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4s_8ohts.rs:23:9\n   |\n\
    23 |         res\n   |         ^^^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr: Vec<isize> = Vec::new();\n\
    \    for i in 0..arr.len() {\n        sorted_arr.push(i);\n    }\n    \n    for\
    \ i in 0..arr.len() {\n        for j in (i + 1)..arr.len() {\n            if arr[i]\
    \ > arr[j] {\n                let tmp_swap = arr[j];\n                arr[j] =\
    \ arr[i];\n                arr[i] = tmp_swap;\n            }\n        }\n    }\n\
    \    for i in 0..arr.len() {\n        sorted_arr[i] = arr[i];\n    }\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp75p888vm.rs:14:25\n   |\n\
    14 |         sorted_arr.push(i);\n   |                         ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |         sorted_arr.push(i.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(arr.len() >= 2);\n    let mut\
    \ vec = arr.to_vec();\n    vec.sort_unstable_by(|a, b| {\n        debug_assert!(a.is_negative());\n\
    \        debug_assert!(b.is_negative());\n        a.checked_add(b).ok().expect(\"\
    overflow\");\n        0\n    });\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4g68evn9.rs:17:23\n   |\n\
    17 |         a.checked_add(b).ok().expect(\"overflow\");\n   |               \
    \        ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |         a.checked_add(*b).ok().expect(\"overflow\");\n\
    \   |                       +\n\nerror[E0599]: no method named `ok` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmp4g68evn9.rs:17:26\n   |\n\
    17 |         a.checked_add(b).ok().expect(\"overflow\");\n   |               \
    \           ^^ help: there is an associated function with a similar name: `or`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4g68evn9.rs:18:9\n   |\n18 | \
    \        0\n   |         ^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|x, y| {\n        // count ones\
    \ in binary\n        let bin = binary_format_to_int(x) + binary_format_to_int(y);\n\
    \        // count ones in decimal\n        let bin = binary_format_to_int(x).cmp(&binary_format_to_int(y));\n\
    \        bin\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_format_to_int` in this scope\n\
    \  --> /tmp/tmpcyr41r32.rs:14:19\n   |\n14 |         let bin = binary_format_to_int(x)\
    \ + binary_format_to_int(y);\n   |                   ^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `binary_format_to_int`\
    \ in this scope\n  --> /tmp/tmpcyr41r32.rs:14:45\n   |\n14 |         let bin =\
    \ binary_format_to_int(x) + binary_format_to_int(y);\n   |                   \
    \                          ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `binary_format_to_int` in this scope\n  --> /tmp/tmpcyr41r32.rs:16:19\n\
    \   |\n16 |         let bin = binary_format_to_int(x).cmp(&binary_format_to_int(y));\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `binary_format_to_int` in this scope\n  --> /tmp/tmpcyr41r32.rs:16:48\n\
    \   |\n16 |         let bin = binary_format_to_int(x).cmp(&binary_format_to_int(y));\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcyr41r32.rs:12:5\n\
    \   |\n11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n12 | /     arr.sort_by(|x, y| {\n13 | |         // count ones in binary\n\
    14 | |         let bin = binary_format_to_int(x) + binary_format_to_int(y);\n\
    15 | |         // count ones in decimal\n16 | |         let bin = binary_format_to_int(x).cmp(&binary_format_to_int(y));\n\
    17 | |         bin\n18 | |     })\n   | |______^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), arr.iter().map(|x| x\
    \ as usize).sum());\n    arr.iter()\n        .map(|x| {\n            if x <= 0\
    \ {\n                0\n            } else if x == 1 {\n                1\n  \
    \          } else {\n                x as usize\n            }\n        })\n \
    \       .sort_by_key(|&x| {\n            let mut s = x * (x as usize).leading_zeros();\n\
    \            s /= 10;\n            s\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6zi4v5kf.rs:15:21\n   |\n\
    15 |             if x <= 0 {\n   |                     ^\n   |               \
    \      |\n   |                     expected `&isize`, found integer\n   |    \
    \                 help: consider borrowing here: `&0`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp6zi4v5kf.rs:17:25\n   |\n17 |     \
    \        } else if x == 1 {\n   |                         ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmp6zi4v5kf.rs:23:10\n\
    \   |\n23 |         .sort_by_key(|&x| {\n   |          ^^^^^^^^^^^ method not\
    \ found in `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp6zi4v5kf.rs:14:14:\
    \ 22:10]>`\n\nerror[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmp6zi4v5kf.rs:12:46\n\
    \   |\n12 |     assert_eq!(arr.len(), arr.iter().map(|x| x as usize).sum());\n\
    \   |                                              -^^^^^^^^^\n   |          \
    \                                    |\n   |                                 \
    \             cannot cast `&isize` as `usize`\n   |                          \
    \                    help: dereference the expression: `*x`\n\nerror[E0606]: casting\
    \ `&isize` as `usize` is invalid\n  --> /tmp/tmp6zi4v5kf.rs:20:17\n   |\n20 |\
    \                 x as usize\n   |                 -^^^^^^^^^\n   |          \
    \       |\n   |                 cannot cast `&isize` as `usize`\n   |        \
    \         help: dereference the expression: `*x`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599, E0606.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = arr.to_vec();\n\n    result.sort_by_key(|x|\
    \ {\n        x.iter().fold(0, |sum, bit| sum + if bit == 1 { 1 } else { 0 })\n\
    \    });\n\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmplf95r58r.rs:15:11\n   |\n15 |         x.iter().fold(0,\
    \ |sum, bit| sum + if bit == 1 { 1 } else { 0 })\n   |           ^^^^ method not\
    \ found in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|x, y| x.checked_sub(y)\n     \
    \   .map(|a| a.checked_mul(&2).ok().expect(\"overflow of isize\"))\n        .unwrap_or(0))\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzksy8y36.rs:12:38\n   |\n\
    12 |     arr.sort_by(|x, y| x.checked_sub(y)\n   |                           \
    \           ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n12 |     arr.sort_by(|x, y| x.checked_sub(*y)\n   |      \
    \                                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzksy8y36.rs:13:32\n\
    \   |\n13 |         .map(|a| a.checked_mul(&2).ok().expect(\"overflow of isize\"\
    ))\n   |                                ^^ expected `isize`, found `&{integer}`\n\
    \   |\nhelp: consider removing the borrow\n   |\n13 -         .map(|a| a.checked_mul(&2).ok().expect(\"\
    overflow of isize\"))\n13 +         .map(|a| a.checked_mul(2).ok().expect(\"overflow\
    \ of isize\"))\n   | \n\nerror[E0599]: no method named `ok` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpzksy8y36.rs:13:36\n   |\n13 |         .map(|a|\
    \ a.checked_mul(&2).ok().expect(\"overflow of isize\"))\n   |                \
    \                    ^^ help: there is an associated function with a similar name:\
    \ `or`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzksy8y36.rs:12:5\n   |\n\
    11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    12 | /     arr.sort_by(|x, y| x.checked_sub(y)\n13 | |         .map(|a| a.checked_mul(&2).ok().expect(\"\
    overflow of isize\"))\n14 | |         .unwrap_or(0))\n   | |______________________^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| {\n        let mut mask\
    \ = 1u8;\n        let mut bits = x as u8;\n        while bits != 0 {\n       \
    \     bits &= (bits - 1) << 1;\n            mask <<= 1;\n        }\n        mask\n\
    \    });\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdxu84_3c.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror[E0606]: casting `&isize` as `u8` is invalid\n  --> /tmp/tmpdxu84_3c.rs:14:24\n\
    \   |\n14 |         let mut bits = x as u8;\n   |                        -^^^^^^\n\
    \   |                        |\n   |                        cannot cast `&isize`\
    \ as `u8`\n   |                        help: dereference the expression: `*x`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut temp = vec![];\n    for i in arr {\n\
    \        temp.push(i); // to keep a copy as we do not have reference\n    }\n\
    \    temp.sort_by(|a, b| {\n        // Count the number of 1s in a\n        let\
    \ mut num_ones_in_a = 0;\n        for i in &mut temp {\n            if i == a\
    \ {\n                num_ones_in_a += 1;\n            }\n        }\n\n       \
    \ // Count the number of 1s in b\n        let mut num_ones_in_b = 0;\n       \
    \ for i in &mut temp {\n            if i == b {\n                num_ones_in_b\
    \ += 1;\n            }\n        }\n\n        // Sort based on number of ones in\
    \ their binary representation\n        if num_ones_in_a < num_ones_in_b {\n  \
    \          -1\n        } else {\n            1\n        }\n    });\n    return\
    \ temp\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcdwaxp1r.rs:35:13\n   |\n\
    35 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcdwaxp1r.rs:37:13\n\
    \   |\n37 |             1\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = vec![];\n    for i in arr {\n\
    \        if i <= 0 {\n            vec![i; 0]\n        } else {\n            vec.push(vec.iter().fold(i,\
    \ |acc, i| acc + 1 << i as isize))\n        }\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpomqktlu7.rs:15:13\n   |\n\
    14 | /         if i <= 0 {\n15 | |             vec![i; 0]\n   | |            \
    \ ^^^^^^^^^^ expected `()`, found struct `Vec`\n16 | |         } else {\n17 |\
    \ |             vec.push(vec.iter().fold(i, |acc, i| acc + 1 << i as isize))\n\
    18 | |         }\n   | |_________- expected this to be `()`\n   |\n   = note:\
    \ expected unit type `()`\n                 found struct `Vec<isize>`\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\nhelp: consider using a semicolon here\n   |\n18 |         };\n\
    \   |          +\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  -->\
    \ /tmp/tmpomqktlu7.rs:17:61\n   |\n17 |             vec.push(vec.iter().fold(i,\
    \ |acc, i| acc + 1 << i as isize))\n   |                                     \
    \                        -^^^^^^^^^\n   |                                    \
    \                         |\n   |                                            \
    \                 cannot cast `&isize` as `isize`\n   |                      \
    \                                       help: dereference the expression: `*i`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n\n    let mut sorted_arr = arr;\n    sorted_arr.sort();\n\n    if arr.len()\
    \ < 100 {\n        sorted_arr.sort_by_key(|&a| a.check_bits_1());\n    }\n\n \
    \   sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `check_bits_1` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpq9o1wg06.rs:20:39\n   |\n20 |         sorted_arr.sort_by_key(|&a|\
    \ a.check_bits_1());\n   |                                       ^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter()\n        .map(|num| {\n        \
    \    if num == 1 {\n                num.to_string().parse::<isize>().unwrap()\n\
    \            } else {\n                num.pow2().checked_add(-num).unwrap()\n\
    \            }\n        })\n        .sort_by(|a, b| a.cmp(b))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpipxpvafs.rs:14:20\n\
    \   |\n14 |             if num == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `pow2`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpipxpvafs.rs:17:21\n\
    \   |\n17 |                 num.pow2().checked_add(-num).unwrap()\n   |      \
    \               ^^^^ help: there is an associated function with a similar name:\
    \ `pow`\n\nerror[E0599]: no method named `sort_by` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpipxpvafs.rs:20:10\n   |\n20 |         .sort_by(|a,\
    \ b| a.cmp(b))\n   |          ^^^^^^^ method not found in `Map<std::slice::Iter<'_,\
    \ isize>, _>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut num_ones = 1;\n    let mut dec = 0;\n    for &x in arr {\n\
    \        if x == 1 {\n            num_ones += 1;\n        } else {\n         \
    \   let x = x / pow2(x) + pow2(dec);\n            dec += 1;\n            x = x\
    \ * pow2(x) + pow2(dec);\n            num_ones += 1;\n        }\n\n        if\
    \ num_ones > 4 {\n            num_ones = 1;\n            dec += 1;\n        }\n\
    \        arr.push(x);\n    }\n    if num_ones > 4 {\n        num_ones = 1;\n \
    \       dec += 1;\n    }\n    arr.sort();\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmps3oiwmf1.rs:22:25\n\
    \   |\n22 |             let x = x / pow2(x) + pow2(dec);\n   |               \
    \          ^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `pow2` in this scope\n  --> /tmp/tmps3oiwmf1.rs:22:35\n   |\n22 |          \
    \   let x = x / pow2(x) + pow2(dec);\n   |                                   ^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `pow2` in this\
    \ scope\n  --> /tmp/tmps3oiwmf1.rs:24:21\n   |\n24 |             x = x * pow2(x)\
    \ + pow2(dec);\n   |                     ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `pow2` in this scope\n  --> /tmp/tmps3oiwmf1.rs:24:31\n\
    \   |\n24 |             x = x * pow2(x) + pow2(dec);\n   |                   \
    \            ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps3oiwmf1.rs:18:9\n   |\n18 |     for &x in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![0; arr.len()];\n\n    let\
    \ mut cur: isize = arr.len() - 1;\n    while cur >= 0 {\n        // Get the number\
    \ of ones in arr[cur]\n        let ones = arr\n            .iter()\n         \
    \   .map(|x| x if x == 1 else 0)\n            .count();\n\n        // Add new\
    \ element to the result array\n        res[cur] = ones + arr[cur];\n\n       \
    \ // Move to previous index\n        cur -= ones;\n    }\n\n    // Return to original\
    \ order\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: missing condition for `if` expression\n  --> /tmp/tmp3mjutnc9.rs:19:26\n\
    \   |\n19 |             .map(|x| x if x == 1 else 0)\n   |                   \
    \       ^ expected if condition here\n\nerror: expected one of `!`, `)`, `,`,\
    \ `.`, `::`, `?`, `{`, or an operator, found keyword `if`\n  --> /tmp/tmp3mjutnc9.rs:19:24\n\
    \   |\n19 |             .map(|x| x if x == 1 else 0)\n   |                   \
    \     ^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3mjutnc9.rs:14:26\n   |\n14 |     let mut cur: isize = arr.len()\
    \ - 1;\n   |                  -----   ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |                  |\n   |                  expected due to this\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n14 |     let mut cur: isize = (arr.len() - 1).try_into().unwrap();\n\
    \   |                          +             +++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3mjutnc9.rs:23:9\n\
    \   |\n23 |         res[cur] = ones + arr[cur];\n   |         ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp3mjutnc9.rs:23:27\n   |\n23 |         res[cur]\
    \ = ones + arr[cur];\n   |                           ^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3mjutnc9.rs:26:16\n\
    \   |\n26 |         cur -= ones;\n   |                ^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot subtract"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), arr.iter().map(|e| {\n\
    \        debug_assert_eq!(!(e.checked_mul(2).is_ok(), false);\n        e\n   \
    \ }).sum::<isize>(), arr.len());\n    let mut result = Vec::with_capacity(arr.len());\n\
    \    for i in 0..arr.len() {\n        let mut cnt = 0;\n        for j in 0..arr.len()\
    \ {\n            if arr[i] == arr[j] {\n                cnt += 1;\n          \
    \  }\n        }\n        result.push(i + cnt);\n    }\n    result.sort_by_key(|e|\
    \ {\n        debug_assert_eq!(e.checked_mul(2).is_ok(), false);\n        e\n \
    \   });\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmphybnxqio.rs:13:25\n\
    \   |\n12 |     assert_eq!(arr.len(), arr.iter().map(|e| {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    13 |         debug_assert_eq!(!(e.checked_mul(2).is_ok(), false);\n   |      \
    \                   ^ unclosed delimiter\n14 |         e\n15 |     }).sum::<isize>(),\
    \ arr.len());\n   |     ^ mismatched closing delimiter\n\nerror: no rules expected\
    \ the token `;`\n  --> /tmp/tmphybnxqio.rs:13:60\n   |\n13 |         debug_assert_eq!(!(e.checked_mul(2).is_ok(),\
    \ false);\n   |                                                            ^ no\
    \ rules expected this token in macro call\n\nerror: format argument must be a\
    \ string literal\n  --> /tmp/tmphybnxqio.rs:15:24\n   |\n15 |     }).sum::<isize>(),\
    \ arr.len());\n   |                        ^^^^^^^^^\n   |\nhelp: you might be\
    \ missing a string literal to format with\n   |\n15 |     }).sum::<isize>(), \"\
    {}\", arr.len());\n   |                        +++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphybnxqio.rs:12:5\n   |\n12 | /     assert_eq!(arr.len(),\
    \ arr.iter().map(|e| {\n13 | |         debug_assert_eq!(!(e.checked_mul(2).is_ok(),\
    \ false);\n14 | |         e\n15 | |     }).sum::<isize>(), arr.len());\n   | |_________________________________^\
    \ expected `usize`, found `isize`\n   |\n   = note: this error originates in the\
    \ macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0599]: no method named `is_ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmphybnxqio.rs:27:43\n   |\n27 |         debug_assert_eq!(e.checked_mul(2).is_ok(),\
    \ false);\n   |                                           ^^^^^ method not found\
    \ in `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphybnxqio.rs:30:5\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n30 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<isize>"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter = HashMap::new();\n    for\
    \ &i in arr {\n        let mut val = i;\n        counter.insert(i, val as isize);\n\
    \    }\n    let mut result: Vec<isize> = Vec::with_capacity(arr.len());\n    for\
    \ i in arr.iter() {\n        let mut val = i;\n        while let Some(&v) = counter.get(&val)\
    \ {\n            val = v;\n            result.push(i);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6enkizn7.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6enkizn7.rs:13:9\n   |\n13 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6enkizn7.rs:22:25\n   |\n22 |             result.push(i);\n   |\
    \                         ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |             result.push(*i);\n   |    \
    \                     +\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.into_iter().collect::<Vec<_>>().sort_by(|x,\
    \ y| -cmp(binary(x), binary(y)))\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `cmp` in this scope\n  --> /tmp/tmpgzbv8ie8.rs:12:57\n\
    \   |\n12 |     arr.into_iter().collect::<Vec<_>>().sort_by(|x, y| -cmp(binary(x),\
    \ binary(y)))\n   |                                                         ^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `binary` in this\
    \ scope\n  --> /tmp/tmpgzbv8ie8.rs:12:61\n   |\n12 |     arr.into_iter().collect::<Vec<_>>().sort_by(|x,\
    \ y| -cmp(binary(x), binary(y)))\n   |                                       \
    \                      ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `binary` in this scope\n  --> /tmp/tmpgzbv8ie8.rs:12:72\n   |\n\
    12 |     arr.into_iter().collect::<Vec<_>>().sort_by(|x, y| -cmp(binary(x), binary(y)))\n\
    \   |                                                                        ^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgzbv8ie8.rs:12:5\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    12 |     arr.into_iter().collect::<Vec<_>>().sort_by(|x, y| -cmp(binary(x), binary(y)))\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut m = 0.0;\n    let mut b = 0.0;\n    let mut c = 0.0;\n   \
    \ for i in arr.iter().cloned() {\n        m += i;\n        b += 1.0 * i;\n   \
    \     c += i;\n    }\n    let mut i = 0;\n    while b != 0.0 {\n        if b >\
    \ m {\n            return vec![];\n        }\n        i += 1;\n        let t =\
    \ b / m;\n        b = c - t * m;\n        c = t;\n        m += 1;\n    }\n   \
    \ return vec![i as usize; arr.len()];\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `isize` to `{float}`\n  --> /tmp/tmp11fxbo6o.rs:19:11\n\
    \   |\n19 |         m += i;\n   |           ^^ no implementation for `{float}\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot multiply `{float}` by `isize`\n  --> /tmp/tmp11fxbo6o.rs:20:18\n\
    \   |\n20 |         b += 1.0 * i;\n   |                  ^ no implementation for\
    \ `{float} * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0277]: cannot add-assign `isize` to `{float}`\n  --> /tmp/tmp11fxbo6o.rs:21:11\n\
    \   |\n21 |         c += i;\n   |           ^^ no implementation for `{float}\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot add-assign `{integer}` to `{float}`\n  -->\
    \ /tmp/tmp11fxbo6o.rs:32:11\n   |\n32 |         m += 1;\n   |           ^^ no\
    \ implementation for `{float} +="
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        vec![]\n    }\n\
    \    if arr.len() == 1 {\n        vec![1]\n    }\n    if arr.len() == 2 {\n  \
    \      vec![2, 1]\n    }\n    if arr.len() == 3 {\n        vec![1, 2, 3]\n   \
    \ }\n    if arr.len() == 4 {\n        vec![1, 3, 4]\n    }\n    if arr.len() ==\
    \ 5 {\n        vec![1, 0, 2, 3]\n    }\n    if arr.len() == 6 {\n        vec![0,\
    \ 1, 3, 2]\n    }\n    if arr.len() == 7 {\n        vec![0, 1, 2, 4]\n    }\n\
    \    if arr.len() == 8 {\n        vec![0, 1, 2, 3, 4]\n    }\n    if arr.len()\
    \ == 9 {\n        vec![0, 1, 2, 3, 4, 5]\n    }\n    if arr.len() == 10 {\n  \
    \      vec![0, 1, 2, 3, 4, 5, 6, 7]\n    }\n    if arr.len() == 11 {\n       \
    \ vec![0, 1, 2, 3, 4, 5, 6, 7, 8]\n    }\n    if arr.len() == 12 {\n        vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    }\n    if arr.len() == 13 {\n        vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    }\n    if arr.len() == 14 {\n        vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    }\n    if arr.len() == 15 {\n      \
    \  vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    }\n    if arr.len() ==\
    \ 16 {\n        vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    }\n  \
    \  if arr.len() == 17 {\n        vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14]\n    }\n    if arr.len() == 18 {\n        vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    }\n    if arr.len() == 19 {\n        vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    }\n    if arr.len()\
    \ == 20 {\n        vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\
    \ 16, 17]\n    }\n    if arr.len() == 21 {\n        vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n    }\n    if arr.len() == 22\
    \ {\n        vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\
    \ 18, 19]\n    }\n    if arr.len() == 23 {\n        vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    }\n    if arr.len()\
    \ == 24 {\n        vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\
    \ 16, 17, 18, 19, 20, 21]\n    }\n    if arr.len(\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp66180uko.rs:88:1\n   |\n\
    87 |     if arr.len(\n   |     -- this `if` expression has a condition, but no\
    \ block\n88 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmp66180uko.rs:87:15\n   |\n11 | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                              - closing delimiter\
    \ possibly meant for this\n...\n87 |     if arr.len(\n   |               ^ unclosed\
    \ delimiter\n88 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp66180uko.rs:13:9\n   |\n12 | /     if arr.len() == 0 {\n\
    13 | |         vec![]\n   | |         ^^^^^^ expected `()`, found struct `Vec`\n\
    14 | |     }\n   | |_____- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                 found struct `Vec<_>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\nhelp: consider using a semicolon here\n   |\n14 |     };\n \
    \  |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp66180uko.rs:16:9\n\
    \   |\n15 | /     if arr.len() == 1 {\n16 | |         vec![1]\n   | |        \
    \ ^^^^^^^ expected `()`, found struct `Vec`\n17 | |     }\n   | |_____- expected\
    \ this to be `()`\n   |\n   = note: expected unit type `()`\n                \
    \ found struct `Vec<{integer}>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp:\
    \ consider using a semicolon here\n   |\n17 |     };\n   |      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp66180uko.rs:19:9\n   |\n18 | /     if arr.len()\
    \ == 2 {\n19 | |         vec![2, 1]\n   | |         ^^^^^^^^^^ expected `()`,\
    \ found struct `Vec`\n20 | |     }\n   | |_____- expected this to be `()`\n  \
    \ |\n   = note: expected unit type `()`\n                 found struct `Vec<{integer}>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \  |\n20 |     };\n   |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/t"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // 1. sort the array based on the number of\
    \ ones\n    arr.sort_by_key(|x| {\n        count_ones(x) % 2\n    })\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_ones` in this scope\n  --> /tmp/tmp4bd3gps3.rs:14:9\n\
    \   |\n14 |         count_ones(x) % 2\n   |         ^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4bd3gps3.rs:13:5\n  \
    \ |\n11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                        ---------- expected `Vec<isize>` because of return type\n\
    12 |       // 1. sort the array based on the number of ones\n13 | /     arr.sort_by_key(|x|\
    \ {\n14 | |         count_ones(x) % 2\n15 | |     })\n   | |______^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    sorted_arr.sort_by_key(|x| binary_num_ones(x));\n    sorted_arr.sort_by_key(|x|\
    \ x.checked_mul(10).floor() as isize);\n    sorted_arr\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_num_ones` in this scope\n  -->\
    \ /tmp/tmp9de10lw4.rs:14:32\n   |\n14 |     sorted_arr.sort_by_key(|x| binary_num_ones(x));\n\
    \   |                                ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `floor` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp9de10lw4.rs:15:50\n   |\n15 |     sorted_arr.sort_by_key(|x|\
    \ x.checked_mul(10).floor() as isize);\n   |                                 \
    \                 ^^^^^ method not found in `Option<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().fold(Vec::new(), |mut v,\
    \ i| {\n        if i > 0 {\n            v.sort_by(|a, b| {\n                match\
    \ {\n                    a as i8 && b as i8 => 0,\n                    a as i8\
    \ || b as i8 => a as i8 | b as i8,\n                    a as i16 && b as i16 =>\
    \ 0,\n                    a as i16 || b as i16 => a as i16 | b as i16,\n     \
    \               a as i32 && b as i32 => 0,\n                    a as i32 || b\
    \ as i32 => a as i32 | b as i32,\n                    a as i64 && b as i64 =>\
    \ 0,\n                    a as i64 || b as i64 => a as i64 | b as i64,\n     \
    \               _ => 0,\n                }\n            });\n        }\n     \
    \   v.push(i);\n        v\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `.`, `::`, `;`, `<`, `?`, or `}`, found\
    \ `=>`\n  --> /tmp/tmpnm8dxnzz.rs:16:40\n   |\n16 |                     a as i8\
    \ && b as i8 => 0,\n   |                                        ^^ expected one\
    \ of 8 possible tokens\n\nerror: expected one of `.`, `?`, `{`, or an operator,\
    \ found `}`\n  --> /tmp/tmpnm8dxnzz.rs:26:13\n   |\n15 |                 match\
    \ {\n   |                 ----- while parsing this `match` expression\n...\n25\
    \ |                 }\n   |                  - expected one of `.`, `?`, `{`,\
    \ or an operator\n26 |             });\n   |             ^ unexpected token\n\n\
    error: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut counts = HashMap::<isize, usize>::new();\n    let mut res\
    \ = vec![];\n    let mut last_zero = isize::MAX;\n    for el in arr {\n      \
    \  if *el != 0 {\n            last_zero = el;\n        } else {\n            counts.entry(*el).or_default()\
    \ = (*el as usize + 1);\n        }\n    }\n    for el in arr {\n        if *el\
    \ != 0 {\n            counts\n                .entry(*el as usize)\n         \
    \       .or_default()\n                += (*el as usize - last_zero);\n      \
    \  }\n    }\n\n    for el in counts.iter() {\n        let mut val = *el;\n   \
    \     let mut pos = 0;\n        for _ in 0..el {\n            if val != 0 {\n\
    \                pos += 1;\n                val >>= 1;\n            }\n      \
    \  }\n        res.push((*el, pos));\n    }\n\n    res\n        .sort_by(|a, b|\
    \ b.1.partial_cmp(a.1))\n        .map(|el| el.0)\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpznahjibj.rs:15:22\n   |\n15 |     let mut counts = HashMap::<isize,\
    \ usize>::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmpznahjibj.rs:22:46\n\
    \   |\n22 |             counts.entry(*el).or_default() = (*el as usize + 1);\n\
    \   |                                              ^                ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n22 -             counts.entry(*el).or_default() = (*el as usize + 1);\n\
    22 +             counts.entry(*el).or_default() = *el as usize + 1;\n   | \n\n\
    warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpznahjibj.rs:30:20\n\
    \   |\n30 |                 += (*el as usize - last_zero);\n   |             \
    \       ^                        ^\n   |\nhelp: remove these parentheses\n   |\n\
    30 -                 += (*el as usize - last_zero);\n30 +                 += *el\
    \ as usize - last_zero;\n   | \n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpznahjibj.rs:19:12\n   |\n19 |         if *el != 0 {\n   |     \
    \       ^^^\n\nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpznahjibj.rs:22:44\n\
    \   |\n22 |             counts.entry(*el).or_default() = (*el as usize + 1);\n\
    \   |             ------------------------------ ^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmpznahjibj.rs:22:26\n   |\n22 |             counts.entry(*el).or_default()\
    \ = (*el as usize + 1);\n   |                          ^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpznahjibj.rs:22:47\n   |\n22 |\
    \             counts.entry(*el).or_default() = (*el as usize + 1);\n   |     \
    \                                          ^^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmpznahjibj.rs:26:12\n   |\n26 |         if *el\
    \ != "
  stdout: ''
  timestamp: 1659976142
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n\n    let mut l = arr.len();\n    let mut counts = Vec::with_capacity(l);\n\
    \    for i in 0..l {\n        if arr[i] == 1 {\n            counts.push(i);\n\
    \        }\n    }\n    let mut sorted_arr = arr.to_owned();\n    let mut sort_index\
    \ = counts.len();\n\n    while sort_index > 0 {\n        for i in 0..sort_index\
    \ {\n            sorted_arr[i] = arr[counts[i]];\n        }\n        counts.pop();\n\
    \        sort_index -= 1;\n    }\n    sorted_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpuktaayxo.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut ones\
    \ = vec![];\n    for x in arr {\n        let mut y = x >> 1;\n        if x & 1\
    \ != 0 {\n            ones.push(y);\n        } else {\n            y.push(y as\
    \ isize);\n            result.push(y as isize);\n        }\n    }\n    if !ones.is_empty()\
    \ {\n        result.sort_by_key(|x| ones[x]);\n    }\n    result.push(..ones);\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp30ete9u7.rs:19:15\n   |\n19 |             y.push(y as isize);\n\
    \   |               ^^^^ method not found in `isize`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp30ete9u7.rs:24:32\n \
    \  |\n24 |         result.sort_by_key(|x| ones[x]);\n   |                    \
    \            ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp30ete9u7.rs:26:17\n   |\n26 |\
    \     result.push(..ones);\n   |                 ^^^^^^ expected `isize`, found\
    \ struct `RangeTo`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `RangeTo<Vec<isize>>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut count = arr\n        .iter()\n    \
    \    .map(|x| x.to_bin().count())\n        .sum();\n    count = match count {\n\
    \        0 => 0,\n        1 => 1,\n        2 => 1,\n        3 => 2,\n        4\
    \ => 2,\n        5 => 3,\n        6 => 3,\n        7 => 4,\n        8 => 4,\n\
    \        9 => 5,\n        10 => 5,\n        11 => 6,\n        12 => 6,\n     \
    \   13 => 7,\n        14 => 7,\n        15 => 8,\n        16 => 8,\n        17\
    \ => 9,\n        18 => 9,\n        19 => 10,\n        20 => 10,\n        21 =>\
    \ 11,\n        22 => 11,\n        23 => 12,\n        24 => 12,\n        25 =>\
    \ 13,\n        26 => 13,\n        27 => 14,\n        28 => 14,\n        29 =>\
    \ 15,\n        30 => 15,\n        31 => 16,\n        32 => 16,\n        33 =>\
    \ 17,\n        34 => 17,\n        35 => 18,\n        36 => 18,\n        37 =>\
    \ 19,\n        38 => 19,\n        39 => 20,\n        40 => 20,\n        41 =>\
    \ 21,\n        42 => 21,\n        43 => 22,\n        44 => 22,\n        45 =>\
    \ 23,\n        46 => 23,\n        47 => 24,\n        48 => 24,\n        49 =>\
    \ 25,\n        50 => 25,\n        51 => 26,\n        52 => 26,\n        53 =>\
    \ 27,\n        54 => 27,\n        55 => 28,\n        56 => 28,\n        57 =>\
    \ 29,\n        58 => 29,\n        59 => 30,\n        60 => 30,\n        61 =>\
    \ 31,\n        62 => 31,\n        63 => 32,\n        64 => 32,\n        65 =>\
    \ 33,\n        66 => 33,\n        67 => 34,\n        68 => 34,\n        69 =>\
    \ 35,\n        70 => 35,\n        71 => 36,\n        72 => 36,\n        73 =>\
    \ 37,\n        74 => 37,\n        75 => 38,\n        76 => 38,\n        77 =>\
    \ 39,\n        78 => 39,\n        79 => 40,\n        80 => 40,\n        81 =>\
    \ 41,\n        82 => 41,\n        83 => 42,\n        84 => 42,\n        85 =>\
    \ 43,\n        86 \n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp65fdzuu5.rs:116:3\n\
    \    |\n11  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n...\n16  |     count\
    \ = match count {\n    |                         - this delimiter might not be\
    \ properly closed...\n...\n104 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n116 | }\n    |   ^\n\nerror: expected one of `...`, `..=`,\
    \ `..`, `=>`, `if`, or `|`, found `}`\n   --> /tmp/tmp65fdzuu5.rs:104:1\n    |\n\
    103 |         86 \n    |           - expected one of `...`, `..=`, `..`, `=>`,\
    \ `if`, or `|`\n104 | }\n    | ^ unexpected token\n\nerror: expected one of `.`,\
    \ `;`, `?`, `}`, or an operator, found keyword `fn`\n   --> /tmp/tmp65fdzuu5.rs:11:46\n\
    \    |\n11  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    ^ unclosed delimiter\n...\n104 | }\n    |\
    \  -\n    |  |\n    |  expected one of `.`, `;`, `?`, `}`, or an operator\n  \
    \  |  help: `}` may belong here\n105 | \n106 | fn main() {\n    | ^^ unexpected\
    \ token\n\nerror[E0599]: no method named `to_bin` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp65fdzuu5.rs:14:20\n   |\n14 |         .map(|x|\
    \ x.to_bin().count())\n   |                    ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut cnt = arr.iter().cloned().filter(|x|\
    \ *x == 1).count();\n    let mut num_ones = 0;\n    let mut decimal_val = isize::MIN;\n\
    \    for i in arr {\n        if *i == 1 {\n            num_ones += 1;\n      \
    \  } else {\n            decimal_val *= 10;\n            decimal_val += *i as\
    \ isize;\n        }\n    }\n    while cnt > 0 {\n        cnt -= 1;\n        if\
    \ num_ones > 0 {\n            decimal_val *= 10;\n            decimal_val += num_ones\
    \ as isize;\n        }\n        res.push(decimal_val);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp4en31fbo.rs:17:12\n\
    \   |\n17 |         if *i == 1 {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp4en31fbo.rs:21:28\n   |\n21 |        \
    \     decimal_val += *i as isize;\n   |                            ^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    arr.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpq_x8eog3.rs:12:5\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n12 |     arr.sort();\n   |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut count = arr.len();\n\
    \n    let mut sorted_arr: Vec<isize> = arr.to_vec();\n    sorted_arr.sort_unstable_by_key(|&x|\
    \ {\n        count -= 1;\n\n        // binary representation\n        if x ==\
    \ 0 { 1 } else { 0 }\n\n        // decimal representation\n        //\n      \
    \  // (10 - x)%10\n        //\n        loop {\n            if i > j {\n      \
    \          return false;\n            }\n\n            if arr[i as usize] < arr[i\
    \ as usize] * (10 - i%10) {\n                i += 1;\n            } else {\n \
    \               j += 1;\n            }\n\n            if count == 0 {\n      \
    \          break;\n            }\n        }\n        true\n    });\n\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgfpbj_j8.rs:25:21\n   |\n\
    25 |         if x == 0 { 1 } else { 0 }\n   |         ------------^-------------\n\
    \   |         |           |\n   |         |           expected `()`, found integer\n\
    \   |         expected this to be `()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgfpbj_j8.rs:25:32\n   |\n25 |         if x == 0 { 1 } else { 0 }\n \
    \  |         -----------------------^--\n   |         |                      |\n\
    \   |         |                      expected `()`, found integer\n   |      \
    \   expected this to be `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return arr;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut min_idx = i;\n   \
    \ let mut min_val = arr[i];\n    for i in 0..(arr.len() - 1) {\n        if arr[i]\
    \ == 0 || arr[i] == 1 {\n            i += 1;\n            continue;\n        }\n\
    \        // min_idx and min_val are already set\n        if min_val > arr[j] {\n\
    \            min_val = arr[j];\n            min_idx = j;\n        }\n        i\
    \ += 1;\n        j += 1;\n    }\n    let mut temp_arr = vec![];\n    for i in\
    \ 0..min_idx {\n        temp_arr.push(arr[i]);\n    }\n    temp_arr.push(min_val);\n\
    \    for i in 0..(arr.len() - 1) {\n        arr[i] = temp_arr[i];\n    }\n   \
    \ temp_arr.to_owned()\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmpg4wcv7ee.rs:21:13\n\
    \   |\n21 |             i += 1;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `i` is never read\n  --> /tmp/tmpg4wcv7ee.rs:29:9\n   |\n\
    29 |         i += 1;\n   |         ^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpg4wcv7ee.rs:15:9\n\
    \   |\n15 |     let mut i = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpg4wcv7ee.rs:21:13\n\
    \   |\n19 |     for i in 0..(arr.len() - 1) {\n   |         -\n   |         |\n\
    \   |         first assignment to `i`\n   |         help: consider making this\
    \ binding mutable: `mut i`\n20 |         if arr[i] == 0 || arr[i] == 1 {\n21 |\
    \             i += 1;\n   |             ^^^^^^ cannot assign twice to immutable\
    \ variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  -->\
    \ /tmp/tmpg4wcv7ee.rs:29:9\n   |\n19 |     for i in 0..(arr.len() - 1) {\n   |\
    \         -\n   |         |\n   |         first assignment to `i`\n   |      \
    \   help: consider making this binding mutable: `mut i`\n...\n29 |         i +=\
    \ 1;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]:\
    \ cannot borrow `arr` as mutable, as it is not declared as mutable\n  --> /tmp/tmpg4wcv7ee.rs:38:9\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \  --- help: consider changing this to be mutable: `mut arr`\n...\n38 |      \
    \   arr[i] = temp_arr[i];\n   |         ^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed\
    \ explanations: E0384, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    assert!(arr.len() >= 1);\n    let mut vec =\
    \ vec![];\n    let mut count = arr.iter().cloned().filter(|&x| *x != 0).count();\n\
    \    let mut max_count = max_count_bit(count);\n    for &x in arr {\n        if\
    \ *x != 0 {\n            vec.push(x as isize);\n            count -= *x;\n   \
    \         max_count = max_count_bit(count);\n        }\n    }\n\n    let mut count\
    \ = count;\n    while max_count > 1 {\n        let mut max_count = max_count_bit(count);\n\
    \        for i in (0..vec.len()).rev() {\n            if vec[i] == 0 {\n     \
    \           vec.pop();\n                count += 1;\n                vec[i] =\
    \ 0;\n            } else {\n                max_count -= 1;\n            }\n \
    \       }\n    }\n\n    vec\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_count_bit` in this scope\n  -->\
    \ /tmp/tmp5nhzzzf7.rs:15:25\n   |\n15 |     let mut max_count = max_count_bit(count);\n\
    \   |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `max_count_bit` in this scope\n  --> /tmp/tmp5nhzzzf7.rs:20:25\n\
    \   |\n20 |             max_count = max_count_bit(count);\n   |              \
    \           ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_count`\n\
    \nerror[E0425]: cannot find function `max_count_bit` in this scope\n  --> /tmp/tmp5nhzzzf7.rs:26:29\n\
    \   |\n26 |         let mut max_count = max_count_bit(count);\n   |          \
    \                   ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `max_count`\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp5nhzzzf7.rs:14:53\n\
    \   |\n14 |     let mut count = arr.iter().cloned().filter(|&x| *x != 0).count();\n\
    \   |                                                     ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5nhzzzf7.rs:16:9\n   |\n16 |     for &x in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: -1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut rev_arr = arr;\n    rev_arr.sort();\n    let mut count = 0;\n\
    \    let mut cnt = 0;\n    for &i in &rev_arr {\n        cnt += i;\n        if\
    \ cnt > count {\n            count = cnt;\n        }\n    }\n    rev_arr.sort();\n\
    \    sort_array(rev_arr)\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976148
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ones = arr.iter().filter(|&i| i & 1\
    \ == 1).count();\n    arr.sort_by_key(|&i| {\n        ones += i & 1;\n       \
    \ i\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphxh28rn2.rs:14:17\n   |\n\
    14 |         ones += i & 1;\n   |                 ^^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmphxh28rn2.rs:14:14\n\
    \   |\n14 |         ones += i & 1;\n   |              ^^ no implementation for\
    \ `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n\n    sorted_arr.sort_by_key(|x|\
    \ {\n        let mut bit_count = 0;\n        for i in 0..256 {\n            if\
    \ x&(1u8 << i) != 0 {\n                bit_count += 1;\n            }\n      \
    \  }\n\n        // Binary is most readable in this order\n        if bit_count\
    \ == 7 {\n            0\n        } else if bit_count == 0 {\n            1\n \
    \       } else {\n            // Decimal is least readable in this order\n   \
    \         bit_count - bit_count / 8\n        }\n    });\n\n    sorted_arr\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6x3hkdjj.rs:17:18\n   |\n\
    17 |             if x&(1u8 << i) != 0 {\n   |                  ^^^^^^^^^^ expected\
    \ `isize`, found `u8`\n\nerror[E0277]: no implementation for `&isize & u8`\n \
    \ --> /tmp/tmp6x3hkdjj.rs:17:17\n   |\n17 |             if x&(1u8 << i) != 0 {\n\
    \   |                 ^ no implementation for `&isize & u8`\n   |\n   = help:\
    \ the trait `BitAnd<u8>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `BitAnd<Rhs>`:\n             <&'a i128 as BitAnd<i128>>\n\
    \             <&'a i16 as BitAnd<i16>>\n             <&'a i32 as BitAnd<i32>>\n\
    \             <&'a i64 as BitAnd<i64>>\n             <&'a i8 as BitAnd<i8>>\n\
    \             <&'a isize as BitAnd<isize>>\n             <&'a u128 as BitAnd<u128>>\n\
    \             <&'a u16 as BitAnd<u16>>\n           and 40 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![0; arr.len()];\n    for\
    \ i in arr.iter() {\n        result[i as usize] = (*i as usize).count_ones() as\
    \ isize;\n    }\n    result.sort_by_key(|&i| i);\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmpopj7jxpe.rs:14:16\n\
    \   |\n14 |         result[i as usize] = (*i as usize).count_ones() as isize;\n\
    \   |                -^^^^^^^^^\n   |                |\n   |                cannot\
    \ cast `&isize` as `usize`\n   |                help: dereference the expression:\
    \ `*i`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ones = vec![];\n    for i in arr.iter()\
    \ {\n        ones.push(*i as isize);\n    }\n    let mut sorted_arr = vec![];\n\
    \    for i in ones {\n        if i == 0 {\n            sorted_arr.push(i);\n \
    \       } else {\n            let index = sorted_arr.iter().find(|&j| j == i);\n\
    \            sorted_arr[index] = i;\n        }\n    }\n    sorted_arr\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpv_way9sq.rs:21:55\n\
    \   |\n21 |             let index = sorted_arr.iter().find(|&j| j == i);\n   |\
    \                                                       ^^ no implementation for\
    \ `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `Option<&isize>`\n\
    \  --> /tmp/tmpv_way9sq.rs:22:13\n   |\n22 |             sorted_arr[index] = i;\n\
    \   |             ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `Option<&isize>`\n   = note: required because of the requirements on the\
    \ impl of `Index<Option<&isize>>` for `Vec<isize>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // 1. Write an auxiliary function which counts\
    \ the number of 1's in a number \n    // arr[i] in ascending order in O(n)\n \
    \   fn num_ones(i: isize) -> isize {\n        0\n    }\n\n    // 2. Write a sorting\
    \ algorithm which sorts arr based on number of ones in \n    // arr[i] in ascending\
    \ order.\n\n    // 3. Write a function which sorts arr based on decimal value\
    \ in ascending \n    // order.\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0lfziw_m.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr2 = arr.clone();\n    let mut cnt:\
    \ usize = 0;\n    for x in arr2 {\n        if cnt == 0 {\n            cnt++;\n\
    \            arr2.swap(x.clone(), 0);\n            arr2.swap(x.clone(), 1);\n\
    \        } else {\n            if x % 2 == 0 {\n                cnt += 2;\n  \
    \          } else {\n                cnt += 1;\n            }\n            arr2.swap(x.clone(),\
    \ cnt);\n        }\n    }\n    arr2\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpppxg8w4q.rs:16:16\n\
    \   |\n16 |             cnt++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n16 |             { let tmp = cnt; cnt +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n16 -         \
    \    cnt++;\n16 +             cnt += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpppxg8w4q.rs:25:23\n   |\n25 |             arr2.swap(x.clone(),\
    \ cnt);\n   |                       ^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |             arr2.swap(x.clone().try_into().unwrap(),\
    \ cnt);\n   |                                ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().map(|x| {\n        let mut bin =\
    \ x.to_bin();\n        let mut count = 1;\n        for b in bin.chars().skip_while(|c|\
    \ c != '1') {\n            count *= 2;\n        }\n        count += 1;\n     \
    \   count >> 1\n    }).sort_by(|a, b| {\n        b.cmp(a)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_bin` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpje36m6y2.rs:13:25\n   |\n13 |         let mut\
    \ bin = x.to_bin();\n   |                         ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror[E0599]: no method named `sort_by`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmpje36m6y2.rs:20:8\n\
    \   |\n20 |     }).sort_by(|a, b| {\n   |        ^^^^^^^ method not found in `Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpje36m6y2.rs:12:20: 20:6]>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for num in\
    \ arr {\n        if num == 0 {\n            result.push(-num);\n        } else\
    \ {\n            result.push(num);\n        }\n    }\n    result.sort();\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpitgte5k_.rs:26:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n    let\
    \ mut counter = vec![];\n    for i in sorted_arr.iter() {\n        counter.push(i);\n\
    \    }\n    counter.sort_unstable_by_key(|x| x.to_dec().unwrap());\n    for i\
    \ in 0..sorted_arr.len() {\n        sorted_arr[i] = counter[i];\n    }\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_dec` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmp3yo09akv.rs:17:40\n   |\n17 |     counter.sort_unstable_by_key(|x|\
    \ x.to_dec().unwrap());\n   |                                        ^^^^^^ help:\
    \ there is an associated function with a similar name: `to_be`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3yo09akv.rs:19:25\n   |\n19 |         sorted_arr[i]\
    \ = counter[i];\n   |         -------------   ^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         sorted_arr[i]\
    \ = *counter[i];\n   |                         +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), arr.iter().filter(|x|\
    \ x == 1).count());\n    let mut sorted_arr = vec![0; arr.len()];\n    let mut\
    \ sorted_arr_iter = 0;\n    for (i, &val) in arr.iter_mut().enumerate() {\n  \
    \      let num_bits = count_bits(val);\n        sorted_arr[i] += num_bits as isize;\n\
    \        if num_bits == 0 {\n            sorted_arr[sorted_arr_iter] = i;\n  \
    \          sorted_arr_iter += 1;\n        }\n    }\n    sorted_arr.sort_unstable();\n\
    \    let mut sorted_arr_result = vec![];\n    for i in 0..sorted_arr_iter {\n\
    \        sorted_arr_result.push(sorted_arr[i]);\n    }\n    sorted_arr_result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_bits` in this scope\n  --> /tmp/tmp59nvd8g1.rs:16:24\n\
    \   |\n16 |         let num_bits = count_bits(val);\n   |                    \
    \    ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't compare `&&isize`\
    \ with `{integer}`\n  --> /tmp/tmp59nvd8g1.rs:12:51\n   |\n12 |     assert_eq!(arr.len(),\
    \ arr.iter().filter(|x| x == 1).count());\n   |                              \
    \                     ^^ no implementation for `&&isize == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `&&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp59nvd8g1.rs:15:13\n\
    \   |\n15 |     for (i, &val) in arr.iter_mut().enumerate() {\n   |          \
    \   ^^^^     -------------------------- this expression has type `Option<(usize,\
    \ &mut isize)>`\n   |             |\n   |             types differ in mutability\n\
    \   |             help: you can probably remove the explicit borrow: `val`\n \
    \  |\n   = note: expected mutable reference `&mut isize`\n                   \
    \   found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp59nvd8g1.rs:19:43\n\
    \   |\n19 |             sorted_arr[sorted_arr_iter] = i;\n   |             ---------------------------\
    \   ^ expected `isize`, found `usize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.into_iter().map(|x| x as isize).sort_by_key(|x|\
    \ binary_count(x)).collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_count` in this scope\n  -->\
    \ /tmp/tmp9xpjf5t5.rs:12:57\n   |\n12 |     arr.into_iter().map(|x| x as isize).sort_by_key(|x|\
    \ binary_count(x)).collect()\n   |                                           \
    \              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `sort_by_key` found for struct `Map` in the current scope\n  --> /tmp/tmp9xpjf5t5.rs:12:41\n\
    \   |\n12 |     arr.into_iter().map(|x| x as isize).sort_by_key(|x| binary_count(x)).collect()\n\
    \   |                                         ^^^^^^^^^^^ method not found in\
    \ `Map<std::vec::IntoIter<isize>, [closure@/tmp/tmp9xpjf5t5.rs:12:25: 12:39]>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut len = arr.len();\n    arr.sort_unstable_by(|&x,\
    \ &y| x.binary_search(y));\n    while len > 0 {\n        if arr[len - 1] == 0\
    \ {\n            len -= 1;\n        } else {\n            arr[len - 1].iter().cloned().sort_unstable_by(|&x,\
    \ &y| x.cmp(y).unwrap());\n            len -= 1;\n        }\n    }\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `binary_search` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpyzvmoipu.rs:13:37\n   |\n13 |     arr.sort_unstable_by(|&x,\
    \ &y| x.binary_search(y));\n   |                                     ^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `iter` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpyzvmoipu.rs:18:26\n   |\n18\
    \ |             arr[len - 1].iter().cloned().sort_unstable_by(|&x, &y| x.cmp(y).unwrap());\n\
    \   |                          ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut result = arr.clone();\n    quicksort(&mut result, 0, result.len()\
    \ - 1);\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `quicksort` in this scope\n  --> /tmp/tmp42hwu6o7.rs:16:5\n\
    \   |\n16 |     quicksort(&mut result, 0, result.len() - 1);\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counters = vec![0; arr.len()];\n  \
    \  let mut sorted_arr = vec![];\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            counters[i/2] += 1;\n        } else {\n            sorted_arr.push(i);\n\
    \        }\n    }\n    sorted_arr.sort_by(|a, b| {\n        let count_a = counters[a]\
    \ as isize;\n        let count_b = counters[b] as isize;\n        if count_a <\
    \ count_b {\n            1\n        } else if count_a > count_b {\n          \
    \  -1\n        } else {\n            a.cmp(&b)\n        }\n    });\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp3vonh_ts.rs:16:13\n   |\n16 |             counters[i/2] += 1;\n   |\
    \             ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `&&isize`\n  --> /tmp/tmp3vonh_ts.rs:22:23\n\
    \   |\n22 |         let count_a = counters[a] as isize;\n   |                \
    \       ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&&isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `&&isize`\n  --> /tmp/tmp3vonh_ts.rs:23:23\n\
    \   |\n23 |         let count_b = counters[b] as isize;\n   |                \
    \       ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&&isize>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3vonh_ts.rs:25:13\n   |\n25 |\
    \             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3vonh_ts.rs:27:13\n\
    \   |\n27 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3vonh_ts.rs:32:5\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n32 |     sorted_arr\n   |     ^^^^^^^^"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Your code goes here\n    let mut nums =\
    \ arr.clone();\n    swap(&mut nums, 0, arr.len());\n    nums.sort_by(|a, b| {\n\
    \        let cmp = if a > b { 1 } else { a as isize };\n        if a > b { 1 }\
    \ else { -1 }\n    });\n    nums\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpg_cdedxx.rs:14:5\n\
    \   |\n14 |     swap(&mut nums, 0, arr.len());\n   |     ^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg_cdedxx.rs:17:20\n   |\n17 |         if a > b { 1 } else { -1 }\n \
    \  |                    ^ expected enum `std::cmp::Ordering`, found integer\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpg_cdedxx.rs:17:31\n   |\n17 |  \
    \       if a > b { 1 } else { -1 }\n   |                               ^^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror[E0606]: casting `&isize` as\
    \ `isize` is invalid\n  --> /tmp/tmpg_cdedxx.rs:16:41\n   |\n16 |         let\
    \ cmp = if a > b { 1 } else { a as isize };\n   |                            \
    \             -^^^^^^^^^\n   |                                         |\n   |\
    \                                         cannot cast `&isize` as `isize`\n  \
    \ |                                         help: dereference the expression:\
    \ `*a`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0606.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut tmp = arr.clone();\n    let mut counts:\
    \ Vec<usize> = vec![];\n    for i in tmp.iter() {\n        counts.push(i);\n \
    \   }\n    counts.sort_unstable();\n    for i in counts {\n        tmp[i] = tmp[i].checked_sub(1);\n\
    \    }\n    tmp\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfi6qwtkj.rs:15:21\n   |\n\
    15 |         counts.push(i);\n   |                     ^ expected `usize`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfi6qwtkj.rs:19:18\n\
    \   |\n19 |         tmp[i] = tmp[i].checked_sub(1);\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |         |\n   |         expected\
    \ due to the type of this binding\n   |\n   = note: expected type `isize`\n  \
    \            found enum `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| x.count_ones() as isize)\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0vvgfqyh.rs:12:5\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n12 |\
    \     arr.sort_by_key(|x| x.count_ones() as isize)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        let mut cnt =\
    \ 0;\n        let mut res = 0;\n        for &n in &arr {\n            if *n <\
    \ 0 {\n                cnt += *n;\n            } else {\n                res +=\
    \ *n;\n                cnt += 1;\n            }\n        }\n        res / cnt\n\
    \    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpfpp0xkoc.rs:16:16\n\
    \   |\n16 |             if *n < 0 {\n   |                ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpfpp0xkoc.rs:17:24\n   |\n17 |\
    \                 cnt += *n;\n   |                        ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpfpp0xkoc.rs:19:24\n   |\n\
    19 |                 res += *n;\n   |                        ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfpp0xkoc.rs:23:9\n   |\n23 |         res / cnt\n\
    \   |         ^^^^^^^^^ expected enum `std::cmp::Ordering`, found integer\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfpp0xkoc.rs:12:5\n   |\n11 |   fn\
    \ sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                          \
    \           ---------- expected `Vec<isize>` because of return type\n12 | /  \
    \   arr.sort_by(|a, b| {\n13 | |         let mut cnt = 0;\n14 | |         let\
    \ mut res = 0;\n15 | |         for &n in &arr {\n...  |\n23 | |         res /\
    \ cnt\n24 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    arr.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpq_x8eog3.rs:12:5\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n12 |     arr.sort();\n   |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        if a < b {\n\
    \            Some(a.clone() as usize)\n        } else {\n            Some(b.clone()\
    \ as usize)\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzc8nz0n7.rs:14:13\n   |\n\
    14 |             Some(a.clone() as usize)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzc8nz0n7.rs:16:13\n   |\n16 |             Some(b.clone()\
    \ as usize)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpzc8nz0n7.rs:12:5\n   |\n11 |   fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                     ---------- expected `Vec<isize>`\
    \ because of return type\n12 | /     arr.sort_by(|a, b| {\n13 | |         if a\
    \ < b {\n14 | |             Some(a.clone() as usize)\n15 | |         } else {\n\
    16 | |             Some(b.clone() as usize)\n17 | |         }\n18 | |     })\n\
    \   | |______^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![arr[0]];\n    let mut cnt\
    \ = 0;\n    for x in arr.iter().rev() {\n        if cnt > 0 && cnt >= x {\n  \
    \          cnt -= x;\n            res[0] = x;\n        } else {\n            cnt\
    \ += x;\n            res[res.len() - 1] = x;\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp_2b8ewgf.rs:15:27\n\
    \   |\n15 |         if cnt > 0 && cnt >= x {\n   |                           ^^\
    \ no implementation for `isize < &isize` and `isize > &isize`\n   |\n   = help:\
    \ the trait `PartialOrd<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialOrd<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_2b8ewgf.rs:17:22\n   |\n17 |\
    \             res[0] = x;\n   |             ------   ^ expected `isize`, found\
    \ `&isize`\n   |             |\n   |             expected due to the type of this\
    \ binding\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |         \
    \    res[0] = *x;\n   |                      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_2b8ewgf.rs:20:34\n   |\n20 |             res[res.len() - 1] =\
    \ x;\n   |             ------------------   ^ expected `isize`, found `&isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |             res[res.len()\
    \ - 1] = *x;\n   |                                  +\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec1 = vec![0; arr.len()];\n    let\
    \ mut vec2 = vec![0; arr.len()];\n\n    for i in arr {\n        if vec1[i] !=\
    \ 0 {\n            vec2[i] = vec1[i];\n        }\n        vec1[i] = i;\n    }\n\
    \n    for i in arr {\n        if vec2[i] == vec1[i] {\n            vec1[i] = i;\n\
    \        }\n    }\n\n    for i in arr {\n        if vec2[i] != 0 {\n         \
    \   vec1[i] = vec1[i] / vec2[i];\n        }\n    }\n\n    for i in 0..arr.len()\
    \ {\n        vec1[i] = vec1[i] + (i + 1);\n    }\n\n    for i in arr {\n     \
    \   if vec1[i] < i {\n            vec1.swap(i, vec1[i]);\n        }\n    }\n\n\
    \    vec1\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp9emgkcr6.rs:16:12\n   |\n16 |         if vec1[i] != 0 {\n   |      \
    \      ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp9emgkcr6.rs:17:13\n\
    \   |\n17 |             vec2[i] = vec1[i];\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9emgkcr6.rs:17:23\n   |\n17 |  \
    \           vec2[i] = vec1[i];\n   |                       ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9emgkcr6.rs:19:9\n   |\n19 |   \
    \      vec1[i] = i;\n   |         ^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9emgkcr6.rs:23:12\n   |\n23 |  \
    \       if vec2[i] == vec1[i] {\n   |            ^^^^^^^ slice indices are of\
    \ ty"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        let mut c = 0.0;\n\
    \        while a != 0 {\n            c = c.max(&a);\n            a = a >> 1;\n\
    \        }\n        let mut d = 0.0;\n        while b != 0 {\n            d =\
    \ d.max(&b);\n            b = b >> 1;\n        }\n        c.cmp(&d).expect(\"\
    a and b are not equal\")\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp46vx9qvd.rs:14:17\n\
    \   |\n14 |         while a != 0 {\n   |                 ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0689]: can't call method `max`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmp46vx9qvd.rs:15:19\n   |\n\
    15 |             c = c.max(&a);\n   |                   ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `f32`\n   |\n13 |         let mut c: f32\
    \ = 0.0;\n   |             ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp46vx9qvd.rs:16:17\n   |\n12 |     arr.sort_by(|a, b| {\n   |       \
    \           - expected due to this parameter type\n...\n16 |             a = a\
    \ >> 1;\n   |                 ^^^^^^\n   |                 |\n   |           \
    \      expected `&isize`, found `isize`\n   |                 help: consider borrowing\
    \ here: `&(a >> 1)`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp46vx9qvd.rs:19:17\n   |\n19 |         while b != 0 {\n   |    \
    \             ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0689]: can't call method `max` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmp46vx9qvd.rs:20:19\n   |\n20 |             d = d.max(&b);\n   |\
    \                   ^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `f32`\n   |\n18 |         let mut d: f32 = 0.0;\n   |             ~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp46vx9qvd.rs:21:17\n   |\n12 |\
    \     "
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort_by(|x, y| {\n    \
    \    let mut i = x;\n        let mut j = y;\n        while i < j {\n         \
    \   while i + 1 < j && arr[i] + arr[i + 1] == 1 {\n                i += 1;\n \
    \           }\n            while i + 1 < j && arr[j] + arr[j + 1] == 1 {\n   \
    \             j += 1;\n            }\n            if i < j {\n               \
    \ let tmp = *i;\n                *i = *j;\n                *j = tmp;\n       \
    \     }\n        }\n        i - j\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpicrd6e0h.rs:12:25\n   |\n12 |     arr.iter().cloned().sort_by(|x,\
    \ y| {\n   |                         ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpatcsw1qy.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = arr.clone();\n\
    \    let mut num: usize = 0;\n    for i in 0..arr.len() {\n        if &arr[i]\
    \ != 0 {\n            num |= 1 << i;\n            result.push(i);\n        }\n\
    \    }\n    if num > 0 {\n        num = sort_array(&result) + num;\n        num\
    \ = num.pow(2);\n        num = num.cmp(&num);\n        while num != 0 {\n    \
    \        let pos = num % 10;\n            let value = result.iter().position(|i|\
    \ i == pos).unwrap();\n            result.swap(pos, value);\n            num =\
    \ num / 10;\n            num = num.cmp(&num);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp5wrl1chp.rs:15:20\n\
    \   |\n15 |         if &arr[i] != 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5wrl1chp.rs:17:25\n   |\n17 |             result.push(i);\n   |    \
    \                     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    17 |             result.push(i.try_into().unwrap());\n   |                   \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wrl1chp.rs:21:26\n\
    \   |\n21 |         num = sort_array(&result) + num;\n   |                   \
    \       ^^^^^^^ expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n           found reference `&Vec<isize>`\nhelp: consider\
    \ removing the borrow\n   |\n21 -         num = sort_array(&result) + num;\n21\
    \ +         num = sort_array(result) + num;\n   | \n\nerror[E0369]: cannot add\
    \ `usize` to `Vec<isize>`\n  --> /tmp/tmp5wrl1chp.rs:21:35\n   |\n21 |       \
    \  num = sort_array(&result) + num;\n   |               ------------------- ^\
    \ --- usize\n   |               |\n   |               Vec<isize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5wrl1chp.rs:23:15\n   |\n13 |     let mut num:\
    \ usize = 0;\n   |                  ----- expected due to this type\n...\n23 |\
    \         num = num.cmp(&num);\n   |               ^^^^^^^^^^^^^ expected `usize`,\
    \ found enum `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wrl1chp.rs:26:57\n\
    \   |\n26 |             let value = result.iter().position(|i| i == pos).unwrap();\n\
    \   |                                                         ^^^ expected `isize`,\
    \ found `usize"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    // Count number of ones.\n    let mut count = arr\n        .iter()\n\
    \        .fold(0, |sum, elt| sum + elt.iter().any(|&x| x == 1));\n    if count\
    \ < 32 {\n        arr.sort_unstable();\n        return arr;\n    }\n    // Count\
    \ number of ones divided by 32\n    count = count / 32;\n    // Sort according\
    \ to number of ones.\n    arr.sort_unstable_by_key(|elt| elt / count);\n    return\
    \ arr;\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpvl6qte8a.rs:18:39\n   |\n18 |         .fold(0,\
    \ |sum, elt| sum + elt.iter().any(|&x| x == 1));\n   |                       \
    \                ^^^^ method not found in `&isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut count =\
    \ 0;\n    for el in arr.iter() {\n        if count > 0 {\n            if el ==\
    \ 1 {\n                count -= 1;\n                res.push(el);\n          \
    \  } else {\n                count += 1;\n            }\n        }\n    }\n  \
    \  res.sort();\n    res.iter()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp2ct5enhc.rs:16:19\n\
    \   |\n16 |             if el == 1 {\n   |                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2ct5enhc.rs:25:5\n   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                   ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     res.iter()\n   |     ^^^^^^^^^^ expected struct\
    \ `Vec`, found struct `std::slice::Iter`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `std::slice::Iter<'_, &isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().filter(|&x| x <= 0).rev().cloned().sort_by_key(|x|\
    \ {\n        let mut n = x;\n        let mut d = 0;\n        while n > 0 {\n \
    \           n >>= 1;\n            d += 1;\n        }\n        d / 2\n    }).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqkckxz7.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&x| x <= 0).rev().cloned().sort_by_key(|x| {\n   |\
    \                                 ^\n   |                                 |\n\
    \   |                                 expected `&isize`, found integer\n   | \
    \                                help: consider borrowing here: `&0`\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `Cloned` in the current scope\n\
    \  --> /tmp/tmpkqkckxz7.rs:12:51\n   |\n12 |     arr.iter().filter(|&x| x <= 0).rev().cloned().sort_by_key(|x|\
    \ {\n   |                                                   ^^^^^^^^^^^ method\
    \ not found in `Cloned<Rev<Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpkqkckxz7.rs:12:23:\
    \ 12:34]>>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort_by_key(|&x| {\n  \
    \      binary.binary_count_ones_reversed(x).unwrap()\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `binary` in this scope\n  --> /tmp/tmp68xeeub4.rs:13:9\n\
    \   |\n13 |         binary.binary_count_ones_reversed(x).unwrap()\n   |      \
    \   ^^^^^^ not found in this scope\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmp68xeeub4.rs:12:25\n\
    \   |\n12 |     arr.iter().cloned().sort_by_key(|&x| {\n   |                 \
    \        ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| x.ones_count_());\n   \
    \ arr.sort_by_key(|x| x.decimal_value());\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ones_count_` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp5ha2ssyg.rs:12:27\n   |\n12 |     arr.sort_by_key(|x|\
    \ x.ones_count_());\n   |                           ^^^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror[E0599]: no method named `decimal_value` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmp5ha2ssyg.rs:13:27\n   |\n13 | \
    \    arr.sort_by_key(|x| x.decimal_value());\n   |                           ^^^^^^^^^^^^^\
    \ method not found in `&isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by(|a,\
    \ b| count_ones_in_bin(a) < count_ones_in_bin(b));\n    sorted_arr.sort_by(|a,\
    \ b| a < b);\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_ones_in_bin` in this scope\n\
    \  --> /tmp/tmpn03r33t6.rs:13:31\n   |\n13 |     sorted_arr.sort_by(|a, b| count_ones_in_bin(a)\
    \ < count_ones_in_bin(b));\n   |                               ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `count_ones_in_bin`\
    \ in this scope\n  --> /tmp/tmpn03r33t6.rs:13:54\n   |\n13 |     sorted_arr.sort_by(|a,\
    \ b| count_ones_in_bin(a) < count_ones_in_bin(b));\n   |                     \
    \                                 ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpn03r33t6.rs:13:31\n   |\n13 |  \
    \   sorted_arr.sort_by(|a, b| count_ones_in_bin(a) < count_ones_in_bin(b));\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn03r33t6.rs:14:31\n   |\n14 |     sorted_arr.sort_by(|a,\
    \ b| a < b);\n   |                               ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() <= 1 {\n        return arr;\n\
    \    }\n    let mut counts = Vec::new();\n    for i in 0..arr.len() {\n      \
    \  let v = arr[i];\n        if v == 0 {\n            counts.push(0);\n       \
    \ } else {\n            counts.push(*(1 << ((v as usize) - 1).leading_zeros()\
    \ as isize) + 1);\n        }\n    }\n    counts.sort_by_key(|i| i).collect();\n\
    \    arr.sort_by_key(|i| {\n        let v = *((i as usize).leading_zeros() as\
    \ usize) + 1;\n        counts.iter().zip(v).rfold(0, |sum, (i, _)| *sum + i) as\
    \ usize\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp1re9_afy.rs:21:25\n\
    \   |\n21 |             counts.push(*(1 << ((v as usize) - 1).leading_zeros()\
    \ as isize) + 1);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmp1re9_afy.rs:24:31\n   |\n\
    24 |     counts.sort_by_key(|i| i).collect();\n   |                          \
    \     ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmp1re9_afy.rs:26:17\n   |\n26 |         let v = *((i as usize).leading_zeros()\
    \ as usize) + 1;\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp1re9_afy.rs:27:53\n\
    \   |\n27 |         counts.iter().zip(v).rfold(0, |sum, (i, _)| *sum + i) as usize\n\
    \   |                                                     ^^^^\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmp1re9_afy.rs:26:19\n  \
    \ |\n26 |         let v = *((i as usize).leading_zeros() as usize) + 1;\n   |\
    \                   ^-^^^^^^^^^^\n   |                   ||\n   |            \
    \       |help: dereference the expression: `*i`\n   |                   cannot\
    \ cast `&isize` as `usize`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0606, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n    let mut sorted_arr = arr;\n    let mut zero_index = arr.len();\n\n\
    \    for zero_index in 0..arr.len() {\n        for non_zero_index in 0..arr.len()\
    \ {\n            if arr[zero_index] > 0 && arr[non_zero_index] >= 1 {\n      \
    \          sorted_arr.swap(zero_index, non_zero_index);\n                break;\n\
    \            }\n        }\n    }\n\n    sorted_arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `zero_index`\n  --> /tmp/tmpf7jh_9ub.rs:16:13\n\
    \   |\n16 |     let mut zero_index = arr.len();\n   |             ^^^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_zero_index`\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpf7jh_9ub.rs:16:9\n   |\n16 |     let mut\
    \ zero_index = arr.len();\n   |         ----^^^^^^^^^^\n   |         |\n   | \
    \        help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by\
    \ default\n\nerror[E0382]: borrow of moved value: `arr`\n  --> /tmp/tmpf7jh_9ub.rs:16:26\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \  --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     let mut sorted_arr = arr;\n   |            \
    \              --- value moved here\n16 |     let mut zero_index = arr.len();\n\
    \   |                          ^^^^^^^^^ value borrowed here after move\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| {\n        let mut res\
    \ = 0;\n        for &y in &arr {\n            if *y > 0 { res += 1 }\n       \
    \ }\n        res\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpp0v2jd6m.rs:15:16\n\
    \   |\n15 |             if *y > 0 { res += 1 }\n   |                ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut s = arr.len();\n    if s == 0 {\n \
    \       return arr;\n    }\n    // first sort according to number of ones\n  \
    \  let mut max_ones = 0;\n    let mut idx = -1;\n    for i in 0..s {\n       \
    \ if arr[i] > max_ones {\n            max_ones = arr[i];\n            idx = i;\n\
    \        }\n    }\n    let mut ones = 0;\n    for i in 0..s {\n        if arr[i]\
    \ == max_ones {\n            ones += 1;\n        }\n    }\n    // now sort according\
    \ to decimal value\n    if ones > 0 {\n        let mut min_dec = 0;\n        for\
    \ i in 0..s {\n            if arr[i] < min_dec {\n                min_dec = arr[i];\n\
    \                idx = i;\n            }\n        }\n        if ones < max_ones\
    \ {\n            idx += 1;\n        }\n    }\n    sort_array(&arr[..idx])\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdhlzfi_p.rs:18:19\n\
    \   |\n18 |     let mut idx = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdhlzfi_p.rs:44:16\n   |\n44 |     sort_array(&arr[..idx])\n   |\
    \                ^^^^^^^^^^^ expected struct `Vec`, found `&[isize]`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n           found reference `&[isize]`\n\
    help: try using a conversion method\n   |\n44 |     sort_array((&arr[..idx]).to_vec())\n\
    \   |                +           ++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut s = arr.to_owned();\n    let mut counter:\
    \ Vec<isize> = Vec::new();\n    for val in s {\n        if val & 1 == 1 {\n  \
    \          counter.push(*val);\n        }\n    }\n    s.sort_by(|a, b| b.cmp(&a));\n\
    \    for val in counter {\n        s.push(*val);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp_t7b2wd4.rs:16:26\n\
    \   |\n16 |             counter.push(*val);\n   |                          ^^^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp_t7b2wd4.rs:21:16\n\
    \   |\n21 |         s.push(*val);\n   |                ^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // YOUR CODE HERE\n    let mut ones = 0;\n\
    \    let mut dec = 0;\n    let mut i = 0;\n    for i in arr.iter() {\n       \
    \ if *i == 1 {\n            ones += 1;\n        } else {\n            dec += *i;\n\
    \        }\n    }\n    let mut i = 0;\n    for i in arr.iter() {\n        if ones\
    \ > 0 {\n            i += dec + i;\n            ones += 1;\n            dec +=\
    \ *i;\n        } else {\n            i += *i;\n            ones += 1;\n      \
    \  }\n    }\n    vec![i - 1, i]\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpe_dtfqr7.rs:26:13\n   |\n26 |             i += dec +\
    \ i;\n   |             -^^^^^^^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can\
    \ dereference `i`\n   |\n26 |             *i += dec + i;\n   |             +\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&isize`\n\
    \  --> /tmp/tmpe_dtfqr7.rs:30:13\n   |\n30 |             i += *i;\n   |      \
    \       -^^^^^^\n   |             |\n   |             cannot use `+=` on type\
    \ `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference `i`\n\
    \   |\n30 |             *i += *i;\n   |             +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0368`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n\n    // TODO: Your code goes here\n    let mut num = 0;\n    for v in\
    \ arr.iter().rev() {\n        if v != 0 {\n            num |= v;\n        } else\
    \ {\n            arr.swap(0, arr.len() - 1);\n            arr.swap(num - 1, num);\n\
    \            num = 0;\n        }\n    }\n    if num > 0 {\n        arr.swap(0,\
    \ arr.len() - 1);\n        arr.swap(num - 1, num);\n    }\n\n    arr\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpo86k3hnz.rs:19:14\n\
    \   |\n19 |         if v != 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo86k3hnz.rs:23:22\n\
    \   |\n23 |             arr.swap(num - 1, num);\n   |                      ^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n23 |           \
    \  arr.swap((num - 1).try_into().unwrap(), num);\n   |                      +\
    \       +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo86k3hnz.rs:23:31\n\
    \   |\n23 |             arr.swap(num - 1, num);\n   |                        \
    \       ^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n23 |      \
    \       arr.swap(num - 1, num.try_into().unwrap());\n   |                    \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo86k3hnz.rs:29:18\n\
    \   |\n29 |         arr.swap(num - 1, num);\n   |                  ^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |         arr.swap((num\
    \ - 1).try_into().unwrap(), num);\n   |                  +       +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo86k3hnz.rs:29:27\n   |\n29 |\
    \         arr.swap(num - 1, num);\n   |                           ^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |         arr.swap(num\
    \ - 1, num.try_into().unwrap());\n   |                              ++++++++++"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort(|x, y| {\n       \
    \ match x.leading_zeros() {\n            0 => y.leading_zeros(),\n           \
    \ 1 => x.leading_zeros() > y.leading_zeros() ? 1 : 0,\n            _ => match\
    \ x.leading_zeros() {\n                0 => 1,\n                _ => -1,\n   \
    \         },\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `1`\n\
    \  --> /tmp/tmpsg78i1bo.rs:15:58\n   |\n15 |             1 => x.leading_zeros()\
    \ > y.leading_zeros() ? 1 : 0,\n   |               --                        \
    \                 ^ expected one of `,`, `.`, `?`, `}`, or an operator\n   | \
    \              |\n   |               while parsing the `match` arm starting here\n\
    \nerror[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpsg78i1bo.rs:12:25\n   |\n12 |     arr.iter().cloned().sort(|x,\
    \ y| {\n   |                         ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\n    for i in\
    \ 0..arr.len() {\n        let mut num = arr[i];\n        let mut count = 1;\n\n\
    \        while num > 0 {\n            if num % 2 == 1 {\n                result.push(i);\n\
    \                num /= 2;\n            } else {\n                count += 1;\n\
    \                num /= 2;\n            }\n        }\n\n        result.push(i);\n\
    \        result.push(count);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiyvtgia7.rs:32:5\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    32 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort_by_key(|x| {\n   \
    \     std::cmp::PartialOrd::cmp(x.to_bin(), x.to_bin().to_radix_reverse(2))\n\
    \    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpbl26pzoq.rs:12:25\n   |\n12 |     arr.iter().cloned().sort_by_key(|x|\
    \ {\n   |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nwarning: trait objects without an explicit `dyn` are deprecated\n\
    \  --> /tmp/tmpbl26pzoq.rs:13:9\n   |\n13 |         std::cmp::PartialOrd::cmp(x.to_bin(),\
    \ x.to_bin().to_radix_reverse(2))\n   |         ^^^^^^^^^^^^^^^^^^^^\n   |\n \
    \  = note: `#[warn(bare_trait_objects)]` on by default\n   = warning: this is\
    \ accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n13 |         <dyn std::cmp::PartialOrd>::cmp(x.to_bin(),\
    \ x.to_bin().to_radix_reverse(2))\n   |         ++++                     +\n\n\
    error[E0599]: the function or associated item `cmp` exists for trait object `dyn\
    \ PartialOrd<_>`, but its trait bounds were not satisfied\n    --> /tmp/tmpbl26pzoq.rs:13:31\n\
    \     |\n13   |           std::cmp::PartialOrd::cmp(x.to_bin(), x.to_bin().to_radix_reverse(2))\n\
    \     |                                 ^^^ function or associated item cannot\
    \ be called on `dyn PartialOrd<_>` due to unsatisfied trait bounds\n     |\n \
    \    = note: the following trait bounds were not satisfied:\n             `dyn\
    \ PartialOrd<_>: Ord`\n             which is required by `&dyn PartialOrd<_>:\
    \ Ord`\n             `dyn PartialOrd<_>: Ord`\n             which is required\
    \ by `&mut dyn PartialOrd<_>: Ord`\n             `dyn PartialOrd<_>: Iterator`\n\
    \             which is required by `&mut dyn PartialOrd<_>: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(arr.len());\n\
    \n    if arr.len() == 0 {\n        return result;\n    }\n\n    let mut cnt =\
    \ 0;\n    let mut min = 0;\n    let mut max = arr.len() - 1;\n\n    while cnt\
    \ < 100 {\n        if arr[max] - arr[min] < 2 {\n            // swap\n       \
    \     let tmp = min;\n            min = max;\n            max = tmp;\n       \
    \ }\n\n        if arr[max] - arr[min] > 2 {\n            cnt += 1;\n         \
    \   min += 1;\n            max -= 1;\n        } else {\n            cnt += 1;\n\
    \        }\n    }\n\n    let mut i = 0;\n    while i < min {\n        result.push(arr[i]);\n\
    \        i += 1;\n    }\n\n    i = min;\n    while i < max {\n        result.push(arr[i]);\n\
    \        i += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmprg5xldp4.rs:56:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr2 = arr.clone();\n    \n    // convert\
    \ numbers in array to their binary representation, then sort it\n    arr2.sort_by_key(|x|\
    \ bin(x)[..].len());\n    arr2.sort_by_key(|x| x.to_dec().unwrap());\n    \n \
    \   arr2\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `bin` in this scope\n  --> /tmp/tmpjo5gx0ko.rs:15:26\n\
    \   |\n15 |     arr2.sort_by_key(|x| bin(x)[..].len());\n   |                \
    \          ^^^ not found in this scope\n\nerror[E0599]: no method named `to_dec`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpjo5gx0ko.rs:16:28\n\
    \   |\n16 |     arr2.sort_by_key(|x| x.to_dec().unwrap());\n   |             \
    \               ^^^^^^ help: there is an associated function with a similar name:\
    \ `to_be`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in arr.iter().cloned()\
    \ {\n        result.push(i);\n    }\n    result.sort();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp7q6gjv2x.rs:22:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut rev_arr = arr;\n    rev_arr.sort();\n    let mut result =\
    \ vec![];\n    for i in 0..(rev_arr.len() - 1) {\n        result.push(rev_arr[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp91ebz26k.rs:26:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() <= 2 {\n        arr\n    } else\
    \ {\n        let mut swapped = false;\n        let mut largest = 0;\n        for\
    \ &i in arr {\n            let bin = format!(\"{:b}\", i).to_string();\n     \
    \       largest += bin.chars().count() as isize;\n            if largest > 1 {\n\
    \                swapped = true;\n                break;\n            }\n    \
    \    }\n        if !swapped {\n            arr\n        } else {\n           \
    \ let mut temp: Vec<isize> = vec![];\n            for &i in arr {\n          \
    \      let bin = format!(\"{:b}\", i).to_string();\n                let count\
    \ = bin.chars().count() as isize;\n                temp.append((count as isize).pow(2\
    \ as i32) - 1);\n            }\n            temp = temp.iter().cloned().collect();\n\
    \            let mut i = 0;\n            for &i in temp {\n                swap(&mut\
    \ arr, i, &mut temp, i);\n                i += 1;\n            }\n           \
    \ arr\n        }\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpv2ao9mqh.rs:37:17\n\
    \   |\n37 |                 swap(&mut arr, i, &mut temp, i);\n   |           \
    \      ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv2ao9mqh.rs:17:13\n   |\n17 |\
    \         for &i in arr {\n   |             ^^    --- this expression has type\
    \ `Option<isize>`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `i`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv2ao9mqh.rs:29:17\n   |\n29 |\
    \             for &i in arr {\n   |                 ^^    --- this expression\
    \ has type `Option<isize>`\n   |                 |\n   |                 expected\
    \ `isize`, found reference\n   |                 help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv2ao9mqh.rs:32:50\n\
    \   |\n32 |                 temp.append((count as isize).pow(2 as i32) - 1);\n\
    \   |                                                  ^^^^^^^^ expected `u32`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n32 |                 temp.append((count as\
    \ isize).pow((2 as i32).try_into().unwrap()) - 1);\n   |                     \
    \                             +        +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv2ao9mqh.rs:32:29\n   |\n32 |              \
    \   temp.append((count as isize).pow(2 as i32) - 1);\n   |                   \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut Vec<isize>`, found\
    \ `isize`\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n   \
    \                        found type `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv2ao9mqh.rs:36:17\n   |\n36 |             for &i in t"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        if a == b {\n\
    \            0\n        } else {\n            if a < b {\n                -1\n\
    \            } else {\n                1\n            }\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf2g0ksyq.rs:14:13\n   |\n\
    14 |             0\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf2g0ksyq.rs:17:17\n\
    \   |\n17 |                 -1\n   |                 ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf2g0ksyq.rs:19:17\n\
    \   |\n19 |                 1\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf2g0ksyq.rs:12:5\n\
    \   |\n11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n12 | /     arr.sort_by(|a, b| {\n13 | |         if a == b {\n14 | |  \
    \           0\n15 | |         } else {\n...  |\n21 | |         }\n22 | |     })\n\
    \   | |______^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        debug_assert!(a\
    \ < b);\n        debug_assert!(b < a);\n        debug_assert!((a & b) != 0 ||\
    \ (a & b) == 0);\n        debug_assert!((b & a) != 0 || (b & a) == 0);\n\n   \
    \     let mut n = 0;\n        loop {\n            if a & 1 != 0 {\n          \
    \      n |= 1;\n                a >>= 1;\n            } else {\n             \
    \   break;\n            }\n        }\n        loop {\n            if b & 1 !=\
    \ 0 {\n                n |= 1;\n                b >>= 1;\n            } else {\n\
    \                break;\n            }\n        }\n\n        debug_assert!(n !=\
    \ 0);\n        n\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `>>=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmp52756g68.rs:22:17\n   |\n22 |                 a >>=\
    \ 1;\n   |                 -^^^^^^\n   |                 |\n   |             \
    \    cannot use `>>=` on type `&isize`\n   |\nhelp: `>>=` can be used on `isize`,\
    \ you can dereference `a`\n   |\n22 |                 *a >>= 1;\n   |        \
    \         +\n\nerror[E0368]: binary assignment operation `>>=` cannot be applied\
    \ to type `&isize`\n  --> /tmp/tmp52756g68.rs:30:17\n   |\n30 |              \
    \   b >>= 1;\n   |                 -^^^^^^\n   |                 |\n   |     \
    \            cannot use `>>=` on type `&isize`\n   |\nhelp: `>>=` can be used\
    \ on `isize`, you can dereference `b`\n   |\n30 |                 *b >>= 1;\n\
    \   |                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp52756g68.rs:37:9\n\
    \   |\n37 |         n\n   |         ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp52756g68.rs:12:5\n\
    \   |\n11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n12 | /     arr.sort_by(|a, b| {\n13 | |         debug_assert!(a < b);\n\
    14 | |         debug_assert!(b < a);\n15 | |         debug_assert!((a & b) !=\
    \ 0 || (a & b) == 0);\n...  |\n37 | |         n\n38 | |     })\n   | |______^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut temp = vec![];\n    let mut cnt = 0;\n\
    \    let mut cur = -1;\n    for x in arr.iter() {\n        if x == 0 {\n     \
    \       cnt += 1;\n        } else {\n            cnt += 1;\n            temp.push(cnt);\n\
    \        }\n        cur += 1;\n    }\n    for i in 0..temp.len() {\n        arr[i]\
    \ = arr[temp[i] - 1];\n    }\n    arr.sort();\n    for i in 0..temp.len() {\n\
    \        arr[i] += cur;\n    }\n    arr\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpsgg_t85x.rs:16:14\n\
    \   |\n16 |         if x == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = arr.clone();\n\n   \
    \ // sort negative numbers at the end\n    if arr.iter().any(|&x| x < 0) {\n \
    \       sorted_array.sort_by_key(|x| -x);\n    }\n\n    // sort positive numbers\
    \ in descending order\n    if arr.iter().any(|&x| x >= 0) {\n        sorted_array.sort_by_key(|x|\
    \ -x.clone());\n    }\n\n    sorted_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmprbotyy9y.rs:29:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| {\n        let mut v =\
    \ x;\n        v.checked_mul(2).ok_or(\"Invalid number in binary representation\"\
    )?;\n        v.checked_add(1).ok_or(\"Invalid number in binary representation\"\
    )?;\n        v\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the `?` operator can only be used in a closure that returns\
    \ `Result` or `Option` (or another type that implements `FromResidual`)\n  -->\
    \ /tmp/tmp1v9x_rnv.rs:14:74\n   |\n12 |       arr.sort_by_key(|x| {\n   |  _____________________-\n\
    13 | |         let mut v = x;\n14 | |         v.checked_mul(2).ok_or(\"Invalid\
    \ number in binary representation\")?;\n   | |                               \
    \                                           ^ cannot use the `?` operator in a\
    \ closure that returns `&isize`\n15 | |         v.checked_add(1).ok_or(\"Invalid\
    \ number in binary representation\")?;\n16 | |         v\n17 | |     })\n   |\
    \ |_____- this function should return `Result` or `Option` to accept `?`\n   |\n\
    \   = help: the trait `FromResidual<Result<Infallible, &str>>` is not implemented\
    \ for `&isize`\n\nerror[E0277]: the `?` operator can only be used in a closure\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmp1v9x_rnv.rs:15:74\n   |\n12 |       arr.sort_by_key(|x| {\n   |\
    \  _____________________-\n13 | |         let mut v = x;\n14 | |         v.checked_mul(2).ok_or(\"\
    Invalid number in binary representation\")?;\n15 | |         v.checked_add(1).ok_or(\"\
    Invalid number in binary representation\")?;\n   | |                         \
    \                                                 ^ cannot use the `?` operator\
    \ in a closure that returns `&isize`\n16 | |         v\n17 | |     })\n   | |_____-\
    \ this function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<Result<Infallible, &str>>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1v9x_rnv.rs:12:5\n   |\n11 | \
    \  fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                      \
    \               ---------- expected `Vec<isize>` because of return type\n12 |\
    \ /     arr.sort_by_key(|x| {\n13 | |         let mut v = x;\n14 | |         v.checked_mul(2).ok_or(\"\
    Invalid number in binary representation\")?;\n15 | |         v.checked_add(1).ok_or(\"\
    Invalid number in binary representation\")?;\n16 | |         v\n17"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Solution 1.\n    // The idea is to create\
    \ a map of [1..n] where the keys are the binary ones\n    // and the values are\
    \ the corresponding decimal number.\n    let mut one_num_map = vec![];\n    for\
    \ i in 0..arr.len() {\n        let ones = i >> 6;\n        let num = i & 0x3F;\n\
    \        one_num_map.push((ones, num));\n    }\n    one_num_map.sort_by(|a, b|\
    \ a.1.cmp(&b.1));\n    // The first element of the tuple is the binary ones, the\
    \ second the decimal\n    // ones.\n    let sorted_arr = arr.iter().cloned().map(|i|\
    \ {\n        one_num_map\n            .iter()\n            .find(|(&i, _)| i ==\
    \ 1)\n            .map(|&(_, num)| num)\n            .unwrap_or(i as isize)\n\
    \    }).collect();\n    sorted_arr.sort_unstable();\n    sorted_arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkpdgsdxs.rs:27:21\n   |\n\
    27 |             .find(|(&i, _)| i == 1)\n   |                     ^^   - expected\
    \ due to this\n   |                     |\n   |                     expected `usize`,\
    \ found reference\n   |                     help: you can probably remove the\
    \ explicit borrow: `i`\n   |\n   = note:   expected type `usize`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkpdgsdxs.rs:29:24\n\
    \   |\n29 |             .unwrap_or(i as isize)\n   |                        ^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n29 |           \
    \  .unwrap_or((i as isize).try_into().unwrap())\n   |                        +\
    \          +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        arr\n    } else\
    \ {\n        let mut counter: Vec<isize> = vec![];\n        let mut max_count\
    \ = 1isize;\n        for i in arr.iter().cloned() {\n            counter.push(i);\n\
    \            if *i > max_count {\n                max_count = *i;\n          \
    \  }\n        }\n        // Sort the counter according to the number of the ones\
    \ in their binary representation\n        // In ascending order\n        counter.sort_by_key(|&x|\
    \ {\n            let mut counter2 = counter;\n            let mut count = 0;\n\
    \            while (counter2.len() > 0 && counter >= 0) {\n                count\
    \ += *counter2.last().unwrap();\n                counter2.pop();\n           \
    \ }\n            count + x;\n        });\n        // Sort based on the decimal\
    \ value\n        // In descending order\n        counter.sort_by_key(|&x| {\n\
    \            *x / max_count\n        });\n        // Copy the array into a new\
    \ one and return it\n        arr.clone_from_slice(counter)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmproldzquj.rs:28:19\n\
    \   |\n28 |             while (counter2.len() > 0 && counter >= 0) {\n   |   \
    \                ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n28 -             while\
    \ (counter2.len() > 0 && counter >= 0) {\n28 +             while counter2.len()\
    \ > 0 && counter >= 0 {\n   | \n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmproldzquj.rs:19:16\n   |\n19 |             if *i > max_count {\n\
    \   |                ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmproldzquj.rs:20:29\n   |\n20 |                 max_count = *i;\n\
    \   |                             ^^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmproldzquj.rs:28:53\n   |\n28 |             while (counter2.len() > 0\
    \ && counter >= 0) {\n   |                                                   \
    \  ^ expected struct `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `{integer}`\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmproldzquj.rs:37:13\n   |\n37 |             *x / max_count\n\
    \   |             ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmproldzquj.rs:40:30\n\
    \   |\n40 |         arr.clone_from_slice(counter)\n   |                      \
    \        ^^^^^^^\n   |                              |\n   |                  \
    \            expected `&[isize]`, found struct `Vec`\n   |                   \
    \           help: consider borrowing here: `&counter`\n   |\n   = note: expected\
    \ reference `&[isize]`\n                 found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmproldzquj.rs:40:9\n   |\n11 | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                   ----------\
    \ expected `Vec<isize>` because of return type\n...\n40 |         arr.clone_from_slice(counter)\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror:"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut leng = arr.len();\n    let mut ones = 0;\n    let mut decimals = 0;\n\n\
    \    while i < leng {\n        match arr[i].checked_sub(1).is_zero() {\n     \
    \       false => i += 1,\n            true => {\n                ones += 1;\n\
    \                j += 1;\n                i += 1;\n            }\n        };\n\
    \n        if arr[i] > 0 && ones <= leng {\n            ones += 1;\n          \
    \  j += 1;\n            i += 1;\n        } else if arr[i] < 0 && ones <= leng\
    \ {\n            ones += 1;\n            i += 1;\n        } else {\n         \
    \   decimals += 1;\n            j += 1;\n            i += 1;\n        }\n    }\n\
    \n    while j < leng {\n        if decimals == leng {\n            return arr.clone();\
    \ // unchanged\n        }\n\n        arr[j] += decimals;\n        j += 1;\n  \
    \      decimals = 0;\n    }\n\n    while i < leng {\n        if decimals == leng\
    \ {\n            return arr.clone(); // unchanged\n        }\n\n        arr[i]\
    \ += decimals;\n        i += 1;\n        decimals = 0;\n    }\n\n    arr\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmp8lfx2u_7.rs:19:37\n   |\n19 |         match arr[i].checked_sub(1).is_zero()\
    \ {\n   |                                     ^^^^^^^ method not found in `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8lfx2u_7.rs:47:19\n   |\n47 |\
    \         arr[j] += decimals;\n   |                   ^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `isize`\n  --> /tmp/tmp8lfx2u_7.rs:47:16\n\
    \   |\n47 |         arr[j] += decimals;\n   |                ^^ no implementation\
    \ for `isize += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8lfx2u_7.rs:57:19\n\
    \   |\n57 |         arr[i] += decimals;\n   |                   ^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `isize`\n\
    \  --> /tmp/tmp8lfx2u_7.rs:57:16\n   |\n57 |         arr[i] += decimals;\n   |\
    \                ^^ no implementation for `isize += usize`\n   |\n   = help: the\
    \ trait `AddAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut count_arr\
    \ = vec![];\n    for i in arr {\n        count_arr.push(1);\n    }\n    for i\
    \ in 1..arr.len() {\n        if count_arr[i] - count_arr[i - 1] > 0 {\n      \
    \      let len = count_arr[i - 1];\n            count_arr[i - 1] += count_arr[i];\n\
    \            count_arr[i] = len;\n        }\n    }\n    for i in 0..count_arr.len()\
    \ {\n        if count_arr[i] == 0 {\n            let len = i;\n            res.push(len);\n\
    \        }\n    }\n    for i in 0..arr.len() {\n        if count_arr[i] == 0 {\n\
    \            let len = i;\n            res.push(len);\n        }\n    }\n    for\
    \ i in 0..count_arr.len() {\n        if count_arr[i] == 0 {\n            let len\
    \ = i;\n            res.push(len);\n        }\n    }\n    for i in 0..count_arr.len()\
    \ {\n        if count_arr[i] == 0 {\n            let len = i;\n            res.push(len);\n\
    \        }\n    }\n    for i in 0..count_arr.len() {\n        if count_arr[i]\
    \ == 0 {\n            let len = i;\n            res.push(len);\n        }\n  \
    \  }\n    for i in 0..count_arr.len() {\n        if count_arr[i] == 0 {\n    \
    \        let len = i;\n            res.push(len);\n        }\n    }\n    for i\
    \ in 0..count_arr.len() {\n        if count_arr[i] == 0 {\n            let len\
    \ = i;\n            res.push(len);\n        }\n    }\n    for i in 0..count_arr.len()\
    \ {\n        if count_arr[i] == 0 {\n            let len = i;\n            res.push(len);\n\
    \        }\n    }\n    for i in 0..count_arr.len() {\n        if count_arr[i]\
    \ == 0 {\n            let len = i;\n            res.push(len);\n        }\n  \
    \  }\n    for i in 0..count_arr.len() {\n        if count_arr[i] == 0 {\n    \
    \        let len = i;\n            res.push(len);\n        }\n    }\n    for i\
    \ in 0..count_arr.len() {\n        if count_arr[i] == 0 {\n            let len\
    \ = i;\n            res.push(len);\n        }\n    }\n    for i in 0..count_arr.len()\
    \ {\n        if count_arr[i] == 0 {\n            let len = i;\n            res.push(len);\n\
    \        }\n    }\n    for i in 0..count_arr.len() {\n        if count_arr[i]\
    \ == 0 {\n            let len = i;\n            res.push(len);\n        }\n  \
    \  }\n    for i in 0..count_arr.len() {\n        if count_arr[i] == 0 {\n    \
    \        let len = i;\n            res.push(len);\n        }\n    }\n    for i\
    \ in 0..count_arr.len() {\n        if count_arr[i] == 0 {\n            let len\
    \ = i;\n            res.push(len);\n        }\n    }\n    for i in 0..count_arr.len()\
    \ {\n        if count_arr[i] == 0 {\n            let len = i;\n            res.push(len);\n\
    \        }\n    }\n    for i in 0..count_arr.len() {\n        if count_arr[i]\
    \ == 0 {\n            let len = i;\n            res.push(len);\n        }\n\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgp8co_s6.rs:138:3\n\
    \    |\n11  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n...\n120 |     for\
    \ i in 0..count_arr.len() {\n    |                                 - this delimiter\
    \ might not be properly closed...\n...\n126 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n138 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgp8co_s6.rs:11:35\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Your code here\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpstbbcyzq.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut count = HashMap::<isize, usize>::new();\n\
    \n    for num in arr {\n        count.entry(num).or_insert(0) += 1;\n    }\n\n\
    \    arr.iter().cloned().sorted().filter(|&x| x.is_some()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpbrybeeb3.rs:12:21\n   |\n12 |     let mut count = HashMap::<isize, usize>::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpbrybeeb3.rs:15:39\n   |\n\
    15 |         count.entry(num).or_insert(0) += 1;\n   |         -----------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Cloned` in the current scope\n  -->\
    \ /tmp/tmpbrybeeb3.rs:18:25\n   |\n18 |     arr.iter().cloned().sorted().filter(|&x|\
    \ x.is_some()).collect()\n   |                         ^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0433, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut ones:\
    \ Vec<usize> = Vec::new();\n    let mut total_ones = 0;\n    for &x in arr {\n\
    \        if x < 0 {\n            result.push(x);\n        } else {\n         \
    \   ones.push(x);\n            total_ones += 1;\n        }\n    }\n    if total_ones\
    \ < 2 {\n        arr\n    } else {\n        let mut i = 0;\n        for &x in\
    \ ones {\n            result[i++] = x;\n        }\n        while i < result.len()\
    \ {\n            result[i] = result[i] + 1;\n            i += 1;\n        }\n\
    \        sort_array(result);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpxgj8vxob.rs:28:21\n\
    \   |\n28 |             result[i++] = x;\n   |                     ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |             result[{\
    \ let tmp = i; i += 1; tmp }] = x;\n   |                    +++++++++++  ~~~~~~~~~~~~~~~\n\
    28 -             result[i++] = x;\n28 +             result[i += 1] = x;\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxgj8vxob.rs:15:9\n   |\n15\
    \ |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxgj8vxob.rs:24:9\n   |\n23 | /     if total_ones < 2 {\n24 | |\
    \         arr\n   | |         ^^^ expected `()`, found struct `Vec`\n25 | |  \
    \   } else {\n26 | |         let mut i = 0;\n...  |\n34 | |         sort_array(result);\n\
    35 | |     }\n   | |_____- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                 found struct `Vec<isize>`\nhelp: you might\
    \ have meant to return this value\n   |\n24 |         return arr;\n   |      \
    \   ++++++    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxgj8vxob.rs:27:13\n\
    \   |\n27 |         for &x in ones {\n   |             ^^    ---- this expression\
    \ has type `Option<usize>`\n   |             |\n   |             expected `usize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `usize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxgj8vxob.rs:34:20\n  \
    \ |\n34 |         sort_array(result);\n   |                    ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxgj8vxob.rs:36:5\n   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                   "
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter: Vec<isize> = vec![];\n   \
    \ arr.iter().cloned().for_each(|val| {\n        if val == 0 {\n            counter.push(0);\n\
    \        } else {\n            counter.push(counter.last().unwrap() + 1);\n  \
    \      }\n    });\n    counter.sort();\n    arr.iter().cloned().zip(counter.cloned()).map(|(val,\
    \ cnt)| {\n        if cnt == 0 {\n            val\n        } else {\n        \
    \    let mut decimal = val / cnt.to_f();\n            let result = decimal * 10\
    \ + val % cnt;\n            result\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmps_jlhiyf.rs:21:37\n\
    \    |\n21  |       arr.iter().cloned().zip(counter.cloned()).map(|(val, cnt)|\
    \ {\n    |                                       ^^^^^^ `Vec<isize>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_jlhiyf.rs:21:5\n\
    \   |\n11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n21 | /     arr.iter().cloned().zip(counter.cloned()).map(|(val, cnt)|\
    \ {\n22 | |         if cnt == 0 {\n23 | |             val\n24 | |         } else\
    \ {\n...  |\n28 | |         }\n29 | |     })\n   | |______^ expected struct `Vec`,\
    \ found struct `Map`\n   |\n   = note: expected struct `Vec<isize>`\n        \
    \      found struct `Map<Zip<Cloned<std::slice::Iter<'_, isize>>, _>, _>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return vec![];\n\
    \    }\n\n    let mut array = arr.to_owned();\n\n    let mut count = 0;\n    let\
    \ mut max_val = array[0];\n\n    for i in 1..array.len() {\n        if array[i]\
    \ > max_val {\n            max_val = array[i];\n            count = i;\n     \
    \   }\n    }\n\n    for i in 1..array.len() {\n        if array[i] == max_val\
    \ {\n            array[i] = array[count];\n            array[i] = array[i] - 1;\n\
    \        }\n    }\n\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpi1xi8pi9.rs:40:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().fold(Vec::new(), |mut vec| {\n \
    \       let mut counter: isize = 0;\n        for &num in vec {\n            counter\
    \ += num;\n            vec.push(-counter);\n        }\n        vec\n    })\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n\
    \  --> /tmp/tmp4654p48b.rs:12:16\n   |\n12 |     arr.iter().fold(Vec::new(), |mut\
    \ vec| {\n   |                ^^^^             --------- takes 1 argument\n  \
    \ |                |\n   |                expected closure that takes 2 arguments\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort_by_key(|x| count_ones_in_binary(&x))\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_ones_in_binary` in this scope\n\
    \  --> /tmp/tmp2rtkav7s.rs:12:41\n   |\n12 |     arr.iter().cloned().sort_by_key(|x|\
    \ count_ones_in_binary(&x))\n   |                                         ^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `sort_by_key` found\
    \ for struct `Cloned` in the current scope\n  --> /tmp/tmp2rtkav7s.rs:12:25\n\
    \   |\n12 |     arr.iter().cloned().sort_by_key(|x| count_ones_in_binary(&x))\n\
    \   |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_arr: Vec<isize> = arr.to_vec();\n\
    \    for i in 0..new_arr.len() {\n        let mut cnt: usize = 0;\n        let\
    \ mut idx: usize = 0;\n        while cnt != 1 && idx < new_arr.len() {\n     \
    \       cnt += 1;\n            let num = new_arr[idx];\n            new_arr[idx]\
    \ = new_arr[idx+1];\n            new_arr[idx+1] = num;\n            idx += 1;\n\
    \        }\n    }\n    new_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp3m9mxlho.rs:29:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.clone();\n    for &x in &arr\
    \ {\n        if x <= 0 {\n            continue;\n        }\n        let mut count\
    \ = 0;\n        let mut tmp = 0;\n        while x != 0 {\n            if x & 1\
    \ != 0 {\n                tmp = x;\n                x >>= 1;\n               \
    \ count += 1;\n            }\n            x >>= 1;\n        }\n        if count\
    \ > arr.len() / 2 {\n            arr.swap(0, count);\n        } else {\n     \
    \       arr.swap(0, arr.len() - count);\n        }\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `tmp` is assigned to, but never used\n  --> /tmp/tmpf6eayj1a.rs:18:17\n\
    \   |\n18 |         let mut tmp = 0;\n   |                 ^^^\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n   = note: consider using `_tmp`\
    \ instead\n\nwarning: value assigned to `tmp` is never read\n  --> /tmp/tmpf6eayj1a.rs:21:17\n\
    \   |\n21 |                 tmp = x;\n   |                 ^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `x`\n  --> /tmp/tmpf6eayj1a.rs:22:17\n   |\n13 |     for &x in &arr {\n   |\
    \          -\n   |          |\n   |          first assignment to `x`\n   |   \
    \       help: consider making this binding mutable: `mut x`\n...\n22 |       \
    \          x >>= 1;\n   |                 ^^^^^^^ cannot assign twice to immutable\
    \ variable\n\nerror[E0384]: cannot assign twice to immutable variable `x`\n  -->\
    \ /tmp/tmpf6eayj1a.rs:25:13\n   |\n13 |     for &x in &arr {\n   |          -\n\
    \   |          |\n   |          first assignment to `x`\n   |          help: consider\
    \ making this binding mutable: `mut x`\n...\n25 |             x >>= 1;\n   | \
    \            ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0502]:\
    \ cannot borrow `arr` as mutable because it is also borrowed as immutable\n  -->\
    \ /tmp/tmpf6eayj1a.rs:28:13\n   |\n13 |     for &x in &arr {\n   |           \
    \    ----\n   |               |\n   |               immutable borrow occurs here\n\
    \   |               immutable borrow later used here\n...\n28 |             arr.swap(0,\
    \ count);\n   |             ^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\n\
    error[E0502]: cannot borrow `arr` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpf6eayj1a.rs:30:13\n   |\n13 |     for &x in &arr {\n   |      \
    \         ----\n   |               |\n   |               immutable borrow occurs\
    \ here\n   |               immutable borrow later used here\n...\n30 |       \
    \      arr.swap(0, arr.len() - count);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerr"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().cloned().sort_by_key(|&x| {\n  \
    \      x.leading_zeros().count_ones() as isize\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpwd9xopfo.rs:12:25\n   |\n12 |     arr.iter().cloned().sort_by_key(|&x|\
    \ {\n   |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() == 0 {\n        return arr;\n\
    \    }\n\n    let mut nums: Vec<isize> = vec![];\n    for i in arr {\n       \
    \ if nums.contains(&i) {\n            nums.remove(&i);\n        } else {\n   \
    \         nums.push(i as isize);\n        }\n    }\n\n    let mut nums2 = vec![];\n\
    \    for i in nums {\n        if nums2.contains(&i) {\n            nums2.remove(&i);\n\
    \        } else {\n            nums2.push(i);\n        }\n    }\n\n    let mut\
    \ result = vec![];\n    for i in nums2 {\n        if nums.contains(&i) {\n   \
    \         result.append(i as isize);\n        } else {\n            result.push(i);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9o4z1t80.rs:19:25\n   |\n\
    19 |             nums.remove(&i);\n   |                         ^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9o4z1t80.rs:28:26\n\
    \   |\n28 |             nums2.remove(&i);\n   |                          ^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9o4z1t80.rs:37:27\n\
    \   |\n37 |             result.append(i as isize);\n   |                     \
    \      ^^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<_>`\n                           found type `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = arr.to_vec();\n    vec.sort_by_key(|&x|\
    \ {\n        let mut count = 0;\n        for x in &vec {\n            if x ==\
    \ 1 {\n                count += 1;\n            }\n        }\n        count /\
    \ 2\n    });\n    vec\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpi6qerphm.rs:16:18\n\
    \   |\n16 |             if x == 1 {\n   |                  ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Your code goes here\n    for i in arr.iter()\
    \ {\n        if *i & 1 == 1 {\n            arr.swap(i, arr.iter().skip(i).count());\n\
    \        }\n    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8cfdkjq_.rs:15:22\n   |\n\
    15 |             arr.swap(i, arr.iter().skip(i).count());\n   |              \
    \        ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8cfdkjq_.rs:15:41\n   |\n15 |             arr.swap(i, arr.iter().skip(i).count());\n\
    \   |                                         ^ expected `usize`, found `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() <= 1 {\n        arr\n    } else\
    \ {\n        let mut counts = HashMap::new();\n        for el in arr {\n     \
    \       counts.entry(*el).or_insert(0)\n                .cloned()\n          \
    \      += 1;\n        }\n        let mut keys = counts.keys().to_vec();\n    \
    \    keys.sort();\n        let mut result = Vec::with_capacity(arr.len());\n \
    \       for key in keys {\n            result.push(arr[key]);\n        }\n   \
    \     result\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpfottfsx1.rs:15:26\n   |\n15 |         let mut counts = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpfottfsx1.rs:17:26\n   |\n\
    17 |             counts.entry(*el).or_insert(0)\n   |                        \
    \  ^^^\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpfottfsx1.rs:19:17\n\
    \   |\n17 | /             counts.entry(*el).or_insert(0)\n18 | |             \
    \    .cloned()\n   | |_________________________- cannot assign to this expression\n\
    19 |                   += 1;\n   |                   ^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0433,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        // binary representation\
    \ of isize\n        let mut a_num_bin: Vec<usize> = a.to_bits().collect();\n \
    \       a_num_bin.pop();\n\n        // binary representation of isize\n      \
    \  let mut b_num_bin: Vec<usize> = b.to_bits().collect();\n        b_num_bin.pop();\n\
    \n        // number of ones in binary representation\n        let mut num_ones\
    \ = a_num_bin.iter().filter(|x| x == 1).count();\n        num_ones += b_num_bin.iter().filter(|x|\
    \ x == 1).count();\n\n        if num_ones == 0 {\n            a_num_bin.iter().filter(|x|\
    \ x == 1).count().cmp(b_num_bin.iter().filter(|x| x == 1).count())\n        }\
    \ else {\n            a_num_bin.iter().filter(|x| x == 1).count().cmp(b_num_bin.iter().filter(|x|\
    \ x == 1).count()).reverse()\n        }\n    });\n    arr\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_bits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp4u5fps72.rs:14:43\n   |\n14 |         let mut\
    \ a_num_bin: Vec<usize> = a.to_bits().collect();\n   |                       \
    \                    ^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_be`\n\nerror[E0599]: no method named `to_bits` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmp4u5fps72.rs:18:43\n   |\n18 | \
    \        let mut b_num_bin: Vec<usize> = b.to_bits().collect();\n   |        \
    \                                   ^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_be`\n\nerror[E0277]: can't compare `&&usize` with `{integer}`\n\
    \  --> /tmp/tmp4u5fps72.rs:22:58\n   |\n22 |         let mut num_ones = a_num_bin.iter().filter(|x|\
    \ x == 1).count();\n   |                                                     \
    \     ^^ no implementation for `&&usize == {integer}`\n   |\n   = help: the trait\
    \ `PartialEq<{integer}>` is not implemented for `&&usize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&&usize` with `{integer}`\n  --> /tmp/tmp4u5fps72.rs:23:51\n\
    \   |\n23 |         num_ones += b_num_bin.iter().filter(|x| x == 1).count();\n\
    \   |                                                   ^^ no implementation for\
    \ `&&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&&usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&&usize`\
    \ with `{integer}`\n  --> /tmp/tmp4u5fps72.rs:26:43\n   |\n26 |             a_num_bin.iter().filter(|x|\
    \ x == 1).count().cmp(b_num_bin.iter().filter(|x| x == 1).count())\n   |     \
    \                         "
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = arr.to_vec();\n    sorted_array.sort();\n\
    \    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpxx8ig_gr.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n\
    \    }\n\n    sort_array(arr.to_owned(), &arr)\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpbim0wwjd.rs:16:5\n   |\n16 |     sort_array(arr.to_owned(), &arr)\n\
    \   |     ^^^^^^^^^^ --------------  ---- supplied 2 arguments\n   |     |\n \
    \  |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpbim0wwjd.rs:11:4\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ^^^^^^^^^^\
    \ ---------------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter: Vec<isize> = vec![];\n   \
    \ for &el in arr {\n        counter.push((el as usize) & !0);\n    }\n    counter.sort_unstable();\n\
    \    counter.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa4ole3am.rs:13:9\n   |\n\
    13 |     for &el in arr {\n   |         ^^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `el`\n   |\n   = note:  \
    \ expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa4ole3am.rs:14:22\n   |\n14 |         counter.push((el\
    \ as usize) & !0);\n   |                      ^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |         counter.push(((el as\
    \ usize) & !0).try_into().unwrap());\n   |                      +            \
    \      +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().enumerate().sort_by(|(i, x)| (*x).count_ones()\
    \ as isize)\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpyie8vc6f.rs:12:28\n   |\n12 |     arr.iter().enumerate().sort_by(|(i,\
    \ x)| (*x).count_ones() as isize)\n   |                            ^^^^^^^ method\
    \ not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // write your logic here\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ov19w4c.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x|\
    \ {\n        if *x != 0 {\n            *x.clone() as isize\n        } else {\n\
    \            0\n        }\n    });\n    sorted_arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpwz16pdbc.rs:15:13\n\
    \   |\n15 |             *x.clone() as isize\n   |             ^^^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // O(n^2) solution: O(n) solution is to sort\
    \ in descending order\n    // and move elements to a new array which keeps track\
    \ of the original order\n    let mut arr = arr.clone();\n    let mut result =\
    \ Vec::new();\n    for value in arr {\n        // binary representation of num\n\
    \        let mut binary_repr: Vec<isize> = vec![];\n        while value != 0 {\n\
    \            binary_repr.push(value%10);\n            value /= 10;\n        }\n\
    \        // count number of ones in binary representation\n        let mut counter\
    \ = binary_repr.iter().filter(|&b| b == 1).count();\n\n        // sort by number\
    \ of ones in binary representation\n        if counter == 0 {\n            result.push(value);\n\
    \        } else if counter < 1 {\n            counter = -1;\n        }\n\n   \
    \     // sort by decimal value of binary_repr\n        if counter == 0 {\n   \
    \         let mut decimal_val = binary_repr.iter().map(|&b| b*10).sum();\n   \
    \         binary_repr.sort_by(|a, b| decimal_val < b);\n        }\n\n        //\
    \ combine binary representation and decimal value\n        for num in binary_repr\
    \ {\n            result.push(num + value/10);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp7xqqoo4w.rs:24:60\n\
    \   |\n24 |         let mut counter = binary_repr.iter().filter(|&b| b == 1).count();\n\
    \   |                                                            ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmp7xqqoo4w.rs:30:23\n   |\n30 |           \
    \  counter = -1;\n   |                       ^^\n   |                       |\n\
    \   |                       cannot apply unary operator `-`\n   |            \
    \           help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7xqqoo4w.rs:36:40\n   |\n36 |             binary_repr.sort_by(|a,\
    \ b| decimal_val < b);\n   |                                        ^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = arr.clone();\n    res.sort_by(|a,\
    \ b| {\n        if a != 0 {\n            a / b\n        } else {\n           \
    \ b / a\n        }\n    });\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpafmbaaki.rs:14:14\n\
    \   |\n14 |         if a != 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpafmbaaki.rs:15:13\n\
    \   |\n15 |             a / b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpafmbaaki.rs:17:13\n\
    \   |\n17 |             b / a\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter = Vec::new();\n    for num\
    \ in arr {\n        if num != 0 {\n            counter.push(num);\n        }\n\
    \    }\n    let mut counter = counter.clone();\n    counter.sort_by(|a, b| {\n\
    \        if a > b {\n            -1\n        } else if a < b {\n            1\n\
    \        } else {\n            0\n        }\n    });\n    counter.clone().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3b6hhaze.rs:21:13\n   |\n\
    21 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3b6hhaze.rs:23:13\n\
    \   |\n23 |             1\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3b6hhaze.rs:25:13\n\
    \   |\n25 |             0\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp3b6hhaze.rs:28:21\n\
    \    |\n28  |       counter.clone().collect()\n    |                       ^^^^^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|&i| {\n        let val = (i\
    \ as i32).checked_mul(2).ok_or(Error::new(INVALID_INPUT))?;\n        Some(val)\n\
    \    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmpjk_6vczr.rs:13:51\n   |\n13 |         let val = (i as i32).checked_mul(2).ok_or(Error::new(INVALID_INPUT))?;\n\
    \   |                                                   ^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::error::Error;\n\
    \   |\n1  | use std::fmt::Error;\n   |\n1  | use std::io::Error;\n   |\n\nerror[E0425]:\
    \ cannot find value `INVALID_INPUT` in this scope\n  --> /tmp/tmpjk_6vczr.rs:13:62\n\
    \   |\n13 |         let val = (i as i32).checked_mul(2).ok_or(Error::new(INVALID_INPUT))?;\n\
    \   |                                                              ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the `?` operator can only be used on\
    \ `Option`s, not `Result`s, in a closure that returns `Option`\n  --> /tmp/tmpjk_6vczr.rs:13:77\n\
    \   |\n12 |       arr.sort_by_key(|&i| {\n   |  _____________________-\n13 | |\
    \         let val = (i as i32).checked_mul(2).ok_or(Error::new(INVALID_INPUT))?;\n\
    \   | |                                                                      \
    \       ^ use `.ok()?` if you want to discard the `Result<Infallible, _>` error\
    \ information\n14 | |         Some(val)\n15 | |     });\n   | |_____- this function\
    \ returns an `Option`\n   |\n   = help: the trait `FromResidual<Result<Infallible,\
    \ _>>` is not implemented for `Option<i32>`\n   = help: the following other types\
    \ implement trait `FromResidual<R>`:\n             <Option<T> as FromResidual<Yeet<()>>>\n\
    \             <Option<T> as FromResidual>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut arr =\
    \ arr.to_owned();\n    arr.sort_by(|x, y| x.count_ones() as isize cmp y.count_ones()\
    \ as isize);\n    while arr.len() > 0 {\n        let mut first = arr[0];\n   \
    \     let mut last = arr[0];\n        let mut ones = 1;\n        for x in &arr\
    \ {\n            if x > last {\n                last = x;\n            }\n   \
    \         ones = ones * x.count_ones() as isize;\n        }\n        result.push(first);\n\
    \        result.push(last);\n        result.push(ones);\n        arr = &arr[1..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `)`, `,`, `.`, `::`, `<`, `?`, or an operator,\
    \ found `cmp`\n  --> /tmp/tmpj6_zk266.rs:14:48\n   |\n14 |     arr.sort_by(|x,\
    \ y| x.count_ones() as isize cmp y.count_ones() as isize);\n   |             \
    \                                  -^^^ expected one of 9 possible tokens\n  \
    \ |                                               |\n   |                    \
    \                           help: missing `,`\n\nerror: expected one of `!`, `)`,\
    \ `,`, `.`, `::`, `?`, `{`, or an operator, found `y`\n  --> /tmp/tmpj6_zk266.rs:14:52\n\
    \   |\n14 |     arr.sort_by(|x, y| x.count_ones() as isize cmp y.count_ones()\
    \ as isize);\n   |                                                   -^ expected\
    \ one of 8 possible tokens\n   |                                             \
    \      |\n   |                                                   help: missing\
    \ `,`\n\nerror[E0425]: cannot find value `cmp` in this scope\n  --> /tmp/tmpj6_zk266.rs:14:48\n\
    \   |\n14 |     arr.sort_by(|x, y| x.count_ones() as isize cmp y.count_ones()\
    \ as isize);\n   |                                                ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmpj6_zk266.rs:14:52\n\
    \   |\n14 |     arr.sort_by(|x, y| x.count_ones() as isize cmp y.count_ones()\
    \ as isize);\n   |                                                    ^ not found\
    \ in this scope\n\nerror[E0061]: this function takes 1 argument but 3 arguments\
    \ were supplied\n   --> /tmp/tmpj6_zk266.rs:14:9\n    |\n14  |     arr.sort_by(|x,\
    \ y| x.count_ones() as isize cmp y.count_ones() as isize);\n    |         ^^^^^^^\
    \ ------------------------------ --- ----------------------- supplied 3 arguments\n\
    \    |         |\n    |         expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6_zk266.rs:20:20\n\
    \   |\n20 |             if x > last {\n   |                    ^^^^\n   |    \
    \                |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&last`\n\nerror[E0308]:\
    \ mismatched"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort();\n    arr.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpq_x8eog3.rs:12:5\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n12 |     arr.sort();\n   |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = vec![];\n    for i in arr.iter()\
    \ {\n        let b = i >> 31;\n        let a = i & 0x07;\n        let c = a ^\
    \ b;\n        if c == 0 {\n            ret.push(i);\n        } else {\n      \
    \      ret.push(b);\n            ret.push(a);\n        }\n    }\n    ret.sort();\n\
    \    ret\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8wxni1ml.rs:20:22\n   |\n\
    20 |             ret.push(b);\n   |                      ^\n   |             \
    \         |\n   |                      expected `&isize`, found `isize`\n   |\
    \                      help: consider borrowing here: `&b`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8wxni1ml.rs:21:22\n   |\n21 |             ret.push(a);\n\
    \   |                      ^\n   |                      |\n   |              \
    \        expected `&isize`, found `isize`\n   |                      help: consider\
    \ borrowing here: `&a`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wxni1ml.rs:25:5\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n25 |     ret\n   |     ^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() <= 1 {\n        arr\n    } else\
    \ {\n        let mut counter: Vec<isize> = Vec::new();\n        for (i, x) in\
    \ arr.iter().enumerate() {\n            if x != 0 {\n                counter.push(i);\n\
    \            }\n        }\n        sort_with_counter(&counter);\n    }\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_with_counter` in this scope\n\
    \  --> /tmp/tmpvszk7qr1.rs:21:9\n   |\n21 |         sort_with_counter(&counter);\n\
    \   |         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpvszk7qr1.rs:17:18\n   |\n17\
    \ |             if x != 0 {\n   |                  ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvszk7qr1.rs:18:30\n\
    \   |\n18 |                 counter.push(i);\n   |                           \
    \   ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n18 |        \
    \         counter.push(i.try_into().unwrap());\n   |                         \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvszk7qr1.rs:14:12\n\
    \   |\n14 |       } else {\n   |  ____________^\n15 | |         let mut counter:\
    \ Vec<isize> = Vec::new();\n16 | |         for (i, x) in arr.iter().enumerate()\
    \ {\n17 | |             if x != 0 {\n...  |\n21 | |         sort_with_counter(&counter);\n\
    22 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n\n    for i in arr.iter().rev()\
    \ {\n        let x = i / 2;\n        let y = i / 2;\n        let z = i / 2;\n\n\
    \        let mut count = 0;\n        while y != 0 {\n            if y & 1 != 1\
    \ {\n                count = count + 1;\n            }\n            y = y >> 1;\n\
    \        }\n\n        while z != 0 {\n            if z & 1 != 1 {\n          \
    \      count = count - 1;\n            }\n            z = z >> 1;\n        }\n\
    \n        if count > 0 {\n            result.push(x);\n        } else {\n    \
    \        result.push(y);\n        }\n    }\n\n    result\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `y`\n  --> /tmp/tmp76pfl_p0.rs:24:13\n\
    \   |\n16 |         let y = i / 2;\n   |             -\n   |             |\n \
    \  |             first assignment to `y`\n   |             help: consider making\
    \ this binding mutable: `mut y`\n...\n24 |             y = y >> 1;\n   |     \
    \        ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `z`\n  --> /tmp/tmp76pfl_p0.rs:31:13\n\
    \   |\n17 |         let z = i / 2;\n   |             -\n   |             |\n \
    \  |             first assignment to `z`\n   |             help: consider making\
    \ this binding mutable: `mut z`\n...\n31 |             z = z >> 1;\n   |     \
    \        ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut v = arr\n        .iter()\n        .map(|x|\
    \ {\n            debug_assert!(x > 0, \"Sort the array first!\");\n          \
    \  *x & !1\n        })\n        .count();\n\n    v.sort_unstable();\n    v.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbhch429n.rs:15:31\n   |\n\
    15 |             debug_assert!(x > 0, \"Sort the array first!\");\n   |      \
    \                         ^\n   |                               |\n   |      \
    \                         expected `&isize`, found integer\n   |             \
    \                  help: consider borrowing here: `&0`\n\nerror[E0599]: no method\
    \ named `sort_unstable` found for type `usize` in the current scope\n  --> /tmp/tmpbhch429n.rs:20:7\n\
    \   |\n20 |     v.sort_unstable();\n   |       ^^^^^^^^^^^^^ method not found\
    \ in `usize`\n\nerror[E0599]: `usize` is not an iterator\n  --> /tmp/tmpbhch429n.rs:21:7\n\
    \   |\n21 |     v.into_iter().collect()\n   |       ^^^^^^^^^ `usize` is not an\
    \ iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `usize: Iterator`\n           which is required by `usize: IntoIterator`\n\
    \           `&usize: Iterator`\n           which is required by `&usize: IntoIterator`\n\
    \           `&mut usize: Iterator`\n           which is required by `&mut usize:\
    \ IntoIterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter()\n        .cloned()\n        .enumerate()\n\
    \        .sort((a, b) => {\n            let val1 =\n                a.1.to_bin().len()\
    \ + b.1.to_bin().len() - a.0.to_bin().len();\n            let val2 = a.1.to_decimal().cmp(b.1.to_decimal());\n\
    \            if val1 != val2 {\n                val1\n            } else {\n \
    \               a.0.to_decimal().cmp(b.0.to_decimal())\n            }\n      \
    \  })\n        .map(|(a, b)| {\n            a.1.to_decimal()\n        })\n   \
    \     .collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmpv6ninx_m.rs:15:22\n   |\n15 |         .sort((a, b) => {\n   | \
    \                     ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\n\
    error: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.to_owned();\n    arr.sort_by(|a,\
    \ b| {\n        if a > b {\n            1\n        } else {\n            -1\n\
    \        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxifig6d5.rs:15:13\n   |\n\
    15 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxifig6d5.rs:17:13\n\
    \   |\n17 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter = [0];\n    for x in arr {\n\
    \        let mut s = x;\n        while s > 0 {\n            s -= 1;\n        \
    \    counter[s]+=1;\n        }\n    }\n    counter.sort();\n    let mut result=arr.clone();\n\
    \    for (idx, x) in counter.iter().zip(arr).take(arr.len()).enumerate() {\n \
    \       result[idx] = x;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp5mfhunnc.rs:17:13\n   |\n17 |             counter[s]+=1;\n   |     \
    \        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `[{integer}]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5mfhunnc.rs:23:23\n   |\n23 |\
    \         result[idx] = x;\n   |         -----------   ^ expected `isize`, found\
    \ tuple\n   |         |\n   |         expected due to the type of this binding\n\
    \   |\n   = note: expected type `isize`\n             found tuple `(&{integer},\
    \ isize)`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|x| match x {\n        0 =>\
    \ 1,\n        _ => x.checked_mul(2).unwrap(),\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzhjflii.rs:12:5\n   |\n\
    11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    12 | /     arr.sort_by_key(|x| match x {\n13 | |         0 => 1,\n14 | |     \
    \    _ => x.checked_mul(2).unwrap(),\n15 | |     })\n   | |______^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| {\n        if a < b {\n\
    \            std::cmp::Ordering::Less => a.cmp(&b),\n            std::cmp::Ordering::Equal\
    \ => a.cmp(&b),\n            std::cmp::Ordering::Greater => b.cmp(&a),\n     \
    \       std::cmp::Ordering::Greater => b.cmp(&a),\n        }\n    });\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpu_8w5tf6.rs:14:38\n   |\n14 |             std::cmp::Ordering::Less\
    \ => a.cmp(&b),\n   |                                      ^^ expected one of\
    \ 8 possible tokens\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Solution 1\n    // Use std::iter::BinarySearch\n\
    \    // See also: BinarySearch::index_from\n    let mut index = 1isize;\n    loop\
    \ {\n        match BinarySearch::new(arr.iter().cloned(), index) {\n         \
    \   Ok(pos) if pos == 0isize => break,\n            Ok(pos) => index = pos,\n\
    \            Err(_) => index += 1,\n        }\n    }\n\n    // Solution 2\n  \
    \  // Use std::cmp::Reversed\n    // See also: Reverse::reverse\n    let mut index\
    \ = arr.len() - 1;\n    loop {\n        let pos = Reversed::reverse(&arr[..index]);\n\
    \        if pos == 0 { break; }\n        index = pos - 1;\n    }\n\n    arr[..index]\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BinarySearch`\n\
    \  --> /tmp/tmp5crprzm7.rs:17:15\n   |\n17 |         match BinarySearch::new(arr.iter().cloned(),\
    \ index) {\n   |               ^^^^^^^^^^^^ use of undeclared type `BinarySearch`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Reversed`\n  --> /tmp/tmp5crprzm7.rs:29:19\n\
    \   |\n29 |         let pos = Reversed::reverse(&arr[..index]);\n   |        \
    \           ^^^^^^^^ use of undeclared type `Reversed`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5crprzm7.rs:34:5\n   |\n11 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                   ---------- expected\
    \ `Vec<isize>` because of return type\n...\n34 |     arr[..index]\n   |     ^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |     |\n   |     expected\
    \ struct `Vec`, found slice `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \               found slice `[isize]`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|&i| {\n        if i > 0 {\n\
    \            i / 2\n        } else {\n            -i\n        }\n    });\n   \
    \ arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp1zfv5ks6.rs:12:5\n   |\n11 |   fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                 --- help: consider changing this to be\
    \ mutable: `mut arr`\n12 | /     arr.sort_by_key(|&i| {\n13 | |         if i >\
    \ 0 {\n14 | |             i / 2\n15 | |         } else {\n16 | |             -i\n\
    17 | |         }\n18 | |     });\n   | |______^ cannot borrow as mutable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| b.leading_zeros_in_binary().cmp(&a.leading_zeros_in_binary()))\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `leading_zeros_in_binary` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpsjsb854z.rs:12:26\n   |\n12 | \
    \    arr.sort_by(|a, b| b.leading_zeros_in_binary().cmp(&a.leading_zeros_in_binary()))\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `leading_zeros`\n\nerror[E0599]: no method named\
    \ `leading_zeros_in_binary` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpsjsb854z.rs:12:59\n   |\n12 |     arr.sort_by(|a, b| b.leading_zeros_in_binary().cmp(&a.leading_zeros_in_binary()))\n\
    \   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `leading_zeros`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsjsb854z.rs:12:5\n   |\n11 | fn\
    \ sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                          \
    \         ---------- expected `Vec<isize>` because of return type\n12 |     arr.sort_by(|a,\
    \ b| b.leading_zeros_in_binary().cmp(&a.leading_zeros_in_binary()))\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut largest = 0;\n    let mut smallest = std::i32::MAX;\n    loop {\n      \
    \  if j == arr.len() {\n            break;\n        }\n\n        let mut cur =\
    \ arr[j];\n        let mut k = j + 1;\n        loop {\n            match cur {\n\
    \                0 => i += 1,\n                1 => i += 1,\n                2\
    \ => i += 1,\n                _ => {\n                    match arr[k] {\n   \
    \                     0 => j += 1,\n                        1 => j += 1,\n   \
    \                     2 => j += 1,\n                        _ => break\n     \
    \               }\n                }\n            }\n        }\n\n        largest\
    \ = match arr[i] {\n            0 => smallest,\n            1 => smallest,\n \
    \           2 => smallest,\n            _ => smallest\n        };\n\n        smallest\
    \ = match arr[i] {\n            0 => smallest,\n            1 => smallest,\n \
    \           2 => smallest,\n            _ => smallest\n        };\n\n        arr[i]\
    \ = cur;\n        if i > j {\n            break;\n        }\n    }\n\n    for\
    \ i in 0..(arr.len() - 1) {\n        arr[i] = arr[i] as isize;\n    }\n\n    for\
    \ i in 0..(arr.len() - 1) {\n        arr[i] = smallest;\n    }\n\n    for i in\
    \ 0..(arr.len() - 1) {\n        arr[i] = largest;\n    }\n\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyj9ulkx8.rs:64:18\n   |\n\
    64 |         arr[i] = smallest;\n   |         ------   ^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyj9ulkx8.rs:68:18\n   |\n68 |\
    \         arr[i] = largest;\n   |         ------   ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|i| binary_ones_count(i).clone());\n\
    \    arr.sort_by_key(|i| i.checked_mul(10).unwrap().floor() as isize);\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_ones_count` in this scope\n\
    \  --> /tmp/tmpusnq7kn6.rs:12:25\n   |\n12 |     arr.sort_by_key(|i| binary_ones_count(i).clone());\n\
    \   |                         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `floor` found for type `isize` in the current scope\n  --> /tmp/tmpusnq7kn6.rs:13:52\n\
    \   |\n13 |     arr.sort_by_key(|i| i.checked_mul(10).unwrap().floor() as isize);\n\
    \   |                                                    ^^^^^ help: there is\
    \ an associated function with a similar name: `div_floor`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut count = Vec::new();\n    let mut cur\
    \ = arr[0];\n    for i in arr {\n        if i == cur {\n            count.push(1);\n\
    \        } else {\n            count.push(0);\n        }\n        cur = i;\n \
    \   }\n    count.sort_by_key(|&i| i as isize);\n    let mut res = vec![];\n  \
    \  for i in count {\n        res.push(arr[i]);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp4z60_qu5.rs:25:18\n\
    \    |\n11  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \     --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n25  |         res.push(arr[i]);\n\
    \    |                  ^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `arr`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n14  |     for i in &arr {\n    |              +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.sort_by_key(|&x| {\n        let mut s =\
    \ x; // s is copy of x\n        s >> 1\n    });\n    arr\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp6_vqx2su.rs:13:13\n\
    \   |\n13 |         let mut s = x; // s is copy of x\n   |             ----^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot borrow `arr` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmp6_vqx2su.rs:12:5\n\
    \   |\n11 |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \      --- help: consider changing this to be mutable: `mut arr`\n12 | /     arr.sort_by_key(|&x|\
    \ {\n13 | |         let mut s = x; // s is copy of x\n14 | |         s >> 1\n\
    15 | |     });\n   | |______^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return arr;\n\
    \    }\n\n    let mut i = 0;\n    let mut j = 0;\n\n    for i in 1..arr.len()\
    \ {\n        let mut found = false;\n\n        // Check if we need to swap two\
    \ adjacent numbers\n        if arr[i - 1] != 0 && arr[i] != 0 &&\n           \
    \ arr[i - 1] > arr[i] {\n            let temp = arr[i - 1];\n            arr[i\
    \ - 1] = arr[i];\n            arr[i] = temp;\n            found = true;\n    \
    \    }\n\n        // If no numbers were swapped, move to next number\n       \
    \ if !found {\n            i += 1;\n        }\n    }\n\n    for i in 0..arr.len()\
    \ {\n        if arr[i] != 0 { // If it's not zero, swap with previous number\n\
    \            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j]\
    \ = temp;\n            i += 1;\n            j += 1;\n        }\n    }\n\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpipn_l7em.rs:16:13\n   |\n\
    16 |     let mut i = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: value assigned to `i` is never read\n  --> /tmp/tmpipn_l7em.rs:33:13\n\
    \   |\n33 |             i += 1;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `i` is never read\n  --> /tmp/tmpipn_l7em.rs:42:13\n   |\n\
    42 |             i += 1;\n   |             ^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpipn_l7em.rs:16:9\n\
    \   |\n16 |     let mut i = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0596]: cannot borrow `arr` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpipn_l7em.rs:26:13\n   |\n11 | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n26 |             arr[i - 1] = arr[i];\n   |             ^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `arr` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmpipn_l7em.rs:27:13\n   |\n11 | fn\
    \ sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |               --- help: consider\
    \ changing this to be mutable: `mut arr`\n...\n27 |             arr[i] = temp;\n\
    \   |             ^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign\
    \ twice to immutable variable `i`\n  --> /tmp/tmpipn_l7em.rs:33:13\n   |\n19 |\
    \     for i in 1..arr.len() {\n   |         -\n   |         |\n   |         first\
    \ assignment to `i`\n   |         help: consider making this binding mutable:\
    \ `mut i`\n...\n33 |             i += 1;\n   |             ^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0596]: cannot borrow `arr` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmpipn_l7em.rs:40:13\n   |\n11\
    \ | fn sort_array(ar"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    arr.iter().sort_by(|a, b| {\n        if a <\
    \ b {\n            1\n        } else {\n            -1\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpyuuv_b2e.rs:12:16\n   |\n12 |     arr.iter().sort_by(|a,\
    \ b| {\n   |                ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // TODO: implement this solution\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv8ktmfmk.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sort_arr: [&mut isize; 6] = [&mut 0,\
    \ &mut 0, &mut 0, &mut 0, &mut 0, &mut 0];\n\n    for i in arr.iter() {\n    \
    \    match i {\n            0 => sort_arr[0] = i,\n            1 => sort_arr[1]\
    \ = i,\n            2 => sort_arr[2] = i,\n            3 => sort_arr[3] = i,\n\
    \            4 => sort_arr[4] = i,\n            5 => sort_arr[5] = i,\n      \
    \      _ => panic!(\"Invalid input!\"),\n        }\n    }\n\n    sort_arr\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7_ukzumo.rs:16:32\n   |\n\
    16 |             0 => sort_arr[0] = i,\n   |                                ^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ isize`\n                      found reference `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7_ukzumo.rs:17:32\n   |\n17 |             1 => sort_arr[1]\
    \ = i,\n   |                                ^ types differ in mutability\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_ukzumo.rs:18:32\n\
    \   |\n18 |             2 => sort_arr[2] = i,\n   |                          \
    \      ^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7_ukzumo.rs:19:32\n   |\n19 |             3\
    \ => sort_arr[3] = i,\n   |                                ^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut isize`\n                  \
    \    found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_ukzumo.rs:20:32\n\
    \   |\n20 |             4 => sort_arr[4] = i,\n   |                          \
    \      ^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7_ukzumo.rs:21:32\n   |\n21 |             5\
    \ => sort_arr[5] = i,\n   |                                ^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut isize`\n                  \
    \    found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_ukzumo.rs:26:5\n\
    \   |\n11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n26 |     sort_arr\n   |     ^^^^^^^^ expected struct `Vec`, found array `[&mut\
    \ isize; 6]`\n   |\n   = note: expected struct `Vec<isize>`\n               found\
    \ array `[&mut isize;"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() <= 1 {\n        arr\n    } else\
    \ {\n        let mut max = 0;\n        for &el in arr {\n            if el ==\
    \ 0 {\n                max = el;\n            }\n        }\n        let mut curr\
    \ = 1;\n        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n\
    \        let mut temp = 0;\n        let mut cnt = 0;\n        while i < arr.len()\
    \ {\n            if arr[i] < max {\n                if arr[i] == 0 {\n       \
    \             temp += arr[i];\n                    arr[i] = arr[i];\n        \
    \            arr[i] = temp;\n                    j++;\n                    cnt\
    \ = 1;\n                } else if arr[i] == max {\n                    arr[i -\
    \ k - 1] += arr[i];\n                    arr[i - k - 1] = arr[i - k - 1];\n  \
    \                  temp -= arr[i - k - 1];\n                    arr[i - k - 1]\
    \ = temp;\n                    k++;\n                    cnt += 1;\n         \
    \       } else {\n                    arr[i - k - 1] += arr[i];\n            \
    \        arr[i - k - 1] = arr[i - k - 1];\n                    temp -= arr[i -\
    \ k - 1];\n                    arr[i - k - 1] = temp;\n                    k++;\n\
    \                    cnt += 1;\n                }\n                i += 1;\n \
    \           } else {\n                arr[i - k - 1] += arr[i];\n            \
    \    arr[i - k - 1] = arr[i - k - 1];\n                temp -= arr[i - k - 1];\n\
    \                arr[i - k - 1] = temp;\n                k++;\n              \
    \  cnt += 1;\n                i += 1;\n            }\n        }\n        while\
    \ j > 0 {\n            cnt += 1;\n            j--;\n            for &el in arr\
    \ {\n                if el < max {\n                    if el == 0 {\n       \
    \                 temp += el;\n                        el = el;\n            \
    \            el = temp;\n                        j++;\n                      \
    \  cnt = 1;\n                    } else if el == max {\n                     \
    \   arr[i - k - 1] += el;\n                        arr[i - k - 1] = arr[i - k\
    \ - 1];\n                        temp -= arr[i - k - 1];\n                   \
    \     arr[i - k - 1] = temp;\n                        k++;\n                 \
    \       cnt += 1;\n                    } else {\n                        arr[i\
    \ - k - 1] += el;\n                        arr[i - k - 1] = arr[i - k - 1];\n\
    \                        temp -= arr[i - k - 1];\n                        arr[i\
    \ - k - 1] = temp;\n                        k++;\n                        cnt\
    \ += 1;\n                    }\n                } else {\n                   \
    \ arr[i - k - 1] += el;\n                    arr[i - k - 1] = arr[i - k - 1];\n\
    \                    temp -= arr[i - k - 1];\n                    arr[i - k -\
    \ 1] = temp;\n                    k++;\n                    cnt += 1;\n      \
    \          }\n            }\n        }\n\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpit4_71o6.rs:110:3\n\
    \    |\n11  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \                                    - unclosed delimiter\n...\n14  |     } else\
    \ {\n    |            - this delimiter might not be properly closed...\n...\n\
    98  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    110 | }\n    |   ^\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpit4_71o6.rs:33:22\n\
    \   |\n33 |                     j++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n33 |               \
    \      { let tmp = j; j += 1; tmp };\n   |                     +++++++++++  ~~~~~~~~~~~~~~~\n\
    33 -                     j++;\n33 +                     j += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmpit4_71o6.rs:40:22\n  \
    \ |\n40 |                     k++;\n   |                      ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n40 |                     { let\
    \ tmp = k; k += 1; tmp };\n   |                     +++++++++++  ~~~~~~~~~~~~~~~\n\
    40 -                     k++;\n40 +                     k += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmpit4_71o6.rs:47:22\n  \
    \ |\n47 |                     k++;\n   |                      ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n47 |                     { let\
    \ tmp = k; k += 1; tmp };\n   |                     +++++++++++  ~~~~~~~~~~~~~~~\n\
    47 -                     k++;\n47 +                     k += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmpit4_71o6.rs:56:18\n  \
    \ |\n56 |                 k++;\n   |                  ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n56 |                 { let tmp = k; k +=\
    \ 1; tmp };\n   |                 +++++++++++  ~~~~~~~~~~~~~~~\n56 -         \
    \        k++;\n56 +                 k += 1;\n   | \n\nerror: expected `;`, found\
    \ keyword `for`\n  --> /tmp/tmpit4_71o6.rs:63:17\n   |\n63 |             j--;\n\
    \   |                 ^ help: add "
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() < 2 {\n        return arr;\n \
    \   }\n\n    let mut n = arr.len();\n    let mut count = 0;\n    let mut max_value\
    \ = i32::MAX as isize;\n\n    for x in arr {\n        count += x;\n        if\
    \ count > max_value {\n            max_value = count;\n        }\n    }\n\n  \
    \  let mut result: Vec<isize> = vec![];\n    let mut cur = 0;\n\n    while cur\
    \ < arr.len() {\n        if max_value > 0 {\n            let next_max = max_value\
    \ - arr[cur];\n            for x in arr {\n                count += x;\n     \
    \           if count == next_max {\n                    result.push(cur + x);\n\
    \                    break;\n                }\n            }\n        } else\
    \ {\n            for x in arr {\n                count += x;\n               \
    \ if count == 0 {\n                    result.push(cur + x);\n               \
    \     break;\n                }\n            }\n        }\n        cur += 1;\n\
    \        max_value -= 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpadl05i3a.rs:36:39\n   |\n\
    36 |                     result.push(cur + x);\n   |                         \
    \              ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpadl05i3a.rs:36:33\n   |\n36 |                     result.push(cur\
    \ + x);\n   |                                 ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n36 |                     result.push((cur\
    \ + x).try_into().unwrap());\n   |                                 +       +++++++++++++++++++++\n\
    \nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpadl05i3a.rs:36:37\n\
    \   |\n36 |                     result.push(cur + x);\n   |                  \
    \                   ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpadl05i3a.rs:44:39\n   |\n44 |                     result.push(cur\
    \ + x);\n   |                                       ^ expected `usize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpadl05i3a.rs:44:33\n\
    \   |\n44 |                     result.push(cur + x);\n   |                  \
    \               ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    44 |                     result.push((cur + x).try_into().unwrap());\n   |   \
    \                              +       +++++++++++++++++++++\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmpadl05i3a.rs:44:37\n   |\n44 | \
    \                    result.push(cur + x);\n   |                "
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() < 2 { return arr; }\n    let mut\
    \ left = arr.clone();\n    let mut right = arr.clone();\n    let mut i = 0;\n\
    \    while i < left.len() {\n        if left[i] == 1 {\n            left.swap(i,\
    \ i);\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    while i < left.len() {\n        if right[i] == 1 {\n            right.swap(i,\
    \ i);\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    if left.len() < right.len() {\n        left.reverse();\n    }\n  \
    \  if left.len() < right.len() {\n        right.reverse();\n    }\n    left +=\
    \ &mut &mut right;\n    right += &mut &mut left;\n    arr\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<isize>`\n  --> /tmp/tmp4688ucvl.rs:38:5\n   |\n38 |     left += &mut &mut\
    \ right;\n   |     ----^^^^^^^^^^^^^^^^^^^\n   |     |\n   |     cannot use `+=`\
    \ on type `Vec<isize>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `Vec<isize>`\n  --> /tmp/tmp4688ucvl.rs:39:5\n   |\n39 |\
    \     right += &mut &mut left;\n   |     -----^^^^^^^^^^^^^^^^^^\n   |     |\n\
    \   |     cannot use `+=` on type `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 101
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = arr.clone();\n    sorted_array.sort_unstable();\n\
    \    return sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp1kx_bl5b.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    assert_eq!(arr.len(), arr.iter().map(|e| e.checked_mul(2).is_some()).sum());\n\
    \    arr.iter().cloned().sort_by_key(|e| {\n        if e < 0 {\n            return\
    \ -e.checked_mul(2).is_some();\n        }\n        false\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Sum<bool>` is not satisfied\n   \
    \ --> /tmp/tmpo7nbtt05.rs:12:74\n     |\n12   |     assert_eq!(arr.len(), arr.iter().map(|e|\
    \ e.checked_mul(2).is_some()).sum());\n     |                                \
    \                                          ^^^ the trait `Sum<bool>` is not implemented\
    \ for `usize`\n     |\n     = help: the following other types implement trait\
    \ `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n\
    \               <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n         \
    \      <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16\
    \ as Sum<&'a i16>>\n               <i16 as Sum>\n             and 20 others\n\
    note: required by a bound in `std::iter::Iterator::sum`\n\nerror[E0599]: no method\
    \ named `sort_by_key` found for struct `Cloned` in the current scope\n  --> /tmp/tmpo7nbtt05.rs:13:25\n\
    \   |\n13 |     arr.iter().cloned().sort_by_key(|e| {\n   |                  \
    \       ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut l = arr.len();\n    l.sort_unstable();\n\
    \    for i in 0..l {\n        if arr[i] > 0 { arr[i] = arr[i] - 1 }\n    }\n \
    \   for i in 0..l {\n        if arr[i] > 0 { arr[i] = arr[i] * 2 }\n    }\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_unstable` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpaq2ay_ip.rs:13:7\n   |\n13 |     l.sort_unstable();\n\
    \   |       ^^^^^^^^^^^^^ method not found in `usize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    if arr.len() < 2 {\n        return arr\n  \
    \  }\n    let mut arr = arr.to_vec();\n    arr.sort_by_key(|x| {\n        // Count\
    \ number of ones\n        let bits: usize = x.iter().map(|x| *x != 0).count();\n\
    \        // Sort by number of ones\n        (-bits).cmp(std::cmp::min(bits, 1))\n\
    \    });\n    arr.to_owned()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpb3d24iry.rs:18:29\n   |\n18 |         let bits:\
    \ usize = x.iter().map(|x| *x != 0).count();\n   |                           \
    \  ^^^^ method not found in `&isize`\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpb3d24iry.rs:20:9\n   |\n20 |         (-bits).cmp(std::cmp::min(bits,\
    \ 1))\n   |         ^^^^^^^ cannot apply unary operator `-`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb3d24iry.rs:20:35\n\
    \   |\n20 |         (-bits).cmp(std::cmp::min(bits, 1))\n   |                \
    \                   ^^^^\n   |                                   |\n   |     \
    \                              expected `&usize`, found `usize`\n   |        \
    \                           help: consider borrowing here: `&bits`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb3d24iry.rs:20:41\n   |\n20 |         (-bits).cmp(std::cmp::min(bits,\
    \ 1))\n   |                                         ^\n   |                  \
    \                       |\n   |                                         expected\
    \ `&usize`, found integer\n   |                                         help:\
    \ consider borrowing here: `&1`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.clone();\n    arr.sort_by(|a,\
    \ b| {\n        // Get number of set bits in a\n        let num_a_bits = get_num_set_bits(a);\n\
    \        // Get number of set bits in b\n        let num_b_bits = get_num_set_bits(b);\n\
    \        // If number of set bits is equal, compare based on decimal value\n \
    \       if num_a_bits == num_b_bits {\n            a as isize - b as isize\n \
    \       } else {\n            // If number of set bits is larger, sort according\
    \ to binary representation\n            num_a_bits < num_b_bits as isize - a as\
    \ isize\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_num_set_bits` in this scope\n \
    \ --> /tmp/tmptu069nmw.rs:15:26\n   |\n15 |         let num_a_bits = get_num_set_bits(a);\n\
    \   |                          ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_num_set_bits` in this scope\n  --> /tmp/tmptu069nmw.rs:17:26\n\
    \   |\n17 |         let num_b_bits = get_num_set_bits(b);\n   |              \
    \            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptu069nmw.rs:20:13\n   |\n20 |             a as isize -\
    \ b as isize\n   |             ^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptu069nmw.rs:23:13\n\
    \   |\n23 |             num_a_bits < num_b_bits as isize - a as isize\n   |  \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  -->\
    \ /tmp/tmptu069nmw.rs:20:13\n   |\n20 |             a as isize - b as isize\n\
    \   |             -^^^^^^^^^\n   |             |\n   |             cannot cast\
    \ `&isize` as `isize`\n   |             help: dereference the expression: `*a`\n\
    \nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmptu069nmw.rs:20:26\n\
    \   |\n20 |             a as isize - b as isize\n   |                        \
    \  -^^^^^^^^^\n   |                          |\n   |                         \
    \ cannot cast `&isize` as `isize`\n   |                          help: dereference\
    \ the expression: `*b`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n\
    \  --> /tmp/tmptu069nmw.rs:23:48\n   |\n23 |             num_a_bits < num_b_bits\
    \ as isize - a as isize\n   |                                                -^^^^^^^^^\n\
    \   |                                                |\n   |                 \
    \                               cannot cast `&isize` as `isize`\n   |        \
    \                                        help: dereference the expression: `*a`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:"
  stdout: ''
  timestamp: 1659976143
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    // Write your code here.\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcebkxva2.rs:11:35\n   |\n\
    11 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |    ----------      \
    \               ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976142
- exit_code: 1
  program: "/// In this Kata, you have to sort a vector of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
    /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
    \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.to_vec();\n\n    sorted_arr.reserve(sorted_arr.len()\
    \ - 1);\n\n    // Sorting binary numbers.\n    for &i in &mut sorted_arr {\n \
    \       if i < 64 {\n            i += 1;\n        }\n    }\n\n    // Sorting decimal\
    \ numbers.\n    let mut counter = u64::from(0);\n    for i in &mut sorted_arr\
    \ {\n        let mut remainder = 0;\n        let mut carry = 0;\n        for j\
    \ in i {\n            if j < 64 {\n                remainder += j;\n         \
    \       carry = 1;\n            } else {\n                remainder += 63 + (j\
    \ - 64);\n                carry = 0;\n            }\n        }\n\n        let\
    \ mut tmp = remainder * counter;\n        tmp += carry;\n        sorted_arr.swap(i,\
    \ tmp as usize);\n        counter += 1;\n    }\n\n    sorted_arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp62opwf29.rs:17:9\n   |\n\
    17 |     for &i in &mut sorted_arr {\n   |         ^^    --------------- this\
    \ expression has type `Option<&mut isize>`\n   |         |\n   |         types\
    \ differ in mutability\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note: expected mutable reference `&mut isize`\n    \
    \                  found reference `&_`\n\nerror[E0277]: `isize` is not an iterator\n\
    \  --> /tmp/tmp62opwf29.rs:28:18\n   |\n28 |         for j in i {\n   |      \
    \            ^ `isize` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `isize`\n   = note: if you want to iterate between `start`\
    \ until a value `end`, use the exclusive range syntax `start..end` or the inclusive\
    \ range syntax `start..=end`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `&mut isize`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&mut isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp62opwf29.rs:40:25\n   |\n40 |         sorted_arr.swap(i,\
    \ tmp as usize);\n   |                         ^ expected `usize`, found `&mut\
    \ isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976143
