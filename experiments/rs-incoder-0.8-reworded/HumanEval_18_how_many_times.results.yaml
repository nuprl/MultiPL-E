language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.iter().position(|c| string.find(c) == string.find(substring)).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmprabrnx9t.rs:9:12\n  |\n9 |     string.iter().position(|c|\
    \ string.find(c) == string.find(substring)).count()\n  |            ^^^^ method\
    \ not found in `String`\n  |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \  |\n9 |     string.chars().position(|c| string.find(c) == string.find(substring)).count()\n\
    \  |            ~~~~~\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found\
    \ `String`\n    --> /tmp/tmprabrnx9t.rs:9:62\n     |\n9    |     string.iter().position(|c|\
    \ string.find(c) == string.find(substring)).count()\n     |                  \
    \                                       ---- ^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                                             \
    \            |\n     |                                                       \
    \  required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing here\n\
    \     |\n9    |     string.iter().position(|c| string.find(c) == string.find(&substring)).count()\n\
    \     |                                                              +\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    let mut j = string.len();\n    while i < j && string.contains(substring,\
    \ i) {\n        i += 1;\n    }\n    if i < j {\n        j -= i;\n    }\n    j\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp7yp3vhy3.rs:11:27\n     |\n11   |     while i < j && string.contains(substring,\
    \ i) {\n     |                           ^^^^^^^^ ---------  - supplied 2 arguments\n\
    \     |                           |\n     |                           expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7yp3vhy3.rs:17:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    17 |     j\n   |     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    17 |     j.try_into().unwrap()\n   |      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    let mut iter = string.char_indices();\n    for (i, c)\
    \ in iter.by_ref().take(substring.chars()).enumerate() {\n        if c == substring\
    \ {\n            cnt += 1;\n        } else {\n            cnt = 0;\n        }\n\
    \        if cnt == 0 {\n            return i;\n        }\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5n5qig7r.rs:11:38\n   |\n\
    11 |     for (i, c) in iter.by_ref().take(substring.chars()).enumerate() {\n \
    \  |                                      ^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found struct `Chars`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5n5qig7r.rs:12:17\n\
    \   |\n12 |         if c == substring {\n   |                 ^^^^^^^^^ expected\
    \ tuple, found struct `String`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \             found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5n5qig7r.rs:18:20\n\
    \   |\n18 |             return i;\n   |                    ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = string.char_indices()\n        .filter(|x| *x.contains(&substring))\n\
    \        .count();\n    for c in string.chars() {\n        if c.contains(&substring)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for reference `&(usize,\
    \ char)` in the current scope\n  --> /tmp/tmpz9ewmakt.rs:10:24\n   |\n10 |   \
    \      .filter(|x| *x.contains(&substring))\n   |                        ^^^^^^^^\
    \ method not found in `&(usize, char)`\n\nerror[E0599]: no method named `contains`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpz9ewmakt.rs:13:14\n\
    \   |\n13 |         if c.contains(&substring) {\n   |              ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9ewmakt.rs:17:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n17 |     count\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c|\n        string.chars().any(|s| c == s)\n    )\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp0rd9do7h.rs:9:20\n    |\n9   |       string.chars().count(|c|\n\
    \    |  ____________________^^^^^_-\n    | |                    |\n    | |   \
    \                 expected 0 arguments\n10  | |         string.chars().any(|s|\
    \ c == s)\n    | |______________________________________- supplied 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0rd9do7h.rs:9:5\n   |\n8  |   fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                   ----- expected `isize` because of return type\n9  | /    \
    \ string.chars().count(|c|\n10 | |         string.chars().any(|s| c == s)\n11\
    \ | |     )\n   | |_____^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n11 |     ).try_into().unwrap()\n   |      ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| substring.contains(c))\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpedzjh38i.rs:9:20\n    |\n9   |     string.chars().count(|c| substring.contains(c))\n\
    \    |                    ^^^^^ ------------------------- supplied 1 argument\n\
    \    |                    |\n    |                    expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpedzjh38i.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ substring.contains(c))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ substring.contains(c)).try_into().unwrap()\n  |                            \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut substring = string.replace(substring, \"\");\n    let mut string_length\
    \ = 0;\n    for letter in string.chars() {\n        if letter.is_whitespace()\
    \ {\n            string_length += 1;\n        }\n        else {\n            if\
    \ letter.as_bytes()[0] >= 'a' && letter.as_bytes()[0] <= 'z' {\n             \
    \   string_length += 1;\n            }\n            else {\n                string_length\
    \ += 1;\n            }\n        }\n    }\n    string_length\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   -->\
    \ /tmp/tmpvd69nrhy.rs:9:40\n    |\n9   |     let mut substring = string.replace(substring,\
    \ \"\");\n    |                                ------- ^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n    |                                |\n    |      \
    \                          required by a bound introduced by this call\n    |\n\
    \    = note: the trait bound `String: Pattern<'_>` is not satisfied\n    = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `str::<impl str>::replace`\nhelp: consider borrowing\
    \ here\n    |\n9   |     let mut substring = string.replace(&substring, \"\");\n\
    \    |                                        +\n\nerror[E0599]: no method named\
    \ `as_bytes` found for type `char` in the current scope\n  --> /tmp/tmpvd69nrhy.rs:16:23\n\
    \   |\n16 |             if letter.as_bytes()[0] >= 'a' && letter.as_bytes()[0]\
    \ <= 'z' {\n   |                       ^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvd69nrhy.rs:16:54\n   |\n16 |             if letter.as_bytes()[0]\
    \ >= 'a' && letter.as_bytes()[0] <= 'z' {\n   |                              \
    \                        ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    let mut count = 0;\n    string.chars()\n        .filter(|c|\
    \ c == substring[0])\n        .cloned()\n        .take(string.len())\n       \
    \ .for_each(|c| {\n            if c == substring[0] {\n                i += 1;\n\
    \            } else {\n                i += 1;\n                count = 0;\n \
    \           }\n            if i == string.len() {\n                count += 1;\n\
    \            }\n        });\n    return count;\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpbvck37_9.rs:12:26\n   |\n12 |         .filter(|c| c == substring[0])\n\
    \   |                          ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpbvck37_9.rs:12:17:\
    \ 12:38]> as Iterator>::Item == &_`\n    --> /tmp/tmpbvck37_9.rs:13:10\n     |\n\
    13   |         .cloned()\n     |          ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `take`\
    \ exists for struct `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpbvck37_9.rs:12:17:\
    \ 12:38]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpbvck37_9.rs:14:10\n\
    \   |\n14 |            .take(string.len())\n   |             ^^^^ method cannot\
    \ be called on `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpbvck37_9.rs:12:17: 12:38]>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Filter<Chars<'_>, [closure@/tmp/tmpbvck37_9.rs:12:17:\
    \ 12:38]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<Chars<'_>,\
    \ [closure@/tmp/tmpbvck37_9.rs:12:17: 12:38]>>: Iterator`\n           `Cloned<Filter<Chars<'_>,\
    \ [closure@/tmp/tmpbvck37_9.rs:12:17: 12:38]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<Filter<Chars<'_>, [closure@/tmp/tmpbvck37_9.rs:12:17:\
    \ 12:38]>>: Iterator`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmpbvck37_9"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string[string.find(substring)..].contains(substring) {\n        let len\
    \ = substring.len();\n        string.rfind(substring, 0, len).map(|pos| string.len()\
    \ - pos).unwrap_or(0)\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpqwyo7je8.rs:9:27\n     |\n9    |     if string[string.find(substring)..].contains(substring)\
    \ {\n     |                      ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                      |\n     |                      required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n9    |     if string[string.find(&substring)..].contains(substring)\
    \ {\n     |                           +\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `RangeFrom<Option<usize>>`\n --> /tmp/tmpqwyo7je8.rs:9:8\n  |\n\
    9 |     if string[string.find(substring)..].contains(substring) {\n  |       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  |\n  = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \    --> /tmp/tmpqwyo7je8.rs:11:16\n     |\n11   |         string.rfind(substring,\
    \ 0, len).map(|pos| string.len() - pos).unwrap_or(0)\n     |                ^^^^^\
    \ ---------  -  --- supplied 3 arguments\n     |                |\n     |    \
    \            expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqwyo7je8.rs:11:9\n   |\n8  | fn\
    \ how_many_times(string: String, substring: String) -> isize {\n   |         \
    \             "
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices().filter(|c| c.0.contains(substring)).count()\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `usize` in the\
    \ current scope\n --> /tmp/tmp0tf8g6ds.rs:9:42\n  |\n9 |     string.char_indices().filter(|c|\
    \ c.0.contains(substring)).count()\n  |                                      \
    \    ^^^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp0tf8g6ds.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.char_indices().filter(|c|\
    \ c.0.contains(substring)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.char_indices().filter(|c|\
    \ c.0.contains(substring)).count().try_into().unwrap()\n  |                  \
    \                                                    ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    while let Some(pos) = string.find(substring, i) {\n  \
    \      i += pos;\n        i += 1;\n    }\n    i + 1\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpqhxyvx3c.rs:10:34\n     |\n10   |     while let Some(pos) = string.find(substring,\
    \ i) {\n     |                                  ^^^^ ---------  - supplied 2 arguments\n\
    \     |                                  |\n     |                           \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqhxyvx3c.rs:14:5\n   |\n8  | fn\
    \ how_many_times(string: String, substring: String) -> isize {\n   |         \
    \                                                ----- expected `isize` because\
    \ of return type\n...\n14 |     i + 1\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n14 |     (i + 1).try_into().unwrap()\n  \
    \ |     +     +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = string.find(substring);\n    while index != String::npos {\n\
    \        index = string.find(substring, index + 1);\n        string.swap(0, index);\n\
    \    }\n    string\n        .len()\n        .checked_sub(substring.len())\n  \
    \      .expect(\"Could not find substring\")\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp_yffocfa.rs:9:33\n     |\n9    |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n9    |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp_yffocfa.rs:10:28\n\
    \   |\n10 |     while index != String::npos {\n   |                          \
    \  ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmp_yffocfa.rs:11:46\n   |\n\
    11 |         index = string.find(substring, index + 1);\n   |                \
    \                        ----- ^ - {integer}\n   |                           \
    \             |\n   |                                        Option<usize>\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmp_yffocfa.rs:11:24\n     |\n11   |         index = string.find(substring,\
    \ index + 1);\n     |                        ^^^^ ---------  --------- supplied\
    \ 2 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp_yffocfa.rs:12:16\n   |\n12 |         string.swap(0, index);\n   | \
    \               ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_yffocfa.rs:14:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |   "
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn9_ebv8y.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0\n    }\n\
    \    if string.contains(&substring) {\n        return 1 + how_many_times(&string[..string.len()\
    \ - substring.len()], substring)\n    } else {\n        return how_many_times(&string[..],\
    \ substring)\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n \
    \   assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvnr2g33w.rs:13:35\n   |\n\
    13 |         return 1 + how_many_times(&string[..string.len() - substring.len()],\
    \ substring)\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n13 |         return 1 + how_many_times((&string[..string.len() - substring.len()]).to_string(),\
    \ substring)\n   |                                   +                       \
    \                  +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvnr2g33w.rs:15:31\n\
    \   |\n15 |         return how_many_times(&string[..], substring)\n   |      \
    \                         ^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n15 |         return how_many_times((&string[..]).to_string(),\
    \ substring)\n   |                               +           +++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ n = 0;\n    let mut i = -1;\n    while i < string.len() && i < substring.len()\
    \ {\n        if string[i] >= substring[i] {\n            break;\n        }\n \
    \       i += 1;\n    }\n    i += 1;\n    while i < string.len() {\n        if\
    \ string[i] >= substring[i] {\n            n += 1;\n        } else {\n       \
    \     break;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpyktah7lm.rs:13:17\n\
    \   |\n13 |     let mut i = -1;\n   |                 ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpyktah7lm.rs:15:12\n   |\n15 |         if\
    \ string[i] >= substring[i] {\n   |            ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyktah7lm.rs:15:25\n   |\n15 |         if string[i] >= substring[i]\
    \ {\n   |                         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyktah7lm.rs:22:12\n   |\n22 |         if string[i] >= substring[i]\
    \ {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<us"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().position(|&c| substring.chars().any(|&sc| c==sc))\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc6ekf4h4.rs:9:30\n  |\n9 |\
    \     string.chars().position(|&c| substring.chars().any(|&sc| c==sc))\n  |  \
    \                            ^--\n  |                              ||\n  |   \
    \                           |expected due to this\n  |                       \
    \       expected `char`, found reference\n  |                              help:\
    \ did you mean `c`: `&char`\n  |\n  = note:   expected type `char`\n         \
    \ found reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpc6ekf4h4.rs:9:57\n\
    \  |\n9 |     string.chars().position(|&c| substring.chars().any(|&sc| c==sc))\n\
    \  |                                                         ^---\n  |       \
    \                                                  ||\n  |                   \
    \                                      |expected due to this\n  |            \
    \                                             expected `char`, found reference\n\
    \  |                                                         help: did you mean\
    \ `sc`: `&char`\n  |\n  = note:   expected type `char`\n          found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpc6ekf4h4.rs:9:5\n  |\n\
    8 | fn how_many_times(string: String, substring: String) -> isize {\n  |     \
    \                                                    ----- expected `isize` because\
    \ of return type\n9 |     string.chars().position(|&c| substring.chars().any(|&sc|\
    \ c==sc))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n\
    \             found enum `Option<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut current_pos = 0;\n    let mut count = 0;\n    string\n        .chars()\n\
    \        .filter(|c| c == substring[current_pos] || c == substring[current_pos\
    \ + 1] || c == substring[current_pos + 2])\n        .filter(|c| c != '\\0')\n\
    \        .for_each(|c| {\n            if c == substring[current_pos] {\n     \
    \           count += 1;\n            }\n            current_pos += 1;\n      \
    \  });\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpm3bcjflm.rs:13:26\n   |\n13 |         .filter(|c| c == substring[current_pos]\
    \ || c == substring[current_pos + 1] || c == substring[current_pos + 2])\n   |\
    \                          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpm3bcjflm.rs:13:57\n   |\n13 |         .filter(|c| c == substring[current_pos]\
    \ || c == substring[current_pos + 1] || c == substring[current_pos + 2])\n   |\
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpm3bcjflm.rs:13:92\n   |\n13 |         .filter(|c| c == substring[current_pos]\
    \ || c == substring[current_pos + 1] || c == substring[current_pos + 2])\n   |\
    \                                                                            \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the tr"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    for cs in string.chars().filter_map(|c| {\n        match\
    \ find_in_substring(cs, substring.chars()) {\n            Some(count) => Some(count),\n\
    \            None => None,\n        }\n    }) {\n        if let Some(count) =\
    \ cs {\n            i += count;\n        }\n    }\n    i\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_in_substring` in this scope\n\
    \  --> /tmp/tmpe_kjjhob.rs:11:15\n   |\n11 |         match find_in_substring(cs,\
    \ substring.chars()) {\n   |               ^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `cs` in this scope\n  --> /tmp/tmpe_kjjhob.rs:11:33\n\
    \   |\n11 |         match find_in_substring(cs, substring.chars()) {\n   |   \
    \                              ^^ help: a local variable with a similar name exists:\
    \ `c`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let substring = substring.to_lowercase();\n    let mut counter = 0;\n    let\
    \ mut pos = 0;\n    let mut end = string.len() - substring.len();\n    while pos\
    \ < end {\n        if string[pos] == substring[substring.len() - 1].to_lowercase()\
    \ {\n            substring.push_str(&string[pos + 1].to_lowercase());\n      \
    \      counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3j0tez6q.rs:14:12\n\
    \   |\n14 |         if string[pos] == substring[substring.len() - 1].to_lowercase()\
    \ {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3j0tez6q.rs:14:27\n\
    \   |\n14 |         if string[pos] == substring[substring.len() - 1].to_lowercase()\
    \ {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3j0tez6q.rs:15:33\n   |\n15 |             substring.push_str(&string[pos\
    \ + 1].to_lowercase());\n   |                                 ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<Rang"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    for c in string.chars() {\n        if c != substring.chars().nth(i)\
    \ {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm6o9vbb3.rs:11:17\n   |\n\
    11 |         if c != substring.chars().nth(i) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpm6o9vbb3.rs:15:5\n   |\n8  | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n   |                                                   \
    \      ----- expected `isize` because of return type\n...\n15 |     i\n   |  \
    \   ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n15 |     i.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices()\n        .filter_map(|i| i.contains(&substring).cloned())\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmpfta2gfqi.rs:10:27\n   |\n10 |         .filter_map(|i|\
    \ i.contains(&substring).cloned())\n   |                           ^^^^^^^^ method\
    \ not found in `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfta2gfqi.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.char_indices()\n10 | |   \
    \      .filter_map(|i| i.contains(&substring).cloned())\n11 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n11 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut pos = 0;\n    while pos < string.len() {\n        let mut end = pos\
    \ + substring.len();\n        while end < string.len() {\n            if string[pos]\
    \ == substring[end] {\n                end += 1;\n            } else {\n     \
    \           break;\n            }\n        }\n        pos += end as usize;\n \
    \   }\n    pos\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpup_q_q4s.rs:13:16\n\
    \   |\n13 |             if string[pos] == substring[end] {\n   |             \
    \   ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpup_q_q4s.rs:13:31\n   |\n13 |             if string[pos] == substring[end]\
    \ {\n   |                               ^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpup_q_q4s.rs:21:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n21 |     pos\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     pos.try_into().unwrap()\n   |  \
    \      ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a,b)|a == b).count()\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp77dmy10m.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a,b)|a\
    \ == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,b)|a\
    \ == b).count().try_into().unwrap()\n  |                                     \
    \                                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    for mut c in string.chars() {\n        if !substring.contains(&c)\
    \ {\n            cnt += 1;\n        }\n        if substring.ends_with(&c) {\n\
    \            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp7pkqwv0r.rs:11:32\n\
    \     |\n11   |         if !substring.contains(&c) {\n     |                 \
    \      -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |   \
    \                    |\n     |                       required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ !substring.contains(*&c) {\n     |                                +\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp7pkqwv0r.rs:14:32\n\
    \   |\n14 |         if substring.ends_with(&c) {\n   |                      ---------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n   |                   \
    \   |\n   |                      required by a bound introduced by this call\n\
    \   |\n   = help: the trait `Fn<(char,)>` is not implemented for `char`\n   =\
    \ note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nhelp: consider dereferencing here\n   |\n14 |   \
    \      if substring.ends_with(*&c) {\n   |                                +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut string = string.as_bytes();\n    let mut substring = substring.as_bytes();\n\
    \    let mut count = 0;\n\n    let mut char_pos = 0;\n    let mut char_pos_end\
    \ = string.len() as usize;\n    let mut char_is_found = substring.len() > 0;\n\
    \n    while char_pos < char_pos_end {\n        if char_is_found {\n          \
    \  count += 1;\n        }\n\n        let mut next_char_pos = char_pos + 1;\n \
    \       if next_char_pos > char_pos_end {\n            next_char_pos = char_pos_end;\n\
    \        }\n\n        if char_is_found {\n            if substring[char_pos as\
    \ usize] == string[next_char_pos as usize] {\n                count += 1;\n  \
    \              char_is_found = false;\n            } else {\n                char_pos\
    \ = next_char_pos;\n            }\n        } else {\n            char_is_found\
    \ = true;\n            char_pos = next_char_pos;\n        }\n    }\n\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpvlel5l3c.rs:28:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c != substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpuklmmvgh.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c != substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpuklmmvgh.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c != substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c != substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .chars()\n        .filter_map(|c| if string.starts_with(substring)\
    \ { Some(c + substring.len()) } else { None })\n        .filter(|c| c != None)\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpc5izyf3u.rs:11:47\n     |\n11   |         .filter_map(|c| if string.starts_with(substring)\
    \ { Some(c + substring.len()) } else { None })\n     |                       \
    \            ----------- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |                                   |\n     |                          \
    \         required by a bound introduced by this call\n     |\n     = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\nhelp: consider borrowing\
    \ here\n     |\n11   |         .filter_map(|c| if string.starts_with(&substring)\
    \ { Some(c + substring.len()) } else { None })\n     |                       \
    \                        +\n\nerror[E0369]: cannot add `usize` to `char`\n  -->\
    \ /tmp/tmpc5izyf3u.rs:11:67\n   |\n11 |         .filter_map(|c| if string.starts_with(substring)\
    \ { Some(c + substring.len()) } else { None })\n   |                         \
    \                                        - ^ --------------- usize\n   |     \
    \                                                            |\n   |         \
    \                                                        char\n\nerror[E0277]:\
    \ can't compare `&_` with `Option<_>`\n  --> /tmp/tmpc5izyf3u.rs:12:23\n   |\n\
    12 |         .filter(|c| c != None)\n   |                       ^^ no implementation\
    \ for `&_ == Option<_>`\n   |\n   = help: the trait `PartialEq<Option<_>>` is\
    \ not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5izyf3u.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string\n10 | |         .chars()\n\
    11 | |         .filter_map(|c| if string.starts_with(substring) { Some(c + substring.len())\
    \ } else { None })\n12 | |         .filter(|c| c != None)\n13 | |         .count()\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   substring\n        .as_bytes()\n        .iter()\n        .map(|c| if string.contains(&c)\
    \ { 1 } else { 0 })\n        .sum()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `u8`\n    --> /tmp/tmpfaseby0b.rs:12:37\n\
    \     |\n12   |         .map(|c| if string.contains(&c) { 1 } else { 0 })\n  \
    \   |                            -------- ^^ expected an `Fn<(char,)>` closure,\
    \ found `u8`\n     |                            |\n     |                    \
    \        required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `Fn<(char,)>` is not implemented for `u8`\n     = help: the following\
    \ other types implement trait `Pattern<'a>`:\n               &'b String\n    \
    \           &'b [char; N]\n               &'b [char]\n               &'b str\n\
    \               &'c &'b str\n               [char; N]\n               char\n \
    \              pattern::MultiCharEqPattern<C>\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&u8`\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&&u8`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(&a, &b)|\
    \ a == b)\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppp76xs9k.rs:11:19\n   |\n\
    11 |         .filter(|(&a, &b)| a == b)\n   |                   ^^    - expected\
    \ due to this\n   |                   |\n   |                   expected `char`,\
    \ found reference\n   |                   help: you can probably remove the explicit\
    \ borrow: `a`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppp76xs9k.rs:11:23\n  \
    \ |\n11 |         .filter(|(&a, &b)| a == b)\n   |                       ^^- expected\
    \ due to this\n   |                       |\n   |                       expected\
    \ `char`, found reference\n   |                       help: you can probably remove\
    \ the explicit borrow: `b`\n   |\n   = note:   expected type `char`\n        \
    \   found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppp76xs9k.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(&a, &b)| a == b)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count() + 1\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpiqg4wq2s.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count() + 1).try_into().unwrap()\n  |     +                    \
    \                                                     +++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| substring.chars().any(|c| c == c))\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpwyp1ngmp.rs:9:20\n    |\n9   |     string.chars().count(|c| substring.chars().any(|c|\
    \ c == c))\n    |                    ^^^^^ -------------------------------------\
    \ supplied 1 argument\n    |                    |\n    |                    expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpwyp1ngmp.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().count(|c| substring.chars().any(|c| c == c))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ substring.chars().any(|c| c == c)).try_into().unwrap()\n  |                \
    \                                                ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    let mut s = string;\n    let mut sub = substring;\n\
    \    while !s.is_empty() {\n        if s.starts_with(sub) {\n            cnt +=\
    \ 1;\n        }\n        s += sub;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpe4y1oj4p.rs:13:26\n     |\n13   |         if s.starts_with(sub)\
    \ {\n     |              ----------- ^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |              |\n     |              required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n13   |         if s.starts_with(&sub) {\n\
    \     |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe4y1oj4p.rs:16:14\n\
    \   |\n16 |         s += sub;\n   |              ^^^\n   |              |\n  \
    \ |              expected `&str`, found struct `String`\n   |              help:\
    \ consider borrowing here: `&sub`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 {\n        0\n    } else if string[1..].contains(&substring)\
    \ {\n        1\n    } else if substring.contains(&string) {\n        2\n    }\
    \ else {\n        string\n            .iter()\n            .zip(string.iter().cloned())\n\
    \            .filter_map(|(a, b)| if b == &a { Some(0) } else { Some(1) })\n \
    \           .filter(|&a| a == 0 || a == 1)\n            .count() + 1\n    }\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpoh3o0c2w.rs:17:14\n   |\n17 |             .iter()\n   |\
    \              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n17 |             .chars()\n   |              ~~~~~\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpoh3o0c2w.rs:18:25\n   |\n18 |             .zip(string.iter().cloned())\n\
    \   |                         ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n18 |             .zip(string.chars().cloned())\n\
    \   |                         ~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(ref c, ref s)| c == s).count().unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `usize` in the\
    \ current scope\n --> /tmp/tmpqle84hxa.rs:9:84\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ c, ref s)| c == s).count().unwrap_or(0)\n  |                               \
    \                                                     ^^^^^^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut n = 0;\n    while string.contains(&substring) {\n        n += 1;\n\
    \        string = string.trim_suffix(substring);\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trim_suffix` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmptsguf_iz.rs:12:25\n   |\n12 |         string\
    \ = string.trim_suffix(substring);\n   |                         ^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `strip_suffix`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   match how_many_times_for(string) {\n        None => None,\n        Some(pos)\
    \ => Some(pos as isize),\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `how_many_times_for` in this scope\n\
    \ --> /tmp/tmpagz7qywb.rs:9:11\n  |\n9 |     match how_many_times_for(string)\
    \ {\n  |           ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpagz7qywb.rs:10:17\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n9  |\
    \     match how_many_times_for(string) {\n10 |         None => None,\n   |   \
    \              ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c.contains(substring)).count() as isize\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmps6nly03z.rs:9:33\n  |\n9 |     string.chars().filter(|c|\
    \ c.contains(substring)).count() as isize\n  |                               \
    \  ^^^^^^^^ method not found in `&char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   match find_substring_occurrence(string, substring) {\n        Some(count)\
    \ => count,\n        None => 0,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_substring_occurrence` in this\
    \ scope\n --> /tmp/tmp4xwjnu81.rs:9:11\n  |\n9 |     match find_substring_occurrence(string,\
    \ substring) {\n  |           ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).count().unwrap_or(0)\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `usize` in the\
    \ current scope\n --> /tmp/tmp1o4zk0sr.rs:9:51\n  |\n9 |     string.chars().zip(substring.chars()).count().unwrap_or(0)\n\
    \  |                                                   ^^^^^^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(a, b)|\
    \ {\n            if a == b {\n                true\n            } else {\n   \
    \             a.is_match(b) && !b.is_match(a)\n            }\n        })\n   \
    \     .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_match` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp9x7taczi.rs:15:19\n   |\n15 |             \
    \    a.is_match(b) && !b.is_match(a)\n   |                   ^^^^^^^^ method not\
    \ found in `&char`\n\nerror[E0599]: no method named `is_match` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmp9x7taczi.rs:15:37\n   |\n15 |  \
    \               a.is_match(b) && !b.is_match(a)\n   |                        \
    \             ^^^^^^^^ method not found in `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9x7taczi.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.chars()\n10 | |         .zip(substring.chars())\n11 | |     \
    \    .filter(|(a, b)| {\n12 | |             if a == b {\n...  |\n17 | |      \
    \   })\n18 | |         .count()\n   | |________________^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.contains(substring) {\n        1\n    } else {\n        string.lower().contains(substring.lower())\n\
    \    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp6nl7_fjm.rs:9:24\n     |\n9    |     if string.contains(substring)\
    \ {\n     |               -------- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |               |\n     |               required by a bound\
    \ introduced by this call\n     |\n     = note: the trait bound `String: Pattern<'_>`\
    \ is not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n9    |     if string.contains(&substring)\
    \ {\n     |                        +\n\nerror[E0599]: no method named `lower`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp6nl7_fjm.rs:12:16\n\
    \   |\n12 |         string.lower().contains(substring.lower())\n   |         \
    \       ^^^^^ method not found in `String`\n\nerror[E0599]: no method named `lower`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp6nl7_fjm.rs:12:43\n\
    \   |\n12 |         string.lower().contains(substring.lower())\n   |         \
    \                                  ^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut position = 0;\n    for ch in string.chars()\
    \ {\n        if ch == substring.chars().first() {\n            counter = counter\
    \ + 1;\n        } else {\n            counter = counter + how_many_times(string.chars().skip_while(|&c|\
    \ c != ch).collect::<String>(), substring);\n        }\n        position = ch;\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n \
    \   assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `first` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpyycdm9m2.rs:12:36\n   |\n12 |         if ch == substring.chars().first()\
    \ {\n   |                                    ^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyycdm9m2.rs:17:20\n   |\n10 |\
    \     let mut position = 0;\n   |                        - expected due to this\
    \ value\n...\n17 |         position = ch;\n   |                    ^^ expected\
    \ integer, found `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| *a < *b).count().unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpv3im9z54.rs:9:60\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)| *a < *b).count().unwrap_or(0)\n\
    \  |                                                            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmpv3im9z54.rs:9:65\n  |\n9 |\
    \     string.chars().zip(substring.chars()).filter(|&(a, b)| *a < *b).count().unwrap_or(0)\n\
    \  |                                                                 ^^\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for type `usize` in the current scope\n -->\
    \ /tmp/tmpv3im9z54.rs:9:77\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| *a < *b).count().unwrap_or(0)\n  |                                     \
    \                                        ^^^^^^^^^ method not found in `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut pos = 0;\n    while pos < string.len() {\n        let start = pos;\n\
    \        let end = string.find(substring, start);\n        match end {\n     \
    \       None => break,\n            Some(last) => start = last,\n        }\n\n\
    \        pos += end - start;\n    }\n    pos\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmps4kuljj1.rs:12:26\n     |\n12   |         let end = string.find(substring,\
    \ start);\n     |                          ^^^^ ---------  ----- supplied 2 arguments\n\
    \     |                          |\n     |                          expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0369]: cannot\
    \ subtract `usize` from `Option<usize>`\n  --> /tmp/tmps4kuljj1.rs:18:20\n   |\n\
    18 |         pos += end - start;\n   |                --- ^ ----- usize\n   |\
    \                |\n   |                Option<usize>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps4kuljj1.rs:20:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    20 |     pos\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |     pos.try_into().unwrap()\n   |        ++++++++++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    for c in string.chars() {\n        if substring.contains(c)\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `4`', /tmp/tmp763rdwoz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| c == substring)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp08e0m3s4.rs:9:20\n    |\n9   |     string.chars().count(|c| c\
    \ == substring)\n    |                    ^^^^^ ------------------ supplied 1\
    \ argument\n    |                    |\n    |                    expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp08e0m3s4.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ c == substring)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c| c\
    \ == substring).try_into().unwrap()\n  |                                     \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\
    \n    let mut i = 0;\n    let mut j = string.len() - substring.len();\n    while\
    \ i < j {\n        let k = min(j, string::find_first_not_of(substring, i + 1));\n\
    \        let k = min(k, string::find_last_not_of(substring, i));\n\n        let\
    \ mut count = j - i;\n        if k < i {\n            count = k;\n        }\n\
    \        i += count;\n        j -= count;\n    }\n    i\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmp0l80m5ia.rs:16:24\n   |\n16 |         let k = min(j, string::find_first_not_of(substring,\
    \ i + 1));\n   |                        ^^^^^^ use of undeclared crate or module\
    \ `string`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `string`\n  --> /tmp/tmp0l80m5ia.rs:17:24\n   |\n17 |         let k = min(k,\
    \ string::find_last_not_of(substring, i));\n   |                        ^^^^^^\
    \ use of undeclared crate or module `string`\n\nerror[E0425]: cannot find function\
    \ `min` in this scope\n  --> /tmp/tmp0l80m5ia.rs:16:17\n   |\n16 |         let\
    \ k = min(j, string::find_first_not_of(substring, i + 1));\n   |             \
    \    ^^^\n...\n29 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n16 |\
    \         let k = main(j, string::find_first_not_of(substring, i + 1));\n   |\
    \                 ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `min` in this scope\n\
    \  --> /tmp/tmp0l80m5ia.rs:17:17\n   |\n17 |         let k = min(k, string::find_last_not_of(substring,\
    \ i));\n   |                 ^^^\n...\n29 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n17 |         let k = main(k, string::find_last_not_of(substring,\
    \ i));\n   |                 ~~~~\nhelp: consider importing this function\n  \
    \ |\n1  | use std::cmp::min;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0l80m5ia.rs:26:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n26 |     i\n   |     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n26 |     i.try_into().unwrap()\n   |    \
    \  ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detai"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt: usize = 0;\n    let mut string_len = string.len();\n    let mut\
    \ substring_len = substring.len();\n    let mut i = 0;\n\n    while i < string_len\
    \ && i < substring_len {\n        if string[string_len - i - 1] == substring[substring_len\
    \ - i - 1] {\n            cnt += 1;\n            i += 1;\n        } else {\n \
    \           i += 1;\n        }\n    }\n\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp24c9bnm.rs:15:12\n\
    \   |\n15 |         if string[string_len - i - 1] == substring[substring_len -\
    \ i - 1] {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp24c9bnm.rs:15:42\n   |\n15 |         if string[string_len - i\
    \ - 1] == substring[substring_len - i - 1] {\n   |                           \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp24c9bnm.rs:23:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n23 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |     cnt.try_into().unwrap()\n   |  \
    \      ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed e"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = string.find(substring);\n    while index >= 0 {\n        index\
    \ += string.find(substring, index).unwrap();\n        index -= 1;\n    }\n   \
    \ index\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp9syjkz70.rs:9:33\n     |\n9    |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n9    |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9syjkz70.rs:10:20\n\
    \   |\n10 |     while index >= 0 {\n   |                    ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    10 |     while index >= Some(0) {\n   |                    +++++ +\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9syjkz70.rs:11:25\n\
    \     |\n11   |         index += string.find(substring, index).unwrap();\n   \
    \  |                         ^^^^ ---------  ----- supplied 2 arguments\n    \
    \ |                         |\n     |                         expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp9syjkz70.rs:11:9\n\
    \   |\n11 |         index += string.find(substring, index).unwrap();\n   |   \
    \      -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n   | \
    \        cannot use `+=` on type `Option<usize>`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmp9syjkz70.rs:12:9\n\
    \   |\n12 |         index -= 1;\n   |         -----^^^^^\n   |         |\n   |\
    \         cannot use `-=` on type `Option<usize>`\n\nerror[E0308]: mismat"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = 0;\n    while !string.starts_with(&substring) {\n        match\
    \ string.chars().nth(index) {\n            None => return 0,\n            Some(c)\
    \ => index = index + 1,\n        }\n    }\n    let mut count = 0;\n    let mut\
    \ offset = 0;\n    while !string.ends_with(&substring) {\n        match string.chars().nth(index)\
    \ {\n            None => return count,\n            Some(c) => {\n           \
    \     count = count + 1;\n                offset = offset + 1;\n            }\n\
    \        }\n        match string.chars().nth(index + 1) {\n            None =>\
    \ return count,\n            Some(c) => offset = offset + 1,\n        }\n    \
    \    index = index + 2;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpyrqc3sch.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let substring = &substring[..];\n\n    string.find_first_not_of(substring).map(|pos|\
    \ string.count(pos, substring.len()))\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_first_not_of` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmph1kxecf1.rs:11:12\n   |\n11 |     string.find_first_not_of(substring).map(|pos|\
    \ string.count(pos, substring.len()))\n   |            ^^^^^^^^^^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmph1kxecf1.rs:11:58\n\
    \    |\n11  |       string.find_first_not_of(substring).map(|pos| string.count(pos,\
    \ substring.len()))\n    |                                                   \
    \         ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpllid46h6.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpllid46h6.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|&(ref a,\
    \ ref b)| a == b)\n        .count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `count` on type `Filter<Zip<Chars<'_>,\
    \ Chars<'_>>, [closure@/tmp/tmpk5tkbh2t.rs:11:17: 11:41]>`\n  --> /tmp/tmpk5tkbh2t.rs:12:10\n\
    \   |\n12 |         .count\n   |          ^^^^^ method, not a field\n   |\nhelp:\
    \ use parentheses to call the method\n   |\n12 |         .count()\n   |      \
    \         ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0615`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.find(substring).unwrap() as isize\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpegqvph62.rs:9:17\n     |\n9    |     string.find(substring).unwrap()\
    \ as isize\n     |            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |            |\n     |            required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is\
    \ not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n9    |     string.find(&substring).unwrap()\
    \ as isize\n     |                 +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   match string.find(substring) {\n        Some(index) => {\n            let\
    \ substring: String = string[..index];\n            let substring: String = string[index..].to_owned();\n\
    \            let substring: String = string[..index].to_owned();\n           \
    \ let substring: String = string[index..].to_owned();\n            let substring:\
    \ String = string[..index].to_owned();\n            let substring: String = string[index..].to_owned();\n\
    \            string.chars().count(|c| c == 'a' || c == substring[0] || c == substring[1]\
    \ || c == substring[2] || c == substring[3] || c == substring[4] || c == substring[5]\
    \ || c == substring[6] || c == substring[7] || c == substring[8] || c == substring[9]\
    \ || c == substring[10] || c == substring[11] || c == substring[12] || c == substring[13]\
    \ || c == substring[14] || c == substring[15] || c == substring[16] || c == substring[17]\
    \ || c == substring[18] || c == substring[19] || c == substring[20] || c == substring[21]\
    \ || c == substring[22] || c == substring[23] || c == substring[24] || c == substring[25]\
    \ || c == substring[26] || c == substring[27] || c == substring[28] || c == substring[29]\
    \ || c == substring[30] || c == substring[31] || c == substring[32] || c == substring[33]\
    \ || c == substring[34] || c == substring[35] || c == substring[36] || c == substring[37]\
    \ || c == substring[38] || c == substring[39] || c == substring[40] || c == substring[41]\
    \ || c == substring[42]) || substring.length()\n        }\n        None => 0\n\
    \    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpj5buacpr.rs:9:23\n     |\n9    |     match string.find(substring)\
    \ {\n     |                  ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |                  |\n     |                  required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is\
    \ not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n9    |     match string.find(&substring)\
    \ {\n     |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj5buacpr.rs:11:37\n\
    \   |\n11 |             let substring: String = string[..index];\n   |       \
    \                     ------   ^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                            |        |\n   |           \
    \                 |        expected struct `String`, found `str`\n   |       \
    \                     expected due to this\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpj5buacpr.rs:17:55\n   |\n17\
    \ | ...   string.chars().count(|c| c == 'a' || c == substring[0] || c == substring[1]\
    \ || c == substring[2] || c == substring[3] || c == subst...\n   |           \
    \                                      ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpj5buacpr.rs:17:76\n   |\n17 | ...   string.chars().count(|"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut pos = 0;\n    let mut count = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, &pos, &count) {\n            count +=\
    \ 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \    --> /tmp/tmpurkah_1n.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ &pos, &count) {\n     |                   ^^^^^^^^^^^ ---------  ----  ------\
    \ supplied 3 arguments\n     |                   |\n     |                   expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).count(|&(a, b)| a == b)\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpv1v2ync4.rs:9:43\n    |\n9   |     string.chars().zip(substring.chars()).count(|&(a,\
    \ b)| a == b)\n    |                                           ^^^^^ ----------------\
    \ supplied 1 argument\n    |                                           |\n   \
    \ |                                           expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n --> /tmp/tmpv1v2ync4.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().zip(substring.chars()).count(|&(a,\
    \ b)| a == b)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).count(|&(a,\
    \ b)| a == b).try_into().unwrap()\n  |                                       \
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp6nbsyrfv.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp6nbsyrfv.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut n = 0;\n    for c in string.chars() {\n        if c == substring.chars()\
    \ {\n            n += 1;\n        } else {\n            if substring.chars().any(|c|\
    \ *c == c) {\n                n += 1;\n            } else {\n                n\
    \ += 0;\n            }\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpggvpgbcm.rs:11:17\n   |\n\
    11 |         if c == substring.chars() {\n   |                 ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `Chars`\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmpggvpgbcm.rs:14:42\n   |\n14 |             if substring.chars().any(|c|\
    \ *c == c) {\n   |                                          ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices().filter(|a| a.1.is_some()).filter(move |a| a.0 == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_some` found for type `char` in the current\
    \ scope\n --> /tmp/tmpd8pumbbs.rs:9:42\n  |\n9 |     string.char_indices().filter(|a|\
    \ a.1.is_some()).filter(move |a| a.0 == substring).count()\n  |              \
    \                            ^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpd8pumbbs.rs:9:76\n  |\n9 |     string.char_indices().filter(|a|\
    \ a.1.is_some()).filter(move |a| a.0 == substring).count()\n  |              \
    \                                                              ^^^^^^^^^ expected\
    \ `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpd8pumbbs.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.char_indices().filter(|a| a.1.is_some()).filter(move\
    \ |a| a.0 == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.char_indices().filter(|a|\
    \ a.1.is_some()).filter(move |a| a.0 == substring).count().try_into().unwrap()\n\
    \  |                                                                         \
    \                     ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    let mut char_pos = 0;\n  \
    \  let mut start = match string.find(substring) {\n        Ok(pos) => pos,\n \
    \       Err(_) => return 0,\n    };\n    while start != isize::MAX {\n       \
    \ let mut end = string.len();\n        if end > char_pos {\n            end -=\
    \ char_pos;\n        }\n        let mut start_char = string.chars().nth(start).unwrap();\n\
    \        let mut end_char = string.chars().nth(end).unwrap();\n        if start_char\
    \ == end_char {\n            start += 1;\n            end += 1;\n            continue;\n\
    \        }\n        if start_char.ascii_lowercase().eq(end_char.ascii_lowercase())\
    \ {\n            counter = counter + 1;\n        }\n        let mut start_pos\
    \ = start_char.position();\n        let mut end_pos = end_char.position();\n \
    \       while start_pos < end_pos {\n            let next_char = string.chars().nth(start_pos\
    \ + 1).unwrap();\n            if next_char.ascii_lowercase().eq(end_char.ascii_lowercase())\
    \ {\n                counter = counter + 1;\n            }\n            start_pos\
    \ = start_pos + 1;\n            end_pos = end_pos + 1;\n        }\n        char_pos\
    \ = start;\n        start = match string.find(substring, start + 1) {\n      \
    \      Ok(pos) => pos,\n            Err(_) => return 0,\n        };\n    }\n \
    \   counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpkvfq0yyl.rs:12:39\n     |\n12   |     let mut start = match string.find(substring)\
    \ {\n     |                                  ---- ^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                                  |\n     |  \
    \                                required by a bound introduced by this call\n\
    \     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n12   |     let mut start = match string.find(&substring)\
    \ {\n     |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkvfq0yyl.rs:13:9\n   |\n12 |     let mut start = match\
    \ string.find(substring) {\n   |                           ----------------------\
    \ this expression has type `Option<usize>`\n13 |         Ok(pos) => pos,\n   |\
    \         ^^^^^^^ expected enum `Option`, found enum `Result`\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found enum `Result<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkvfq0yyl.rs:14:9\n   |\n12 |     let mut start\
    \ = match string.find(substring) {\n   |                           ----------------------\
    \ this expression has type `Option<usize>`\n13 |         Ok(pos) => pos,\n14 |\
    \         Err(_) => return 0,\n   |         ^^^^^^ expected enum `Option`, found\
    \ enum `Result`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found enum `Result<_, _>`\n\nerror[E0277]: can't compare `usize` with `isize`\n\
    \  --> /tmp/tmpkvfq0yyl.rs:16:17\n   |\n16 |     while start != isize::MAX {\n\
    \   |                 ^^ no implementation for `usize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n   "
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.find(&substring).map(|i| i + substring.length()).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpp7dilvht.rs:9:51\n  |\n9 |     string.find(&substring).map(|i|\
    \ i + substring.length()).count()\n  |                                       \
    \            ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmpp7dilvht.rs:9:61\n\
    \    |\n9   |       string.find(&substring).map(|i| i + substring.length()).count()\n\
    \    |                                                               ^^^^^ `Option<usize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppmc0u5kb.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmppmc0u5kb.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpllid46h6.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpllid46h6.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0\n    let mut i = 0;\n    while i != string.len() {\n \
    \       i += string.find(substring, i)?;\n        counter += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp18tszfr9.rs:9:24\n\
    \   |\n9  |     let mut counter = 0\n   |                        ^ help: add `;`\
    \ here\n10 |     let mut i = 0;\n   |     --- unexpected token\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp18tszfr9.rs:12:21\n\
    \     |\n12   |         i += string.find(substring, i)?;\n     |             \
    \        ^^^^ ---------  - supplied 2 arguments\n     |                     |\n\
    \     |                     expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmp18tszfr9.rs:12:39\n   |\n8  | / fn how_many_times(string: String,\
    \ substring: String) -> isize {\n9  | |     let mut counter = 0\n10 | |     let\
    \ mut i = 0;\n11 | |     while i != string.len() {\n12 | |         i += string.find(substring,\
    \ i)?;\n   | |                                       ^ cannot use the `?` operator\
    \ in a function that returns `isize`\n...  |\n15 | |     counter\n16 | | }\n \
    \  | |_- this function should return `Result` or `Option` to accept `?`\n   |\n\
    \   = help: the trait `FromResidual<Option<Infallible>>` is not implemented for\
    \ `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0277.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c != substring[0]).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpz6j_37kf.rs:9:36\n  |\n9 |     string.chars().filter(|c| c != substring[0]).count()\
    \ as isize\n  |                                    ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Use substr_count because it's faster and more intuitive.\n    string.substr_count(substring)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `substr_count` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp3pqkaucv.rs:10:12\n   |\n10 |     string.substr_count(substring)\n\
    \   |            ^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    let mut len = string.length;\n    let mut char = string[0];\n\
    \    while i < len {\n        if char == substring[0] {\n            i += 1;\n\
    \            len -= 1;\n        } else {\n            i += 1;\n        }\n   \
    \     char = string[i];\n    }\n    len\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmpd9phg3vs.rs:10:26\n\
    \   |\n10 |     let mut len = string.length;\n   |                          ^^^^^^\
    \ unknown field\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpd9phg3vs.rs:11:20\n   |\n11 |     let mut char = string[0];\n \
    \  |                    ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpd9phg3vs.rs:13:20\n   |\n13 |         if char == substring[0] {\n\
    \   |                    ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpd9phg3vs.rs:19:16\n   |\n19 |         char = string[i];\n   | \
    \               ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n  \
    \ = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclus"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut pos = 0;\n    let mut count = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            count += 1;\n  \
    \      }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp0f5hz5dw.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n\n    for c in string.chars() {\n        if substring.contains(c)\
    \ {\n            count += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `4`', /tmp/tmp0an3z_k0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .chars()\n        .filter(|c| c == substring)\n        .count()\
    \ + (substring.length()..string.len())\n        .filter(|c| c != substring)\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n  --> /tmp/tmpg2o2nep7.rs:11:23\n\
    \   |\n11 |         .filter(|c| c == substring)\n   |                       ^^\
    \ no implementation for `&char == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpg2o2nep7.rs:12:31\n   |\n12 |         .count()\
    \ + (substring.length()..string.len())\n   |                               ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ can't compare `&usize` with `String`\n  --> /tmp/tmpg2o2nep7.rs:13:23\n   |\n\
    13 |         .filter(|c| c != substring)\n   |                       ^^ no implementation\
    \ for `&usize == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&usize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg2o2nep7.rs:9:5\n   |\n8  |   fn how_many_times(string: String, substring:\
    \ String) -> isize {\n   |                                                   \
    \        ----- expected `isize` because of return type\n9  | /     string\n10\
    \ | |         .chars()\n11 | |         .filter(|c| c == substring)\n12 | |   \
    \      .count() + (substring.length()..string.len())\n13 | |         .filter(|c|\
    \ c != substring)\n14 | |         .count()\n   | |________________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n9  ~     (string\n10 |         .chars()\n\
    11 |         .filter(|c| c == substring)\n12 |         .count() + (substring.length()..string.len())\n\
    13 |         .filter(|c| c != substring)\n14 ~         .count()).try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detaile"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices()\n        .filter(|&(_, index)| index >= substring.len())\n\
    \        .count(|&(_, index)| substring.contains(&string[index..]))\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrezzrfz.rs:10:40\n   |\n\
    10 |         .filter(|&(_, index)| index >= substring.len())\n   |           \
    \                             ^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpsrezzrfz.rs:11:10\n    |\n11  |         .count(|&(_, index)| substring.contains(&string[index..]))\n\
    \    |          ^^^^^ -------------------------------------------------- supplied\
    \ 1 argument\n    |          |\n    |          expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsrezzrfz.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.char_indices()\n10 | |   \
    \      .filter(|&(_, index)| index >= substring.len())\n11 | |         .count(|&(_,\
    \ index)| substring.contains(&string[index..]))\n   | |__________________________________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |         .count(|&(_,\
    \ index)| substring.contains(&string[index..])).try_into().unwrap()\n   |    \
    \                                                               ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn9_ebv8y.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| c != substring.chars().next())\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpoiyko5fj.rs:9:20\n    |\n9   |     string.chars().count(|c| c\
    \ != substring.chars().next())\n    |                    ^^^^^ ---------------------------------\
    \ supplied 1 argument\n    |                    |\n    |                    expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoiyko5fj.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().count(|c| c != substring.chars().next())\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ c != substring.chars().next()).try_into().unwrap()\n  |                    \
    \                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut substring_len = substring.len();\n    let mut count_of_matches = 0;\n\
    \    let mut last_seen_pos = 0;\n    let mut last_seen_substring: String;\n  \
    \  let mut last_seen_substring_len = 0;\n    while string.len() > 0 {\n      \
    \  last_seen_substring = substring;\n        last_seen_substring_len = 0;\n  \
    \      last_seen_pos = 0;\n        while last_seen_substring.len() > 0 {\n   \
    \         last_seen_pos += 1;\n            if last_seen_substring.starts_with(&string[last_seen_pos..])\
    \ {\n                count_of_matches += 1;\n                last_seen_substring.clear();\n\
    \            } else {\n                last_seen_substring.truncate(last_seen_substring.len());\n\
    \            }\n        }\n        string.truncate(string.len() - substring_len);\n\
    \    }\n    count_of_matches\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `last_seen_pos` is never read\n  --> /tmp/tmp_v0l8_wb.rs:11:13\n\
    \   |\n11 |     let mut last_seen_pos = 0;\n   |             ^^^^^^^^^^^^^\n \
    \  |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: variable `last_seen_substring_len`\
    \ is assigned to, but never used\n  --> /tmp/tmp_v0l8_wb.rs:13:13\n   |\n13 |\
    \     let mut last_seen_substring_len = 0;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_last_seen_substring_len` instead\n\nwarning: value assigned to `last_seen_substring_len`\
    \ is never read\n  --> /tmp/tmp_v0l8_wb.rs:16:9\n   |\n16 |         last_seen_substring_len\
    \ = 0;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable does not need to be mutable\n --> /tmp/tmp_v0l8_wb.rs:9:9\n\
    \  |\n9 |     let mut substring_len = substring.len();\n  |         ----^^^^^^^^^^^^^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `substring`\n  --> /tmp/tmp_v0l8_wb.rs:15:31\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                   --------- move occurs because `substring`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n15 |    \
    \     last_seen_substring = substring;\n   |                               ^^^^^^^^^\
    \ value moved here, in previous iteration of loop\n\nerror[E0596]: cannot borrow\
    \ `string` as mutable, as it is not declared as mutable\n  --> /tmp/tmp_v0l8_wb.rs:27:9\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                   ------ help: consider changing this to be mutable: `mut\
    \ string`\n...\n27 |         string.truncate(string.len() - substring_len);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors; 4 warnings emitted\n\nSome errors\
    \ have detailed exp"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| substring.contains(c))\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpedzjh38i.rs:9:20\n    |\n9   |     string.chars().count(|c| substring.contains(c))\n\
    \    |                    ^^^^^ ------------------------- supplied 1 argument\n\
    \    |                    |\n    |                    expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpedzjh38i.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ substring.contains(c))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ substring.contains(c)).try_into().unwrap()\n  |                            \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut string_iter = string.char_indices();\n   \
    \ let mut substr_iter = substring.char_indices();\n    while let Some((start,\
    \ end)) = string_iter.next() {\n        if let Some((_, end)) = substr_iter.next()\
    \ {\n            if start == end {\n                count += 1;\n            \
    \    continue;\n            }\n            if start > end {\n                break;\n\
    \            }\n            if let Some(_) = string_iter.next() {\n          \
    \      count += 1;\n            }\n        }\n        break;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptswq8nni.rs:14:25\n   |\n\
    14 |             if start == end {\n   |                         ^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptswq8nni.rs:18:24\n\
    \   |\n18 |             if start > end {\n   |                        ^^^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // TODO: Handle special cases\n    string.chars().count(substring.chars())\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpn52iugsu.rs:10:20\n    |\n10  |     string.chars().count(substring.chars())\n\
    \    |                    ^^^^^ ----------------- supplied 1 argument\n    | \
    \                   |\n    |                    expected 0 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpn52iugsu.rs:10:5\n   |\n8  | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n   |                                                   \
    \      ----- expected `isize` because of return type\n9  |     // TODO: Handle\
    \ special cases\n10 |     string.chars().count(substring.chars())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     string.chars().count(substring.chars()).try_into().unwrap()\n\
    \   |                                            ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|&(c1, c2)|\
    \ c1 == c2)\n        .count();\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfartpf1f.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| *substring == c)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpya8o25us.rs:9:20\n    |\n9   |     string.chars().count(|c| *substring\
    \ == c)\n    |                    ^^^^^ ------------------- supplied 1 argument\n\
    \    |                    |\n    |                    expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpya8o25us.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ *substring == c)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ *substring == c).try_into().unwrap()\n  |                                  \
    \            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   how_many_times_impl(string::as_str(string), substring::as_str(substring))\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \ --> /tmp/tmptxilpg8f.rs:9:25\n  |\n9 |     how_many_times_impl(string::as_str(string),\
    \ substring::as_str(substring))\n  |                         ^^^^^^ use of undeclared\
    \ crate or module `string`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `substring`\n --> /tmp/tmptxilpg8f.rs:9:49\n  |\n9 |     how_many_times_impl(string::as_str(string),\
    \ substring::as_str(substring))\n  |                                         \
    \        ^^^^^^^^^ use of undeclared crate or module `substring`\n\nerror[E0425]:\
    \ cannot find function `how_many_times_impl` in this scope\n --> /tmp/tmptxilpg8f.rs:9:5\n\
    \  |\n9 |     how_many_times_impl(string::as_str(string), substring::as_str(substring))\n\
    \  |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|&(_, s)|\
    \ s == Some(0))\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphg38o1yw.rs:11:32\n   |\n\
    11 |         .filter(|&(_, s)| s == Some(0))\n   |                           \
    \     ^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphg38o1yw.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.chars()\n10 | |         .zip(substring.chars())\n11 | |     \
    \    .filter(|&(_, s)| s == Some(0))\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut substring = substring;\n    let mut count = 0;\n    while let Some(pos)\
    \ = string.find(&mut substring) {\n        if pos < 0 || pos == string.len() {\n\
    \            count += 1;\n            substring.clear();\n        } else {\n \
    \           count += 1;\n            substring.push_str(&string[pos + 1..]);\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpctkms81i.rs:11:39\n     |\n11   |     while let Some(pos) = string.find(&mut\
    \ substring) {\n     |                                  ---- ^^^^^^^^^^^^^^ expected\
    \ an `FnMut<(char,)>` closure, found `String`\n     |                        \
    \          |\n     |                                  required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `FnMut<(char,)>` is not implemented\
    \ for `String`\n     = help: the following other types implement trait `Pattern<'a>`:\n\
    \               &'b String\n               &'b str\n               &'c &'b str\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&mut String`\n     = note: required because of the requirements on the\
    \ impl of `Pattern<'_>` for `&mut String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp6nbsyrfv.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp6nbsyrfv.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .iter()\n        .filter_map(|c| match c {\n            c\
    \ if c == substring => Some(1),\n            _ => None,\n        })\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp5wdxh9_x.rs:10:10\n   |\n10 |         .iter()\n   |   \
    \       ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n10 |         .chars()\n   |          ~~~~~\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut len = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n \
    \       let substring_len = substring.len();\n        while pos < string.len()\
    \ && len + substring_len <= string.len() {\n            if string[pos...pos +\
    \ substring_len] == substring {\n                pos += substring_len;\n     \
    \           len += substring_len;\n                break;\n            }\n   \
    \         pos += 1;\n        }\n        if pos == string.len() {\n           \
    \ break;\n        }\n    }\n    len\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmpz3l1913i.rs:14:26\n   |\n\
    14 |             if string[pos...pos + substring_len] == substring {\n   |   \
    \                       ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n\
    14 |             if string[pos..pos + substring_len] == substring {\n   |    \
    \                      ~~\nhelp: or `..=` for an inclusive range\n   |\n14 | \
    \            if string[pos..=pos + substring_len] == substring {\n   |       \
    \                   ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3l1913i.rs:25:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n25 |     len\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |     len.try_into().unwrap()\n   |  \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter_map(|c| {\n        if c.contains(&substring) {\n   \
    \         Some(c.len_after_eq(0))\n        } else {\n            None\n      \
    \  }\n    }).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpqqcbytu0.rs:10:14\n   |\n10 |         if c.contains(&substring)\
    \ {\n   |              ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no\
    \ method named `len_after_eq` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpqqcbytu0.rs:11:20\n   |\n11 |             Some(c.len_after_eq(0))\n\
    \   |                    ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqqcbytu0.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.chars().filter_map(|c| {\n10 | |         if c.contains(&substring)\
    \ {\n11 | |             Some(c.len_after_eq(0))\n12 | |         } else {\n13 |\
    \ |             None\n14 | |         }\n15 | |     }).count()\n   | |______________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut it = string.char_indices();\n\n    it.next();\
    \ // move on to the first character\n    while let Some(index) = it.next() {\n\
    \        if let Some(end) = string.find(substring, index) {\n            count\
    \ += end - index;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpurcupr01.rs:14:35\n     |\n14   |         if let Some(end) =\
    \ string.find(substring, index) {\n     |                                   ^^^^\
    \ ---------  ----- supplied 2 arguments\n     |                              \
    \     |\n     |                                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0277]: cannot subtract `(usize,\
    \ char)` from `usize`\n  --> /tmp/tmpurcupr01.rs:15:26\n   |\n15 |           \
    \  count += end - index;\n   |                          ^ no implementation for\
    \ `usize - (usize, char)`\n   |\n   = help: the trait `Sub<(usize, char)>` is\
    \ not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut positions = find_string_positions(string, substring);\n\n    let mut\
    \ count = 0;\n\n    while let Some(i) = positions.next() {\n        let pos =\
    \ i + 1;\n\n        let mut string2 = string.chars();\n\n        string2.position(pos,\
    \ positions.len()).unwrap();\n\n        let mut string1 = substring.chars();\n\
    \n        string1.position(pos, positions.len()).unwrap();\n\n        let start\
    \ = string1.clone();\n        let end = string2.clone();\n\n        if overlapping_cases(start,\
    \ end) {\n            count += 1;\n        }\n    }\n\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_string_positions` in this scope\n\
    \ --> /tmp/tmp9px7a4_j.rs:9:25\n  |\n9 |     let mut positions = find_string_positions(string,\
    \ substring);\n  |                         ^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `overlapping_cases` in this\
    \ scope\n  --> /tmp/tmp9px7a4_j.rs:27:12\n   |\n27 |         if overlapping_cases(start,\
    \ end) {\n   |            ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9px7a4_j.rs:18:17\n\
    \     |\n18   |         string2.position(pos, positions.len()).unwrap();\n   \
    \  |                 ^^^^^^^^ ---  --------------- supplied 2 arguments\n    \
    \ |                 |\n     |                 expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmp9px7a4_j.rs:22:17\n     |\n22\
    \   |         string1.position(pos, positions.len()).unwrap();\n     |       \
    \          ^^^^^^^^ ---  --------------- supplied 2 arguments\n     |        \
    \         |\n     |                 expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.find(substring).map(|s| string.find(substring, s).unwrap_or(string.len()))\n\
    \        .sum()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmplv3xx5i7.rs:9:17\n     |\n9    |     string.find(substring).map(|s|\
    \ string.find(substring, s).unwrap_or(string.len()))\n     |            ---- ^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |            |\n     |\
    \            required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n9    |     string.find(&substring).map(|s| string.find(substring,\
    \ s).unwrap_or(string.len()))\n     |                 +\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmplv3xx5i7.rs:9:43\n\
    \     |\n9    |     string.find(substring).map(|s| string.find(substring, s).unwrap_or(string.len()))\n\
    \     |                                           ^^^^ ---------  - supplied 2\
    \ arguments\n     |                                           |\n     |      \
    \                                     expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0599]: `Option<usize>` is not an iterator\n\
    \   --> /tmp/tmplv3xx5i7.rs:10:10\n    |\n10  |           .sum()\n    |      \
    \      ^^^ `Option<usize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<usize>: Iterator`\n  \
    \          which is required by `&mut Option<usize>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.ends_with(substring) {\n        return 1\n    }\n    if substring.ends_with(string)\
    \ {\n        return 2\n    }\n    if string.contains(substring) {\n        return\
    \ 3\n    }\n    return 0\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n -->\
    \ /tmp/tmp6dglkkwg.rs:9:25\n  |\n9 |     if string.ends_with(substring) {\n  |\
    \               --------- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \  |               |\n  |               required by a bound introduced by this\
    \ call\n  |\n  = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `String`\nhelp: consider borrowing here\n  |\n9 |     if string.ends_with(&substring)\
    \ {\n  |                         +\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n  --> /tmp/tmp6dglkkwg.rs:12:28\n   |\n12 |     if\
    \ substring.ends_with(string) {\n   |                  --------- ^^^^^^ expected\
    \ an implementor of trait `Pattern<'_>`\n   |                  |\n   |       \
    \           required by a bound introduced by this call\n   |\n   = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n   = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nhelp: consider\
    \ borrowing here\n   |\n12 |     if substring.ends_with(&string) {\n   |     \
    \                       +\n\nerror[E0277]: expected a `FnMut<(char,)>` closure,\
    \ found `String`\n    --> /tmp/tmp6dglkkwg.rs:15:24\n     |\n15   |     if string.contains(substring)\
    \ {\n     |               -------- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |               |\n     |               required by a bound\
    \ introduced by this call\n     |\n     = note: the trait bound `String: Pattern<'_>`\
    \ is not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n15   |     if string.contains(&substring)\
    \ {\n     |                        +\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0usize;\n    let mut start = string.find(substring);\n   \
    \ while start != String::npos {\n        count += 1;\n        start = string.find(substring,\
    \ start+1);\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpuxudruzm.rs:10:33\n     |\n10   |     let mut start = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n10   |     let mut start = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpuxudruzm.rs:11:28\n\
    \   |\n11 |     while start != String::npos {\n   |                          \
    \  ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpuxudruzm.rs:13:45\n   |\n\
    13 |         start = string.find(substring, start+1);\n   |                  \
    \                      -----^- {integer}\n   |                               \
    \         |\n   |                                        Option<usize>\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpuxudruzm.rs:13:24\n\
    \     |\n13   |         start = string.find(substring, start+1);\n     |     \
    \                   ^^^^ ---------  ------- supplied 2 arguments\n     |     \
    \                   |\n     |                        expected 1 argument\n   \
    \  |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuxudruzm.rs:15:5\n   |\n8  | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                 ----- expected `isize` because of return type\n...\n15 |   \
    \  count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and "
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count()\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpk5wr3yn0.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpk5wr3yn0.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |                           \
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0\n    for _ in string.find_iter(substring) {\n        counter\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpppdczy9z.rs:9:24\n\
    \   |\n9  |     let mut counter = 0\n   |                        ^ help: add `;`\
    \ here\n10 |     for _ in string.find_iter(substring) {\n   |     --- unexpected\
    \ token\n\nerror[E0599]: no method named `find_iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpppdczy9z.rs:10:21\n   |\n10 |     for _\
    \ in string.find_iter(substring) {\n   |                     ^^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars())\n        .filter(|(&a, &b)| a == b)\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9wriw3pn.rs:10:19\n   |\n\
    10 |         .filter(|(&a, &b)| a == b)\n   |                   ^^    - expected\
    \ due to this\n   |                   |\n   |                   expected `char`,\
    \ found reference\n   |                   help: you can probably remove the explicit\
    \ borrow: `a`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9wriw3pn.rs:10:23\n  \
    \ |\n10 |         .filter(|(&a, &b)| a == b)\n   |                       ^^- expected\
    \ due to this\n   |                       |\n   |                       expected\
    \ `char`, found reference\n   |                       help: you can probably remove\
    \ the explicit borrow: `b`\n   |\n   = note:   expected type `char`\n        \
    \   found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9wriw3pn.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars().zip(substring.chars())\n\
    10 | |         .filter(|(&a, &b)| a == b)\n11 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while string.chars().any(|&c|\
    \ c == substring[index]) {\n        if index == 0 {\n            index = 1;\n\
    \            continue;\n        }\n        index += 1;\n        count += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpccm8zqyb.rs:11:31\n   |\n\
    11 |     while string.chars().any(|&c| c == substring[index]) {\n   |        \
    \                       ^--\n   |                               ||\n   |     \
    \                          |expected due to this\n   |                       \
    \        expected `char`, found reference\n   |                              \
    \ help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpccm8zqyb.rs:11:40\n   |\n11 |     while string.chars().any(|&c|\
    \ c == substring[index]) {\n   |                                        ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .split_words(|s| s.contains(&substring))\n        .count();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_words` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpvqqvq_kl.rs:10:10\n   |\n10 |         .split_words(|s|\
    \ s.contains(&substring))\n   |          ^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_off`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpvqqvq_kl.rs:8:57\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |    --------------                                  \
    \     ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut substring_iter = string.char_indices().find(|&(_, index)| {\n    \
    \    index.into_iter().contains(&substring.chars().nth(substring.len()))\n   \
    \ });\n    substring_iter.next().map(|&(_, index)| index.to_usize()).sum()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmpb85z5pjb.rs:10:15\n\
    \   |\n10 |         index.into_iter().contains(&substring.chars().nth(substring.len()))\n\
    \   |               ^^^^^^^^^ `char` is not an iterator\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `char: Iterator`\n  \
    \         which is required by `char: IntoIterator`\n           `&char: Iterator`\n\
    \           which is required by `&char: IntoIterator`\n           `&mut char:\
    \ Iterator`\n           which is required by `&mut char: IntoIterator`\n\nerror[E0599]:\
    \ no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpb85z5pjb.rs:12:20\n\
    \   |\n12 |     substring_iter.next().map(|&(_, index)| index.to_usize()).sum()\n\
    \   |                    ^^^^ method not found in `Option<(usize, char)>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while count < string.chars().count()\
    \ && index != substring.chars().len() {\n        if string.chars()[index] == substring.chars()[index]\
    \ {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmppzdd2u4d.rs:11:72\n   |\n11 |     while count < string.chars().count()\
    \ && index != substring.chars().len() {\n   |                                \
    \                                        ^^^ method not found in `Chars<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmppzdd2u4d.rs:12:12\n\
    \   |\n12 |         if string.chars()[index] == substring.chars()[index] {\n \
    \  |            ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `Chars<'_>`\n  --> /tmp/tmppzdd2u4d.rs:12:37\n   |\n12 |         if\
    \ string.chars()[index] == substring.chars()[index] {\n   |                  \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppzdd2u4d.rs:17:5\n   |\n8  | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                 ----- expected `isize` because of return type\n...\n17 |   \
    \  count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + how_many_times_multi(string.chars(),\
    \ substring)\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `how_many_times_multi` in this scope\n\
    \ --> /tmp/tmppkeimezz.rs:9:57\n  |\n9 |     string.chars().filter(|c| c == substring).count()\
    \ + how_many_times_multi(string.chars(), substring)\n  |                     \
    \                                    ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppkeimezz.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + how_many_times_multi(string.chars(),\
    \ substring)\n  |                                 ^^ no implementation for `&char\
    \ == String`\n  |\n  = help: the trait `PartialEq<String>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppkeimezz.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| c == substring).count() + how_many_times_multi(string.chars(),\
    \ substring)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + how_many_times_multi(string.chars(), substring)).try_into().unwrap()\n\
    \  |     +                                                                   \
    \                                +++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n\n    for i in string.chars().skip_while(|&a| a != substring[0])\
    \ {\n        for j in string.chars().skip_while(|&b| b != substring[0]) {\n  \
    \          if i == j {\n                continue;\n            }\n           \
    \ for k in string.chars().skip_while(|&c| c != substring[0]) {\n             \
    \   if k == j {\n                    continue;\n                }\n          \
    \      if i != k && j != k && i != c && j != c {\n                    break;\n\
    \                }\n                cnt += 1;\n            }\n        }\n    }\n\
    \n    cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp27894j5d.rs:20:45\n\
    \   |\n20 |                 if i != k && j != k && i != c && j != c {\n   |  \
    \                                           ^ help: a local variable with a similar\
    \ name exists: `i`\n\nerror[E0425]: cannot find value `c` in this scope\n  -->\
    \ /tmp/tmp27894j5d.rs:20:55\n   |\n20 |                 if i != k && j != k &&\
    \ i != c && j != c {\n   |                                                   \
    \    ^ help: a local variable with a similar name exists: `i`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp27894j5d.rs:11:50\n\
    \   |\n11 |     for i in string.chars().skip_while(|&a| a != substring[0]) {\n\
    \   |                                                  ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp27894j5d.rs:12:54\n   |\n12 |         for j in string.chars().skip_while(|&b|\
    \ b != substring[0]) {\n   |                                                 \
    \     ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c != substring[0]).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpz6j_37kf.rs:9:36\n  |\n9 |     string.chars().filter(|c| c != substring[0]).count()\
    \ as isize\n  |                                    ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| *c == substring).count()\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaa2_tdp7.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == substring).count()\n  |                \
    \                     ^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpaa2_tdp7.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ *c == substring).count().try_into().unwrap()\n  |                          \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for (c0, c1) in string.chars().zip(substring.chars())\
    \ {\n        count += c0.cmp(&c1);\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `std::cmp::Ordering` to `{integer}`\n \
    \ --> /tmp/tmp49e77p6n.rs:11:15\n   |\n11 |         count += c0.cmp(&c1);\n  \
    \ |               ^^ no implementation for `{integer} += std::cmp::Ordering`\n\
    \   |\n   = help: the trait `AddAssign<std::cmp::Ordering>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .chars()\n        .filter(|c| c.contains(substring))\n   \
    \     .count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp4a02bk1x.rs:11:23\n   |\n11 |         .filter(|c|\
    \ c.contains(substring))\n   |                       ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4a02bk1x.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string\n10 | |         .chars()\n\
    11 | |         .filter(|c| c.contains(substring))\n12 | |         .count() + 1\n\
    \   | |____________________^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n9  ~     (string\n10 |         .chars()\n11 |         .filter(|c|\
    \ c.contains(substring))\n12 ~         .count() + 1).try_into().unwrap()\n   |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Step 1: Build auxiliary data structures representing the set of possible\
    \ substrings and their lengths.\n    // If there is at least one prefix and no\
    \ suffix of the substring, we only need to consider suffixes\n    let mut suffixes\
    \ = vec![];\n    let mut prefixes = vec![];\n    for &s in &substring {\n    \
    \    if string.starts_with(s) {\n            prefixes.push(s);\n        } else\
    \ {\n            suffixes.push(s);\n        }\n    }\n    // Step 2: Iterate over\
    \ the substrings to find the number of occurrences.\n    let mut count = 0;\n\
    \    for suffix in suffixes {\n        for &prefix in prefixes {\n           \
    \ if string.starts_with(prefix) && string.ends_with(suffix) {\n              \
    \  count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmprlaemhpv.rs:13:15\n\
    \   |\n13 |     for &s in &substring {\n   |               ^^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(substring.chars())\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpuf7r___9.rs:9:20\n    |\n9   |     string.chars().count(substring.chars())\n\
    \    |                    ^^^^^ ----------------- supplied 1 argument\n    | \
    \                   |\n    |                    expected 0 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpuf7r___9.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(substring.chars())\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n9 |     string.chars().count(substring.chars()).try_into().unwrap()\n\
    \  |                                            ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n\n    for pos in string.find(&substring) {\n        if\
    \ pos == String::npos {\n            break;\n        }\n\n        count += 1;\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n \
    \   assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp20lrlpta.rs:12:27\n   |\n12 | \
    \        if pos == String::npos {\n   |                           ^^^^ function\
    \ or associated item not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(_, s)| s == String::new()).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp3juj32c8.rs:9:61\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|(_, s)| s == String::new()).count()\n\
    \  |                                                             ^^ no implementation\
    \ for `&char == String`\n  |\n  = help: the trait `PartialEq<String>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp3juj32c8.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().zip(substring.chars()).filter(|(_, s)| s == String::new()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(_,\
    \ s)| s == String::new()).count().try_into().unwrap()\n  |                   \
    \                                                                   ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for start in string.char_indices() {\n        let\
    \ end = start.clone();\n        let len = string.len();\n        if start >= substring.len()\
    \ {\n            continue;\n        }\n\n        if end+1 < len {\n          \
    \  if string.chars().position(|&c| c == substring[start..end+1])\n           \
    \     > substring.chars().position(|&c| c == substring[start..end+2])\n      \
    \      {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_zrrszo.rs:13:21\n   |\n\
    13 |         if start >= substring.len() {\n   |                     ^^^^^^^^^^^^^^^\
    \ expected tuple, found `usize`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \               found type `usize`\n\nerror[E0369]: cannot add `{integer}` to\
    \ `(usize, char)`\n  --> /tmp/tmph_zrrszo.rs:17:15\n   |\n17 |         if end+1\
    \ < len {\n   |            ---^- {integer}\n   |            |\n   |          \
    \  (usize, char)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph_zrrszo.rs:18:41\n\
    \   |\n18 |             if string.chars().position(|&c| c == substring[start..end+1])\n\
    \   |                                         ^--\n   |                      \
    \                   ||\n   |                                         |expected\
    \ due to this\n   |                                         expected `char`, found\
    \ reference\n   |                                         help: did you mean `c`:\
    \ `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0369]: cannot add `{integer}` to `(usize, char)`\n  --> /tmp/tmph_zrrszo.rs:18:70\n\
    \   |\n18 |             if string.chars().position(|&c| c == substring[start..end+1])\n\
    \   |                                                                   ---^-\
    \ {integer}\n   |                                                            \
    \       |\n   |                                                              \
    \     (usize, char)\n\nerror[E0277]: the type `String` cannot be indexed by `std::ops::Range<(usize,\
    \ char)>`\n  --> /tmp/tmph_zrrszo.rs:18:50\n   |\n18 |             if string.chars().position(|&c|\
    \ c == substring[start..end+1])\n   |                                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `std::ops::Range<(usize,\
    \ char)>`\n   |\n   = help: the trait `Index<std::ops::Range<(usize, char)>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as I"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    for c in string.chars() {\n        if c.is_ascii() {\n\
    \            if substring.chars().any(|c| c == c) {\n                i += 1;\n\
    \            }\n        } else {\n            if substring.contains(&c) {\n  \
    \              i += 1;\n            }\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp_mdyo2qd.rs:16:35\n\
    \     |\n16   |             if substring.contains(&c) {\n     |              \
    \            -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n   \
    \  |                          |\n     |                          required by a\
    \ bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing\
    \ here\n     |\n16   |             if substring.contains(*&c) {\n     |      \
    \                             +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 1;\n    for pos in string.find(substring) {\n        if pos\
    \ == String::npos {\n            count += 1;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpkctl47n8.rs:10:28\n     |\n10   |     for pos in string.find(substring)\
    \ {\n     |                       ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                       |\n     |                      \
    \ required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing here\n\
    \     |\n10   |     for pos in string.find(&substring) {\n     |             \
    \               +\n\nerror[E0599]: no function or associated item named `npos`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpkctl47n8.rs:11:27\n\
    \   |\n11 |         if pos == String::npos {\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    for pos in string.find(substring) {\n        if\
    \ pos == 0 {\n            counter = 1;\n        } else {\n            counter\
    \ += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpwhy70ffj.rs:10:28\n     |\n10   |     for pos in string.find(substring)\
    \ {\n     |                       ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                       |\n     |                      \
    \ required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing here\n\
    \     |\n10   |     for pos in string.find(&substring) {\n     |             \
    \               +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn9_ebv8y.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 1;\n    let mut i = 0;\n    while i < string.len() && i <\
    \ substring.len() {\n        if string[i] == substring[i] {\n            count\
    \ += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwmkrni9s.rs:12:12\n\
    \   |\n12 |         if string[i] == substring[i] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwmkrni9s.rs:12:25\n   |\n12 |         if string[i] == substring[i]\
    \ {\n   |                         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut pos = 0;\n    let mut counter = 0;\n    while let Some(po) = string.find(substring,\
    \ pos) {\n        counter += 1;\n        pos += 1;\n    }\n    counter\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpl_ozub5r.rs:11:33\n     |\n11   |     while let Some(po) = string.find(substring,\
    \ pos) {\n     |                                 ^^^^ ---------  --- supplied\
    \ 2 arguments\n     |                                 |\n     |              \
    \                   expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.find(substring).unwrap_or(0)\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpdbcshhw6.rs:9:17\n     |\n9    |     string.find(substring).unwrap_or(0)\n\
    \     |            ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |            |\n     |            required by a bound introduced by this\
    \ call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n9    |     string.find(&substring).unwrap_or(0)\n\
    \     |                 +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdbcshhw6.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.find(substring).unwrap_or(0)\n  |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n  |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n  |\n9 |     string.find(substring).unwrap_or(0).try_into().unwrap()\n\
    \  |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c.contains(&substring)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp4cssh_s0.rs:9:33\n  |\n9 |     string.chars().filter(|c|\
    \ c.contains(&substring)).count()\n  |                                 ^^^^^^^^\
    \ method not found in `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4cssh_s0.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| c.contains(&substring)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| c.contains(&substring)).count().try_into().unwrap()\n\
    \  |                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter_map(|c| {\n        Some(substring)\n            .chars()\n\
    \            .filter_map(|c| {\n                if c == c {\n                \
    \    Some(c)\n                } else {\n                    None\n           \
    \     }\n            })\n            .count()\n            .unwrap_or(0)\n   \
    \ })\n    .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp171_182r.rs:11:14\n   |\n11 |             .chars()\n  \
    \ |              ^^^^^ method not found in `Option<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp171_182r.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.chars().filter_map(|c| {\n10 | |         Some(substring)\n11\
    \ | |             .chars()\n12 | |             .filter_map(|c| {\n...  |\n21 |\
    \ |     })\n22 | |     .count()\n   | |____________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |     .count().try_into().unwrap()\n   |       \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.find_iter(&substring).count()\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_iter` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpetqdr32v.rs:9:12\n  |\n9 |     string.find_iter(&substring).count()\n\
    \  |            ^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // TODO: optimize\n    let mut counter = 0;\n    string.chars()\n        .zip(substring.chars())\n\
    \        .for_each(|(char1, char2)| {\n            if char1 == char2 {\n     \
    \           counter = counter + 1;\n            }\n        });\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpr0mv57b_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| c == substring)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp08e0m3s4.rs:9:20\n    |\n9   |     string.chars().count(|c| c\
    \ == substring)\n    |                    ^^^^^ ------------------ supplied 1\
    \ argument\n    |                    |\n    |                    expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp08e0m3s4.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ c == substring)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c| c\
    \ == substring).try_into().unwrap()\n  |                                     \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| *c == *substring).count()\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4om5w17o.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == *substring).count()\n  |               \
    \                      ^^^^^^^^^^ expected `char`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp4om5w17o.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == *substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ *c == *substring).count().try_into().unwrap()\n  |                         \
    \                               ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    while start < string.len()\
    \ {\n        let end = string.find(substring, start);\n        if end == Option::None.or(start\
    \ == end) {\n            break;\n        }\n        let s = string.to_string();\n\
    \        count += end - start;\n        start = end;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmppuetdj14.rs:12:26\n     |\n12   |         let end = string.find(substring,\
    \ start);\n     |                          ^^^^ ---------  ----- supplied 2 arguments\n\
    \     |                          |\n     |                          expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppuetdj14.rs:13:44\n   |\n13 |         if end == Option::None.or(start\
    \ == end) {\n   |                                            ^^^ expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppuetdj14.rs:13:35\n\
    \   |\n13 |         if end == Option::None.or(start == end) {\n   |          \
    \                         ^^^^^^^^^^^^ expected enum `Option`, found `bool`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `bool`\n\
    \nerror[E0369]: cannot subtract `usize` from `Option<usize>`\n  --> /tmp/tmppuetdj14.rs:17:22\n\
    \   |\n17 |         count += end - start;\n   |                  --- ^ ----- usize\n\
    \   |                  |\n   |                  Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppuetdj14.rs:18:17\n   |\n10 |     let mut start\
    \ = 0;\n   |                     - expected due to this value\n...\n18 |     \
    \    start = end;\n   |                 ^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   substring\n        .chars()\n        .filter_map(|c| {\n            if let\
    \ Some(c) = string.find(&c) {\n                Some(c)\n            } else {\n\
    \                None\n            }\n        })\n        .count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp29v0l4w3.rs:12:42\n\
    \     |\n12   |             if let Some(c) = string.find(&c) {\n     |       \
    \                              ---- ^^ expected an `Fn<(char,)>` closure, found\
    \ `char`\n     |                                     |\n     |               \
    \                      required by a bound introduced by this call\n     |\n \
    \    = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider dereferencing here\n     |\n12   |             if let Some(c) = string.find(*&c)\
    \ {\n     |                                          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp29v0l4w3.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     substring\n10 | |         .chars()\n11 | |         .filter_map(|c| {\n\
    12 | |             if let Some(c) = string.find(&c) {\n...  |\n17 | |        \
    \ })\n18 | |         .count()\n   | |________________^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(_, substring)|\
    \ substring == 0)\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `{integer}`\n  --> /tmp/tmpecjlv_w6.rs:11:44\n\
    \   |\n11 |         .filter(|(_, substring)| substring == 0)\n   |           \
    \                                 ^^ no implementation for `&char == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpecjlv_w6.rs:11:47\n   |\n11 |         .filter(|(_, substring)|\
    \ substring == 0)\n   |                                               ^ expected\
    \ `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpecjlv_w6.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(_, substring)| substring == 0)\n12 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n12 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    string.char_indices().filter_map(|(_i, c)| c.contains(&substring)).for_each(|(_i,\
    \ _)| {\n        count += 1;\n    });\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsjf92jj2.rs:10:50\n   |\n10 |     string.char_indices().filter_map(|(_i,\
    \ c)| c.contains(&substring)).for_each(|(_i, _)| {\n   |                     \
    \                             ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices()\n        .filter(|i| i.start == string.find(substring,\
    \ i.start))\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `start` on type `&(usize, char)`\n  --> /tmp/tmpjuljeri4.rs:10:23\n\
    \   |\n10 |         .filter(|i| i.start == string.find(substring, i.start))\n\
    \   |                       ^^^^^\n\nerror[E0609]: no field `start` on type `&(usize,\
    \ char)`\n  --> /tmp/tmpjuljeri4.rs:10:57\n   |\n10 |         .filter(|i| i.start\
    \ == string.find(substring, i.start))\n   |                                  \
    \                       ^^^^^\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpjuljeri4.rs:10:39\n     |\n10\
    \   |         .filter(|i| i.start == string.find(substring, i.start))\n     |\
    \                                       ^^^^ ---------  ------- supplied 2 arguments\n\
    \     |                                       |\n     |                      \
    \                 expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjuljeri4.rs:9:5\n   |\n\
    8  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.char_indices()\n10 | |         .filter(|i|\
    \ i.start == string.find(substring, i.start))\n11 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0609.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count() + 1\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp5q047fvm.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count() +\
    \ 1\n     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count() + 1\n     |                                \
    \                  +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5q047fvm.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\
    \ + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ substring.contains(c)).count() + 1).try_into().unwrap()\n  |     +         \
    \                                                   +++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut sub = String::from(substring);\n    let mut string_to_search = String::from(string);\n\
    \n    for _ in 0..(string.len() - sub.length()) {\n        if sub == string_to_search\
    \ {\n            return string.chars().count(|c| c == sub);\n        }\n\n   \
    \     match string_to_search.chars().find(sub) {\n            Some(i) => {\n \
    \               string_to_search.replace(i, i + sub.length(), \"\");\n       \
    \     }\n            None => (),\n        }\n    }\n    0\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5rdfbhe_.rs:12:37\n   |\n12 |     for _ in 0..(string.len()\
    \ - sub.length()) {\n   |                                     ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp5rdfbhe_.rs:14:35\n\
    \    |\n14  |             return string.chars().count(|c| c == sub);\n    |  \
    \                                 ^^^^^ ------------ supplied 1 argument\n   \
    \ |                                   |\n    |                               \
    \    expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5rdfbhe_.rs:14:20\n   |\n14 |             return\
    \ string.chars().count(|c| c == sub);\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |           \
    \  return string.chars().count(|c| c == sub).try_into().unwrap();\n   |      \
    \                                                ++++++++++++++++++++\n\nerror[E0277]:\
    \ expected a `FnMut<(&char,)>` closure, found `String`\n    --> /tmp/tmp5rdfbhe_.rs:17:45\n\
    \     |\n17   |         match string_to_search.chars().find(sub) {\n     |   \
    \                                     ---- ^^^ expected an `FnMut<(&char,)>` closure,\
    \ found `String`\n     |                                        |\n     |    \
    \                                    required by a bound introduced by this call\n\
    \     |\n     = help: the trait `for<'r> FnMut<(&'r char,)>` is not implemented\
    \ for `String`\nnote: required by a bound in `find`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmp5rdfbhe_.rs:19:53\n\
    \   |\n19 |                 string_to_search.replace(i, i + sub.length(), \"\"\
    );\n   |                                                     ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E006"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut substring_end = substring.len();\n    let mut string_end = string.len();\n\
    \    let mut count = 0;\n    while string_end > 0 && substring_end > 0 {\n   \
    \     if string[string_end - 1] == substring[substring_end - 1] {\n          \
    \  count += 1;\n            string_end -= 1;\n            substring_end -= 1;\n\
    \        } else if string_end > 0 {\n            string_end -= 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp56giw960.rs:13:12\n\
    \   |\n13 |         if string[string_end - 1] == substring[substring_end - 1]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp56giw960.rs:13:38\n   |\n13 |         if string[string_end - 1]\
    \ == substring[substring_end - 1] {\n   |                                    \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(a,b)| a\
    \ == b)\n        .count();\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp68p73tqv.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpllid46h6.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpllid46h6.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Count overlapping cases\n    let mut count = 0;\n    let mut start = 0;\n\
    \    let mut len = string.len();\n    while start < len {\n        if string.find(substring,\
    \ start) != start {\n            break;\n        }\n        start += 1;\n    \
    \    count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp3dylkc3u.rs:14:19\n     |\n14   |         if string.find(substring,\
    \ start) != start {\n     |                   ^^^^ ---------  ----- supplied 2\
    \ arguments\n     |                   |\n     |                   expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3dylkc3u.rs:14:45\n   |\n14 |         if string.find(substring,\
    \ start) != start {\n   |                                             ^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |         if string.find(substring, start) != Some(start) {\n   |  \
    \                                           +++++     +\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(&_, _),\
    \ (&_, _)| true)\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 1 argument, but it takes 2 arguments\n\
    \  --> /tmp/tmpr9i3gr1q.rs:11:10\n   |\n11 |         .filter(|(&_, _), (&_, _)|\
    \ true)\n   |          ^^^^^^ ------------------ takes 2 arguments\n   |     \
    \     |\n   |          expected closure that takes 1 argument\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr9i3gr1q.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.chars()\n10 | |         .zip(substring.chars())\n11 | |     \
    \    .filter(|(&_, _), (&_, _)| true)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0593.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut iter = string.char_indices();\n    iter.for_each(|(index,\
    \ c)| {\n        if c.eq_ignore_ascii_case(substring[0]) {\n            count\
    \ += 1;\n            iter.by_ref().for_each(|(_, c)| {\n                if !c.eq_ignore_ascii_case(substring[1])\
    \ {\n                    count += 1;\n                    iter.by_ref().for_each(|(_,\
    \ c)| {\n                        if !c.eq_ignore_ascii_case(substring[2]) {\n\
    \                            count += 1;\n                            iter.by_ref().for_each(|(_,\
    \ c)| {\n                                if !c.eq_ignore_ascii_case(substring[3])\
    \ {\n                                    count += 1;\n                       \
    \             iter.by_ref().for_each(|(_, c)| {\n                            \
    \            if !c.eq_ignore_ascii_case(substring[4]) {\n                    \
    \                        count += 1;\n                                       \
    \     iter.by_ref().for_each(|(_, c)| {\n                                    \
    \            if !c.eq_ignore_ascii_case(substring[5]) {\n                    \
    \                                count += 1;\n                               \
    \                     iter.by_ref().for_each(|(_, c)| {\n                    \
    \                                    if !c.eq_ignore_ascii_case(substring[6])\
    \ {\n                                                            count += 1;\n\
    \                                                            iter.by_ref().for_each(|(_,\
    \ c)| {\n                                                                if !c.eq_ignore_ascii_case(substring[7])\
    \ {\n                                                                    count\
    \ += 1;\n                                                                    iter.by_ref().for_each(|(_,\
    \ c)| {\n                                                                    \
    \    if !c.eq_ignore_ascii_case(substring[8]) {\n                            \
    \                                                count += 1;\n               \
    \                                                             iter.by_ref().for_each(|(_,\
    \ c)| {\n                                                                    \
    \            if !c.eq_ignore_ascii_case(substring[9]) {\n                    \
    \                                                                count += 1;\n\
    \                                                                            \
    \        iter.by_ref().for_each(|(_, c)| {\n                                 \
    \                                                       if !c.eq_ignore_ascii_case(substring[10])\
    \ {\n                                                                        \
    \                    count += 1;\n                                           \
    \                                                 iter.by_ref().for_each(|(_,\
    \ c)| {\n                                                                    \
    \                            if !c.eq_ignore_ascii_case(substring[11]) {\n   \
    \                                                                            \
    \                     count += 1;\n                                          \
    \                                                      }\n                   \
    \                                                                         });\n\
    \                                                                            \
    \            }\n                                                             \
    \                       });\n                                                \
    \                                }\n                                         \
    \                                   });\n                                    \
    \                                    }\n                                     \
    \                               });\n                                        \
    \                        }\n                                                 \
    \           });\n                                                        }\n \
    \                                                   });\n                    \
    \                            }\n                                            });\n\
    \                                        }\n                                 \
    \   });\n                                }\n                            });\n\
    \                        }\n                    });\n                }\n     \
    \       });\n        }\n    });\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp3utmwaq6.rs:12:35\n   |\n12 |         if c.eq_ignore_ascii_case(substring[0])\
    \ {\n   |                                   ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3utmwaq6.rs:15:44\n   |\n15 |                 if !c.eq_ignore_ascii_case(substring[1])\
    \ {\n   |                                            ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3utmwaq6.rs:18:52\n   |\n18 |                         if !c.eq_ignore_ascii_case(substring[2])\
    \ {\n   |                                                    ^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    let mut current_index = 0;\n    for current_char in string.chars()\
    \ {\n        if current_index != 0 {\n            i += 1;\n        }\n       \
    \ if current_char == substring.as_bytes()[current_index] {\n            current_index\
    \ += 1\n        } else {\n            current_index = 0\n        }\n    }\n  \
    \  i\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp071qtrh6.rs:15:28\n   |\n\
    15 |         if current_char == substring.as_bytes()[current_index] {\n   |  \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `u8`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(i, j)| i != j).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaojhuqc5.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(i, j)|\
    \ i != j).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(i,\
    \ j)| i != j).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a.0 == b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&char`\n --> /tmp/tmp2zoyvi4p.rs:9:61\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)| a.0 == b).count()\n\
    \  |                                                             ^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp2zoyvi4p.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a.0 == b).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a.0 == b).count().try_into().unwrap()\n  |                             \
    \                                               ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| substring.contains(c))\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpedzjh38i.rs:9:20\n    |\n9   |     string.chars().count(|c| substring.contains(c))\n\
    \    |                    ^^^^^ ------------------------- supplied 1 argument\n\
    \    |                    |\n    |                    expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpedzjh38i.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ substring.contains(c))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ substring.contains(c)).try_into().unwrap()\n  |                            \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.count(substring)\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmplf00bken.rs:9:12\n\
    \    |\n9   |       string.count(substring)\n    |              ^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0\n    for c in string.chars() {\n        if substring.contains(c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp2fzho0mq.rs:9:22\n\
    \   |\n9  |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    10 |     for c in string.chars() {\n   |     --- unexpected token\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut pos = 0;\n    let mut count = 0;\n    while pos < string.len() {\n\
    \        let sub_pos = string.find(substring, pos);\n        if sub_pos == String::npos\
    \ {\n            break;\n        }\n        if sub_pos > pos {\n            count\
    \ += 1;\n            pos += sub_pos + 1;\n        }\n        pos += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpgdmzxov4.rs:12:30\n     |\n12   |         let sub_pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgdmzxov4.rs:13:31\n   |\n13 |         if sub_pos\
    \ == String::npos {\n   |                               ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgdmzxov4.rs:16:22\n\
    \   |\n16 |         if sub_pos > pos {\n   |                      ^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |         if sub_pos > Some(pos) {\n   |                      +++++\
    \   +\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpgdmzxov4.rs:18:28\n\
    \   |\n18 |             pos += sub_pos + 1;\n   |                    ------- ^\
    \ - {integer}\n   |                    |\n   |                    Option<usize>\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(&x, &y)| x.cmp(y) == 0).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp821gpxt8.rs:9:52\n  |\n9 |\
    \     string.chars().zip(substring.chars()).filter(|(&x, &y)| x.cmp(y) == 0).count()\n\
    \  |                                                    ^^    - expected due to\
    \ this\n  |                                                    |\n  |        \
    \                                            expected `char`, found reference\n\
    \  |                                                    help: you can probably\
    \ remove the explicit borrow: `x`\n  |\n  = note:   expected type `char`\n   \
    \       found reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp821gpxt8.rs:9:56\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|(&x, &y)| x.cmp(y)\
    \ == 0).count()\n  |                                                        ^^-\
    \ expected due to this\n  |                                                  \
    \      |\n  |                                                        expected\
    \ `char`, found reference\n  |                                               \
    \         help: you can probably remove the explicit borrow: `y`\n  |\n  = note:\
    \   expected type `char`\n          found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp821gpxt8.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().zip(substring.chars()).filter(|(&x,\
    \ &y)| x.cmp(y) == 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(&x,\
    \ &y)| x.cmp(y) == 0).count().try_into().unwrap()\n  |                       \
    \                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for char in string.chars() {\n        if char == substring.chars()\
    \ {\n            count += 1;\n        }\n        if char == substring.chars().nth(string.len())\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplf6vfqn4.rs:11:20\n   |\n\
    11 |         if char == substring.chars() {\n   |                    ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `Chars`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplf6vfqn4.rs:14:20\n   |\n14 |         if char == substring.chars().nth(string.len())\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<char>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = 0;\n    loop {\n        let mut index = string.find(substring,\
    \ index).unwrap();\n        if index == string.len() {\n            break;\n \
    \       }\n\n        index += 1;\n        if index > string.len() {\n        \
    \    break;\n        }\n    }\n    return index;\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpn7d3hh1s.rs:11:32\n     |\n11   |         let mut index = string.find(substring,\
    \ index).unwrap();\n     |                                ^^^^ ---------  -----\
    \ supplied 2 arguments\n     |                                |\n     |      \
    \                          expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| *a == *b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp5rzne_61.rs:9:60\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)| *a == *b).count()\n\
    \  |                                                            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmp5rzne_61.rs:9:66\n  |\n9 |\
    \     string.chars().zip(substring.chars()).filter(|&(a, b)| *a == *b).count()\n\
    \  |                                                                  ^^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5rzne_61.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| *a == *b).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| *a == *b).count().try_into().unwrap()\n  |                             \
    \                                                ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut char_count: HashSet<char> = HashSet::new();\n    let mut char_array\
    \ = string\n        .char_indices()\n        .filter_map(|(char_idx, _)| char_idx.is_not_found())\n\
    \        .collect();\n\n    let mut char_array_iterator = char_array.iter().cloned();\n\
    \    let mut current_pos = 0;\n    let mut current_char = char_array_iterator.next().unwrap().unwrap();\n\
    \n    while char_array_iterator.any(|(_, next_char)| {\n        if next_char ==\
    \ current_char {\n            char_count\n                .entry(current_char)\n\
    \                .or_insert(0)\n                += 1;\n            current_pos\
    \ = char_idx + 1;\n            current_char = char_array_iterator.next().unwrap().unwrap();\n\
    \            char_count\n                .entry(current_char)\n              \
    \  .or_insert(0)\n                += 1;\n        } else if next_char != current_char\
    \ {\n            char_count.remove(&current_char);\n            current_pos =\
    \ char_idx + 1;\n            current_char = char_array_iterator.next().unwrap().unwrap();\n\
    \            char_count\n                .entry(current_char)\n              \
    \  .or_insert(0)\n                += 1;\n        }\n        true\n    }) {\n \
    \       char_count.remove(&current_char);\n        current_pos = 0;\n        current_char\
    \ = char_array_iterator.next().unwrap().unwrap();\n    }\n\n    char_count.iter().filter(|(current,\
    \ _)| current == 0).count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpppe5ccr8.rs:9:25\n\
    \  |\n9 |     let mut char_count: HashSet<char> = HashSet::new();\n  |       \
    \                  ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpppe5ccr8.rs:9:41\n\
    \  |\n9 |     let mut char_count: HashSet<char> = HashSet::new();\n  |       \
    \                                  ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0425]: cannot find value `char_idx` in this scope\n  --> /tmp/tmpppe5ccr8.rs:25:27\n\
    \   |\n25 |             current_pos = char_idx + 1;\n   |                    \
    \       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `char_idx`\
    \ in this scope\n  --> /tmp/tmpppe5ccr8.rs:33:27\n   |\n33 |             current_pos\
    \ = char_idx + 1;\n   |                           ^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `is_not_found` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpppe5ccr8.rs:12:46\n   |\n12 |         .filter_map(|(char_idx,\
    \ _)| char_idx.is_not_found())\n   |                                         \
    \     ^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpppe5ccr8.rs:24:17\n   |\n21 | /          \
    \   char_count\n22 | |                 .entry(current_char)\n23 | |          \
    \       .or_insert(0)\n   | |_____________________________- cannot assign to this\
    \ expression\n24 |                   += 1;\n   |                   ^^\n   |\n\
    help: you might have meant to use pattern destructuring\n   |\n19 |     while\
    \ let char_array_iterator.any(|(_, next_char)| {\n   |           +++\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpppe5ccr8.rs:30:17\n   |\n\
    27 | /             char_count\n28 | |                 .entry(current_char)\n29\
    \ | |                 .or_insert(0)\n   | |_____________________________- cannot\
    \ assign to this expression\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 1; // to prevent the first substring from being counted twice\n\
    \    let mut index_of_first_char = 0;\n    for i = 1; i < string.len(); i++) {\n\
    \        let next_char = string.chars().nth(i).unwrap();\n        if next_char\
    \ == substring.chars().nth(i - 1).unwrap() {\n            count += 1;\n      \
    \  }\n        else {\n            count += 2;\n        }\n        index_of_first_char\
    \ = i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpbehof0y0.rs:22:1\n\
    \   |\n11 |     for i = 1; i < string.len(); i++) {\n   |                    \
    \                   - this opening brace...\n...\n20 |     }\n   |     - ...matches\
    \ this closing brace\n21 |     count\n22 | }\n   | ^ unexpected closing delimiter\n\
    \nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpbehof0y0.rs:8:63\n \
    \  |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n \
    \  |                                                               ^ unclosed\
    \ delimiter\n...\n11 |     for i = 1; i < string.len(); i++) {\n   |         \
    \                            ^ mismatched closing delimiter\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.find_prefix(substring).len()\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_prefix` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpkp_7rshm.rs:9:12\n  |\n9 |     string.find_prefix(substring).len()\n\
    \  |            ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(ref c, ref s)| c == s).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp1qenit59.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|c| c.0.contains(&c.1)).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmp7w32nyp9.rs:9:58\n  |\n9 |     string.chars().zip(substring.chars()).filter(|c|\
    \ c.0.contains(&c.1)).count() as isize\n  |                                  \
    \                        ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    for pos in string.char_indices().rev() {\n     \
    \   if string[pos.1 - 1].contains(substring) {\n            counter += 1;\n  \
    \      }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpz83s6ur7.rs:11:25\n\
    \   |\n11 |         if string[pos.1 - 1].contains(substring) {\n   |         \
    \          ----- ^ - {integer}\n   |                   |\n   |               \
    \    char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.count_overlaping(substring).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `count_overlaping` found for struct `String`\
    \ in the current scope\n --> /tmp/tmp3uqx2c41.rs:9:12\n  |\n9 |     string.count_overlaping(substring).unwrap()\n\
    \  |            ^^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `contains`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .chars()\n        .filter(|c| c.contains(substring))\n   \
    \     .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp4b8_igmg.rs:11:23\n   |\n11 |         .filter(|c|\
    \ c.contains(substring))\n   |                       ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4b8_igmg.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string\n10 | |         .chars()\n\
    11 | |         .filter(|c| c.contains(substring))\n12 | |         .count()\n \
    \  | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    12 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut it = string.char_indices();\n    for _ in 0..(substring.len()\
    \ - string.len()) {\n        if let Some(pos) = it.next() {\n            if pos\
    \ == (substring.len() - string.len()) {\n                count++;\n          \
    \  } else {\n                count = count;\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_y4r50ld.rs:17:22\n\
    \   |\n17 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n17 -                 count++;\n17 +                 count\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_y4r50ld.rs:16:23\n\
    \   |\n16 |             if pos == (substring.len() - string.len()) {\n   |   \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found `usize`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found type `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut s = string.chars();\n    let mut sub = substring.chars();\n\
    \    while let Some(Ok(s)) = s.next() {\n        let sub = sub.next();\n     \
    \   if sub.is_some() && !sub.as_ref().unwrap().starts_with(s) {\n            counter\
    \ += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp1twpxd9.rs:12:20\n   |\n\
    12 |     while let Some(Ok(s)) = s.next() {\n   |                    ^^^^^   \
    \ -------- this expression has type `Option<char>`\n   |                    |\n\
    \   |                    expected `char`, found enum `Result`\n   |\n   = note:\
    \ expected type `char`\n              found enum `Result<_, _>`\n\nerror[E0599]:\
    \ no method named `starts_with` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmpp1twpxd9.rs:14:52\n   |\n14 |         if sub.is_some() && !sub.as_ref().unwrap().starts_with(s)\
    \ {\n   |                                                    ^^^^^^^^^^^ method\
    \ not found in `&char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    let mut len = string.len();\n    let mut i = -1;\n \
    \   while len > 0 && cnt < substring.length() {\n        i += 1;\n        cnt\
    \ = 0;\n        while len > 0 && i < len {\n            let c = string[i];\n \
    \           if c != substring[cnt] {\n                break;\n            }\n\
    \            i += 1;\n            cnt += 1;\n        }\n    }\n    i\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmptj4vcohc.rs:12:38\n   |\n12 |     while len > 0\
    \ && cnt < substring.length() {\n   |                                      ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptj4vcohc.rs:11:17\n\
    \   |\n11 |     let mut i = -1;\n   |                 ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmptj4vcohc.rs:16:21\n   |\n16 |         \
    \    let c = string[i];\n   |                     ^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmptj4vcohc.rs:17:21\n   |\n17 |             if c != substring[cnt]\
    \ {\n   |                     ^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Inde"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .split_whitespace()\n        .filter_map(|s| s.chars().filter_map(|c|\
    \ *c.contains(&substring).unwrap_or(false)).count() as usize)\n        .sum()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp89uac8kn.rs:11:53\n   |\n11 |         .filter_map(|s| s.chars().filter_map(|c|\
    \ *c.contains(&substring).unwrap_or(false)).count() as usize)\n   |          \
    \                                           ^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp89uac8kn.rs:11:25\n   |\n11 |\
    \         .filter_map(|s| s.chars().filter_map(|c| *c.contains(&substring).unwrap_or(false)).count()\
    \ as usize)\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n11 |         .filter_map(|s| Some(s.chars().filter_map(|c| *c.contains(&substring).unwrap_or(false)).count()\
    \ as usize))\n   |                         +++++                             \
    \                                                      +\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c.contains(&substring))\n        .filter(|c| c.contains(&substring[..1]))\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmpdccgd_4m.rs:9:33\n  |\n9 |     string.chars().filter(|c|\
    \ c.contains(&substring))\n  |                                 ^^^^^^^^ method\
    \ not found in `&char`\n\nerror[E0599]: no method named `contains` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpdccgd_4m.rs:10:23\n   |\n10 |  \
    \       .filter(|c| c.contains(&substring[..1]))\n   |                       ^^^^^^^^\
    \ method not found in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdccgd_4m.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars().filter(|c| c.contains(&substring))\n\
    10 | |         .filter(|c| c.contains(&substring[..1]))\n11 | |         .count()\n\
    \   | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n11 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() <= substring.len() {\n        return 0;\n    }\n\n    let\
    \ mut s = string;\n    let mut sub = substring;\n    let mut n = 0;\n    while\
    \ s.len() > 0 {\n        if s.contains(&sub) {\n            n += 1;\n        }\n\
    \        s += sub;\n        sub = String::from(\"\");\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw4dmwi2l.rs:20:14\n   |\n\
    20 |         s += sub;\n   |              ^^^\n   |              |\n   |     \
    \         expected `&str`, found struct `String`\n   |              help: consider\
    \ borrowing here: `&sub`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .take(string.len())\n\
    \        .filter(|(s, sub)| s == sub)\n        .count(|(_, (_, sub))| true)\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpl60e13gf.rs:13:10\n    |\n13  |         .count(|(_, (_, sub))|\
    \ true)\n    |          ^^^^^ -------------------- supplied 1 argument\n    |\
    \          |\n    |          expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl60e13gf.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .take(string.len())\n12 | |         .filter(|(s, sub)| s == sub)\n\
    13 | |         .count(|(_, (_, sub))| true)\n   | |____________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |         .count(|(_,\
    \ (_, sub))| true).try_into().unwrap()\n   |                                 \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut pos = 0;\n    let mut count = 0;\n    while pos < string.len() {\n\
    \        if string.contains(&substring, pos) {\n            count += 1;\n    \
    \    }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpzgkyojza.rs:12:19\n     |\n12   |         if string.contains(&substring,\
    \ pos) {\n     |                   ^^^^^^^^ ----------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices()\n        .filter(|&(c1, c2)| c1 == c2)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpujghhv22.rs:10:35\n   |\n\
    10 |         .filter(|&(c1, c2)| c1 == c2)\n   |                             \
    \      ^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpujghhv22.rs:9:5\n   |\n8  |   fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                   ----- expected `isize` because of return type\n9  | /    \
    \ string.char_indices()\n10 | |         .filter(|&(c1, c2)| c1 == c2)\n11 | |\
    \         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.find(substring).unwrap_or(0)\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpdbcshhw6.rs:9:17\n     |\n9    |     string.find(substring).unwrap_or(0)\n\
    \     |            ---- ^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |            |\n     |            required by a bound introduced by this\
    \ call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::find`\nhelp:\
    \ consider borrowing here\n     |\n9    |     string.find(&substring).unwrap_or(0)\n\
    \     |                 +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdbcshhw6.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.find(substring).unwrap_or(0)\n  |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n  |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n  |\n9 |     string.find(substring).unwrap_or(0).try_into().unwrap()\n\
    \  |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count() + 1\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp5q047fvm.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count() +\
    \ 1\n     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count() + 1\n     |                                \
    \                  +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5q047fvm.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\
    \ + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ substring.contains(c)).count() + 1).try_into().unwrap()\n  |     +         \
    \                                                   +++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n\n    for c in string.chars() {\n        if !substring.contains(&c)\
    \ {\n            break;\n        }\n\n        counter += 1;\n    }\n\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp5x3k7c2f.rs:12:32\n\
    \     |\n12   |         if !substring.contains(&c) {\n     |                 \
    \      -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |   \
    \                    |\n     |                       required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n12   |         if\
    \ !substring.contains(*&c) {\n     |                                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().any(|c| string.find(substring, c) != None)\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp9z6flm2g.rs:9:35\n     |\n9    |     string.chars().any(|c| string.find(substring,\
    \ c) != None)\n     |                                   ^^^^ ---------  - supplied\
    \ 2 arguments\n     |                                   |\n     |            \
    \                       expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9z6flm2g.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().any(|c| string.find(substring,\
    \ c) != None)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() &&\
    \ pos < substring.len() {\n        if string[pos] == substring[pos] {\n      \
    \      counter = counter + 1;\n            pos = pos + 1;\n        } else {\n\
    \            pos = pos + 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnt0kf8dp.rs:12:12\n\
    \   |\n12 |         if string[pos] == substring[pos] {\n   |            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnt0kf8dp.rs:12:27\n   |\n12 |         if string[pos] == substring[pos]\
    \ {\n   |                           ^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut string_iter = string.chars();\n    let mut substr_iter = substring.chars();\n\
    \    let mut count = 0;\n    while let Some(first_char) = substr_iter.next() {\n\
    \        let first_char = first_char.to_string();\n        let mut second_char\
    \ = string_iter.next()?;\n        let mut second_char = second_char.to_string();\n\
    \        if second_char == first_char {\n            count++;\n        } else\
    \ {\n            second_char = first_char;\n            count += second_char ==\
    \ first_char ? 1 : 0;\n        }\n        if count >= substring.len() {\n    \
    \        break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmprstjnxtw.rs:17:18\n\
    \   |\n17 |             count++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |             { let tmp =\
    \ count; count += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    17 -             count++;\n17 +             count += 1;\n   | \n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmprstjnxtw.rs:20:50\n\
    \   |\n20 |             count += second_char == first_char ? 1 : 0;\n   |    \
    \                                              ^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror[E0277]: the `?` operator can only be used in a\
    \ function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmprstjnxtw.rs:14:49\n   |\n8  | / fn how_many_times(string:\
    \ String, substring: String) -> isize {\n9  | |     let mut string_iter = string.chars();\n\
    10 | |     let mut substr_iter = substring.chars();\n11 | |     let mut count\
    \ = 0;\n...  |\n14 | |         let mut second_char = string_iter.next()?;\n  \
    \ | |                                                 ^ cannot use the `?` operator\
    \ in a function that returns `isize`\n...  |\n26 | |     count\n27 | | }\n   |\
    \ |_- this function should return `Result` or `Option` to accept `?`\n   |\n \
    \  = help: the trait `FromResidual<Option<Infallible>>` is not implemented for\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprstjnxtw.rs:26:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n26 |     count\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n26 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices()\n        .filter_map(|(i, c)| if c == substring { Some(i)\
    \ } else { None })\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp504ku9ww.rs:10:38\n   |\n\
    10 |         .filter_map(|(i, c)| if c == substring { Some(i) } else { None })\n\
    \   |                                      ^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp504ku9ww.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.char_indices()\n10 | |   \
    \      .filter_map(|(i, c)| if c == substring { Some(i) } else { None })\n11 |\
    \ |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Convert from UTF-8 to lower case so that case-sensitivity can be ignored.\n\
    \    let substring = substring\n        .as_bytes()\n        .iter()\n       \
    \ .map(|c| c.to_lowercase())\n        .collect();\n    string.bytes_with_mut().count(|c|\
    \ substring.contains(c))\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_lowercase` found for reference `&u8`\
    \ in the current scope\n  --> /tmp/tmpga12g59v.rs:13:20\n   |\n13 |         .map(|c|\
    \ c.to_lowercase())\n   |                    ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method\
    \ named `bytes_with_mut` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpga12g59v.rs:15:12\n   |\n15 |     string.bytes_with_mut().count(|c|\
    \ substring.contains(c))\n   |            ^^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| *c == substring).count()\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaa2_tdp7.rs:9:37\n  |\n9 |\
    \     string.chars().filter(|c| *c == substring).count()\n  |                \
    \                     ^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpaa2_tdp7.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| *c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ *c == substring).count().try_into().unwrap()\n  |                          \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string\n        .chars()\n        .filter(|c| c == substring[..])\n      \
    \  .count() + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `str`\n  --> /tmp/tmp35c7_mft.rs:11:23\n\
    \   |\n11 |         .filter(|c| c == substring[..])\n   |                    \
    \   ^^ no implementation for `&char == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35c7_mft.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string\n10 | |         .chars()\n\
    11 | |         .filter(|c| c == substring[..])\n12 | |         .count() + 1\n\
    \   | |____________________^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n9  ~     (string\n10 |         .chars()\n11 |         .filter(|c|\
    \ c == substring[..])\n12 ~         .count() + 1).try_into().unwrap()\n   |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().fold(0, |acc, _| acc + (substring.chars().count(|c| c == &mut\
    \ s[0])))\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `s` in this scope\n --> /tmp/tmpnwcypaf9.rs:9:82\n\
    \  |\n9 |     string.chars().fold(0, |acc, _| acc + (substring.chars().count(|c|\
    \ c == &mut s[0])))\n  |                                                     \
    \                             ^ help: a local variable with a similar name exists:\
    \ `c`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpnwcypaf9.rs:9:62\n    |\n9   |     string.chars().fold(0, |acc,\
    \ _| acc + (substring.chars().count(|c| c == &mut s[0])))\n    |             \
    \                                                 ^^^^^ ------------------ supplied\
    \ 1 argument\n    |                                                          \
    \    |\n    |                                                              expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpnwcypaf9.rs:9:43\n  |\n9 |     string.chars().fold(0,\
    \ |acc, _| acc + (substring.chars().count(|c| c == &mut s[0])))\n  |         \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot add `usize` to `isize`\n\
    \ --> /tmp/tmpnwcypaf9.rs:9:41\n  |\n9 |     string.chars().fold(0, |acc, _| acc\
    \ + (substring.chars().count(|c| c == &mut s[0])))\n  |                      \
    \                   ^ no implementation for `isize + usize`\n  |\n  = help: the\
    \ trait `Add<usize>` is not implemented for `isize`\n  = help: the following other\
    \ types implement trait `Add<Rhs>`:\n            <&'a f32 as Add<f32>>\n     \
    \       <&'a f64 as Add<f64>>\n            <&'a i128 as Add<i128>>\n         \
    \   <&'a i16 as Add<i16>>\n            <&'a i32 as Add<i32>>\n            <&'a\
    \ i64 as Add<i64>>\n            <&'a i8 as Add<i8>>\n            <&'a isize as\
    \ Add<isize>>\n          and 48 others\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277, E0308, E0425.\nFor more\
    \ information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.iter()\n        .zip(substring.iter())\n        .count(|(s, _)| s ==\
    \ _)\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpk70vycp6.rs:11:30\n   |\n11 |         .count(|(s,\
    \ _)| s == _)\n   |                              ^ `_` not allowed here\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpk70vycp6.rs:9:12\n  |\n9 |     string.iter()\n  |            ^^^^ method\
    \ not found in `String`\n  |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \  |\n9 |     string.chars()\n  |            ~~~~~\n\nerror[E0599]: no method\
    \ named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpk70vycp6.rs:10:24\n\
    \   |\n10 |         .zip(substring.iter())\n   |                        ^^^^ method\
    \ not found in `String`\n   |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n10 |         .zip(substring.chars())\n   |                        ~~~~~\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .map(|(a, b)| (a,\
    \ b))\n        .filter(|(a, b)| a.0 == b.0)\n        .count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&char`\n  --> /tmp/tmprpr_ib5e.rs:12:28\n\
    \   |\n12 |         .filter(|(a, b)| a.0 == b.0)\n   |                       \
    \     ^\n\nerror[E0609]: no field `0` on type `&char`\n  --> /tmp/tmprpr_ib5e.rs:12:35\n\
    \   |\n12 |         .filter(|(a, b)| a.0 == b.0)\n   |                       \
    \            ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprpr_ib5e.rs:9:5\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .map(|(a, b)| (a, b))\n12 | |         .filter(|(a, b)| a.0 == b.0)\n\
    13 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string[..substring.length()].contains(substring) {\n        1\n    } else\
    \ {\n        string\n            .chars()\n            .filter(|c| *c == substring)\n\
    \            .count()\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp56lqll98.rs:9:27\n  |\n9 |     if string[..substring.length()].contains(substring)\
    \ {\n  |                           ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure,\
    \ found `String`\n    --> /tmp/tmp56lqll98.rs:9:46\n     |\n9    |     if string[..substring.length()].contains(substring)\
    \ {\n     |                                     -------- ^^^^^^^^^ expected an\
    \ implementor of trait `Pattern<'_>`\n     |                                 \
    \    |\n     |                                     required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is\
    \ not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n9    |     if string[..substring.length()].contains(&substring)\
    \ {\n     |                                              +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp56lqll98.rs:14:31\n   |\n14 |             .filter(|c| *c\
    \ == substring)\n   |                               ^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp56lqll98.rs:12:9\n\
    \   |\n8  |   fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                           ----- expected\
    \ `isize` because of return type\n...\n12 | /         string\n13 | |         \
    \    .chars()\n14 | |             .filter(|c| *c == substring)\n15 | |       \
    \      .count()\n   | |____________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |             .count().try_into().unwrap()\n   |\
    \                     ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an "
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppmc0u5kb.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmppmc0u5kb.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count() as isize\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8dvy2u25.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp6nbsyrfv.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp6nbsyrfv.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n\n    string.char_indices().filter_map(|(i, c)| {\n\
    \        if c != substring.chars().nth(i) {\n            counter = counter + 1;\n\
    \        }\n\n        counter\n    }).count()\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp84mperbc.rs:12:17\n   |\n\
    12 |         if c != substring.chars().nth(i) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp84mperbc.rs:16:9\n   |\n16 |         counter\n   |         ^^^^^^^\
    \ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |         Some(counter)\n   |         +++++       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp84mperbc.rs:11:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n...\n\
    11 | /     string.char_indices().filter_map(|(i, c)| {\n12 | |         if c !=\
    \ substring.chars().nth(i) {\n13 | |             counter = counter + 1;\n14 |\
    \ |         }\n15 | |\n16 | |         counter\n17 | |     }).count()\n   | |______________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a != b).count() as isize\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp3v4pn_mb.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.char_indices()\n        .filter(|index| {\n            index.0..=\n\
    \                (substring.len() + substring.as_bytes()[index.1..].len()) ==\
    \ index.1\n        })\n        .count()\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[u8]` cannot be indexed by `RangeFrom<char>`\n\
    \  --> /tmp/tmpncv53rvo.rs:12:36\n   |\n12 |                 (substring.len()\
    \ + substring.as_bytes()[index.1..].len()) == index.1\n   |                  \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `RangeFrom<char>`\n   = help: the following other types implement trait\
    \ `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n     \
    \        <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because of\
    \ the requirements on the impl of `Index<RangeFrom<char>>` for `[u8]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpncv53rvo.rs:12:78\n   |\n12 |              \
    \   (substring.len() + substring.as_bytes()[index.1..].len()) == index.1\n   |\
    \                                                                            \
    \  ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpncv53rvo.rs:12:17\n   |\n12 |                 (substring.len()\
    \ + substring.as_bytes()[index.1..].len()) == index.1\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpncv53rvo.rs:11:13\n\
    \   |\n11 | /             index.0..=\n12 | |                 (substring.len()\
    \ + substring.as_bytes()[index.1..].len()) == index.1\n   | |____________________________________________________________________________________^\
    \ expected `bool`, found struct `RangeInclusive`\n   |\n   = note: expected type\
    \ `bool`\n            found struct `RangeInclusive<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpncv53rvo.rs:9:5\n   |\n8  |   fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                           ----- expected `isize` because of return type\n9 \
    \ | /     string.char_indices()\n10 | |         .filter(|index| {\n11 | |    \
    \         index.0..=\n12 | |                 (substring.len() + substri"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = 0usize;\n    let mut count = 0usize;\n    while index <= string.len()\
    \ {\n        index = string.find(substring, index);\n        count += 1;\n   \
    \     index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp1itssdx4.rs:12:24\n     |\n12   |         index = string.find(substring,\
    \ index);\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n\
    \     |                        |\n     |                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1itssdx4.rs:12:17\n   |\n9  |     let mut index = 0usize;\n   |\
    \                     ------ expected due to this value\n...\n12 |         index\
    \ = string.find(substring, index);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1itssdx4.rs:16:5\n   |\n8  | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                 ----- expected `isize` because of return type\n...\n16 |   \
    \  count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(a,b)| a\
    \ == b)\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp81d0m8od.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a,b)| a == b)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().count(|c| substring.contains(&c))\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp4raysss2.rs:9:20\n    |\n9   |     string.chars().count(|c| substring.contains(&c))\n\
    \    |                    ^^^^^ -------------------------- supplied 1 argument\n\
    \    |                    |\n    |                    expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp4raysss2.rs:9:5\n  |\n8 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                                                    \
    \     ----- expected `isize` because of return type\n9 |     string.chars().count(|c|\
    \ substring.contains(&c))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().count(|c|\
    \ substring.contains(&c)).try_into().unwrap()\n  |                           \
    \                          ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().fold(0, |acc, c| acc + substring.chars().any(|c| c == c))\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `bool` to `isize`\n --> /tmp/tmpfaitg_i1.rs:9:41\n\
    \  |\n9 |     string.chars().fold(0, |acc, c| acc + substring.chars().any(|c|\
    \ c == c))\n  |                                         ^ no implementation for\
    \ `isize + bool`\n  |\n  = help: the trait `Add<bool>` is not implemented for\
    \ `isize`\n  = help: the following other types implement trait `Add<Rhs>`:\n \
    \           <&'a f32 as Add<f32>>\n            <&'a f64 as Add<f64>>\n       \
    \     <&'a i128 as Add<i128>>\n            <&'a i16 as Add<i16>>\n           \
    \ <&'a i32 as Add<i32>>\n            <&'a i64 as Add<i64>>\n            <&'a i8\
    \ as Add<i8>>\n            <&'a isize as Add<isize>>\n          and 48 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count(|&(a1,\
    \ a2)| a1.cmp(a2) == 0)\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&(_, _)`\n --> /tmp/tmpzgu7fc_d.rs:9:74\n\
    \  |\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count(|&(a1,\
    \ a2)| a1.cmp(a2) == 0)\n  |                                                 \
    \                         ^^^^^^^^^ consider giving this closure parameter the\
    \ explicit type `&(_, _)`, with the type parameters specified\n  |\n  = note:\
    \ type must be known at this point\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpzgu7fc_d.rs:9:67\n    |\n9   | \
    \    string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count(|&(a1,\
    \ a2)| a1.cmp(a2) == 0)\n    |                                               \
    \                    ^^^^^ --------------------------- supplied 1 argument\n \
    \   |                                                                   |\n  \
    \  |                                                                   expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpzgu7fc_d.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count(|&(a1,\
    \ a2)| a1.cmp(a2) == 0)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count(|&(a1, a2)| a1.cmp(a2) == 0).try_into().unwrap()\n  |    \
    \                                                                            \
    \                     ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0282, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().fold(0, |count, c| count + ((string.contains(&c) ? 1 : 0) as\
    \ isize))\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `1`\n\
    \ --> /tmp/tmpa2lipcrp.rs:9:71\n  |\n9 |     string.chars().fold(0, |count, c|\
    \ count + ((string.contains(&c) ? 1 : 0) as isize))\n  |                     \
    \                                                  ^ expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n\nerror: expected one of `!`, `&&`, `&`, `(`, `)`,\
    \ `*`, `,`, `...`, `.`, `<`, `?`, `[`, `_`, `async`, `const`, `dyn`, `extern`,\
    \ `fn`, `for`, `impl`, `unsafe`, `~`, an operator, lifetime, or path, found `0`\n\
    \ --> /tmp/tmpa2lipcrp.rs:9:75\n  |\n9 |     string.chars().fold(0, |count, c|\
    \ count + ((string.contains(&c) ? 1 : 0) as isize))\n  |                     \
    \                                                     -^ expected one of 25 possible\
    \ tokens\n  |                                                                \
    \          |\n  |                                                            \
    \              help: missing `,`\n\nerror: expected one of `.`, `;`, `?`, `}`,\
    \ or an operator, found `)`\n --> /tmp/tmpa2lipcrp.rs:9:87\n  |\n9 |     string.chars().fold(0,\
    \ |count, c| count + ((string.contains(&c) ? 1 : 0) as isize))\n  |          \
    \                                                                            \
    \ ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due\
    \ to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(a, b)|\
    \ a == b)\n        .count()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeec_od_3.rs:9:5\n   |\n8\
    \  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| a == b)\n12 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   how_many_times_impl(string, substring)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `how_many_times_impl` in this scope\n\
    \ --> /tmp/tmpufelxwdg.rs:9:5\n  |\n9 |     how_many_times_impl(string, substring)\n\
    \  |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars()\n        .zip(substring.chars())\n        .filter(|(a, b)|\
    \ *a == *b)\n        .count() + how_many_times(substring, substring)\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpreayyf1b.rs:12:20\n   |\n\
    12 |         .count() + how_many_times(substring, substring)\n   |           \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpreayyf1b.rs:9:5\n   |\n8  |  \
    \ fn how_many_times(string: String, substring: String) -> isize {\n   |      \
    \                                                     ----- expected `isize` because\
    \ of return type\n9  | /     string.chars()\n10 | |         .zip(substring.chars())\n\
    11 | |         .filter(|(a, b)| *a == *b)\n12 | |         .count() + how_many_times(substring,\
    \ substring)\n   | |_______________________________________________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n9  ~     (string.chars()\n\
    10 |         .zip(substring.chars())\n11 |         .filter(|(a, b)| *a == *b)\n\
    12 ~         .count() + how_many_times(substring, substring)).try_into().unwrap()\n\
    \   |\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpreayyf1b.rs:12:18\n\
    \   |\n12 |         .count() + how_many_times(substring, substring)\n   |    \
    \              ^ no implementation for `usize + isize`\n   |\n   = help: the trait\
    \ `Add<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n    \
    \         <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n      \
    \       <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n          \
    \   <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a\
    \ isize as Add<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c != substring[0] && c != substring[1]).count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmp3cftnlwu.rs:9:36\n  |\n9 |     string.chars().filter(|c| c != substring[0]\
    \ && c != substring[1]).count() + 1\n  |                                    ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n --> /tmp/tmp3cftnlwu.rs:9:57\n\
    \  |\n9 |     string.chars().filter(|c| c != substring[0] && c != substring[1]).count()\
    \ + 1\n  |                                                         ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp3cftnlwu.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| c != substring[0] && c != substring[1]).count()\
    \ + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn'"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0usize;\n    for b in string.chars() {\n        if substring.contains(&b)\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmplf_kg3qm.rs:11:31\n\
    \     |\n11   |         if substring.contains(&b) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ substring.contains(*&b) {\n     |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplf_kg3qm.rs:15:5\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                                \
    \                         ----- expected `isize` because of return type\n...\n\
    15 |     counter\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |     counter.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // The code below is adapted from https://doc.rust-lang.org/std/search\n \
    \   let mut count = 0;\n    string.char_indices()\n        .skip_while(|&(_, c)|\
    \ c != 0)\n        .take_while(|&(_, c)| c != 0)\n        .for_each(|(_, c)| {\n\
    \            count += substring\n                .chars()\n                .skip_while(|&(_,\
    \ c)| c == 0)\n                .take_while(|&(_, c)| c == 0)\n               \
    \ .count() - 1;\n        });\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkm3mufn.rs:12:36\n   |\n\
    12 |         .skip_while(|&(_, c)| c != 0)\n   |                             \
    \       ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppkm3mufn.rs:13:36\n   |\n13 |         .take_while(|&(_, c)| c != 0)\n\
    \   |                                    ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppkm3mufn.rs:17:31\n   |\n17 |              \
    \   .skip_while(|&(_, c)| c == 0)\n   |                               ^^^^^-\n\
    \   |                               |    |\n   |                             \
    \  |    expected due to this\n   |                               expected `char`,\
    \ found tuple\n   |\n   = note: expected type `char`\n             found tuple\
    \ `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppkm3mufn.rs:18:31\n\
    \   |\n18 |                 .take_while(|&(_, c)| c == 0)\n   |              \
    \                 ^^^^^-\n   |                               |    |\n   |    \
    \                           |    expected due to this\n   |                  \
    \             expected `char`, found tuple\n   |\n   = note: expected type `char`\n\
    \             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppkm3mufn.rs:21:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n21 |     count\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.length() != substring.length() {\n        return 0;\n    }\n   \
    \ let mut count = 0;\n    for (i, &c) in string.chars().zip(substring.chars())\
    \ {\n        if c == &c {\n            count += 1;\n            if i == substring.len()\
    \ - 1 {\n                break;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmppu72k_x9.rs:9:15\n  |\n9 |     if string.length()\
    \ != substring.length() {\n  |               ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n --> /tmp/tmppu72k_x9.rs:9:37\n\
    \  |\n9 |     if string.length() != substring.length() {\n  |                \
    \                     ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppu72k_x9.rs:13:13\n\
    \   |\n13 |     for (i, &c) in string.chars().zip(substring.chars()) {\n   | \
    \            ^^     ------------------------------------- this expression has\
    \ type `Option<(char, char)>`\n   |             |\n   |             expected `char`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppu72k_x9.rs:16:21\n  \
    \ |\n16 |             if i == substring.len() - 1 {\n   |                    \
    \ ^^^^^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count: isize = 0;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmptm0b_faw.rs:11:31\n\
    \     |\n11   |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() > substring.len() {\n        return 0;\n    }\n    let mut\
    \ i = 0;\n    while i <= string.len() - substring.len() {\n        let j = i +\
    \ substring.len();\n        if j > string.len() {\n            break;\n      \
    \  }\n        if string.chars().any(|c| c != substring.chars().nth(i)) {\n   \
    \         break;\n        }\n        i += 1;\n    }\n    i + 1\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr_mipz4d.rs:18:40\n   |\n\
    18 |         if string.chars().any(|c| c != substring.chars().nth(i)) {\n   |\
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr_mipz4d.rs:23:5\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                         ----- expected `isize`\
    \ because of return type\n...\n23 |     i + 1\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n23 |     (i + 1).try_into().unwrap()\n\
    \   |     +     +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c != substring[c.len_utf8()]).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpuuuxrxpo.rs:9:36\n\
    \  |\n9 |     string.chars().filter(|c| c != substring[c.len_utf8()]).count()\n\
    \  |                                    ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpuuuxrxpo.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| c != substring[c.len_utf8()]).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ c != substring[c.len_utf8()]).count().try_into().unwrap()\n  |             \
    \                                                       ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
