language: rs
name: HumanEval_61_correct_bracketing
results:
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        brackets.chars().any(|c| c == c)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppnm9ytf4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .split_whitespace()\n        .iter()\n        .zip(brackets.split_whitespace().iter())\n\
    \        .any(|(a, b)| a.is_opening_bracket() == b.is_closing_bracket())\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpxzt0sabv.rs:14:10\n   |\n14 |         .iter()\n\
    \   |          ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpxzt0sabv.rs:15:42\n   |\n15 |         .zip(brackets.split_whitespace().iter())\n\
    \   |                                          ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Check all pairs of parentheses.\n    for parens in 0..brackets.len() {\n   \
    \     let paren = brackets[parens as usize];\n        if paren == parens.to_str()\
    \ {\n            continue;\n        }\n        if paren == ')' {\n           \
    \ let next_paren = brackets[parens.iter().skip(1).next().unwrap() as usize];\n\
    \            if next_paren == ')' {\n                continue;\n            }\n\
    \            false\n        } else {\n            true\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0t5id__j.rs:14:21\n\
    \   |\n14 |         let paren = brackets[parens as usize];\n   |             \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `to_str` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmp0t5id__j.rs:15:28\n   |\n15 |         if paren == parens.to_str() {\n\
    \   |                            ^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `usize` in the current scope\n  --> /tmp/tmp0t5id__j.rs:19:46\n\
    \   |\n19 |             let next_paren = brackets[parens.iter().skip(1).next().unwrap()\
    \ as usize];\n   |                                              ^^^^ method not\
    \ found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0t5id__j.rs:23:13\n\
    \   |\n18 | /         if paren == ')' {\n19 | |             let next_paren = brackets[parens.iter().skip(1).next().unwrap()\
    \ as usize];\n20 | |             if next_paren == ')' {\n21 | |              \
    \   continue;\n22 | |             }\n23 | |             false\n   | |        \
    \     ^^^^^ expected `()`, found `bool`\n24 | |         } else {\n25 | |     \
    \        true\n26 | |         }\n   | |_________- expected this to be `()`\n \
    \  |\nhelp: you might have meant to return this value\n   |\n23 |            \
    \ return false;\n   |             ++++++      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0t5id__j.rs:25:13\n   |\n18 | /         if paren == ')' {\n19 |\
    \ |             let next_paren = brackets[parens.iter().skip(1).next().unwrap()\
    \ as usize];\n20 | |           "
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for (i, c) in brackets.chars().enumerate() {\n    \
    \    if c == ')' {\n            stack.pop();\n        }\n        if c == '(' &&\
    \ !stack.is_empty() {\n            stack.push(c);\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7l1k_sbg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\n\
    \        if let Ok(b) = brackets_opening_brackets.find(c) {\n            brackets_opening_brackets.remove(c);\n\
    \            Some(b) != Some(brackets_closing_brackets.find(c))\n        } else\
    \ {\n            false\n        }\n    )\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `brackets_opening_brackets` in this scope\n\
    \  --> /tmp/tmplq63dt11.rs:13:24\n   |\n13 |         if let Ok(b) = brackets_opening_brackets.find(c)\
    \ {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `brackets_opening_brackets` in this scope\n\
    \  --> /tmp/tmplq63dt11.rs:14:13\n   |\n14 |             brackets_opening_brackets.remove(c);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `brackets_closing_brackets` in this scope\n  --> /tmp/tmplq63dt11.rs:15:29\n\
    \   |\n15 |             Some(b) != Some(brackets_closing_brackets.find(c))\n \
    \  |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets;\n    while !brackets.is_empty() {\n        let opening_position\
    \ = brackets.find('(').unwrap();\n        let mut closing = opening_position;\n\
    \        while closing < brackets.len() {\n            if brackets[closing] ==\
    \ '(' {\n                closing += 1;\n            } else {\n               \
    \ break;\n            }\n        }\n        if closing > opening_position {\n\
    \            brackets = brackets.replace(opening_position.to_string(), closing.to_string());\n\
    \        }\n    }\n    brackets == String::from(\"()\")\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp357kocii.rs:17:16\n\
    \   |\n17 |             if brackets[closing] == '(' {\n   |                ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \   --> /tmp/tmp357kocii.rs:24:33\n    |\n24  |             brackets = brackets.replace(opening_position.to_string(),\
    \ closing.to_string());\n    |                                 ^^^^^^^ expected\
    \ an `FnMut<(char,)>` closure, found `String`\n    |\n    = help: the trait `FnMut<(char,)>`\
    \ is not implemented for `String`\n    = help: the following other types implement\
    \ trait `Pattern<'a>`:\n              &'b String\n              &'b str\n    \
    \          &'c &'b str\n    = note: required because of the requirements on the\
    \ impl of `Pattern<'_>` for `String`\nnote: required by a bound in `str::<impl\
    \ str>::replace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp357kocii.rs:24:71\n\
    \   |\n24 |             brackets = brackets.replace(opening_position.to_string(),\
    \ closing.to_string());\n   |                                                \
    \                       ^^^^^^^^^^^^^^^^^^^\n   |                            \
    \                                           |\n   |                          \
    \                                             expected `&str`, found struct `String`\n\
    \   |                                                                       help:\
    \ consider borrowing here: `&closing.to_string()`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ mo"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_levels = String::new();\n    let mut last_open = false;\n    let mut\
    \ last_close = false;\n    let mut last_char = '';\n    for c in brackets {\n\
    \        match c {\n            '(' if !last_open => {\n                open_levels\
    \ += c;\n                last_open = true;\n            }\n            ')' if\
    \ !last_close => {\n                open_levels = open_levels.trim_end(')');\n\
    \                let mut bracket_levels = open_levels.len();\n               \
    \ while bracket_levels > 0 {\n                    let open_level = open_levels.chars().last().unwrap();\n\
    \                    if open_level == ')' {\n                        bracket_levels--;\n\
    \                    }\n                    open_levels = open_levels.trim_end(open_level);\n\
    \                }\n                last_close = true;\n            }\n      \
    \      _ => {\n                if open_levels.is_empty() {\n                 \
    \   last_char = c == '(';\n                } else {\n                    last_char\
    \ = c != '(';\n                }\n            }\n        }\n    }\n    open_levels.len()\
    \ == brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmpav9l57tv.rs:15:26\n   |\n\
    15 |     let mut last_char = '';\n   |                          ^ empty character\
    \ literal\n\nerror: expected expression, found `;`\n  --> /tmp/tmpav9l57tv.rs:28:41\n\
    \   |\n28 |                         bracket_levels--;\n   |                  \
    \                       ^ expected expression\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmpav9l57tv.rs:16:14\n   |\n16 |     for c in brackets\
    \ {\n   |              ^^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpav9l57tv.rs:19:32\n\
    \   |\n19 |                 open_levels += c;\n   |                          \
    \      ^ expected `&str`, found `char`\n\nerror[E0061]: this function takes 0\
    \ arguments but 1 argument was supplied\n    --> /tmp/tmpav9l57tv.rs:23:43\n \
    \    |\n23   |                 open_levels = open_levels.trim_end(')');\n    \
    \ |                                           ^^^^^^^^ --- supplied 1 argument\n\
    \     |                                           |\n     |                  \
    \                         expected 0 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpav9l57tv.rs:23:31\n\
    \   |\n12 |     let mut open_levels = String::new();\n   |                   \
    \        ------------- expected due to this value\n...\n23 |                 open_levels\
    \ = open_levels.trim_end(')');\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \             |\n   |                               expected struct `String`,\
    \ found `&str`\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n    --> /tmp/tmpav9l57tv.rs:30:47\n     |\n30   |            \
    \         open_levels = open_levels.trim_end(open_level);\n     |            \
    \                                   ^^^^^^^^ ---"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<&str> = brackets.chars().collect();\n    stack.push(\"\");\n\
    \    loop {\n        let mut open_brackets: Vec<&str> = stack.iter().filter(|c|\
    \ c != '(').collect();\n        let mut close_brackets: Vec<&str> = stack.iter().filter(|c|\
    \ c != ')').collect();\n        open_brackets.push(\"\");\n        close_brackets.push(\"\
    \");\n        for bracket in open_brackets.iter().filter(|c| c != '(' && c !=\
    \ ')').collect::<Vec<_>>() {\n            match close_brackets.pop() {\n     \
    \           Some('(') if bracket == \"(\" => stack.push(bracket),\n          \
    \      Some(')') if bracket == \")\" => stack.push(bracket),\n               \
    \ Some(\"\") => (),\n                None => stack.push(bracket),\n          \
    \  }\n        }\n        if close_brackets.iter().any(|c| c == \"\") {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp464cc0ht.rs:12:49\n     |\n12\
    \   |     let mut stack: Vec<&str> = brackets.chars().collect();\n     |     \
    \                                            ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0277]: can't compare `&&&str` with `char`\n  -->\
    \ /tmp/tmp464cc0ht.rs:15:70\n   |\n15 |         let mut open_brackets: Vec<&str>\
    \ = stack.iter().filter(|c| c != '(').collect();\n   |                       \
    \                                               ^^ no implementation for `&&&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: a value of\
    \ type `Vec<&str>` cannot be built from an iterator over elements of type `&&str`\n\
    \    --> /tmp/tmp464cc0ht.rs:15:78\n     |\n15   |         let mut open_brackets:\
    \ Vec<&str> = stack.iter().filter(|c| c != '(').collect();\n     |           \
    \                                                                   ^^^^^^^ value\
    \ of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=&&str>`\n\
    \     |\n     = help: the trait `FromIterator<&&str>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: can't compare `&&&str` with `char`\n\
    \  --> /tmp/tmp464cc"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() == 0 {\n        return false;\n    }\n\n    let mut found = false;\n\
    \    let mut current = String::from(brackets[0]);\n    for bracket in &brackets[1..].chars().filter_map(|c|\
    \ *c != '(').collect::<Vec<_>>() {\n        if bracket == '(' && current.chars().all(|c|\
    \ *c == ')') {\n            current = current.replace(\")\", \"\").to_string();\n\
    \        } else if bracket == ')' && current != \"(\" {\n            found = true;\n\
    \            current = current.replace(\"(\", \"\").to_string();\n        } else\
    \ if current.chars().all(|c| *c != ')' && c != '(') {\n            current = &current[..];\n\
    \        }\n    }\n    !found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpuc40_t06.rs:17:36\n   |\n17 |     let mut current = String::from(brackets[0]);\n\
    \   |                                    ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpuc40_t06.rs:18:58\n\
    \   |\n18 |     for bracket in &brackets[1..].chars().filter_map(|c| *c != '(').collect::<Vec<_>>()\
    \ {\n   |                                                          ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuc40_t06.rs:18:58\n   |\n18 |     for bracket\
    \ in &brackets[1..].chars().filter_map(|c| *c != '(').collect::<Vec<_>>() {\n\
    \   |                                                          ^^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |     for bracket in &brackets[1..].chars().filter_map(|c| Some(*c !=\
    \ '(')).collect::<Vec<_>>() {\n   |                                          \
    \                +++++         +\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpuc40_t06.rs:19:20\n   |\n19 |         if bracket == '(' && current.chars().all(|c|\
    \ *c == ')') {\n   |                    ^^ no implementation for `&_ == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpuc40_t06.rs:19:54\n\
    \   |\n19 |         if bracket == '(' && current.chars().all(|c| *c == ')') {\n\
    \   |                                                "
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ empty brackets is false\n    if brackets.is_empty() {\n        return false;\n\
    \    }\n    // check if last char is a bracket\n    if brackets.chars().last().unwrap()\
    \ != ')' {\n        return false;\n    }\n    // count opening and closing brackets\n\
    \    let mut count = 0;\n    for ch in brackets.chars() {\n        if ch == '('\
    \ {\n            count += 1;\n        } else if ch == ')' {\n            count\
    \ -= 1;\n        }\n        if count < 0 {\n            return false;\n      \
    \  }\n    }\n    // check for duplicate brackets\n    let mut seen_brackets =\
    \ Vec::new();\n    for ch in brackets.chars() {\n        if seen_brackets.contains(&ch)\
    \ {\n            return false;\n        }\n        seen_brackets.push(ch);\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n \
    \   assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvjc8uffu.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<_> = vec![];\n    for (i, char) in brackets.chars().enumerate()\
    \ {\n        if char == ')' {\n            if stack.is_empty() {\n           \
    \     return false;\n            }\n            stack.pop();\n        } else {\n\
    \            stack.push(char);\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ find how many open brackets we have\n    let mut num_opening_brackets = brackets.chars().filter(|x|\
    \ *x != ')').count();\n\n    // find how many closing brackets we have\n    let\
    \ mut num_closing_brackets = brackets.chars().filter(|x| *x != '(').count();\n\
    \n    while num_opening_brackets != 0 && num_closing_brackets != 0 {\n       \
    \ // if opening bracket is closed, we're done with bracketing\n        if num_closing_brackets\
    \ == num_opening_brackets {\n            // if opening bracket is closed and closing\
    \ bracket is open, we're done with bracketing\n            if num_closing_brackets\
    \ <= num_opening_brackets {\n                return true;\n            }\n   \
    \         // if opening bracket is open and closing bracket is closed, we're done\
    \ with bracketing\n            else {\n                // if opening bracket is\
    \ open and closing bracket is open, we're done with bracketing\n             \
    \   if num_opening_brackets == num_closing_brackets {\n                    return\
    \ true;\n                }\n            }\n        }\n        // if opening bracket\
    \ is closed, we're done with bracketing\n        else if num_opening_brackets\
    \ == num_closing_brackets {\n            // if opening bracket is closed and closing\
    \ bracket is closed, we're done with bracketing\n            if num_opening_brackets\
    \ == num_closing_brackets {\n                return true;\n            }\n   \
    \         // if opening bracket is open and closing bracket is closed, we're done\
    \ with bracketing\n            else {\n                // if opening bracket is\
    \ open and closing bracket is open, we're done with bracketing\n             \
    \   if num_opening_brackets == num_closing_brackets {\n                    return\
    \ true;\n                }\n            }\n        }\n        // if opening bracket\
    \ is open, we're done with bracketing\n        else if num_opening_brackets >\
    \ num_closing_brackets {\n            return false;\n        }\n        // if\
    \ opening bracket is closed, we're done with bracketing\n        else {\n    \
    \        return false;\n        }\n\n        // find next opening bracket\n  \
    \      let mut next_opening_bracket = String::new();\n        let mut next_opening_bracket\
    \ = String::new();\n        let mut opening_brackets = String::new();\n\n    \
    \    let mut opening_brackets = String::new();\n        let mut next_opening_bracket\
    \ = String::new();\n        let mut next_opening_bracket = String::new();\n  \
    \      let mut opening_bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxm7b7ire.rs:81:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n18 |     while\
    \ num_opening_brackets != 0 && num_closing_brackets != 0 {\n   |             \
    \                                                     - this delimiter might not\
    \ be properly closed...\n...\n65 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n81 | }\n   |   ^\n\nerror: expected `;`, found `}`\n\
    \  --> /tmp/tmpxm7b7ire.rs:64:32\n   |\n64 |         let mut opening_bracket\n\
    \   |                                ^ help: add `;` here\n65 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxm7b7ire.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|b|\
    \ {\n        match b {\n            '(' | ')' => true,\n            _ => false,\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxevn3nnz.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets: Vec<String> = brackets\n        .chars()\n        .filter(|c|\
    \ c != '(' && c != ')')\n        .collect();\n    let mut close_brackets: Vec<String>\
    \ = brackets\n        .chars()\n        .filter(|c| c == ')' || c == ')')\n  \
    \      .collect();\n    open_brackets.sort();\n    close_brackets.sort();\n  \
    \  let open_brackets_iter = open_brackets.into_iter();\n    open_brackets_iter.for_each(|c|\
    \ {\n        if close_brackets.iter().any(|c| c == c + '(') {\n            return\
    \ false;\n        }\n    });\n    true\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvp8e3xyb.rs:14:23\n\
    \   |\n14 |         .filter(|c| c != '(' && c != ')')\n   |                  \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvp8e3xyb.rs:14:35\n\
    \   |\n14 |         .filter(|c| c != '(' && c != ')')\n   |                  \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpvp8e3xyb.rs:15:10\n\
    \     |\n15   |         .collect();\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpvp8e3xyb.rs:18:23\n   |\n18 |         .filter(|c| c == ')' || c\
    \ == ')')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpvp8e3xyb.rs:18:35\n   |\n18 |   \
    \      .filter(|c| c == ')' || c == ')')\n   |                               \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpvp8e3xyb.rs:19:10\n\
    \     |\n19   |         .collect();\n     |          ^^^^^^^ value of "
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n\n    brackets.chars().for_each(|c|\n     \
    \   if c == ')' {\n            stack.pop();\n        } else if c == '(' {\n  \
    \          stack.push(brackets.len());\n        }\n    });\n\n    stack.len()\
    \ == 0 && false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n \
    \   assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpe1iqj56q.rs:20:6\n\
    \   |\n18 |             stack.push(brackets.len());\n   |                    \
    \                -- block is empty, you might have not meant to close it\n19 |\
    \         }\n20 |     });\n   |      ^ unexpected closing delimiter\n\nerror:\
    \ mismatched closing delimiter: `}`\n  --> /tmp/tmpe1iqj56q.rs:14:30\n   |\n14\
    \ |     brackets.chars().for_each(|c|\n   |                              ^ unclosed\
    \ delimiter\n...\n20 |     });\n   |     ^ mismatched closing delimiter\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .enumerate()\n        .any(|(i, ch)| brackets.chars().any(|(_,\
    \ cb)| cb == ch) && i < brackets.len())\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbw3mbgq1.rs:15:46\n   |\n\
    15 |         .any(|(i, ch)| brackets.chars().any(|(_, cb)| cb == ch) && i < brackets.len())\n\
    \   |                                              ^^^^^^-\n   |             \
    \                                 |     |\n   |                              \
    \                |     expected due to this\n   |                            \
    \                  expected `char`, found tuple\n   |\n   = note: expected type\
    \ `char`\n             found tuple `(_, _)`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \n    for c in brackets {\n        if c == '(' {\n            open_bracket.push(')');\n\
    \        } else if c == ')' {\n            close_bracket.push('(');\n        }\
    \ else {\n            open_bracket.push('(');\n            close_bracket.push(')');\n\
    \        }\n    }\n\n    open_bracket.eq_ignore_ascii_case(close_bracket)\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsfwqevsp.rs:15:14\n\
    \   |\n15 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsfwqevsp.rs:26:39\n   |\n26 |     open_bracket.eq_ignore_ascii_case(close_bracket)\n\
    \   |                                       ^^^^^^^^^^^^^\n   |              \
    \                         |\n   |                                       expected\
    \ `&str`, found struct `String`\n   |                                       help:\
    \ consider borrowing here: `&close_bracket`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ This checks to see if all opening brackets have the same number of closing brackets.\n\
    \    let mut brackets_iter = brackets.char_indices();\n    let mut count = brackets.chars().count();\n\
    \    let mut current_opening_bracket = match brackets_iter.next() {\n        None\
    \ => return false,\n        Some((_, open_count)) => {\n            // Check to\
    \ see if the count of opening brackets is the same as the count of closing brackets.\n\
    \            if open_count != count {\n                return false;\n       \
    \     }\n            current_opening_bracket = Some((open_count, open_count));\n\
    \        }\n    };\n    // Iterate through the opening brackets and see if there\
    \ are any brackets in the correct position.\n    for opening_bracket in &mut brackets_iter\
    \ {\n        let (open_count, close_count) = current_opening_bracket.take().unwrap();\n\
    \        if opening_bracket.0 + close_count != opening_bracket.1 {\n         \
    \   return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `current_opening_bracket` in this scope\n\
    \  --> /tmp/tmp7l5qwhv1.rs:22:13\n   |\n22 |             current_opening_bracket\
    \ = Some((open_count, open_count));\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7l5qwhv1.rs:19:30\n\
    \   |\n19 |             if open_count != count {\n   |                       \
    \       ^^^^^ expected `char`, found `usize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut num_open_brackets: usize = 0;\n    for ch in brackets.chars() {\n      \
    \  match ch {\n            ')' => num_open_brackets += 1,\n            '(' | '['\
    \ => num_open_brackets -= 1,\n            _ => num_open_brackets,\n        }\n\
    \    }\n    num_open_brackets == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp3cr2d4z8.rs:17:18\n\
    \   |\n14 | /         match ch {\n15 | |             ')' => num_open_brackets\
    \ += 1,\n   | |                    ---------------------- this is found to be\
    \ of type `()`\n16 | |             '(' | '[' => num_open_brackets -= 1,\n   |\
    \ |                          ---------------------- this is found to be of type\
    \ `()`\n17 | |             _ => num_open_brackets,\n   | |                  ^^^^^^^^^^^^^^^^^\
    \ expected `()`, found `usize`\n18 | |         }\n   | |_________- `match` arms\
    \ have incompatible types\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut it = brackets.char_indices().filter_map(|(i, x)| {\n        if *x != \"\
    )\" && *x != \"]\" {\n            Some(i)\n        } else {\n            None\n\
    \        }\n    });\n    let mut stack: Vec<usize> = Vec::new();\n    loop {\n\
    \        match it.next() {\n            Some(0) => {\n                // if we\
    \ have a left parenthesis we push it\n                if stack.len() > 0 {\n \
    \                   stack.push(stack.last().unwrap());\n                    stack.pop();\n\
    \                }\n            }\n            Some(_) => {}\n            None\
    \ => {\n                let mut last_idx = stack.last().unwrap();\n          \
    \      let mut last_is_paren = false;\n                let mut last_is_bracket\
    \ = false;\n                loop {\n                    if stack.len() > 0 &&\
    \ stack.last().unwrap() < last_idx.unwrap() {\n                        last_is_paren\
    \ = true;\n                    }\n                    if stack.len() > 0 && stack.last().unwrap()\
    \ > last_idx.unwrap() {\n                        last_is_bracket = true;\n   \
    \                 }\n                    if stack.len() > 0 && (stack.last().unwrap()\
    \ - last_idx.unwrap()) != 1 {\n                        last_is_paren = true;\n\
    \                        last_is_bracket = true;\n                    }\n    \
    \                if stack.len() > 0 {\n                        stack.pop();\n\
    \                    }\n                    if stack.len() > 0 {\n           \
    \             stack.push(stack.last().unwrap() - 1);\n                       \
    \ stack.pop();\n                    }\n                    last_idx = stack.last().unwrap();\n\
    \                    if stack.len() == 0 || last_is_bracket {\n              \
    \          if last_is_paren {\n                            return false;\n   \
    \                     }\n                        break;\n                    }\n\
    \                    if stack.len() == 0 || last_is_paren {\n                \
    \        break;\n                    }\n                }\n            }\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpn_41645j.rs:13:12\n\
    \   |\n13 |         if *x != \")\" && *x != \"]\" {\n   |            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpn_41645j.rs:13:25\n   |\n\
    13 |         if *x != \")\" && *x != \"]\" {\n   |                         ^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn_41645j.rs:25:32\n   |\n25 |\
    \                     stack.push(stack.last().unwrap());\n   |               \
    \                 ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n25 |                     stack.push(*stack.last().unwrap());\n\
    \   |                                +\n\nerror[E0599]: no method named `unwrap`\
    \ found for reference `&usize` in the current scope\n  --> /tmp/tmpn_41645j.rs:35:76\n\
    \   |\n35 |                     if stack.len() > 0 && stack.last().unwrap() <\
    \ last_idx.unwrap() {\n   |                                                  \
    \                          ^^^^^^ method not found in `&usize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for reference `&usize` in the current scope\n\
    \  --> /tmp/tmpn_41645j.rs:38:76\n   |\n38 |                     if stack.len()\
    \ > 0 && stack.last().unwrap() > last_idx.unwrap() {\n   |                   \
    \                                                         ^^^^^^ method not found\
    \ in `&usize`\n\nerror[E0599]: no method named `unwrap` found for reference `&usize`\
    \ in the current scope\n  --> /tmp/tmpn_41645j.rs:41:77\n   |\n41 |          \
    \           if stack.len() > 0 && (stack.last().unwrap() - last_idx.unwrap())\
    \ != 1 {\n   |                                                               \
    \              ^^^^^^ method not found in `&usize`\n\nwarning: unreachable expression\n\
    \  --> /tmp/tmpn_41645j.rs:66:5\n   |\n20 | /     loop {\n21 | |         match\
    \ it.next() {\n22 | |             Some(0) => {\n23 | |                 // if we\
    \ have a left parenthesis we push it\n...  |\n64 | |         }\n65 | |     }\n\
    \   | |_____- any code following this expression is unreachable\n66 |       true\n\
    \   |       ^^^^ unreachable "
  stdout: ''
  timestamp: 1659976133
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\n\
    \        if c == ')' {\n            true\n        } else {\n            if c ==\
    \ '(' {\n                false\n            } else {\n                true\n \
    \           }\n        })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpecjwokn0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut last_open = 0;\n    let mut last_close = 0;\n    for char in brackets.chars()\
    \ {\n        if char == '(' {\n            last_open += 1;\n        } else if\
    \ char == ')' {\n            last_close += 1;\n        }\n        if last_open\
    \ > last_close {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5dw62u3c.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.contains(&BLANK)\
    \ ||\n        (brackets.contains(&OPEN_BRACKET) && brackets.contains(&CLOSE_BRACKET))\
    \ ||\n        (brackets.contains(&OPEN_BRACKET) && !brackets.contains(&CLOSE_BRACKET))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `BLANK` in this scope\n  --> /tmp/tmpnbgnjylu.rs:12:24\n\
    \   |\n12 |     brackets.contains(&BLANK) ||\n   |                        ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `OPEN_BRACKET` in\
    \ this scope\n  --> /tmp/tmpnbgnjylu.rs:13:29\n   |\n13 |         (brackets.contains(&OPEN_BRACKET)\
    \ && brackets.contains(&CLOSE_BRACKET)) ||\n   |                             ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CLOSE_BRACKET` in\
    \ this scope\n  --> /tmp/tmpnbgnjylu.rs:13:65\n   |\n13 |         (brackets.contains(&OPEN_BRACKET)\
    \ && brackets.contains(&CLOSE_BRACKET)) ||\n   |                             \
    \                                    ^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `OPEN_BRACKET` in this scope\n  --> /tmp/tmpnbgnjylu.rs:14:29\n\
    \   |\n14 |         (brackets.contains(&OPEN_BRACKET) && !brackets.contains(&CLOSE_BRACKET))\n\
    \   |                             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CLOSE_BRACKET` in this scope\n  --> /tmp/tmpnbgnjylu.rs:14:66\n\
    \   |\n14 |         (brackets.contains(&OPEN_BRACKET) && !brackets.contains(&CLOSE_BRACKET))\n\
    \   |                                                                  ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2cjp9dz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    if brackets.is_empty() {\n       \
    \ return false;\n    }\n    let mut opening_brackets: HashSet<&str>;\n    loop\
    \ {\n        if brackets.is_empty() {\n            return true;\n        }\n \
    \       let mut char = &mut brackets[..1];\n        loop {\n            if char\
    \ == \")\" {\n                brackets.pop();\n                return false;\n\
    \            }\n            if char == \"(\" {\n                brackets.push(char);\n\
    \                opening_brackets.insert(char);\n            }\n            if\
    \ char == \")\" {\n                opening_brackets.retain(|x| x == &char);\n\
    \                return opening_brackets.is_empty();\n            }\n        \
    \    char = &mut brackets[1..];\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp2kmfucwb.rs:16:31\n\
    \   |\n16 |     let mut opening_brackets: HashSet<&str>;\n   |               \
    \                ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2kmfucwb.rs:28:31\n   |\n28 |              \
    \   brackets.push(char);\n   |                               ^^^^ expected `char`,\
    \ found `&mut str`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0412.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<Box<String>> = vec![];\n    for (i, ch) in brackets.chars().enumerate()\
    \ {\n        if ch == '(' {\n            stack.push(Box::new(\"(\"));\n      \
    \  } else if ch == ')' {\n            stack.pop();\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ if stack.len() != 0 {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfv4kxlcu.rs:15:33\n   |\n\
    15 |             stack.push(Box::new(\"(\"));\n   |                          \
    \       ^^^- help: try using a conversion method: `.to_string()`\n   |       \
    \                          |\n   |                                 expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp04kge0f3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets {\n        stack.push(c);\n\
    \        if stack.len() > 2 {\n            if stack.pop() != c {\n           \
    \     return false;\n            }\n        }\n    }\n    stack.pop() != 0\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpwe7e3d4c.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwe7e3d4c.rs:16:31\n   |\n16 |             if stack.pop()\
    \ != c {\n   |                               ^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n16 |             if stack.pop()\
    \ != Some(c) {\n   |                               +++++ +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwe7e3d4c.rs:21:20\n   |\n21 |     stack.pop() != 0\n  \
    \ |                    ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n21 |     stack.pop() != Some(0)\n \
    \  |                    +++++ +\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut stack = Vec::new();\n    stack.push(0);\n\
    \    while brackets.len() > 0 {\n        let mut curr = stack.last().unwrap();\n\
    \        stack.pop();\n        if curr % 2 == 0 {\n            stack.push(curr\
    \ + 1);\n        } else {\n            let mut next = stack.pop().unwrap();\n\
    \            while next % 2 == 0 {\n                next = stack.pop().unwrap();\n\
    \            }\n            stack.push(next + 1);\n        }\n        curr = next;\n\
    \        brackets = &brackets[1..];\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `next` in this scope\n  --> /tmp/tmpgyf_rk5p.rs:27:16\n\
    \   |\n27 |         curr = next;\n   |                ^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgyf_rk5p.rs:28:20\n   |\n12 |\
    \     let mut brackets = brackets.to_string();\n   |                        --------------------\
    \ expected due to this value\n...\n28 |         brackets = &brackets[1..];\n \
    \  |                    ^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n28 |         brackets = (&brackets[1..]).to_string();\n\
    \   |                    +              +++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.contains(\"\
    (\") && brackets.contains(\")\")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0syfs6d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 2 {\n     \
    \   let mut left = brackets.chars().nth(1);\n        let mut right = brackets.chars().nth(2);\n\
    \        if left == '(' && right == ')' {\n            brackets.remove(2..).unwrap();\n\
    \        } else if left == ')' && right == '(' {\n            brackets.remove(1..).unwrap();\n\
    \        } else {\n            brackets.remove(1..).unwrap();\n            brackets.remove(2..).unwrap();\n\
    \        }\n    }\n    brackets.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__o_jk__.rs:16:20\n   |\n\
    16 |         if left == '(' && right == ')' {\n   |                    ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |         if left == Some('(') && right == ')' {\n   |             \
    \       +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp__o_jk__.rs:16:36\n\
    \   |\n16 |         if left == '(' && right == ')' {\n   |                   \
    \                 ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n16 |         if left == '(' && right == Some(')')\
    \ {\n   |                                    +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__o_jk__.rs:17:29\n   |\n17 |             brackets.remove(2..).unwrap();\n\
    \   |                             ^^^ expected `usize`, found struct `RangeFrom`\n\
    \   |\n   = note: expected type `usize`\n            found struct `RangeFrom<{integer}>`\n\
    \nerror[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp__o_jk__.rs:17:34\n   |\n17 |             brackets.remove(2..).unwrap();\n\
    \   |                                  ^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp__o_jk__.rs:18:27\n   |\n18 |         } else\
    \ if left == ')' && right == '(' {\n   |                           ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         } else if left == Some(')') && right == '(' {\n   |      \
    \                     +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp__o_jk__.rs:18:43\n\
    \   |\n18 |         } else if left == ')' && right == '(' {\n   |            \
    \                               ^^^ expected enum `Option`, found `char`\n   |\n\
    \   = note: expected enum `Option<char>`\n              found type `char`\nhel"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ {\n        c == '(' || c == ')'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvp5vr5sw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracket_stack = vec![];\n    let mut brackets_chars = brackets.chars();\n\
    \    let mut current = String::new();\n    while brackets_chars.next() && bracket_stack.len()\
    \ <= brackets.len() {\n        let mut next = brackets_chars.next();\n       \
    \ while next.unwrap() != ')' && next.unwrap() != ']' {\n            bracket_stack.push(next.unwrap());\n\
    \            current = current.push_str(next.unwrap());\n            next = brackets_chars.next();\n\
    \        }\n        if next.unwrap() == '[' {\n            bracket_stack.pop();\n\
    \            current = current.push_str(\"[\");\n        }\n    }\n    bracket_stack.len()\
    \ == brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnk3kp36.rs:15:11\n   |\n\
    15 |     while brackets_chars.next() && bracket_stack.len() <= brackets.len()\
    \ {\n   |           ^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found enum `Option`\n\
    \   |\n   = note: expected type `bool`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxnk3kp36.rs:19:40\n   |\n19 |\
    \             current = current.push_str(next.unwrap());\n   |               \
    \                         ^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxnk3kp36.rs:19:23\n   |\n14 |     let mut current\
    \ = String::new();\n   |                       ------------- expected due to this\
    \ value\n...\n19 |             current = current.push_str(next.unwrap());\n  \
    \ |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpxnk3kp36.rs:19:31\n   |\n19 |             current = current.push_str(next.unwrap());\n\
    \   |                       ------- ^^^^^^^^ this call modifies `current` in-place\n\
    \   |                       |\n   |                       you probably want to\
    \ use this value after calling the method...\n   = note: ...instead of the `()`\
    \ output of method `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnk3kp36.rs:24:23\n\
    \   |\n14 |     let mut current = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n24 |             current = current.push_str(\"\
    [\");\n   |                       ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpxnk3kp36.rs:24:31\n   |\n24 |             current = current.push_str(\"\
    [\");\n   |                       ------- ^^^^^^^^ this call modifies `current`\
    \ in-place\n   |                       |\n   |                       you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror: aborting due to 4 previous errors\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        if c == ')' {\n            false\n        } else if c == '(' {\n\
    \            true\n        } else {\n            false\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzva2ueov.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        if c == ')' {\n            true\n        } else if c == '(' {\n \
    \           false\n        } else {\n            true\n        }\n    })\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6vg1nt8n.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opened = 0;\n    let mut closed\
    \ = 0;\n    let mut i = 0;\n    while i < brackets.len() {\n        if brackets[i]\
    \ == \"(\" {\n            opened += 1;\n        } else {\n            closed +=\
    \ 1;\n        }\n        i += 1;\n    }\n    opened.is_zero() && closed.is_zero()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptay8a6mx.rs:17:12\n\
    \   |\n17 |         if brackets[i] == \"(\" {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0689]: can't call method `is_zero` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmptay8a6mx.rs:24:12\n   |\n24 |     opened.is_zero()\
    \ && closed.is_zero()\n   |            ^^^^^^^\n   |\nhelp: you must specify a\
    \ type for this binding, like `i32`\n   |\n13 |     let mut opened: i32 = 0;\n\
    \   |         ~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `is_zero` on\
    \ ambiguous numeric type `{integer}`\n  --> /tmp/tmptay8a6mx.rs:24:32\n   |\n\
    24 |     opened.is_zero() && closed.is_zero()\n   |                          \
    \      ^^^^^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n14 |     let mut closed: i32 = 0;\n   |         ~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0689.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut count = 1;\n    let mut opening = brackets.chars().enumerate().filter_map(|(i,\
    \ c)| {\n        if c == '(' {\n            *i += count;\n            true\n \
    \       } else {\n            false\n        }\n    }).collect::<Vec<_>>();\n\
    \    opening.sort_by_key(|x| x.0);\n    let mut closing = brackets.chars().enumerate().filter_map(|(i,\
    \ c)| {\n        if c == ')' {\n            *i += count;\n            true\n \
    \       } else {\n            false\n        }\n    }).collect::<Vec<_>>();\n\
    \    closing.sort_by_key(|x| x.0);\n    opening.len() == closing.len() || opening.iter().zip(closing.iter()).all().unwrap_or(true)\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpax_khfvt.rs:15:13\n\
    \   |\n15 |             *i += count;\n   |             ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpax_khfvt.rs:16:13\n   |\n16 |             true\n   |  \
    \           ^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n16 |             Some(true)\n   |             +++++    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpax_khfvt.rs:18:13\n   |\n18 |  \
    \           false\n   |             ^^^^^ expected enum `Option`, found `bool`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `bool`\n\
    help: try wrapping the expression in `Some`\n   |\n18 |             Some(false)\n\
    \   |             +++++     +\n\nerror[E0609]: no field `0` on type `&_`\n  -->\
    \ /tmp/tmpax_khfvt.rs:21:31\n   |\n21 |     opening.sort_by_key(|x| x.0);\n  \
    \ |                               ^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpax_khfvt.rs:24:13\n   |\n24 |             *i += count;\n   |  \
    \           ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax_khfvt.rs:25:13\n\
    \   |\n25 |             true\n   |             ^^^^ expected enum `Option`, found\
    \ `bool`\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `bool`\nhelp: try wrapping the expression in `Some`\n   |\n25 |            \
    \ Some(true)\n   |             +++++    +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpax_khfvt.rs:27:13\n   |\n27 |             false\n   |         \
    \    ^^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected enum\
    \ `Option<_>`\n              found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n27 |             Some(false)\n   |             +++++     +\n\
    \nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmpax_khfvt.rs:30:31\n \
    \  |\n30 |     closing.sort_by_key(|x| x.0);\n   |                           \
    \    ^\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0609, E0614.\nFor more information about an error, "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<Option<(usize, usize)>> = vec![None];\n    stack.push(Some((0,\
    \ 0)));\n    for i in 0..brackets.len() - 2 {\n        if stack.is_empty() {\n\
    \            return false;\n        }\n        let mut last_opened = Some(stack.pop().unwrap());\n\
    \        for j in i + 1..brackets.len() {\n            let (open, close) = brackets.chars().nth(i).unwrap().chars().nth(j).unwrap();\n\
    \            if open != close {\n                last_opened = Some((open, close));\n\
    \            }\n            stack.push(Some((open + last_opened.unwrap().0, close\
    \ + last_opened.unwrap().1)));\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpw464hh9a.rs:20:66\n   |\n20 |             let (open, close)\
    \ = brackets.chars().nth(i).unwrap().chars().nth(j).unwrap();\n   |          \
    \                                                        ^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw464hh9a.rs:22:36\n\
    \   |\n22 |                 last_opened = Some((open, close));\n   |         \
    \                           ^^^^^^^^^^^^^ expected enum `Option`, found tuple\n\
    \   |\n   = note: expected enum `Option<(usize, usize)>`\n             found tuple\
    \ `(_, _)`\nhelp: try wrapping the expression in `Some`\n   |\n22 |          \
    \       last_opened = Some(Some((open, close)));\n   |                       \
    \             +++++             +\n\nerror[E0609]: no field `0` on type `Option<(usize,\
    \ usize)>`\n  --> /tmp/tmpw464hh9a.rs:24:58\n   |\n24 |             stack.push(Some((open\
    \ + last_opened.unwrap().0, close + last_opened.unwrap().1)));\n   |         \
    \                                                 ^\n\nerror[E0609]: no field\
    \ `1` on type `Option<(usize, usize)>`\n  --> /tmp/tmpw464hh9a.rs:24:90\n   |\n\
    24 |             stack.push(Some((open + last_opened.unwrap().0, close + last_opened.unwrap().1)));\n\
    \   |                                                                        \
    \                  ^\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c != '(' && c != ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8_bkuddd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ match c {\n        '(' => true,\n        _ => false,\n    })\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbcb9wd7j.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_count = 0\n    let mut close_count = 0\n    let mut inside_quote =\
    \ false\n    let mut inside_bracket = false;\n\n    for c in brackets.chars()\
    \ {\n        if c == quote_delimiter {\n            if !inside_quote {\n     \
    \           inside_quote = true;\n            } else {\n                return\
    \ false;\n            }\n        } else {\n            if c == bracket_delimiter\
    \ {\n                if !inside_bracket {\n                    inside_bracket\
    \ = true;\n                } else {\n                    return false;\n     \
    \           }\n            } else {\n                if !inside_quote && !inside_bracket\
    \ {\n                    if c == open_bracket_delimiter {\n                  \
    \      open_count += 1;\n                    } else if c == close_bracket_delimiter\
    \ {\n                        close_count += 1;\n                    }\n      \
    \          }\n            }\n        }\n    }\n\n    if close_count != open_count\
    \ {\n        return false;\n    }\n\n    if open_count == 0 && close_count ==\
    \ 0 {\n        return true;\n    }\n\n    if close_count == 0 {\n        return\
    \ false;\n    }\n\n    for c in brackets.chars() {\n        if c == quote_delimiter\
    \ {\n            inside_quote = false;\n        } else if c == bracket_delimiter\
    \ {\n            inside_bracket = false;\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp6m3ks90t.rs:12:27\n\
    \   |\n12 |     let mut open_count = 0\n   |                           ^ help:\
    \ add `;` here\n13 |     let mut close_count = 0\n   |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp6m3ks90t.rs:13:28\n\
    \   |\n13 |     let mut close_count = 0\n   |                            ^ help:\
    \ add `;` here\n14 |     let mut inside_quote = false\n   |     --- unexpected\
    \ token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp6m3ks90t.rs:14:33\n\
    \   |\n14 |     let mut inside_quote = false\n   |                           \
    \      ^ help: add `;` here\n15 |     let mut inside_bracket = false;\n   |  \
    \   --- unexpected token\n\nerror[E0425]: cannot find value `quote_delimiter`\
    \ in this scope\n  --> /tmp/tmp6m3ks90t.rs:18:17\n   |\n18 |         if c == quote_delimiter\
    \ {\n   |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `bracket_delimiter` in this scope\n  --> /tmp/tmp6m3ks90t.rs:25:21\n\
    \   |\n25 |             if c == bracket_delimiter {\n   |                    \
    \ ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `open_bracket_delimiter` in this scope\n  --> /tmp/tmp6m3ks90t.rs:33:29\n  \
    \ |\n33 |                     if c == open_bracket_delimiter {\n   |         \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `close_bracket_delimiter` in this scope\n  --> /tmp/tmp6m3ks90t.rs:35:36\n\
    \   |\n35 |                     } else if c == close_bracket_delimiter {\n   |\
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `quote_delimiter` in this scope\n \
    \ --> /tmp/tmp6m3ks90t.rs:56:17\n   |\n56 |         if c == quote_delimiter {\n\
    \   |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `bracket_delimiter` in this scope\n  --> /tmp/tmp6m3ks90t.rs:58:24\n\
    \   |\n58 |         } else if c == bracket_delimiter {\n   |                 \
    \       ^^^^^^^^^^^^^^^^^ not found in th"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\").replace(\"\
    \ \", \"\");\n    brackets.replace(\")\", \")\").replace(\" \", \"\");\n    brackets.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxrad25ww.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ First count how many opening brackets there are\n    let mut open_count = 1;\n\
    \    for i in brackets.chars().cloned() {\n        if *i == ')' {\n          \
    \  open_count = 1;\n        } else {\n            open_count += 1;\n        }\n\
    \    }\n\n    // Now check whether every opening bracket has a corresponding closing\
    \ bracket\n    for i in 0..open_count {\n        let open_char = brackets.chars().nth(i);\n\
    \        if open_char != '(' {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpfkmya60l.rs:14:31\n     |\n14   |     for i in brackets.chars().cloned()\
    \ {\n     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpfkmya60l.rs:14:14\n\
    \   |\n14 |     for i in brackets.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpfkmya60l.rs:14:14\n   |\n14 |     for i in brackets.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfkmya60l.rs:25:25\n   |\n25 |\
    \         if open_char != '(' {\n   |                         ^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n    \
    \          found type `char`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n25 |         if open_char != Some('(') {\n   |                         +++++\
    \   +\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut parens = brackets.chars().enumerate();\n    for (i, c) in parens {\n   \
    \     if c == '(' { parens.next_back(); }\n        if c == ')' { parens.next_back();\
    \ }\n        if c == ')' && !parens.next_back() || c == '(' && !parens.next()\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `next_back` exists for struct `Enumerate<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp9ml7f2lj.rs:14:30\n \
    \  |\n14 |           if c == '(' { parens.next_back(); }\n   |               \
    \                 ^^^^^^^^^ method cannot be called on `Enumerate<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n           which\
    \ is required by `Enumerate<Chars<'_>>: DoubleEndedIterator`\n\nerror[E0599]:\
    \ the method `next_back` exists for struct `Enumerate<Chars<'_>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp9ml7f2lj.rs:15:30\n   |\n15 |     \
    \      if c == ')' { parens.next_back(); }\n   |                             \
    \   ^^^^^^^^^ method cannot be called on `Enumerate<Chars<'_>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Chars<'_>: ExactSizeIterator`\n           which is required by `Enumerate<Chars<'_>>:\
    \ DoubleEndedIterator`\n\nerror[E0599]: the method `next_back` exists for struct\
    \ `Enumerate<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp9ml7f2lj.rs:16:32\n\
    \   |\n16 |           if c == ')' && !parens.next_back() || c == '(' && !parens.next()\
    \ {\n   |                                  ^^^^^^^^^ method cannot be called on\
    \ `Enumerate<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n\
    \           which is required by `Enumerate<Chars<'_>>: DoubleEndedIterator`\n\
    \nerror[E0600]: cannot apply unary operator `!` to type `Option<(usize, char)>`\n\
    \  --> /tmp/tmp9ml7f2lj.rs:16:59\n   |\n16 |         if c == ')' && !parens.next_back()\
    \ || c == '(' && !parens.next() {\n   |                                      \
    \                     ^^^^^^^^^^^^^^ cannot apply unary operator `!`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0600.\nFor more information about an error, try `rustc --explain E059"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Look for empty brackets.\n    let mut brackets = brackets.clone();\n    if brackets.is_empty()\
    \ {\n        return true;\n    }\n\n    let mut stack = [String::from(\"(\")];\n\
    \    while let Some(item) = stack.pop() {\n        if item == String::from(\"\
    )\") {\n            // If we hit an empty (, then we know that everything after\
    \ it is an\n            // opening bracket and we know that everything before\
    \ is a closing\n            // bracket.\n            if stack.len() > 0 {\n  \
    \              return false;\n            }\n            // If we didn't hit an\
    \ empty (, then we know that everything before is a\n            // closing bracket.\n\
    \            stack.push(String::from(\"(\"));\n        } else {\n            //\
    \ If we hit an opening bracket, then we know that everything after it is\n   \
    \         // a closing bracket.\n            if item != String::from(\"(\") {\n\
    \                return false;\n            }\n            // If we didn't hit\
    \ an opening bracket, then we know that everything before\n            // is an\
    \ opening bracket.\n            stack.push(String::from(\"\"));\n        }\n \
    \   }\n\n    // If we reach the end of the brackets string, then we have a complete\
    \ match on\n    // the opening brackets and we don't need to do any more processing.\n\
    \    stack.iter().all(|x| x == String::from(\"\"))\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for array `[String; 1]` in the\
    \ current scope\n  --> /tmp/tmp5497vbqc.rs:19:34\n   |\n19 |     while let Some(item)\
    \ = stack.pop() {\n   |                                  ^^^ method not found\
    \ in `[String; 1]`\n\nerror[E0599]: no method named `push` found for array `[String;\
    \ 1]` in the current scope\n  --> /tmp/tmp5497vbqc.rs:29:19\n   |\n29 |      \
    \       stack.push(String::from(\"(\"));\n   |                   ^^^^ method not\
    \ found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for array\
    \ `[String; 1]` in the current scope\n  --> /tmp/tmp5497vbqc.rs:38:19\n   |\n\
    38 |             stack.push(String::from(\"\"));\n   |                   ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0277]: can't compare `&String` with\
    \ `String`\n  --> /tmp/tmp5497vbqc.rs:44:28\n   |\n44 |     stack.iter().all(|x|\
    \ x == String::from(\"\"))\n   |                            ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter1 = brackets.char_indices();\n    let mut iter2 = brackets.char_indices();\n\
    \    let mut stack: Vec<usize> = Vec::new();\n    for (mut i1, _) in iter1 {\n\
    \        if stack.is_empty() {\n            stack.append(i1);\n        } else\
    \ {\n            let mut i2 = stack.pop().unwrap();\n            while i1 < i2\
    \ {\n                iter2 = iter1.clone();\n                let (mut i3, c) =\
    \ iter2.next();\n                if c == ')' {\n                    stack.push(i3);\n\
    \                } else {\n                    iter1 = iter2;\n              \
    \  }\n            }\n        }\n    }\n    iter1.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsgtc5zcj.rs:17:26\n   |\n\
    17 |             stack.append(i1);\n   |                          ^^ expected\
    \ `&mut Vec<usize>`, found `usize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<usize>`\n                           found type `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsgtc5zcj.rs:22:21\n   |\n22 |              \
    \   let (mut i3, c) = iter2.next();\n   |                     ^^^^^^^^^^^   ------------\
    \ this expression has type `Option<(usize, char)>`\n   |                     |\n\
    \   |                     expected enum `Option`, found tuple\n   |\n   = note:\
    \ expected enum `Option<(usize, char)>`\n             found tuple `(_, _)`\n\n\
    error[E0599]: no method named `is_empty` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmpsgtc5zcj.rs:31:11\n   |\n31 |     iter1.is_empty()\n\
    \   |           ^^^^^^^^ method not found in `CharIndices<'_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter_mut = brackets.chars().enumerate().map(|(pos, ch)| {\n        let next\
    \ = brackets.chars().enumerate().find(|(_, ch2)| ch2 == ch);\n        if let Some(next)\
    \ = next {\n            (next.0, ch)\n        } else {\n            (pos, ch)\n\
    \        }\n    }).collect::<Vec<_>>();\n    iter_mut.sort_unstable_by(|(a, b)|\
    \ (a.0, b.0));\n    let mut stack_mut = Vec::new();\n    loop {\n        loop\
    \ {\n            let pos = iter_mut.pop().unwrap();\n            let ch = iter_mut.pop().unwrap();\n\
    \            match stack_mut.get(pos.0 - 1) {\n                Some(last_bracket)\
    \ => {\n                    match last_bracket {\n                        None\
    \ => {}\n                        Some((_, ch2)) => {\n                       \
    \     if ch2 == ch {\n                                stack_mut[pos.0] = (pos.0,\
    \ ch);\n                                return true;\n                       \
    \     }\n                        }\n                    }\n                }\n\
    \                None => {\n                    stack_mut.push(vec![pos.0, ch]);\n\
    \                }\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvqb0buts.rs:13:69\n\
    \   |\n13 |         let next = brackets.chars().enumerate().find(|(_, ch2)| ch2\
    \ == ch);\n   |                                                              \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0593]: closure is expected to take 2 distinct arguments,\
    \ but it takes a single 2-tuple as argument\n  --> /tmp/tmpvqb0buts.rs:20:14\n\
    \   |\n20 |     iter_mut.sort_unstable_by(|(a, b)| (a.0, b.0));\n   |        \
    \      ^^^^^^^^^^^^^^^^ -------- takes a single 2-tuple as argument\n   |    \
    \          |\n   |              expected closure that takes 2 distinct arguments\n\
    \   |\nhelp: change the closure to take multiple arguments instead of a single\
    \ tuple\n   |\n20 |     iter_mut.sort_unstable_by(|a, b| (a.0, b.0));\n   |  \
    \                             ~~~~~~\n\nerror[E0277]: can't compare `&_` with\
    \ `(usize, char)`\n  --> /tmp/tmpvqb0buts.rs:31:36\n   |\n31 | ...           \
    \        if ch2 == ch {\n   |                              ^^ no implementation\
    \ for `&_ == (usize, char)`\n   |\n   = help: the trait `PartialEq<(usize, char)>`\
    \ is not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvqb0buts.rs:32:52\n\
    \   |\n32 | ...                   stack_mut[pos.0] = (pos.0, ch);\n   |      \
    \                 ----------------   ^^^^^^^^^^^ expected enum `Option`, found\
    \ tuple\n   |                       |\n   |                       expected due\
    \ to the type of this binding\n   |\n   = note: expected enum `Option<(_, _)>`\n\
    \             found tuple `(usize, (usize, char))`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n32 |                                 stack_mut[pos.0] = Some((pos.0,\
    \ ch));\n   |                                                    +++++       \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvqb0buts.rs:39:48\n  \
    \ |\n39 |                     stack_mut.push(vec![pos.0, ch]);\n   |         \
    \                                "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = 0;\n    for c in brackets {\n        if c == '(' {\n   \
    \         open_brackets += 1;\n        } else if c == ')' {\n            open_brackets\
    \ -= 1;\n        } else {\n            return false;\n        }\n    }\n    open_brackets\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpyfufix9p.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = vec![];\n    let mut closed_brackets = vec![];\n\n    brackets.char_indices().for_each(|(index,\
    \ char)| {\n        if char == '(' {\n            open_brackets.push(index);\n\
    \        } else if char == ')' {\n            closed_brackets.push(index);\n \
    \       }\n    });\n\n    open_brackets.len() == closed_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7ph19c5c.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|char|\
    \ char == '(' || char == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpswf154h6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ brackets_map.contains(&c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `brackets_map` in this scope\n  --> /tmp/tmp71spd9wt.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| brackets_map.contains(&c))\n   |    \
    \                          ^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = VecDeque::new();\n    let mut has_closing = false;\n    for ch in\
    \ brackets {\n        if ch == '(' {\n            stack.push_back('(');\n    \
    \    } else if ch == ')' {\n            stack.pop_back();\n            if stack.is_empty()\
    \ {\n                has_closing = true;\n                break;\n           \
    \ }\n        } else {\n            break;\n        }\n    }\n    has_closing\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmp3jtq1qr9.rs:12:21\n   |\n12 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0277]: `String` is not an iterator\n  --> /tmp/tmp3jtq1qr9.rs:14:15\n \
    \  |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    for open in \"()\".chars() {\n   \
    \     let mut next = &mut brackets[brackets.len() - 1];\n        if next == open\
    \ {\n            next = next;\n            brackets.pop();\n        } else if\
    \ next != ')' {\n            return false;\n        }\n    }\n    brackets ==\
    \ \"\"\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp19ps26uy.rs:14:29\n\
    \   |\n14 |         let mut next = &mut brackets[brackets.len() - 1];\n   |  \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&mut _` with `char`\n  --> /tmp/tmp19ps26uy.rs:15:17\n\
    \   |\n15 |         if next == open {\n   |                 ^^ no implementation\
    \ for `&mut _ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&mut _`\n\nerror[E0277]: can't compare `&mut _` with `char`\n  --> /tmp/tmp19ps26uy.rs:18:24\n\
    \   |\n18 |         } else if next != ')' {\n   |                        ^^ no\
    \ implementation for `&mut _ == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&mut _`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.len()\
    \ == brackets.chars().count() || brackets.len() == brackets.chars().count(|c|\
    \ *c == '(' && c != ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpc16so5v_.rs:12:93\n\
    \   |\n12 |     brackets.len() == brackets.chars().count() || brackets.len() ==\
    \ brackets.chars().count(|c| *c == '(' && c != ')')\n   |                    \
    \                                                                         ^ consider\
    \ giving this closure parameter a type\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmpc16so5v_.rs:12:86\n    |\n12  |     brackets.len()\
    \ == brackets.chars().count() || brackets.len() == brackets.chars().count(|c|\
    \ *c == '(' && c != ')')\n    |                                              \
    \                                        ^^^^^ ------------------------- supplied\
    \ 1 argument\n    |                                                          \
    \                            |\n    |                                        \
    \                                              expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<_> = Vec::new();\n    let mut has_open = false;\n    let mut\
    \ has_closed = false;\n    let mut depth = 0;\n    for c in brackets {\n     \
    \   if c == '(' && !has_open {\n            stack.push(depth);\n            has_open\
    \ = true;\n        } else if c == '[' && !has_close {\n            stack.push(depth);\n\
    \            has_closed = true;\n        } else if c == ')' && !has_open {\n \
    \           if depth == 0 {\n                return false;\n            }\n  \
    \          depth = stack.pop();\n        } else if c == ']' && !has_close {\n\
    \            if depth == 0 {\n                return false;\n            }\n \
    \           depth = stack.pop();\n        } else {\n            depth = stack.pop();\n\
    \        }\n    }\n    depth == 0 && has_open && has_closed\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `has_close` in this scope\n  --> /tmp/tmpt0gevkqc.rs:20:32\n\
    \   |\n20 |         } else if c == '[' && !has_close {\n   |                 \
    \               ^^^^^^^^^ help: a local variable with a similar name exists: `has_closed`\n\
    \nerror[E0425]: cannot find value `has_close` in this scope\n  --> /tmp/tmpt0gevkqc.rs:28:32\n\
    \   |\n28 |         } else if c == ']' && !has_close {\n   |                 \
    \               ^^^^^^^^^ help: a local variable with a similar name exists: `has_closed`\n\
    \nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpt0gevkqc.rs:16:14\n\
    \   |\n16 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt0gevkqc.rs:27:21\n   |\n15 |     let mut depth = 0;\n\
    \   |                     - expected due to this value\n...\n27 |            \
    \ depth = stack.pop();\n   |                     ^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt0gevkqc.rs:32:21\n\
    \   |\n15 |     let mut depth = 0;\n   |                     - expected due to\
    \ this value\n...\n32 |             depth = stack.pop();\n   |               \
    \      ^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected\
    \ type `{integer}`\n              found enum `Option<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt0gevkqc.rs:34:21\n   |\n15 |     let mut depth\
    \ = 0;\n   |                     - expected due to this value\n...\n34 |     \
    \        depth = stack.pop();\n   |                     ^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<{integer}>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more i"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .any(|c| brackets.chars().any(|d| c == d))\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwdol4i_o.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut counter = 0;\n    let mut\
    \ is_right = true;\n    while bracket_exists(&mut brackets, &mut counter, &mut\
    \ is_right) {\n        bracket_exists(&mut brackets, &mut counter, &mut is_right);\n\
    \    }\n    brackets.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `bracket_exists` in this scope\n  -->\
    \ /tmp/tmp41f1eyzi.rs:15:11\n   |\n15 |     while bracket_exists(&mut brackets,\
    \ &mut counter, &mut is_right) {\n   |           ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `bracket_exists` in this scope\n\
    \  --> /tmp/tmp41f1eyzi.rs:16:9\n   |\n16 |         bracket_exists(&mut brackets,\
    \ &mut counter, &mut is_right);\n   |         ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() == 0 {\n        return true;\n    }\n\n    // We are going to\
    \ find the first opening bracket and count the number of\n    // closing brackets\
    \ until we find an opening bracket with no corresponding\n    // closing bracket.\
    \  For example, if we find an opening bracket '(' in bracket\n    // string '(()())',\
    \ we assume that every opening bracket has a corresponding\n    // closing bracket\
    \ '(' and will move to find another opening bracket after\n    // the first closing\
    \ bracket in brackets string.  As a result, we can find\n    // the opening bracket\
    \ '(' in brackets string, but the first closing bracket\n    // is missing from\
    \ the string.\n    let mut opening_bracket = String::new();\n    let mut num_closing_brackets\
    \ = brackets.len();\n\n    // Move the first opening bracket to opening_bracket\
    \ and check if\n    // brackets string is empty.\n    while !brackets.is_empty()\
    \ {\n        let next = brackets.chars().next().unwrap();\n        if next ==\
    \ '(' {\n            opening_bracket = next\n                .to_string()\n  \
    \              .trim_start_matches('(', true) // ignore leading '('\n        \
    \        .trim_end_matches(')', true) // ignore trailing ')'\n               \
    \ .to_string();\n            num_closing_brackets = num_closing_brackets - 1;\n\
    \        } else {\n            // We reached a closing bracket.  We need to move\
    \ to find\n            // the next opening bracket.  In the example, the next\
    \ opening\n            // bracket is ')'.  So we move to find the next opening\
    \ bracket\n            // in the string and add 1 to num_closing_brackets.  We\
    \ can\n            // also check if brackets string is empty at this point.\n\
    \            brackets = brackets\n                .chars()\n                .skip_while(|c|\
    \ c != '(')\n                .skip_while(|c| c != ')')\n                .collect();\n\
    \            opening_bracket = next\n                .to_string()\n          \
    \      .trim_start_matches('(', true) // ignore leading '('\n                .trim_end_matches(')',\
    \ true) // ignore trailing ')'\n                .to_string();\n            num_closing_brackets\
    \ = num_closing_brackets + 1;\n        }\n    }\n\n    // At this point, we know\
    \ that opening_bracket has exactly one opening\n    // bracket.  Therefore, we\
    \ know that num_closing_brackets is one less than the\n    // total number of\
    \ closing brackets.  Therefore, we can check if opening_bracket\n    // has another\
    \ opening bracket.\n    if num_closing_brackets > 0 {\n        return false;\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp81k1sbfd.rs:34:18\n     |\n34   |                 .trim_start_matches('(',\
    \ true) // ignore leading '('\n     |                  ^^^^^^^^^^^^^^^^^^ ---\
    \  ---- supplied 2 arguments\n     |                  |\n     |              \
    \    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp81k1sbfd.rs:35:18\n\
    \     |\n35   |                 .trim_end_matches(')', true) // ignore trailing\
    \ ')'\n     |                  ^^^^^^^^^^^^^^^^ ---  ---- supplied 2 arguments\n\
    \     |                  |\n     |                  expected 1 argument\n    \
    \ |\nnote: associated function defined here\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp81k1sbfd.rs:46:35\n   |\n46 |                 .skip_while(|c|\
    \ c != '(')\n   |                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp81k1sbfd.rs:47:35\n   |\n47\
    \ |                 .skip_while(|c| c != ')')\n   |                          \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0061]: this function takes 1 argument but\
    \ 2 arguments were supplied\n    --> /tmp/tmp81k1sbfd.rs:51:18\n     |\n51   |\
    \                 .trim_start_matches('(', true) // ignore leading '('\n     |\
    \                  ^^^^^^^^^^^^^^^^^^ ---  ---- supplied 2 arguments\n     | \
    \                 |\n     |                  expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmp81k1sbfd.rs:52:18\n     |\n52\
    \   |                 .trim_end_matches(')', true) // ignore trailing ')'\n  \
    \   |           "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut current = brackets.as_bytes();\n    let mut next = current.clone();\n\n\
    \    while !next.is_empty() {\n        if *next != b'(' {\n            return\
    \ false;\n        }\n\n        next.pop();\n    }\n\n    current.pop();\n\n  \
    \  current == brackets.as_bytes()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for reference `&[u8]` in the\
    \ current scope\n  --> /tmp/tmpi_eyljwj.rs:20:14\n   |\n20 |         next.pop();\n\
    \   |              ^^^ method not found in `&[u8]`\n\nerror[E0277]: can't compare\
    \ `[u8]` with `u8`\n  --> /tmp/tmpi_eyljwj.rs:16:18\n   |\n16 |         if *next\
    \ != b'(' {\n   |                  ^^ no implementation for `[u8] == u8`\n   |\n\
    \   = help: the trait `PartialEq<u8>` is not implemented for `[u8]`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&[B]\
    \ as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n       \
    \      <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U,\
    \ A>>>\n             <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut\
    \ [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror[E0599]: no method named `pop` found for reference\
    \ `&[u8]` in the current scope\n  --> /tmp/tmpi_eyljwj.rs:23:13\n   |\n23 |  \
    \   current.pop();\n   |             ^^^ method not found in `&[u8]`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.is_empty() {\n        return true;\n    }\n    let mut iter = brackets.char_indices();\n\
    \    let mut depth = 0;\n    for (i, c) in iter.next_back() {\n        depth =\
    \ depth * 4 + 1;\n        if c == '(' {\n            depth++;\n        }\n   \
    \     if c == ')' {\n            depth--;\n        }\n        if depth == 0 {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp46ss_hnz.rs:20:18\n\
    \   |\n20 |             depth++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |             { let tmp =\
    \ depth; depth += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    20 -             depth++;\n20 +             depth += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmp46ss_hnz.rs:23:20\n   |\n23 |         \
    \    depth--;\n   |                    ^ expected expression\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '{' || c == '[') || brackets.chars().all(|c| c == ')' || c\
    \ == '}' || c == ']')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz7dl0k0j.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .split_ascii_words()\n        .into_iter()\n        .all(|word| word.chars().all(|c|\
    \ c == '(' || c == ')'))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_ascii_words` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp3hhovfp9.rs:13:10\n   |\n13 |         .split_ascii_words()\n\
    \   |          ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<String> = vec![\"\".to_string()];\n    for (i, c) in brackets.chars().enumerate()\
    \ {\n        stack = stack\n            .iter_mut()\n            .map(|s| s.push(c))\n\
    \            .collect();\n        if stack.iter().all(|c| c.chars().all(|b| b\
    \ == c)) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `()`\n    --> /tmp/tmpjxcpdttj.rs:17:14\n     |\n17  \
    \ |             .collect();\n     |              ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=()>`\n     |\n     = help: the\
    \ trait `FromIterator<()>` is not implemented for `Vec<String>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxcpdttj.rs:18:56\n\
    \   |\n18 |         if stack.iter().all(|c| c.chars().all(|b| b == c)) {\n   |\
    \                                                        ^ expected `char`, found\
    \ `&String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.len()\
    \ % 2 != 0\n        || (brackets.len() / 2 < brackets.len() / 2)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfam18cm8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() <= 1 {\n        return false;\n    }\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk6iv2t1s.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut s = brackets;\n    s.remove_suffix(\")\");\n    s.remove_prefix(\"(\");\n\
    \    s.chars().all(|c| *c == '(' || c == ')')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_suffix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp7lixtyqg.rs:13:7\n   |\n13 |     s.remove_suffix(\"\
    )\");\n   |       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `remove_prefix` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp7lixtyqg.rs:14:7\n   |\n14 |     s.remove_prefix(\"(\");\n   |\
    \       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp7lixtyqg.rs:15:23\n   |\n15 |     s.chars().all(|c|\
    \ *c == '(' || c == ')')\n   |                       ^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .split_ascii_whitespace()\n        .filter(|c| !c.is_ascii_alphanumeric())\n\
    \        .all(|c| c.is_ascii_alphanumeric())\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_alphanumeric` found for reference\
    \ `&&str` in the current scope\n  --> /tmp/tmpnwka99_8.rs:14:24\n   |\n14 |  \
    \       .filter(|c| !c.is_ascii_alphanumeric())\n   |                        ^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `&&str`\n\nerror[E0599]: no method named `is_ascii_alphanumeric`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpnwka99_8.rs:15:20\n\
    \   |\n15 |         .all(|c| c.is_ascii_alphanumeric())\n   |                \
    \    ^^^^^^^^^^^^^^^^^^^^^ method not found in `&str`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets: Vec<_> = brackets.chars().filter_map(|c| {\n        if c\
    \ == b'(' {\n            Some(b'(')\n        } else if c == b')' {\n         \
    \   Some(b')')\n        } else {\n            None\n        }\n    }).collect();\n\
    \n    for open_bracket in open_brackets {\n        let mut close_brackets: Vec<_>\
    \ = brackets.chars().filter_map(|c| {\n            if c == b'(' {\n          \
    \      Some(b'(')\n            } else if c == b')' {\n                Some(b')')\n\
    \            } else {\n                None\n            }\n        }).collect();\n\
    \n        if close_brackets.contains(open_bracket) {\n            // The pair\
    \ is correct\n            continue;\n        }\n\n        // If we get here, the\
    \ pair is incorrect\n        return false;\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp72rm4gl3.rs:13:17\n   |\n\
    13 |         if c == b'(' {\n   |                 ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72rm4gl3.rs:15:24\n  \
    \ |\n15 |         } else if c == b')' {\n   |                        ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72rm4gl3.rs:24:21\n\
    \   |\n24 |             if c == b'(' {\n   |                     ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72rm4gl3.rs:26:28\n\
    \   |\n26 |             } else if c == b')' {\n   |                          \
    \  ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72rm4gl3.rs:33:36\n\
    \   |\n33 |         if close_brackets.contains(open_bracket) {\n   |         \
    \                           ^^^^^^^^^^^^\n   |                               \
    \     |\n   |                                    expected `&u8`, found `u8`\n\
    \   |                                    help: consider borrowing here: `&open_bracket`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps8s_l340.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n\n    for i in 0..brackets.len() {\n        let c =\
    \ brackets[i];\n        if stack.iter().all(|c| *c == c) { // in stack\n     \
    \       stack.pop();\n        } else {\n            stack.push(c);\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_ww5bp98.rs:15:17\n\
    \   |\n15 |         let c = brackets[i];\n   |                 ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ count the number of opening brackets\n    let mut cnt = 0;\n    for ch in brackets.chars()\
    \ {\n        if ch == ')' {\n            cnt -= 1;\n        } else if ch == '('\
    \ {\n            cnt += 1;\n        }\n        if cnt == 0 {\n            return\
    \ false;\n        }\n    }\n\n    // no opening brackets\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3id487rb.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.ends_with('(') && brackets.ends_with(')')\n\
    \        || brackets.ends_with('[') && brackets.ends_with(']')\n        || brackets.ends_with('{')\
    \ && brackets.ends_with('}') {\n        if brackets.ends_with('(')\n         \
    \   || brackets.ends_with('[')\n            || brackets.ends_with('{')\n     \
    \       || brackets.ends_with(')')\n            || brackets.ends_with(']') {\n\
    \            brackets = &brackets[..brackets.len() - 1] + \")\";\n        } else\
    \ {\n            brackets = &brackets[..brackets.len() - 1] + \"(\";\n       \
    \ }\n    }\n    brackets.ends_with(')')\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpcql9aim6.rs:21:56\n\
    \   |\n21 |             brackets = &brackets[..brackets.len() - 1] + \")\";\n\
    \   |                        ------------------------------- ^ --- &str\n   |\
    \                        |                               |\n   |             \
    \           |                               `+` cannot be used to concatenate\
    \ two `&str` strings\n   |                        &str\n   |\n   = note: string\
    \ concatenation requires an owned `String` on the left\nhelp: remove the borrow\
    \ to obtain an owned `String`\n   |\n21 -             brackets = &brackets[..brackets.len()\
    \ - 1] + \")\";\n21 +             brackets = brackets[..brackets.len() - 1] +\
    \ \")\";\n   | \n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpcql9aim6.rs:23:56\n\
    \   |\n23 |             brackets = &brackets[..brackets.len() - 1] + \"(\";\n\
    \   |                        ------------------------------- ^ --- &str\n   |\
    \                        |                               |\n   |             \
    \           |                               `+` cannot be used to concatenate\
    \ two `&str` strings\n   |                        &str\n   |\n   = note: string\
    \ concatenation requires an owned `String` on the left\nhelp: remove the borrow\
    \ to obtain an owned `String`\n   |\n23 -             brackets = &brackets[..brackets.len()\
    \ - 1] + \"(\";\n23 +             brackets = brackets[..brackets.len() - 1] +\
    \ \"(\";\n   | \n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() == 0 {\n        return false;\n    }\n    for bracket in brackets.chars().rev()\
    \ {\n        match bracket {\n            '(' => return true,\n            _ =>\
    \ return false,\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppgltsarx.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::with_capacity(5);\n    stack.append(brackets);\n    for s in\
    \ &stack[1..] {\n        if s.starts_with(\"(\") {\n            if stack.pop().unwrap().ends_with(\"\
    )\") {\n                return false;\n            }\n        } else {\n     \
    \       if stack.pop().unwrap().ends_with(\"(\") {\n                return false;\n\
    \            }\n        }\n        stack.append(s);\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprliq4rih.rs:13:18\n   |\n\
    13 |     stack.append(brackets);\n   |                  ^^^^^^^^ expected `&mut\
    \ Vec<_>`, found struct `String`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                         found struct `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().fold(false,\
    \ |mut acc, c| *acc && *c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmpiiwfhbmv.rs:12:47\n\
    \   |\n12 |     brackets.chars().fold(false, |mut acc, c| *acc && *c == '(')\n\
    \   |                                               ^^^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpiiwfhbmv.rs:12:55\n   |\n12 | \
    \    brackets.chars().fold(false, |mut acc, c| *acc && *c == '(')\n   |      \
    \                                                 ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.replace(\"\
    (\", \"(\").replace(\")\", \")\").is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfopj57w_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<()> = vec![];\n    for (i, c) in brackets.chars().enumerate()\
    \ {\n        if c == '(' {\n            stack.push((i, c));\n        } else if\
    \ c == ')' {\n            assert!(stack.is_empty());\n            let last = stack.last().unwrap_or(i\
    \ + 1);\n            if i != last {\n                let slice = brackets.chars().skip(i).take(last).collect::<String>();\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    stack.iter().all(|&(_, c2)| c2 == '(')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp35jc2rbc.rs:15:24\n   |\n\
    15 |             stack.push((i, c));\n   |                        ^^^^^^ expected\
    \ `()`, found tuple\n   |\n   = note: expected unit type `()`\n              \
    \    found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35jc2rbc.rs:18:47\n\
    \   |\n18 |             let last = stack.last().unwrap_or(i + 1);\n   |      \
    \                                         ^^^^^ expected `&()`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp35jc2rbc.rs:19:21\n   |\n19 |\
    \             if i != last {\n   |                     ^^^^ expected `usize`,\
    \ found `&()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35jc2rbc.rs:20:59\n\
    \   |\n20 |                 let slice = brackets.chars().skip(i).take(last).collect::<String>();\n\
    \   |                                                           ^^^^ expected\
    \ `usize`, found `&()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35jc2rbc.rs:26:24\n\
    \   |\n26 |     stack.iter().all(|&(_, c2)| c2 == '(')\n   |                 \
    \       ^^^^^^-\n   |                        |     |\n   |                   \
    \     |     expected due to this\n   |                        expected `()`, found\
    \ tuple\n   |\n   = note: expected unit type `()`\n                  found tuple\
    \ `(_, _)`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = 0;\n    let mut close_brackets = 0;\n    for bracket in\
    \ brackets {\n        if bracket == '(' {\n            open_brackets += 1;\n \
    \       }\n        if bracket == ')' {\n            close_brackets += 1;\n   \
    \     }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpqtyfqwkq.rs:14:20\n\
    \   |\n14 |     for bracket in brackets {\n   |                    ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ We need to add one to the number of closing brackets to account for last\n \
    \   // closing bracket\n    let mut num_closing_brackets = brackets.len();\n \
    \   if brackets.ends_with(')') {\n        num_closing_brackets++;\n    }\n\n \
    \   for bracket in brackets.chars().take(num_closing_brackets) {\n        if !has_close_bracket(bracket)\
    \ {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp52yqb17j.rs:16:29\n\
    \   |\n16 |         num_closing_brackets++;\n   |                            \
    \ ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |\
    \         { let tmp = num_closing_brackets; num_closing_brackets += 1; tmp };\n\
    \   |         +++++++++++                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    16 -         num_closing_brackets++;\n16 +         num_closing_brackets += 1;\n\
    \   | \n\nerror[E0425]: cannot find function `has_close_bracket` in this scope\n\
    \  --> /tmp/tmp52yqb17j.rs:20:13\n   |\n20 |         if !has_close_bracket(bracket)\
    \ {\n   |             ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut num_open_brackets: usize = 0;\n    let mut num_closed_brackets: usize =\
    \ 0;\n    for i in 0..brackets.len() {\n        if brackets[i] == '(' {\n    \
    \        num_open_brackets += 1;\n        } else {\n            num_closed_brackets\
    \ += 1;\n        }\n        if num_open_brackets == num_closed_brackets {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2kye6vlt.rs:15:12\n\
    \   |\n15 |         if brackets[i] == '(' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.len()\
    \ == brackets.chars().filter(|&c| c == '(' || c == ')').count() && brackets.len()\
    \ == brackets.chars().filter(|&c| c == '[' || c == ']').count() && brackets.len()\
    \ == brackets.chars().filter(|&c| c == '{' || c == '}').count()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu3c84idw.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .rtrim()\n        .chars()\n        .all(|c| c == '(' || c == '[' ||\
    \ c == '{' || c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rtrim` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnlq3qzng.rs:13:10\n   |\n13 |         .rtrim()\n\
    \   |          ^^^^^ help: there is an associated function with a similar name:\
    \ `trim`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        let b = &brackets[i..];\n\
    \        if b == bracket {\n            if i + 1 < brackets.len() {\n        \
    \        if brackets[i + 1] != brackets[i + 2] {\n                    return false;\n\
    \                }\n            }\n        } else {\n            return false;\n\
    \        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpz71xeirw.rs:15:17\n\
    \   |\n15 |         if b == bracket {\n   |                 ^^^^^^^ help: a local\
    \ variable with a similar name exists: `brackets`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpz71xeirw.rs:17:20\n   |\n17 |  \
    \               if brackets[i + 1] != brackets[i + 2] {\n   |                \
    \    ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz71xeirw.rs:17:39\n   |\n17 |                 if brackets[i + 1]\
    \ != brackets[i + 2] {\n   |                                       ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\n\
    \        c != ')' && c != '('\n    )\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0fqpvril.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracket = brackets;\n    while !bracket.is_empty() {\n        if bracket\
    \ == \"()\" {\n            bracket = \"\";\n        } else if bracket == \"[]\"\
    \ {\n            bracket = \"\";\n        } else if bracket == \"{}\" {\n    \
    \        bracket = \"\";\n        } else if bracket == \"<>\" {\n            bracket\
    \ = \"\";\n        } else if bracket == \"<>()\" {\n            bracket = \"\"\
    ;\n        } else if bracket == \"<>[]\" {\n            bracket = \"\";\n    \
    \    } else if bracket == \"<>{}\" {\n            bracket = \"\";\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr12jskno.rs:15:23\n   |\n\
    12 |     let mut bracket = brackets;\n   |                       -------- expected\
    \ due to this value\n...\n15 |             bracket = \"\";\n   |             \
    \          ^^- help: try using a conversion method: `.to_string()`\n   |     \
    \                  |\n   |                       expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr12jskno.rs:17:23\n\
    \   |\n12 |     let mut bracket = brackets;\n   |                       --------\
    \ expected due to this value\n...\n17 |             bracket = \"\";\n   |    \
    \                   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr12jskno.rs:19:23\n\
    \   |\n12 |     let mut bracket = brackets;\n   |                       --------\
    \ expected due to this value\n...\n19 |             bracket = \"\";\n   |    \
    \                   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr12jskno.rs:21:23\n\
    \   |\n12 |     let mut bracket = brackets;\n   |                       --------\
    \ expected due to this value\n...\n21 |             bracket = \"\";\n   |    \
    \                   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr12jskno.rs:23:23\n\
    \   |\n12 |     let mut bracket = brackets;\n   |                       --------\
    \ expected due to this value\n...\n23 |             bracket = \"\";\n   |    \
    \                   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr12jskno.rs:25:23\n\
    \   |\n12 |     let mut bracket = brackets;\n   |                       ------"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ The algorithm below is from:\n    // https://math.stackexchange.com/questions/487676/how-to-check-if-a-bracket-is-correctly\
    \ (answer by Sarah Eisenberg).\n\n    // The algorithm below will count the number\
    \ of unclosed parens.\n    // The algorithm below will count the number of unopened\
    \ parens.\n    // The algorithm below will count the number of unclosed curly\
    \ brackets.\n    // The algorithm below will count the number of unopened curly\
    \ brackets.\n    // The algorithm below will count the number of open and closed\
    \ curly brackets.\n    // The algorithm below will count the number of unclosed\
    \ square brackets.\n    // The algorithm below will count the number of unopened\
    \ square brackets.\n    // The algorithm below will count the number of open and\
    \ closed square brackets.\n\n    let mut opened_count = Vec::new();\n    let mut\
    \ closed_count = Vec::new();\n\n    // The algorithm below will count the number\
    \ of open and closed parens.\n    // The algorithm below will count the number\
    \ of open and closed curly brackets.\n    // The algorithm below will count the\
    \ number of open and closed square brackets.\n    // The algorithm below will\
    \ count the number of open and closed curly brackets.\n\n    let mut unopened_count\
    \ = Vec::new();\n    let mut unclosed_count = Vec::new();\n\n    // The algorithm\
    \ below will count the number of unclosed parens.\n    // The algorithm below\
    \ will count the number of unopened parens.\n    // The algorithm below will count\
    \ the number of unclosed curly brackets.\n    // The algorithm below will count\
    \ the number of unopened curly brackets.\n    // The algorithm below will count\
    \ the number of open and closed curly brackets.\n    // The algorithm below will\
    \ count the number of unclosed square brackets.\n    // The algorithm below will\
    \ count the number of unopened square brackets.\n    // The algorithm below will\
    \ count the number of open and closed square brackets.\n\n    let mut opened_parens\
    \ = Vec::new();\n    let mut closed_parens = Vec::new();\n\n    let mut opened_curly_brackets\
    \ = Vec::new();\n    let mut closed_curly_brackets = Vec::new();\n\n    let mut\
    \ opened_square_brackets = Vec::new();\n    let mut closed_square_brackets = Vec::new();\n\
    \n    let mut opened_brackets = Vec::new();\n    let mut closed_brackets = Vec::new();\n\
    \n    let mut unopened_brackets = Vec::new();\n    let mut unclosed_brackets =\
    \ Vec::new();\n\n    let mut unopened_parens = Vec::new();\n    let mut unclosed_parens\
    \ = Vec\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplnfnof_d.rs:60:34\n   |\n\
    60 |     let mut unclosed_parens = Vec\n   |                                 \
    \ ^ help: add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0423]: expected\
    \ value, found struct `Vec`\n   --> /tmp/tmplnfnof_d.rs:60:31\n    |\n60  |  \
    \     let mut unclosed_parens = Vec\n    |                                 ^^^\
    \ help: use struct literal syntax instead: `Vec { buf: val, len: val }`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplnfnof_d.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')') && brackets.chars().all(|c| c == ')')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcjm109kq.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counter = 0;\n    let mut i = 0;\n    let mut bracket = brackets.chars().nth(i);\n\
    \    while i < brackets.len() {\n        i += 1;\n        counter += 1;\n    \
    \    if bracket != brackets.chars().nth(i) {\n            counter = 0;\n     \
    \   }\n        bracket = brackets.chars().nth(i);\n    }\n    counter > 0\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_ngtv9cu.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracket = brackets.chars().nth(1);\n    let mut next = bracket.clone();\n\
    \    next = next.next_char_unchecked();\n\n    let mut has_correct = false;\n\
    \    while !next.is_none() {\n        if next == ')' {\n            if bracket.eq('(')\
    \ {\n                has_correct = true;\n                break;\n           \
    \ }\n        }\n        next = next.next_char_unchecked();\n        has_correct\
    \ = true;\n    }\n    !has_correct\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next_char_unchecked` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmph0lmvkq6.rs:14:17\n   |\n14 |     next =\
    \ next.next_char_unchecked();\n   |                 ^^^^^^^^^^^^^^^^^^^ method\
    \ not found in `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph0lmvkq6.rs:18:20\n\
    \   |\n18 |         if next == ')' {\n   |                    ^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n    \
    \          found type `char`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n18 |         if next == Some(')') {\n   |                    +++++   +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmph0lmvkq6.rs:19:27\n   |\n19 |  \
    \           if bracket.eq('(') {\n   |                           ^^^ expected\
    \ `&Option<char>`, found `char`\n   |\n   = note: expected reference `&Option<char>`\n\
    \                   found type `char`\n\nerror[E0599]: no method named `next_char_unchecked`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmph0lmvkq6.rs:24:21\n\
    \   |\n24 |         next = next.next_char_unchecked();\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"-LRB-\"\
    ).replace(\")\", \"-RRB-\");\n    brackets.replace(\"(\", \"-LRB-\").replace(\"\
    )\", \"-RRB-\").replace(\"-LRB-\", \"(\")\n        .replace(\"-RRB-\", \")\");\n\
    \    brackets.replace(\"(\", \"-LRB-\").replace(\")\", \"-RRB-\").replace(\"-LRB-\"\
    , \"(\")\n        .replace(\"-RRB-\", \")\").replace(\"-LRB-\", \"(\").replace(\"\
    -RRB-\", \")\");\n    brackets.replace(\"(\", \"-LRB-\").replace(\")\", \"-RRB-\"\
    ).replace(\"-LRB-\", \"(\")\n        .replace(\"-RRB-\", \")\").replace(\"-LRB-\"\
    , \"(\").replace(\"-RRB-\", \")\")\n        .replace(\"-LRB-\", \"(\").replace(\"\
    -RRB-\", \")\").replace(\"-LRB-\", \"(\")\n        .replace(\"-RRB-\", \")\").replace(\"\
    -LRB-\", \"(\").replace(\"-RRB-\", \")\");\n    brackets.replace(\"(\", \"-LRB-\"\
    ).replace(\")\", \"-RRB-\").replace(\"-LRB-\", \"(\")\n        .replace(\"-RRB-\"\
    , \")\").replace(\"-LRB-\", \"(\").replace(\"-RRB-\", \")\")\n        .replace(\"\
    -LRB-\", \"(\").replace(\"-RRB-\", \")\").replace(\"-LRB-\", \"(\")\n        .replace(\"\
    -RRB-\", \")\").replace(\"-LRB-\", \"(\").replace(\"-RRB-\", \")\")\n        .replace(\"\
    -LRB-\", \"(\").replace(\"-RRB-\", \")\").replace(\"-LRB-\", \"(\")\n        .replace(\"\
    -RRB-\", \")\").replace(\"-LRB-\", \"(\").replace(\"-RRB-\", \")\")\n        .replace(\"\
    -LRB-\", \"(\").replace(\"-RRB-\", \")\").replace(\"-LRB-\", \"(\")\n        .replace(\"\
    -RRB-\", \")\").replace(\"-LRB-\", \"(\").replace(\"-RRB-\", \")\")\n        .replace(\"\
    -LRB-\", \"(\").replace(\"-RRB-\", \")\").replace(\"-LRB-\", \"(\")\n        .replace(\"\
    -RRB-\", \")\").replace(\"-LRB-\", \"(\").replace(\"-RRB-\", \")\");\n    brackets.replace(\"\
    (\", \"-LRB-\").replace(\")\", \"-RRB-\").replace(\"-LRB-\", \"(\")\n        .replace(\"\
    -RRB-\", \")\").replace(\"-LRB-\", \"(\").replace(\"-RRB-\", \")\")\n        .replace(\"\
    -LRB-\", \"(\").replace(\"-RRB-\", \")\").replace(\"-LRB-\", \"(\")\n        .replace(\"\
    -RRB-\", \")\").replace(\"-LRB-\", \"(\").replace(\"-\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmprnrya0yu.rs:51:56\n\
    \   |\n51 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n52 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ TODO: this does not work for nested brackets.\n    brackets.chars().all(|c|\
    \ c.is_ascii_digit())\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7s5g3_dq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ empty string has correct bracketing\n    if brackets.is_empty() {\n        return\
    \ true;\n    }\n\n    // empty string has correct bracketing\n    if brackets.as_bytes().is_empty()\
    \ {\n        return true;\n    }\n\n    // each opening bracket has to have corresponding\
    \ closing bracket\n    brackets.chars().take(brackets.len() - 1).all(|c| *c ==\
    \ ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmprtmsgt17.rs:23:55\n\
    \   |\n23 |     brackets.chars().take(brackets.len() - 1).all(|c| *c == ')')\n\
    \   |                                                       ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracket_stack: Vec<usize> = vec![];\n    for bracket in brackets.chars()\
    \ {\n        if bracket.char() == '(' {\n            bracket_stack.push(bracket.index());\n\
    \        } else if bracket.char() == ')' {\n            if bracket_stack.is_empty()\
    \ {\n                return false;\n            }\n            bracket_stack.pop();\n\
    \        }\n    }\n\n    if bracket_stack.is_empty() {\n        return true;\n\
    \    }\n\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `char` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpq8mm9h63.rs:14:20\n   |\n14 |         if bracket.char()\
    \ == '(' {\n   |                    ^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `index` found for type `char` in the current scope\n  --> /tmp/tmpq8mm9h63.rs:15:40\n\
    \   |\n15 |             bracket_stack.push(bracket.index());\n   |           \
    \                             ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `char` found for type `char` in the current scope\n  --> /tmp/tmpq8mm9h63.rs:16:27\n\
    \   |\n16 |         } else if bracket.char() == ')' {\n   |                  \
    \         ^^^^ method not found in `char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found = false;\n    for bracketer in brackets.chars() {\n        if let\
    \ char::Bracket(bracketer) = bracketer {\n            let mut found = false;\n\
    \            for _ in 0..(bracketer - '(') {\n                found = true;\n\
    \            }\n            for _ in (bracketer - '(' + 1) as usize .. (bracketer\
    \ - ')').cmp(bracketer - '(') {\n                found = true;\n            }\n\
    \            if !found {\n                return false;\n            }\n     \
    \   }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `Bracket` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp7lknto_j.rs:14:22\n   |\n14 |         if\
    \ let char::Bracket(bracketer) = bracketer {\n   |                      ^^^^^^^\
    \ associated item not found in `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening = Vec::with_capacity(brackets.len());\n    let mut closing = Vec::with_capacity(brackets.len());\n\
    \    for ch in brackets.chars() {\n        if ch == char::B('(') {\n         \
    \   opening.push(1);\n        } else if ch == char::B(')') {\n            closing.push(1);\n\
    \        } else {\n            opening.push(0);\n            closing.push(0);\n\
    \        }\n    }\n    for open in opening {\n        for closed in closing {\n\
    \            if open != closed {\n                return false;\n            }\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `B` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvnmks34b.rs:15:24\n   |\n15 |         if ch ==\
    \ char::B('(') {\n   |                        ^ associated item not found in `char`\n\
    \nerror[E0599]: no associated item named `B` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvnmks34b.rs:17:31\n   |\n17 |         } else if ch == char::B(')')\
    \ {\n   |                               ^ associated item not found in `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|b|\n\
    \        b == '(' || b == ')' || b == '[' || b == ']' || b == '{' || b == '}'\
    \ || b == '(' || b == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx20txx8d.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Stack::new();\n    stack.push(Some(brackets.chars().next().unwrap()));\n\
    \    let mut bracket = false;\n    while let Some(ch) = stack.peek() {\n     \
    \   if ch == '(' || ch == ')' {\n            stack.pop();\n            if stack.peek()\
    \ == Some('(') {\n                stack.push(Some(')'));\n            }\n    \
    \    } else if ch == '{' || ch == '}' || ch == ']' || ch == ']' {\n          \
    \  bracket = true;\n            stack.pop();\n            stack.pop();\n     \
    \   } else {\n            stack.push(Some(ch));\n        }\n        if stack.len()\
    \ == 0 {\n            bracket = false;\n        }\n    }\n    bracket && stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpn1xjl9iy.rs:12:21\n   |\n12 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for brack in brackets {\n        if !is_open_bracket(brack)\
    \ {\n            stack.push(brack);\n        }\n    }\n\n    let mut open_brackets\
    \ = 0;\n    let mut close_brackets = 0;\n    for brack in stack {\n        if\
    \ brack == \"(\" {\n            open_brackets += 1;\n        }\n        if brack\
    \ == \")\" {\n            close_brackets += 1;\n        }\n    }\n\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_open_bracket` in this scope\n  -->\
    \ /tmp/tmpg1kf8g3w.rs:14:13\n   |\n14 |         if !is_open_bracket(brack) {\n\
    \   |             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpg1kf8g3w.rs:13:18\n   |\n13 |     for brack\
    \ in brackets {\n   |                  ^^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '(' && c != ')'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbsiycfh7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = VecDeque::with_capacity(1);\n    stack.push_back(String::from(\"\
    (\"));\n    stack.push_back(String::from(\")\"));\n    stack.push_back(String::from(\"\
    [\"));\n    stack.push_back(String::from(\"]\"));\n    let mut i = 0;\n    while\
    \ i < brackets.len() {\n        let mut found = false;\n        let mut depth\
    \ = stack.len();\n        while !found && depth != 0 {\n            found = true;\n\
    \            if brackets[brackets.len() - 1 - i] == stack.pop_front() {\n    \
    \            found = false;\n            }\n            depth--;\n        }\n\
    \        i += 1;\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpr2yz2zli.rs:26:20\n\
    \   |\n26 |             depth--;\n   |                    ^ expected expression\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  --> /tmp/tmpr2yz2zli.rs:12:21\n\
    \   |\n12 |     let mut stack = VecDeque::with_capacity(1);\n   |            \
    \         ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr2yz2zli.rs:23:16\n\
    \   |\n23 |             if brackets[brackets.len() - 1 - i] == stack.pop_front()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found = false;\n    for char in brackets.chars() {\n        if char == '('\
    \ {\n            found = true;\n        }\n        if char == ')' {\n        \
    \    found = false;\n        }\n    }\n    found\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6na1qmeg.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        if c == ')' {\n            c != '('\n        } else {\n         \
    \   c != '('\n        }\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptuc48o7w.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ c == '(' || c == '{' || c == '[' || c == '<' || c == '>' || c == ')' || c ==\
    \ '}' || c == ']' || c == '>' || c == ')')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpea6sm9eh.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.is_empty() {\n        return true;\n    }\n    let mut opening = String::new();\n\
    \    let mut closing = String::new();\n    let mut opening_bracket = false;\n\
    \    let mut closing_bracket = false;\n    for i in 0..brackets.len() {\n    \
    \    match brackets[i] {\n            '(' | ')' => {\n                opening.push(brackets[i]);\n\
    \                opening_bracket = true;\n            }\n            '[' | ']'\
    \ => {\n                closing.push(brackets[i]);\n                closing_bracket\
    \ = true;\n            }\n            _ => {\n                continue;\n    \
    \        }\n        }\n        if opening_bracket && closing_bracket {\n     \
    \       return false;\n        }\n    }\n    opening.is_empty() && closing.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe2cunxm3.rs:20:15\n\
    \   |\n20 |         match brackets[i] {\n   |               ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpe2cunxm3.rs:22:30\n   |\n22 |                 opening.push(brackets[i]);\n\
    \   |                              ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpe2cunxm3.rs:26:30\n   |\n26 |                 closing.push(brackets[i]);\n\
    \   |                              ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usiz"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracketing_pair = brackets.chars().enumerate().filter(|(_, char)| char ==\
    \ '(').next();\n    while bracketing_pair.map(|(_, char)| char == '(').unwrap_or(false)\
    \ != brackets.chars().enumerate().filter(|(_, char)| char == ')').next() {\n \
    \       bracketing_pair = brackets.chars().enumerate().filter(|(_, char)| char\
    \ == ')').next().unwrap();\n    }\n    bracketing_pair.is_none()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2584whn3.rs:12:84\n\
    \   |\n12 |     let mut bracketing_pair = brackets.chars().enumerate().filter(|(_,\
    \ char)| char == '(').next();\n   |                                          \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp2584whn3.rs:13:129\n   |\n13 | ...ts.chars().enumerate().filter(|(_,\
    \ char)| char == ')').next() {\n   |                                         \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2584whn3.rs:13:76\n\
    \   |\n13 | ...p_or(false) != brackets.chars().enumerate().filter(|(_, char)|\
    \ char == ')').next() {\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<(usize, char)>`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp2584whn3.rs:14:80\n   |\n14 |         bracketing_pair\
    \ = brackets.chars().enumerate().filter(|(_, char)| char == ')').next().unwrap();\n\
    \   |                                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2584whn3.rs:14:27\n\
    \   |\n12 |     let mut bracketing_pair = brackets.chars().enumerate().filter(|(_,\
    \ char)| char == '(').next();\n   |                               -------------------------------------------------------------------\
    \ expected due to this value\n13 |     while bracketing_pair.map(|(_, char)| char\
    \ == '(').unwrap_or(fals"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_counter = 0;\n    let mut close_counter = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            open_counter++;\n        } else\
    \ if bracket == ')' {\n            close_counter++;\n        } else if open_counter\
    \ == close_counter + 1 {\n            return false;\n        }\n    }\n    open_counter\
    \ == close_counter + 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7hm1_k8n.rs:16:25\n\
    \   |\n16 |             open_counter++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |         \
    \    { let tmp = open_counter; open_counter += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n16 -             open_counter++;\n16\
    \ +             open_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp7hm1_k8n.rs:18:26\n   |\n18 |             close_counter++;\n\
    \   |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n18 |             { let tmp = close_counter; close_counter\
    \ += 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    18 -             close_counter++;\n18 +             close_counter += 1;\n   |\
    \ \n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut left = brackets.chars().filter(|c| c != '(').collect::<Vec<_>>();\n    let\
    \ mut right = brackets.chars().filter(|c| c != ')').collect::<Vec<_>>();\n\n \
    \   if left.len() != right.len() {\n        return false;\n    }\n\n    for i\
    \ in 0..left.len() {\n        let leftchar = &left[i];\n        let rightchar\
    \ = &right[i];\n\n        if leftchar != rightchar {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpro5afupc.rs:12:50\n\
    \   |\n12 |     let mut left = brackets.chars().filter(|c| c != '(').collect::<Vec<_>>();\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpro5afupc.rs:13:51\n\
    \   |\n13 |     let mut right = brackets.chars().filter(|c| c != ')').collect::<Vec<_>>();\n\
    \   |                                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_paren = false;\n    let mut close_paren = false;\n    let mut inside_brackets\
    \ = false;\n    for ch in brackets.chars() {\n        if ch == open_paren {\n\
    \            inside_brackets = true;\n        } else if ch == close_paren {\n\
    \            inside_brackets = false;\n        } else if !inside_brackets {\n\
    \            return false;\n        }\n    }\n    inside_brackets\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0aea911_.rs:16:18\n   |\n\
    16 |         if ch == open_paren {\n   |                  ^^^^^^^^^^ expected\
    \ `char`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0aea911_.rs:18:25\n\
    \   |\n18 |         } else if ch == close_paren {\n   |                      \
    \   ^^^^^^^^^^^ expected `char`, found `bool`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut cur_brackets = 0;\n    let mut prev_brackets = 0;\n    for (i, char) in\
    \ brackets.chars().enumerate() {\n        match char {\n            '(' | '['\
    \ => {\n                if cur_brackets == 0 {\n                    prev_brackets\
    \ = cur_brackets;\n                }\n                cur_brackets += 1;\n   \
    \         }\n            ')' | ']' => {\n                cur_brackets -= 1;\n\
    \                if cur_brackets == 0 {\n                    prev_brackets = cur_brackets;\n\
    \                }\n            }\n            _ => continue,\n        }\n   \
    \ }\n    cur_brackets == prev_brackets\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_b47bhjd.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut in_str = false;\n    for ch in brackets.chars() {\n        if ch.is_ascii()\
    \ {\n            in_str = !in_str;\n        } else {\n            assert!(ch.is_whitespace());\n\
    \        }\n    }\n    in_str\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxuv_h0fk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.is_empty()\
    \ || brackets.chars().all(|c| c == Some('(') || c == Some(')')) || brackets.chars().all(|c|\
    \ c == '(' && c == ')') || brackets.chars().all(|c| c == '[' && c == ']') || brackets.chars().all(|c|\
    \ c == '{' && c == '}') || brackets.chars().all(|c| c == ',') || brackets.chars().all(|c|\
    \ c == '.') || (brackets.chars().contains(c) && brackets.chars().filter(brackets.chars().by_ref().find(c)).count()\
    \ == 1)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp_pajgy6n.rs:12:343\n\
    \   |\n12 | ...ars().all(|c| c == '.') || (brackets.chars().contains(c) && brackets.chars().filter(brackets.chars().by_ref().find(c)).count()\
    \ == 1)\n   |                                                          ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp_pajgy6n.rs:12:404\n\
    \   |\n12 | ...rackets.chars().filter(brackets.chars().by_ref().find(c)).count()\
    \ == 1)\n   |                                                          ^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_pajgy6n.rs:12:58\n\
    \   |\n12 |     brackets.is_empty() || brackets.chars().all(|c| c == Some('(')\
    \ || c == Some(')')) || brackets.chars().all(|c| c == '(' && c == ')') |...\n\
    \   |                                                          ^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_pajgy6n.rs:12:76\n\
    \   |\n12 |     brackets.is_empty() || brackets.chars().all(|c| c == Some('(')\
    \ || c == Some(')')) || brackets.chars().all(|c| c == '(' && c == ')') |...\n\
    \   |                                                                        \
    \    ^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<char>`\n\nerror[E0599]: no method\
    \ named `contains` found for struct `Chars` in the current scope\n  --> /tmp/tmp_pajgy6n.rs:12:334\n\
    \   |\n12 | ...chars().all(|c| c == '.') || (brackets.chars().contains(c) && brackets.chars().filter(brackets.chars().by_ref().find(c)).count()\
    \ == 1)\n   |                                                   ^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0277]: expected a `FnMut<(&char,)>` closure,\
    \ found `Option<char>`\n   --> /tmp/tmp_pajgy6n.rs:12:373\n    |\n12  | ...brackets.chars().filter(brackets.chars().by_ref().find(c)).count()\
    \ == 1)\n    |                     ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ an `FnMut<(&char,"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() == 1 {\n        true\n    } else {\n        let mut stack: Vec<_>\
    \ = brackets.chars().collect();\n        while stack.len() > 0 {\n           \
    \ let mut open_ = stack.pop();\n            let mut close = stack.pop();\n   \
    \         if open_ == '(' && close == ')' {\n                stack.push(')');\n\
    \            } else {\n                stack.push(':');\n            }\n     \
    \   }\n        stack.len() == 0\n    }\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl2dtkzs1.rs:19:25\n   |\n\
    19 |             if open_ == '(' && close == ')' {\n   |                     \
    \    ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum\
    \ `Option<char>`\n              found type `char`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n19 |             if open_ == Some('(') && close == ')' {\n\
    \   |                         +++++   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl2dtkzs1.rs:19:41\n   |\n19 |             if open_ == '(' && close ==\
    \ ')' {\n   |                                         ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n19 |       \
    \      if open_ == '(' && close == Some(')') {\n   |                         \
    \                +++++   +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' && brackets.chars().all(|c| c == '('))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp6vnq2eb.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    let mut open_brackets = vec![];\n    let mut close_brackets\
    \ = vec![];\n    for i in brackets.chars().filter_map(|c| {\n        if c == '('\
    \ {\n            stack.push(i);\n            open_brackets.push(i);\n        }\
    \ else if c == ')' {\n            stack.pop();\n            close_brackets.push(i);\n\
    \        }\n        None\n    }) {\n        if !stack.is_empty() && stack.last()\
    \ != i {\n            return false;\n        }\n        if close_brackets.is_empty()\
    \ && i != open_brackets.pop() {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpcxrfouyn.rs:17:24\n\
    \   |\n17 |             stack.push(i);\n   |                        ^ help: a\
    \ local variable with a similar name exists: `c`\n\nerror[E0425]: cannot find\
    \ value `i` in this scope\n  --> /tmp/tmpcxrfouyn.rs:18:32\n   |\n18 |       \
    \      open_brackets.push(i);\n   |                                ^ help: a local\
    \ variable with a similar name exists: `c`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpcxrfouyn.rs:21:33\n   |\n21 |             close_brackets.push(i);\n\
    \   |                                 ^ help: a local variable with a similar\
    \ name exists: `c`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut result = String::new();\n\n    for c in brackets {\n        if let Some(open)\
    \ = brackets.chars().position(|c| *c == c).map(|i| i) {\n            result.push(c);\n\
    \        }\n    }\n\n    result == \"()\"\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprky5w7jg.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmprky5w7jg.rs:15:59\n   |\n15 | \
    \        if let Some(open) = brackets.chars().position(|c| *c == c).map(|i| i)\
    \ {\n   |                                                           ^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp04kge0f3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all_matches(|c|\
    \ *c != '(')\n        && !brackets.chars().any(|c| *c == ')')\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `all_matches` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpxnfvlwjv.rs:12:22\n   |\n12 |     brackets.chars().all_matches(|c|\
    \ *c != '(')\n   |                      ^^^^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpxnfvlwjv.rs:13:38\n\
    \   |\n13 |         && !brackets.chars().any(|c| *c == ')')\n   |            \
    \                          ^^\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut seen_brackets = HashSet::new();\n    brackets.split_whitespace().flat_map(|b|\
    \ {\n        if b == \")\" {\n            if seen_brackets.contains(b) {\n   \
    \             return false;\n            }\n            seen_brackets.insert(b);\n\
    \            Some(b.chars())\n        } else {\n            Some(b[..])\n    \
    \    }\n    })\n        .all(|c| *c != '(')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpu3jf58xe.rs:12:29\n   |\n12 |     let mut seen_brackets = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: `bool` is not an iterator\n    --> /tmp/tmpu3jf58xe.rs:13:33\n\
    \     |\n13   |     brackets.split_whitespace().flat_map(|b| {\n     |       \
    \                          ^^^^^^^^ `bool` is not an iterator\n     |\n     =\
    \ help: the trait `Iterator` is not implemented for `bool`\n     = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `bool`\nnote:\
    \ required by a bound in `flat_map`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpu3jf58xe.rs:21:18\n\
    \    |\n21  |             Some(b[..])\n    |             ---- ^^^^^ doesn't have\
    \ a size known at compile-time\n    |             |\n    |             required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `str`\nnote: required by a bound in `Some`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpu3jf58xe.rs:21:13\n    |\n21  |             Some(b[..])\n    |     \
    \        ^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `Option`\n\nerror[E0599]: the method `all` exists for struct `FlatMap<SplitWhitespace<'_>,\
    \ bool, [closure@/tmp/tmpu3jf58xe.rs:13:42: 23:6]>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpu3jf58xe.rs:24:10\n   |\n24 |           .all(|c|\
    \ *c != '(')\n   |            ^^^ method cannot be called on `FlatMap<SplitWhitespace<'_>,\
    \ bool, [closure@/tmp/tmpu3jf58xe.rs:13:42: 23:6]>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `bool:\
    \ IntoIterator`\n           which is required by `FlatMap<SplitWhitespace<'_>,\
    \ bool, [closure@/tmp/tmpu3jf58xe.rs:"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = [(false, false)];\n    for c in brackets.chars().cloned() {\n  \
    \      if c == '(' {\n            stack.push((true, false));\n        } else {\n\
    \            stack.pop();\n            if !stack.is_empty() && stack.last().0\
    \ {\n                return false;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpxyprtmc5.rs:13:31\n     |\n13   |     for c in brackets.chars().cloned()\
    \ {\n     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpxyprtmc5.rs:13:14\n\
    \   |\n13 |     for c in brackets.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpxyprtmc5.rs:13:14\n   |\n13 |     for c in brackets.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `push` found for array `[(bool, bool); 1]` in\
    \ the current scope\n  --> /tmp/tmpxyprtmc5.rs:15:19\n   |\n15 |             stack.push((true,\
    \ false));\n   |                   ^^^^ method not found in `[(bool, bool); 1]`\n\
    \nerror[E0599]: no method named `pop` found for array `[(bool, bool); 1]` in the\
    \ current scope\n  --> /tmp/tmpxyprtmc5.rs:17:19\n   |\n17 |             stack.pop();\n\
    \   |                   ^^^ method not found in `[(bool, bool); 1]`\n\nerror[E0609]:\
    \ no field `0` on type `Option<&(bool, bool)>`\n  --> /tmp/tmpxyprtmc5.rs:18:50\n\
    \   |\n18 |             if !stack.is_empty() && stack.last().0 {\n   |       \
    \                                           ^\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0271"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut depth = 0;\n    let mut opening_depth = -1;\n\n    for c in &brackets {\n\
    \        if c == '(' {\n            opening_depth = depth;\n            depth\
    \ += 1;\n        } else if c == ')' {\n            depth -= 1;\n            if\
    \ opening_depth == depth { // close enough to open\n                opening_depth\
    \ = -1;\n            }\n        } else if c == ')' {\n            depth -= 1;\n\
    \            if opening_depth == depth { // close enough to open\n           \
    \     opening_depth = -1;\n            }\n        }\n    }\n    opening_depth\
    \ == -1 ? false : true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `false`\n  --> /tmp/tmpzprwp7zp.rs:31:27\n   |\n31 |     opening_depth == -1\
    \ ? false : true\n   |                           ^^^^^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror[E0277]: `&String` is not an iterator\n  -->\
    \ /tmp/tmpzprwp7zp.rs:15:14\n   |\n15 |     for c in &brackets {\n   |       \
    \       ^^^^^^^^^ `&String` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ c == '(' || c == '[' || c == '{')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfxvhtzhy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = VecDeque::new();\n    stack.push_back(brackets);\n    let mut opening_set\
    \ = HashSet::new();\n    let mut closing_set = HashSet::new();\n    while let\
    \ Some(b) = stack.pop_front() {\n        if opening_set.contains(&b) {\n     \
    \       closing_set.insert(b);\n        } else {\n            opening_set.insert(b);\n\
    \        }\n    }\n    closing_set.len() == opening_set.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpj_p8qw39.rs:12:21\n   |\n12 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpj_p8qw39.rs:14:27\n\
    \   |\n14 |     let mut opening_set = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpj_p8qw39.rs:15:27\n\
    \   |\n15 |     let mut closing_set = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut s = brackets;\n    let mut b = false;\n    while s.len() > 0 {\n       \
    \ if s.ends_with('(') {\n            if b {\n                return false;\n \
    \           }\n            s = &s[..s.len() - 1];\n            b = true;\n   \
    \     } else {\n            if !b {\n                return false;\n         \
    \   }\n            s = &s[..s.len() - 1];\n            b = false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqc93pwkt.rs:19:17\n   |\n\
    12 |     let mut s = brackets;\n   |                 -------- expected due to\
    \ this value\n...\n19 |             s = &s[..s.len() - 1];\n   |             \
    \    ^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n19 |             s = (&s[..s.len() - 1]).to_string();\n\
    \   |                 +                 +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqc93pwkt.rs:25:17\n   |\n12 |     let mut s = brackets;\n\
    \   |                 -------- expected due to this value\n...\n25 |         \
    \    s = &s[..s.len() - 1];\n   |                 ^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n25\
    \ |             s = (&s[..s.len() - 1]).to_string();\n   |                 + \
    \                +++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open = 0;\n    let mut close = 0;\n    let mut bracket_count = 0;\n    let\
    \ mut bracket_stack = [String::from(\")\")]; //stack of open brackets\n    for\
    \ bracket in brackets.chars().filter_map(|c| {\n        if c == char::parenthesis_open()\
    \ {\n            open += 1;\n        } else if c == char::parenthesis_close()\
    \ {\n            close += 1;\n        }\n        if bracket == char::left_parenthesis()\
    \ {\n            bracket_stack.push(String::from(\"(\"));\n            bracket_count\
    \ += 1;\n        } else if bracket == char::right_parenthesis() {\n          \
    \  bracket_stack.push(String::from(\"\"));\n            bracket_count += 1;\n\
    \        }\n        if bracket == char::backslash() {\n            return Some(char::backslash());\n\
    \        }\n        if bracket == char::backslash_escape() {\n            return\
    \ Some(char::backslash_escape());\n        }\n        None\n    }) {\n       \
    \ if bracket_stack.is_empty() || bracket_stack.pop() != String::from(bracket)\
    \ {\n            return false;\n        }\n    }\n    open - close == bracket_count\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqsrp5jjd.rs:22:12\n\
    \   |\n22 |         if bracket == char::left_parenthesis() {\n   |           \
    \ ^^^^^^^ help: a local variable with a similar name exists: `brackets`\n\nerror[E0425]:\
    \ cannot find value `bracket` in this scope\n  --> /tmp/tmpqsrp5jjd.rs:25:19\n\
    \   |\n25 |         } else if bracket == char::right_parenthesis() {\n   |   \
    \                ^^^^^^^ help: a local variable with a similar name exists: `brackets`\n\
    \nerror[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqsrp5jjd.rs:29:12\n\
    \   |\n29 |         if bracket == char::backslash() {\n   |            ^^^^^^^\
    \ help: a local variable with a similar name exists: `brackets`\n\nerror[E0425]:\
    \ cannot find value `bracket` in this scope\n  --> /tmp/tmpqsrp5jjd.rs:32:12\n\
    \   |\n32 |         if bracket == char::backslash_escape() {\n   |           \
    \ ^^^^^^^ help: a local variable with a similar name exists: `brackets`\n\nerror[E0599]:\
    \ no function or associated item named `parenthesis_open` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpqsrp5jjd.rs:17:23\n   |\n17 |         if\
    \ c == char::parenthesis_open() {\n   |                       ^^^^^^^^^^^^^^^^\
    \ function or associated item not found in `char`\n\nerror[E0599]: no function\
    \ or associated item named `parenthesis_close` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpqsrp5jjd.rs:19:30\n   |\n19 |         } else if c == char::parenthesis_close()\
    \ {\n   |                              ^^^^^^^^^^^^^^^^^ function or associated\
    \ item not found in `char`\n\nerror[E0599]: no function or associated item named\
    \ `left_parenthesis` found for type `char` in the current scope\n  --> /tmp/tmpqsrp5jjd.rs:22:29\n\
    \   |\n22 |         if bracket == char::left_parenthesis() {\n   |           \
    \                  ^^^^^^^^^^^^^^^^ function or associated item not found in `char`\n\
    \nerror[E0599]: no method named `push` found for array `[String; 1]` in the current\
    \ scope\n  --> /tmp/tmpqsrp5jjd.rs:23:27\n   |\n23 |             bracket_stack.push(String::from(\"\
    (\"));\n   |                 "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' && unsafe { mem::transmute::<&str, _>(&brackets.chars().next()) ==\
    \ ')' })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `mem`\n\
    \  --> /tmp/tmpssh979p8.rs:12:51\n   |\n12 |     brackets.chars().all(|c| c ==\
    \ ')' && unsafe { mem::transmute::<&str, _>(&brackets.chars().next()) == ')' })\n\
    \   |                                                   ^^^ use of undeclared\
    \ crate or module `mem`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut index = 0;\n    let mut open_bracket = false;\n\n    while index < brackets.len()\
    \ {\n        let mut next_open_bracket = false;\n        let mut next_close_bracket\
    \ = false;\n        loop {\n            let c = brackets.get_char(&index, None).unwrap();\n\
    \            match c {\n                '(' -> next_open_bracket = true;\n   \
    \             _ => (),\n                '[' -> next_close_bracket = true;\n  \
    \              _ => (),\n                ')' -> next_close_bracket = true;\n \
    \               _ => (),\n                ']' -> next_open_bracket = true;\n \
    \               _ => (),\n            }\n            index += 1;\n           \
    \ if next_close_bracket {\n                next_close_bracket = false;\n     \
    \       } else if next_open_bracket {\n                next_open_bracket = false;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if open_bracket == true && next_open_bracket == false {\n            return\
    \ false;\n        }\n        open_bracket = next_open_bracket;\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `->`\n\
    \  --> /tmp/tmp0zek6hrr.rs:21:21\n   |\n21 |                 '(' -> next_open_bracket\
    \ = true;\n   |                     ^^\n   |                     |\n   |     \
    \                expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n   |\
    \                     help: try using a fat arrow here: `=>`\n\nerror: `match`\
    \ arm body without braces\n  --> /tmp/tmp0zek6hrr.rs:21:24\n   |\n21 |       \
    \          '(' -> next_open_bracket = true;\n   |                     -- ^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: use a comma to end a `match` arm expression: `,`\n   |               \
    \      |  |\n   |                     |  this statement is not surrounded by a\
    \ body\n   |                     while parsing the `match` arm starting here\n\
    \nerror: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `->`\n\
    \  --> /tmp/tmp0zek6hrr.rs:23:21\n   |\n23 |                 '[' -> next_close_bracket\
    \ = true;\n   |                     ^^\n   |                     |\n   |     \
    \                expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n   |\
    \                     help: try using a fat arrow here: `=>`\n\nerror: `match`\
    \ arm body without braces\n  --> /tmp/tmp0zek6hrr.rs:23:24\n   |\n23 |       \
    \          '[' -> next_close_bracket = true;\n   |                     -- ^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: use a comma to end a `match` arm expression: `,`\n   |               \
    \      |  |\n   |                     |  this statement is not surrounded by a\
    \ body\n   |                     while parsing the `match` arm starting here\n\
    \nerror: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `->`\n\
    \  --> /tmp/tmp0zek6hrr.rs:25:21\n   |\n25 |                 ')' -> next_close_bracket\
    \ = true;\n   |                     ^^\n   |                     |\n   |     \
    \                expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n   |\
    \                     help: try using a fat arrow here: `=>`\n\nerror: `match`\
    \ arm body without braces\n  --> /tmp/tmp0zek6hrr.rs:25:24\n   |\n25 |       \
    \          ')' -> next_close_bracket = true"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut closed = Bracket::None;\n    let mut opening = Bracket::None;\n    for brack\
    \ in brackets.chars().filter(|c| *c != Bracket::BracketLeft).cloned() {\n    \
    \    match brack {\n            Bracket::BracketLeft => {\n                *opened\
    \ += 1;\n            },\n            Bracket::BracketRight => {\n            \
    \    *closed += 1;\n            }\n        }\n    }\n\n    !opened && !closed\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Bracket`\n  -->\
    \ /tmp/tmpl2u56f_t.rs:12:22\n   |\n12 |     let mut closed = Bracket::None;\n\
    \   |                      ^^^^^^^ use of undeclared type `Bracket`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Bracket`\n  --> /tmp/tmpl2u56f_t.rs:13:23\n\
    \   |\n13 |     let mut opening = Bracket::None;\n   |                       ^^^^^^^\
    \ use of undeclared type `Bracket`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Bracket`\n  --> /tmp/tmpl2u56f_t.rs:14:52\n   |\n14 |     for\
    \ brack in brackets.chars().filter(|c| *c != Bracket::BracketLeft).cloned() {\n\
    \   |                                                    ^^^^^^^ use of undeclared\
    \ type `Bracket`\n\nerror[E0433]: failed to resolve: use of undeclared type `Bracket`\n\
    \  --> /tmp/tmpl2u56f_t.rs:16:13\n   |\n16 |             Bracket::BracketLeft\
    \ => {\n   |             ^^^^^^^ use of undeclared type `Bracket`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Bracket`\n  --> /tmp/tmpl2u56f_t.rs:19:13\n\
    \   |\n19 |             Bracket::BracketRight => {\n   |             ^^^^^^^ use\
    \ of undeclared type `Bracket`\n\nerror[E0425]: cannot find value `opened` in\
    \ this scope\n  --> /tmp/tmpl2u56f_t.rs:17:18\n   |\n17 |                 *opened\
    \ += 1;\n   |                  ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `opened` in this scope\n  --> /tmp/tmpl2u56f_t.rs:25:6\n \
    \  |\n25 |     !opened && !closed\n   |      ^^^^^^ not found in this scope\n\n\
    error[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpl2u56f_t.rs:14:42:\
    \ 14:72]> as Iterator>::Item == &_`\n    --> /tmp/tmpl2u56f_t.rs:14:74\n     |\n\
    14   |     for brack in brackets.chars().filter(|c| *c != Bracket::BracketLeft).cloned()\
    \ {\n     |                                                                  \
    \        ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Filter<Chars<'_>,\
    \ [closure@/tmp/tmpl2"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_bracket = brackets.chars().next();\n    let mut close_bracket = brackets.chars().next();\n\
    \    loop {\n        if open_bracket.map(|c| c).unwrap_or(0) != 1 {\n        \
    \    break;\n        }\n        close_bracket = brackets.chars().next();\n   \
    \     if close_bracket.map(|c| c).unwrap_or(0) != 0 {\n            return false;\n\
    \        }\n        open_bracket = brackets.chars().next();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbiinuw3k.rs:15:46\n   |\n\
    15 |         if open_bracket.map(|c| c).unwrap_or(0) != 1 {\n   |            \
    \                                  ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbiinuw3k.rs:15:52\n   |\n15 |         if open_bracket.map(|c|\
    \ c).unwrap_or(0) != 1 {\n   |                                               \
    \     ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbiinuw3k.rs:19:47\n\
    \   |\n19 |         if close_bracket.map(|c| c).unwrap_or(0) != 0 {\n   |    \
    \                                           ^ expected `char`, found `u8`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbiinuw3k.rs:19:53\n   |\n19 |  \
    \       if close_bracket.map(|c| c).unwrap_or(0) != 0 {\n   |                \
    \                                     ^ expected `char`, found `u8`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\
    \ == brackets.replace(\"()\", \"\")\n        .replace(\"()\", \"\")\n        .replace(\"\
    ((\", \"(\")\n        .replace(\"(\", \"\")\n        .replace(\")(\", \")\")\n\
    \        .replace(\"))\", \")\")\n        .replace(\"))\", \"\")\n        .replace(\"\
    ()\", \"\")\n        .replace(\"()\", \"\")\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpss2nh3rt.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_lowercase();\n    while brackets.len() > 2 {\n  \
    \      if brackets.starts_with(\"(\") && brackets.ends_with(\")\") {\n       \
    \     brackets.remove(1);\n            brackets.remove(1);\n            return\
    \ true;\n        }\n        if brackets.starts_with(\"[\") && brackets.ends_with(\"\
    ]\") {\n            brackets.remove(1);\n            brackets.remove(1);\n   \
    \         return true;\n        }\n        if brackets.starts_with(\"{\") && brackets.ends_with(\"\
    }\") {\n            brackets.remove(1);\n            brackets.remove(1);\n   \
    \         return true;\n        }\n        if brackets.starts_with(\"(\") && brackets.ends_with(\"\
    [\") {\n            brackets.remove(1);\n            brackets.remove(1);\n   \
    \         return true;\n        }\n        if brackets.starts_with(\"[\") && brackets.ends_with(\"\
    (\") {\n            brackets.remove(1);\n            brackets.remove(1);\n   \
    \         return true;\n        }\n        if brackets.starts_with(\"{\") && brackets.ends_with(\"\
    }[\") {\n            brackets.remove(1);\n            brackets.remove(1);\n  \
    \          return true;\n        }\n        if brackets.starts_with(\"{\") &&\
    \ brackets.ends_with(\"()\") {\n            brackets.remove(1);\n            brackets.remove(1);\n\
    \            return true;\n        }\n        if brackets.starts_with(\"[\") &&\
    \ brackets.ends_with(\"](\") {\n            brackets.remove(1);\n            brackets.remove(1);\n\
    \            return true;\n        }\n        if brackets.starts_with(\"()[\"\
    ) && brackets.ends_with(\"[\") {\n            brackets.remove(1);\n          \
    \  brackets.remove(1);\n            return true;\n        }\n        if brackets.starts_with(\"\
    ()[\") && brackets.ends_with(\"(\") {\n            brackets.remove(1);\n     \
    \       brackets.remove(1);\n            return true;\n        }\n        if brackets.starts_with(\"\
    [\") && brackets.ends_with(\"]\") {\n            brackets.remove(1);\n       \
    \     brackets.remove(1);\n            return true;\n        }\n        if brackets.starts_with(\"\
    (){\") && brackets.ends_with(\"}\") {\n            brackets.remove(1);\n     \
    \       brackets.remove(1);\n            return true;\n        }\n        if brackets.starts_with(\"\
    ({\") && brackets.ends_with(\"}[\") {\n            brackets.remove(1);\n     \
    \       brackets.remove(1);\n            return true;\n        }\n        if brackets.starts_with(\"\
    ({\") && brackets.ends_with(\"()\") {\n            brackets.remove(1);\n     \
    \       brackets.remove(1);\n            return true;\n        }\n        if brackets.starts_with(\"\
    {[\") && brackets.ends_with(\"}\") {\n            brackets.remove(1);\n\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr3prdeei.rs:103:3\n\
    \    |\n11  | fn correct_bracketing(brackets: String) -> bool {\n    |       \
    \                                          - unclosed delimiter\n12  |     let\
    \ mut brackets = brackets.to_lowercase();\n13  |     while brackets.len() > 2\
    \ {\n    |                              - unclosed delimiter\n...\n84  |     \
    \    if brackets.starts_with(\"{[\") && brackets.ends_with(\"}\") {\n    |   \
    \                                                               - this delimiter\
    \ might not be properly closed...\n...\n87  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n103 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n   --> /tmp/tmpr3prdeei.rs:13:5\n    |\n11  |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n    |                                              ---- expected\
    \ `bool` because of return type\n12  |       let mut brackets = brackets.to_lowercase();\n\
    13  | /     while brackets.len() > 2 {\n14  | |         if brackets.starts_with(\"\
    (\") && brackets.ends_with(\")\") {\n15  | |             brackets.remove(1);\n\
    16  | |             brackets.remove(1);\n...   |\n102 | |     assert_eq!(candidate(String::from(\"\
    ()()(()())()))()\")), false);\n103 | | }\n    | |__^ expected `bool`, found `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for i in 0..brackets.len() {\n        if i > 0 && brackets[i\
    \ - 1] !== '(' {\n            stack.push(brackets[i - 1]);\n        }\n      \
    \  if i < brackets.len() - 1 && brackets[i + 1] != ')' {\n            stack.push(brackets[i\
    \ + 1]);\n        }\n        if i == 0 || i == brackets.len() - 1 || brackets[i\
    \ - 1] &&\n            brackets[i + 1] &&\n            brackets[i - 1] != brackets[i\
    \ + 1] {\n            stack.push(brackets[i - 1]);\n        }\n    }\n\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: invalid comparison operator `!==`\n  --> /tmp/tmph423smmp.rs:14:37\n\
    \   |\n14 |         if i > 0 && brackets[i - 1] !== '(' {\n   |              \
    \                       ^^^ help: `!==` is not a valid comparison operator, use\
    \ `!=`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmph423smmp.rs:14:21\n   |\n14 |         if i > 0 && brackets[i - 1] !==\
    \ '(' {\n   |                     ^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph423smmp.rs:15:24\n   |\n15 |             stack.push(brackets[i\
    \ - 1]);\n   |                        ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph423smmp.rs:17:38\n   |\n17 |         if i < brackets.len() - 1\
    \ && brackets[i + 1] != ')' {\n   |                                      ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n           "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .take(brackets.len())\n        .all(|b| b == (brackets.chars().next().unwrap())\
    \ as u8)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpggyamk5h.rs:15:23\n   |\n\
    15 |         .all(|b| b == (brackets.chars().next().unwrap()) as u8)\n   |   \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `u8`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .map(|c| {\n            match c {\n               \
    \ '(' | ')' as _ => true,\n                _ => false,\n            }\n      \
    \  })\n        .all(|x| x)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpl0bvva6_.rs:16:27\n   |\n16 |                 '(' | ')'\
    \ as _ => true,\n   |                           ^^ expected one of `...`, `..=`,\
    \ `..`, `=>`, `if`, or `|`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.ends_with(')')\n \
    \       .unwrap()\n        .chars()\n        .all(|c| c == b'(')\n    {\n    \
    \    brackets += '(';\n    }\n    while !brackets.ends_with(')')\n        .unwrap()\n\
    \        .chars()\n        .all(|c| c == b'(')\n    {\n        brackets += ')';\n\
    \    }\n    brackets.ends_with(')')\n        .unwrap()\n        == true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmp8mqcrsch.rs:14:10\n   |\n14 |         .unwrap()\n   | \
    \         ^^^^^^ method not found in `bool`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8mqcrsch.rs:18:21\n   |\n18 |         brackets += '(';\n   |  \
    \                   ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n18 |         brackets +=\
    \ \"(\";\n   |                     ~~~\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `bool` in the current scope\n  --> /tmp/tmp8mqcrsch.rs:21:10\n\
    \   |\n21 |         .unwrap()\n   |          ^^^^^^ method not found in `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8mqcrsch.rs:25:21\n   |\n25 |\
    \         brackets += ')';\n   |                     ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n25 |         brackets += \")\";\n   |                     ~~~\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `bool` in the current scope\n  --> /tmp/tmp8mqcrsch.rs:28:10\n\
    \   |\n28 |         .unwrap()\n   |          ^^^^^^ method not found in `bool`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut has_open_bracket = false;\n    let mut has_close_bracket = false;\n\n  \
    \  for c in brackets.chars() {\n        match c {\n            '(' => {\n    \
    \            has_open_bracket = true;\n            }\n            '[' => {\n \
    \               has_open_bracket = true;\n            }\n            '{' => {\n\
    \                has_open_bracket = true;\n            }\n            '(' | '['\
    \ | '{' => {\n                has_close_bracket = true;\n            }\n     \
    \       _ => {\n                continue;\n            }\n        }\n    }\n\n\
    \    has_close_bracket\n        && has_open_bracket\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfuy0h5oc.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_owned();\n    brackets.reverse();\n    let mut last_open_bracket\
    \ = String::new();\n    let mut found = false;\n    while !brackets.is_empty()\
    \ {\n        let next_open_bracket = brackets.split_off(&last_open_bracket).unwrap();\n\
    \        if found {\n            assert!(next_open_bracket.len() == 1);\n    \
    \        if next_open_bracket.is_empty() {\n                brackets.pop();\n\
    \                continue;\n            }\n            assert!(!brackets.is_empty());\n\
    \        } else {\n            last_open_bracket = next_open_bracket;\n      \
    \      found = true;\n        }\n    }\n    found\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpjws1panw.rs:13:14\n   |\n13 |     brackets.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjws1panw.rs:17:52\n\
    \   |\n17 |         let next_open_bracket = brackets.split_off(&last_open_bracket).unwrap();\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `&String`\n\nerror[E0599]: no method named `unwrap` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpjws1panw.rs:17:72\n   |\n\
    17 |         let next_open_bracket = brackets.split_off(&last_open_bracket).unwrap();\n\
    \   |                                                                        ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ is_opening_bracket(c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_opening_bracket` in this scope\n\
    \  --> /tmp/tmpqv2o0rdc.rs:12:30\n   |\n12 |     brackets.chars().all(|c| is_opening_bracket(c))\n\
    \   |                              ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut index = 0;\n    while index < brackets.len() {\n        let opening = brackets[index];\n\
    \        let closing = brackets[index + 1];\n\n        if opening != closing {\n\
    \            return false;\n        }\n\n        index += 2;\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6vmy6ha5.rs:14:23\n\
    \   |\n14 |         let opening = brackets[index];\n   |                     \
    \  ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6vmy6ha5.rs:15:23\n   |\n15 |         let closing = brackets[index\
    \ + 1];\n   |                       ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening = String::new();\n    let mut closing = String::new();\n    let\
    \ mut inside_bracket = String::new();\n\n    brackets.chars().for_each(|c|\n \
    \       if c == '(' {\n            opening = opening.push_str(&inside_bracket);\n\
    \            inside_bracket.push_str(&inside_bracket);\n        } else {\n   \
    \         closing = closing.push_str(&inside_bracket);\n            inside_bracket.push_str(&inside_bracket);\n\
    \        }\n    );\n\n    opening.len() == 0\n        && closing.len() == 0\n\
    \        && inside_bracket.len() == brackets.len()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr242xma6.rs:18:23\n   |\n\
    12 |     let mut opening = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n18 |             opening = opening.push_str(&inside_bracket);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n\
    \  --> /tmp/tmpr242xma6.rs:18:31\n   |\n18 |             opening = opening.push_str(&inside_bracket);\n\
    \   |                       ------- ^^^^^^^^ this call modifies `opening` in-place\n\
    \   |                       |\n   |                       you probably want to\
    \ use this value after calling the method...\n   = note: ...instead of the `()`\
    \ output of method `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr242xma6.rs:21:23\n\
    \   |\n13 |     let mut closing = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n21 |             closing = closing.push_str(&inside_bracket);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n\
    \  --> /tmp/tmpr242xma6.rs:21:31\n   |\n21 |             closing = closing.push_str(&inside_bracket);\n\
    \   |                       ------- ^^^^^^^^ this call modifies `closing` in-place\n\
    \   |                       |\n   |                       you probably want to\
    \ use this value after calling the method...\n   = note: ...instead of the `()`\
    \ output of method `push_str`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.char_indices();\n    iter.next()\n        .and_then(|idx|\
    \ iter.by_ref().take_while(|&(_, char)| char != '('))\n        .fold(true, |a,\
    \ b| a && b);\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7s_j9qof.rs:14:25\n   |\n\
    14 |         .and_then(|idx| iter.by_ref().take_while(|&(_, char)| char != '('))\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `TakeWhile`\n   |\n   = note: expected\
    \ enum `Option<_>`\n            found struct `TakeWhile<&mut CharIndices<'_>,\
    \ [closure@/tmp/tmp7s_j9qof.rs:14:50: 14:74]>`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n14 |         .and_then(|idx| Some(iter.by_ref().take_while(|&(_,\
    \ char)| char != '(')))\n   |                         +++++                  \
    \                                +\n\nerror[E0599]: `Option<_>` is not an iterator\n\
    \   --> /tmp/tmp7s_j9qof.rs:15:10\n    |\n15  |           .fold(true, |a, b| a\
    \ && b);\n    |            ^^^^ `Option<_>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<_>: Iterator`\n\
    \            which is required by `&mut Option<_>: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7s_j9qof.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    let mut brackets = brackets.to_string();\n    while i < brackets.len()\
    \ {\n        if brackets[i] == '(' && brackets[i + 1] != ')' {\n            return\
    \ false;\n        }\n        i += 2;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl0h6pxe2.rs:15:12\n\
    \   |\n15 |         if brackets[i] == '(' && brackets[i + 1] != ')' {\n   |  \
    \          ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl0h6pxe2.rs:15:34\n   |\n15 |         if brackets[i] == '(' &&\
    \ brackets[i + 1] != ')' {\n   |                                  ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\
    \ == String::from(\"()\") || brackets == String::from(\"[]\")\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuubjohkj.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() != 1 {\n        return false;\n    }\n    if let Some(open) =\
    \ brackets.chars().find(|c| *c != '(') {\n        return false;\n    }\n    if\
    \ let Some(close) = brackets.chars().rfind(|c| *c != ')') {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi3xp8ad9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for brack in brackets.chars().filter_map(|c| if\
    \ c == '(' { (false, 1) } else if c == '[' { (true, 1) } else if c == '{' { (false,\
    \ 0) } else if c == '}' { (true, 0) } else if c == ')' { (false, -1) } else if\
    \ c == ']' { (true, -1) } else { panic!() }).take(10).rev() {\n        if let\
    \ (mut opening, opening_count) = (c, stack.pop().unwrap().1) {\n            if\
    \ let (mut closing, closing_count) = opening.as_mut() {\n                if closing_count\
    \ == opening_count {\n                    closing = opening;\n               \
    \ } else {\n                    stack.append((opening, closing_count));\n    \
    \            }\n            }\n        }\n    }\n    stack.iter().all(|(a, b)|\
    \ a == b)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp7l46bpa5.rs:14:48\n\
    \   |\n14 |         if let (mut opening, opening_count) = (c, stack.pop().unwrap().1)\
    \ {\n   |                                                ^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7l46bpa5.rs:13:64\n   |\n13 |\
    \     for brack in brackets.chars().filter_map(|c| if c == '(' { (false, 1) }\
    \ else if c == '[' { (true, 1) } else if c == '{' { (false, 0) ...\n   |     \
    \                                                           ^^^^^^^^^^ expected\
    \ enum `Option`, found tuple\n   |\n   = note: expected enum `Option<_>`\n   \
    \          found tuple `(bool, {integer})`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n13 |     for brack in brackets.chars().filter_map(|c| if c\
    \ == '(' { Some((false, 1)) } else if c == '[' { (true, 1) } else if c == '{'\
    \ { (false, 0) } else if c == '}' { (true, 0) } else if c == ')' { (false, -1)\
    \ } else if c == ']' { (true, -1) } else { panic!() }).take(10).rev() {\n   |\
    \                                                                +++++       \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7l46bpa5.rs:13:96\n   |\n\
    13 | ... c == '(' { (false, 1) } else if c == '[' { (true, 1) } else if c == '{'\
    \ { (false, 0) } else if c == '}' { (true, 0) } else if c == ')...\n   |     \
    \                                           ^^^^^^^^^ expected enum `Option`,\
    \ found tuple\n   |\n   = note: expected enum `Option<_>`\n             found\
    \ tuple `(bool, {integer})`\nhelp: try wrapping the expression in `Some`\n   |\n\
    13 |     for brack in brackets.chars().filter_map(|c| if c == '(' { (false, 1)\
    \ } else if c == '[' { Some((true, 1)) } else if c == '{' { (false, 0) } else\
    \ if c == '}' { (true, 0) } else if c == ')' { (false, -1) } else if c == ']'\
    \ { (true, -1) } else { panic!() }).take(10).rev() {\n   |                   \
    \                                                                            \
    \ +++++         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7l46bpa5.rs:13:127\n\
    \   |\n13 | ...f c == '[' { (true, 1) } else if c == '{' { "
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_opens = 0;\n    let mut opening_closes = 0;\n    let mut closing_opens\
    \ = 0;\n    let mut closing_closes = 0;\n\n    for ch in brackets {\n        match\
    \ ch {\n            '(' | '[' | '{'\n            => opening_opens += 1,\n    \
    \        _\n            | ')' | ']' | '}' | '{' | '['\n            => closing_opens\
    \ += 1,\n            _\n            | ')' | ']' | '}' | '{' | '['\n          \
    \  => opening_closes += 1,\n            _ => (),\n        }\n    }\n\n    opening_opens\
    \ == closing_opens\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpo78q1s7y.rs:17:15\n\
    \   |\n17 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().enumerate().all(|(i,\
    \ &c)| {\n        let mut opening = c == ',' || c == ']';\n        opening = opening\
    \ && !brackets.starts_with(String::from(\"[\"), i);\n        opening = opening\
    \ && !brackets.ends_with(String::from(\"]\"), i);\n        opening\n    })\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps5fn6o9s.rs:12:43\n   |\n\
    12 |     brackets.chars().enumerate().all(|(i, &c)| {\n   |                  \
    \                         ^^- expected due to this\n   |                     \
    \                      |\n   |                                           expected\
    \ `char`, found reference\n   |                                           help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmps5fn6o9s.rs:14:40\n\
    \     |\n14   |         opening = opening && !brackets.starts_with(String::from(\"\
    [\"), i);\n     |                                        ^^^^^^^^^^^ -----------------\
    \  - supplied 2 arguments\n     |                                        |\n \
    \    |                                        expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmps5fn6o9s.rs:15:40\n     |\n15\
    \   |         opening = opening && !brackets.ends_with(String::from(\"]\"), i);\n\
    \     |                                        ^^^^^^^^^ -----------------  -\
    \ supplied 2 arguments\n     |                                        |\n    \
    \ |                                        expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut depth = String::new();\n    for c in brackets.chars() {\n        if depth.len()\
    \ < 2 {\n            depth.push(c);\n        } else if depth[depth.len() - 2]\
    \ != c {\n            return false;\n        }\n        depth.pop();\n    }\n\
    \    depth.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7h94_10h.rs:16:19\n\
    \   |\n16 |         } else if depth[depth.len() - 2] != c {\n   |            \
    \       ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ find opening and closing brackets\n    let mut open_brackets = &brackets[..1];\n\
    \    let mut closed_brackets = &brackets[1..].chars().enumerate().filter(|(_,\
    \ ch)| ch == '(' || ch == ')').collect();\n\n    // ensure that the opening and\
    \ closing brackets match exactly\n    while open_brackets.len() != closed_brackets.len()\
    \ {\n        // find the first opening bracket\n        let opening = closed_brackets[..].iter().take_while(|&(index,\
    \ _)| index == 0).count();\n        // find the first closing bracket\n      \
    \  let closing = closed_brackets[1..].iter().take_while(|&(_, index)| index ==\
    \ opening).count();\n\n        // if they are not equal, then there is a mismatched\
    \ bracket\n        if opening != closing {\n            return false;\n      \
    \  }\n\n        // if we reach the end of the list, then they should be equal\n\
    \        if closing == 0 {\n            return true;\n        }\n\n        //\
    \ move both opening and closing brackets to the next index\n        open_brackets\
    \ = &open_brackets[opening..];\n        closed_brackets = &closed_brackets[closing..];\n\
    \    }\n\n    // if we get to here, then all brackets are closed off correctly\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_awh40eg.rs:14:86\n\
    \   |\n14 |     let mut closed_brackets = &brackets[1..].chars().enumerate().filter(|(_,\
    \ ch)| ch == '(' || ch == ')').collect();\n   |                              \
    \                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_awh40eg.rs:14:99\n\
    \   |\n14 |     let mut closed_brackets = &brackets[1..].chars().enumerate().filter(|(_,\
    \ ch)| ch == '(' || ch == ')').collect();\n   |                              \
    \                                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().fold(false,\
    \ |acc, c| acc && c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8_uzzpbk.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    !brackets.chars().any(|c|\
    \ c.is_ascii_letter() || c == '(' || c == '[')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp90ipcq_e.rs:12:33\n   |\n12 |     !brackets.chars().any(|c|\
    \ c.is_ascii_letter() || c == '(' || c == '[')\n   |                         \
    \        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter: chars::Iterator = brackets.chars();\n    let mut opened: bool = iter.next();\
    \ // first opening is OK\n    while let Some(open) = opened {\n        let closed\
    \ = iter.next(); // second closing is OK\n        if open == closed {\n      \
    \      iter.next(); // third closing is OK\n            iter.next(); // fourth\
    \ closing is OK\n        }\n        else {\n            closed = Some(open);\n\
    \            opened = Some(closed);\n        }\n    }\n    opened == Some(brackets.len())\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpylwd6tb2.rs:12:19\n   |\n12 |     let mut iter: chars::Iterator\
    \ = brackets.chars();\n   |                   ^^^^^ use of undeclared crate or\
    \ module `chars`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpylwd6tb2.rs:14:15\n\
    \   |\n14 |     while let Some(open) = opened {\n   |               ^^^^^^^^^^\
    \   ------ this expression has type `bool`\n   |               |\n   |       \
    \        expected `bool`, found enum `Option`\n   |\n   = note: expected type\
    \ `bool`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpylwd6tb2.rs:22:22\n   |\n13 |     let mut opened: bool = iter.next();\
    \ // first opening is OK\n   |                     ---- expected due to this type\n\
    ...\n22 |             opened = Some(closed);\n   |                      ^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<Option<_>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpylwd6tb2.rs:25:15\n   |\n25 |     opened == Some(brackets.len())\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found enum `Option`\n\
    \   |\n   = note: expected type `bool`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut current = brackets.chars().nth(1);\n    let mut closed = brackets.chars().nth(1);\n\
    \    for _ in 0..2 {\n        if current != closed {\n            return false;\n\
    \        }\n        closed = brackets.chars().nth(1);\n        current = brackets.chars().nth(1);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6e2aj0kx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counter = 0;\n    for i in brackets.chars().skip(1) {\n        if i == '('\
    \ {\n            counter += 1;\n        } else if i == ')' {\n            counter\
    \ -= 1;\n        } else if counter == 0 {\n            return false;\n       \
    \ }\n    }\n    counter == brackets.chars().count() - 2\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpw7osr9y8.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\
    \ == brackets.replace(\"(\", \"[\").replace(\")\", \"]\").to_string()\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp654bm8t8.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening = brackets.chars();\n    let mut closing = brackets.chars();\n \
    \   let mut next = opening.next();\n    while next.unwrap() != ')' {\n       \
    \ if next.unwrap() == '(' {\n            closing.push(')');\n        } else {\n\
    \            closing.push(':');\n        }\n        next = opening.next();\n \
    \   }\n    closing.pop();\n    closing.as_slice() != opening.as_slice()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpibp4kyak.rs:17:21\n   |\n17 |             closing.push(')');\n\
    \   |                     ^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `push` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpibp4kyak.rs:19:21\n   |\n19 |             closing.push(':');\n   | \
    \                    ^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no\
    \ method named `pop` found for struct `Chars` in the current scope\n  --> /tmp/tmpibp4kyak.rs:23:13\n\
    \   |\n23 |     closing.pop();\n   |             ^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `as_slice` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpibp4kyak.rs:24:13\n   |\n24 |     closing.as_slice() !=\
    \ opening.as_slice()\n   |             ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `as_slice` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpibp4kyak.rs:24:35\n   |\n24 |     closing.as_slice() !=\
    \ opening.as_slice()\n   |                                   ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut chars: Vec<_> = brackets.chars().collect();\n    let mut bracket_count =\
    \ chars.len();\n    while bracket_count > 0 && chars.peek().unwrap() == ')' {\n\
    \        chars.pop();\n        bracket_count -= 1;\n    }\n    bracket_count ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `peek` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpom220xd0.rs:14:38\n   |\n14 |     while bracket_count\
    \ > 0 && chars.peek().unwrap() == ')' {\n   |                                \
    \      ^^^^ method not found in `Vec<char>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets: Vec<String> = brackets.split(')').collect();\n    let mut open_brackets:\
    \ Vec<String> = brackets.clone();\n    open_brackets.drain(..).iter().for_each(|open|\
    \ {\n        if open.starts_with('(') {\n            if open_brackets.iter().any(|b|\
    \ b == open) {\n                open_brackets.remove(open);\n            }\n \
    \       } else {\n            if open_brackets.iter().any(|b| b == open) {\n \
    \               open_brackets.remove(open);\n            } else {\n          \
    \      return false;\n            }\n        }\n    });\n    open_brackets.drain(..).iter().for_each(|open|\
    \ {\n        if open.ends_with(')') {\n            if open_brackets.iter().any(|b|\
    \ b == open) {\n                open_brackets.remove(open);\n            }\n \
    \       } else {\n            if open_brackets.iter().any(|b| b == open) {\n \
    \               open_brackets.remove(open);\n            } else {\n          \
    \      return false;\n            }\n        }\n    });\n    open_brackets.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpfhqc187g.rs:12:57\n     |\n12\
    \   |     let mut brackets: Vec<String> = brackets.split(')').collect();\n   \
    \  |                                                         ^^^^^^^ value of\
    \ type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n \
    \    |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `std::vec::Drain` in the current scope\n  --> /tmp/tmpfhqc187g.rs:14:29\n  \
    \ |\n14 |     open_brackets.drain(..).iter().for_each(|open| {\n   |         \
    \                    ^^^^ private field, not a method\n\nerror[E0599]: no method\
    \ named `iter` found for struct `std::vec::Drain` in the current scope\n  -->\
    \ /tmp/tmpfhqc187g.rs:27:29\n   |\n27 |     open_brackets.drain(..).iter().for_each(|open|\
    \ {\n   |                             ^^^^ private field, not a method\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ !c.is_alphanumeric() && c != '(' && c != ')')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy38dzvif.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp04kge0f3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut has_opening = false;\n    let mut has_closing = false;\n\n    for c in &brackets\
    \ {\n        match c {\n            '(' => {\n                has_opening = true;\n\
    \            }\n            ')' => {\n                has_closing = true;\n  \
    \          }\n            _ => (),\n        }\n    }\n\n    has_opening && has_closing\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp_clixy91.rs:15:14\n\
    \   |\n15 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets: Vec<_> = brackets.chars().collect();\n    let mut closing_brackets:\
    \ Vec<_> = brackets.chars().collect();\n    let mut has_opening_brackets = false;\n\
    \    let mut has_closing_brackets = false;\n    while !opening_brackets.is_empty()\
    \ {\n        let opening_bracket = opening_brackets.remove(0);\n        has_opening_brackets\
    \ = opening_bracket.to_string().len() > 0;\n        if has_opening_brackets {\n\
    \            if opening_bracket.to_string() == \")\" {\n                has_closing_brackets\
    \ = true;\n                break;\n            }\n            has_opening_brackets\
    \ = false;\n        }\n    }\n    if !closing_brackets.is_empty() {\n        has_closing_brackets\
    \ = true;\n    }\n    has_opening_brackets && has_closing_brackets\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvux9xxva.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets {\n        stack.unpush(0);\n\
    \    }\n    let mut bracket: usize = 0;\n    let mut opening_bracket = false;\n\
    \    let mut last: usize = 0;\n    while bracket < brackets.len() {\n        if\
    \ brackets.chars().nth(bracket).unwrap() == ')' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n        if brackets.chars().nth(bracket).unwrap() == '(' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.push(0);\n            opening_bracket = true;\n        }\n\
    \        if opening_bracket {\n            if brackets.chars().nth(bracket).unwrap()\
    \ != ')' {\n                opening_bracket = false;\n            }\n        }\n\
    \        if opening_bracket {\n            stack.push(bracket);\n            last\
    \ = bracket;\n        }\n        bracket += 1;\n    }\n    if stack.len() != 0\
    \ {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp8zi_72ze.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `unpush` found for struct `Vec<usize>` in the current scope\n \
    \ --> /tmp/tmp8zi_72ze.rs:14:15\n   |\n14 |         stack.unpush(0);\n   |   \
    \            ^^^^^^ help: there is an associated function with a similar name:\
    \ `push`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut last = 0;\n    let mut depth = 0;\n   \
    \ for ch in brackets.chars() {\n        if ch == ')' {\n            depth -= 1;\n\
    \            if depth == 0 {\n                stack.push(last);\n            }\n\
    \        }\n        if ch == '(' {\n            depth += 1;\n        }\n     \
    \   last = ch;\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp64u38j3.rs:25:16\n   |\n\
    13 |     let mut last = 0;\n   |                    - expected due to this value\n\
    ...\n25 |         last = ch;\n   |                ^^ expected integer, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut closed = false;\n    brackets.chars().for_each(|c|\n        if closed &&\
    \ c == '(' { closed = false; }\n        closed && c == ')' { closed = true; }\n\
    \    );\n    !closed\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, `else`, or an operator, found\
    \ `closed`\n  --> /tmp/tmp3_kgmt4u.rs:15:9\n   |\n14 |         if closed && c\
    \ == '(' { closed = false; }\n   |                                           \
    \       -\n   |                                                  |\n   |     \
    \                                             expected one of `)`, `,`, `.`, `?`,\
    \ `else`, or an operator\n   |                                               \
    \   help: missing `,`\n15 |         closed && c == ')' { closed = true; }\n  \
    \ |         ^^^^^^ unexpected token\n\nerror: expected one of `)`, `,`, `.`, `?`,\
    \ or an operator, found `{`\n  --> /tmp/tmp3_kgmt4u.rs:15:28\n   |\n15 |     \
    \    closed && c == ')' { closed = true; }\n   |                           -^\
    \ expected one of `)`, `,`, `.`, `?`, or an operator\n   |                   \
    \        |\n   |                           help: missing `,`\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmp3_kgmt4u.rs:15:19\n   |\n\
    15 |         closed && c == ')' { closed = true; }\n   |                   ^ not\
    \ found in this scope\n\nerror[E0061]: this function takes 1 argument but 3 arguments\
    \ were supplied\n   --> /tmp/tmp3_kgmt4u.rs:13:22\n    |\n13  |       brackets.chars().for_each(|c|\n\
    \    |  ______________________^^^^^^^^_-\n    | |                      |\n   \
    \ | |                      expected 1 argument\n14  | |         if closed && c\
    \ == '(' { closed = false; }\n    | |_________________________________________________-\n\
    15  |           closed && c == ')' { closed = true; }\n    |           ------------------\
    \ ------------------ supplied 3 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ we use a set to avoid inserting duplicate brackets\n    let mut brackets = brackets.to_string();\n\
    \    let mut last_close = String::new();\n    while brackets.chars().any(|c| {\n\
    \        match c {\n            ' ' => true,  // ignore spaces\n            '('\
    \ | '[' => true,  // brackets indicate a closure\n            ')' | ']' => true,\
    \  // brackets indicate a closure\n            _ => false,      // otherwise,\
    \ everything else is a closure\n        }\n    }) {\n        brackets.chars().for_each(|c|\n\
    \            if c == ' ' {\n                return;\n            } else if c ==\
    \ '(' || c == '[' {\n                last_close = c;\n            } else if c\
    \ == ')' || c == ']' {\n                if last_close == c {\n               \
    \     last_close = String::new();\n                }\n                last_close\
    \ = String::new();\n            }\n        );\n    }\n    brackets.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbab6d39.rs:27:30\n   |\n\
    14 |     let mut last_close = String::new();\n   |                          -------------\
    \ expected due to this value\n...\n27 |                 last_close = c;\n   |\
    \                              ^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |\n   |                              expected\
    \ struct `String`, found `char`\n\nerror[E0277]: can't compare `String` with `char`\n\
    \  --> /tmp/tmptbab6d39.rs:29:31\n   |\n29 |                 if last_close ==\
    \ c {\n   |                               ^^ no implementation for `String ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Stack::new();\n    let mut open_brackets = String::new();\n    let\
    \ mut close_brackets = String::new();\n    stack.push(brackets);\n    while let\
    \ Some(mut brackets) = stack.pop() {\n        let mut curr = brackets;\n     \
    \   while let Some(mut c) = curr.chars().next() {\n            if c == '(' {\n\
    \                let mut end = c.to_string();\n                close_brackets.push_str(&end);\n\
    \                open_brackets.push('(');\n                stack.push(c);\n  \
    \          } else if c == '{' {\n                let mut end = c.to_string();\n\
    \                close_brackets.push_str(&end);\n                open_brackets.push('{');\n\
    \                stack.push(c);\n            } else if c == '}' {\n          \
    \      let mut end = c.to_string();\n                close_brackets.push_str(&end);\n\
    \                open_brackets.push('}');\n                stack.push(c);\n  \
    \          } else if c == '[' {\n                let mut end = c.to_string();\n\
    \                close_brackets.push_str(&end);\n                open_brackets.push('[');\n\
    \                stack.push(c);\n            } else if c == ']' {\n          \
    \      let mut end = c.to_string();\n                close_brackets.push_str(&end);\n\
    \                open_brackets.push(']');\n                stack.push(c);\n  \
    \          } else if c == '\"' {\n                let mut end = c.to_string();\n\
    \                close_brackets.push_str(&end);\n                open_brackets.push('\"\
    ');\n                stack.push(c);\n            } else if c == '\\'' {\n    \
    \            let mut end = c.to_string();\n                close_brackets.push_str(&end);\n\
    \                open_brackets.push('\\'');\n                stack.push(c);\n\
    \            } else {\n                open_brackets.push_str(&c.to_string());\n\
    \                stack.push(c);\n            }\n        }\n    }\n    open_brackets.len()\
    \ == close_brackets.len() && open_brackets == close_brackets\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp7tz85f2x.rs:12:21\n   |\n12 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\
    \ == brackets.replace(brackets, \"\").chars().all(|c| *c == ')')\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   -->\
    \ /tmp/tmp6lmv_hn7.rs:12:34\n    |\n12  |     brackets == brackets.replace(brackets,\
    \ \"\").chars().all(|c| *c == ')')\n    |                          ------- ^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n    |                      \
    \    |\n    |                          required by a bound introduced by this\
    \ call\n    |\n    = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `str::<impl str>::replace`\nhelp:\
    \ consider borrowing here\n    |\n12  |     brackets == brackets.replace(&brackets,\
    \ \"\").chars().all(|c| *c == ')')\n    |                                  +\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6lmv_hn7.rs:12:64\n\
    \   |\n12 |     brackets == brackets.replace(brackets, \"\").chars().all(|c| *c\
    \ == ')')\n   |                                                              \
    \  ^^\n\nerror[E0277]: can't compare `String` with `bool`\n  --> /tmp/tmp6lmv_hn7.rs:12:14\n\
    \   |\n12 |     brackets == brackets.replace(brackets, \"\").chars().all(|c| *c\
    \ == ')')\n   |              ^^ no implementation for `String == bool`\n   |\n\
    \   = help: the trait `PartialEq<bool>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut s = brackets;\n    let mut open_count = open_chars(&mut s);\n    while open_count\
    \ > 0 {\n        s.remove(0);\n        open_count = open_chars(&mut s);\n    }\n\
    \    s.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `open_chars` in this scope\n  --> /tmp/tmp0i0j44bl.rs:13:26\n\
    \   |\n13 |     let mut open_count = open_chars(&mut s);\n   |               \
    \           ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `open_chars` in this scope\n  --> /tmp/tmp0i0j44bl.rs:16:22\n   |\n16 |    \
    \     open_count = open_chars(&mut s);\n   |                      ^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n\n    for i in 0..brackets.len() {\n      \
    \  stack.push(i);\n    }\n\n    while stack.len() > 0 {\n        let mut pos =\
    \ stack.last().unwrap();\n\n        if brackets[pos] == '(' { stack.push(pos +\
    \ 1); }\n        if brackets[pos] == ')' { stack.pop();\n            if stack.len()\
    \ == 0 { return false; }\n        }\n    }\n\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `&usize`\n  --> /tmp/tmpu9di5ejd.rs:21:12\n\
    \   |\n21 |         if brackets[pos] == '(' { stack.push(pos + 1); }\n   |   \
    \         ^^^^^^^^^^^^^ `String` cannot be indexed by `&usize`\n   |\n   = help:\
    \ the trait `Index<&usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `&usize`\n\
    \  --> /tmp/tmpu9di5ejd.rs:22:12\n   |\n22 |         if brackets[pos] == ')' {\
    \ stack.pop();\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `&usize`\n\
    \   |\n   = help: the trait `Index<&usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_count = 1;\n    let mut\
    \ close_count = 1;\n\n    loop {\n        if open_count > close_count {\n    \
    \        return false;\n        }\n        if open_count == close_count {\n  \
    \          open_count += 1;\n            close_count += 1;\n        } else {\n\
    \            if !brackets.contains('(') {\n                return false;\n   \
    \         }\n            brackets = brackets.replace(\"(\", \"(\");\n        \
    \    brackets = brackets.replace(\")\", \")\");\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976140
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.ends_with(')') {\n\
    \        if !brackets.ends_with('(') {\n            return false;\n        }\n\
    \        let end = brackets.rfind(')');\n        brackets = &brackets[..end +\
    \ 1];\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmprmp_a9m3.rs:18:36\n\
    \   |\n18 |         brackets = &brackets[..end + 1];\n   |                   \
    \             --- ^ - {integer}\n   |                                |\n   | \
    \                               Option<usize>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprmp_a9m3.rs:18:20\n   |\n12 |     let mut brackets = brackets.to_string();\n\
    \   |                        -------------------- expected due to this value\n\
    ...\n18 |         brackets = &brackets[..end + 1];\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n18 |         brackets = (&brackets[..end + 1]).to_string();\n   |     \
    \               +                    +++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counter = 0;\n    let mut bracketing = false;\n    let mut stack: Vec<&str>\
    \ = brackets.chars().collect();\n    while !stack.is_empty() {\n        let char:\
    \ &str = stack.last().unwrap();\n        let last_index: usize = stack\n     \
    \       .iter()\n            .skip(stack.len())\n            .position(|x| x ==\
    \ char)\n            .unwrap_or(usize::max_value());\n        if last_index >\
    \ counter {\n            counter += 1;\n        }\n        if stack.is_empty()\
    \ {\n            break;\n        }\n        stack.truncate(stack.len() - 1);\n\
    \        stack.append(char);\n        bracketing = char == '(' || char == ')';\n\
    \        if stack.len() == 0 {\n            break;\n        }\n    }\n    bracketing\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpcio1e02q.rs:14:49\n     |\n14\
    \   |     let mut stack: Vec<&str> = brackets.chars().collect();\n     |     \
    \                                            ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpcio1e02q.rs:20:29\n\
    \   |\n20 |             .position(|x| x == char)\n   |                       \
    \      ^^ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcio1e02q.rs:29:22\n   |\n29 |         stack.append(char);\n   |    \
    \                  ^^^^ types differ in mutability\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<&str>`\n                      found reference `&str`\n\
    \nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpcio1e02q.rs:30:27\n\
    \   |\n30 |         bracketing = char == '(' || char == ')';\n   |           \
    \                ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.parse::<Tokens<'_>>().unwrap().is_balanced()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Tokens` in this scope\n  --> /tmp/tmpxo7nj98r.rs:12:22\n\
    \   |\n12 |     brackets.parse::<Tokens<'_>>().unwrap().is_balanced()\n   |  \
    \                    ^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.chars();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    let mut opening_char = String::new();\n\
    \    let mut closing_char = String::new();\n\n    loop {\n        match iter.next()\
    \ {\n            Some('(') => {\n                opening_brackets.push_str(&mut\
    \ opening_char);\n                closing_char = String::new();\n            \
    \    opening_char = String::new();\n                closing_char = String::new();\n\
    \            }\n            Some(')') => {\n                closing_brackets.push_str(&mut\
    \ closing_char);\n                opening_char = String::new();\n            \
    \    closing_char = String::new();\n            }\n            Some(c) => opening_char.push_str(&mut\
    \ c),\n            None => {\n                closing_char = closing_char.push_str(&mut\
    \ iter.next().unwrap());\n                opening_char = opening_char.push_str(&mut\
    \ iter.next().unwrap());\n                opening_brackets.push_str(&mut opening_char);\n\
    \                closing_brackets.push_str(&mut closing_char);\n            }\n\
    \        }\n    }\n\n    for opening in opening_brackets.chars() {\n        if\
    \ closing_brackets.chars().any(|c| *c == opening) {\n            return false;\n\
    \        }\n    }\n    for closing in closing_brackets.chars() {\n        if opening_brackets.chars().any(|c|\
    \ *c == closing) {\n            return false;\n        }\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6i97zgcy.rs:31:46\n   |\n\
    31 |             Some(c) => opening_char.push_str(&mut c),\n   |             \
    \                                 ^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note:      expected reference `&str`\n           found mutable reference\
    \ `&mut char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6i97zgcy.rs:33:54\n\
    \   |\n33 |                 closing_char = closing_char.push_str(&mut iter.next().unwrap());\n\
    \   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note:      expected reference `&str`\n\
    \           found mutable reference `&mut char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6i97zgcy.rs:33:32\n   |\n16 |     let mut closing_char = String::new();\n\
    \   |                            ------------- expected due to this value\n...\n\
    33 |                 closing_char = closing_char.push_str(&mut iter.next().unwrap());\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmp6i97zgcy.rs:33:45\n   |\n33 |         \
    \        closing_char = closing_char.push_str(&mut iter.next().unwrap());\n  \
    \ |                                ------------ ^^^^^^^^ this call modifies `closing_char`\
    \ in-place\n   |                                |\n   |                      \
    \          you probably want to use this value after calling the method...\n \
    \  = note: ...instead of the `()` output of method `push_str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6i97zgcy.rs:34:54\n   |\n34 |              \
    \   opening_char = opening_char.push_str(&mut iter.next().unwrap());\n   |   \
    \                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note:      expected reference `&str`\n\
    \           found mutable reference `&mut char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6i97zgcy.rs:34:32\n   |\n15 |     let mut opening_char = String::new();\n\
    \   |            "
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.chars().count() != brackets.len() {\n        return false;\n    }\n\
    \n    let mut brackets_iter = brackets.chars();\n    let mut current_char: char;\n\
    \    loop {\n        current_char = match brackets_iter.next() {\n           \
    \ Some('(') => '(',\n            Some(')') => ')',\n            Some('[') => '[',\n\
    \            Some(']') => ']',\n            _ => return false,\n        };\n\n\
    \        match current_char {\n            Some(b) => if brackets_iter.next()\
    \ != Some(b) {\n                return false;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoip1_gp4.rs:28:13\n   |\n\
    27 |         match current_char {\n   |               ------------ this expression\
    \ has type `char`\n28 |             Some(b) => if brackets_iter.next() != Some(b)\
    \ {\n   |             ^^^^^^^ expected `char`, found enum `Option`\n   |\n   =\
    \ note: expected type `char`\n              found enum `Option<_>`\n\nwarning:\
    \ unreachable expression\n  --> /tmp/tmpoip1_gp4.rs:34:5\n   |\n18 | /     loop\
    \ {\n19 | |         current_char = match brackets_iter.next() {\n20 | |      \
    \       Some('(') => '(',\n21 | |             Some(')') => ')',\n...  |\n32 |\
    \ |         }\n33 | |     }\n   | |_____- any code following this expression is\
    \ unreachable\n34 |       true\n   |       ^^^^ unreachable expression\n   |\n\
    \   = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ c == b'(' && c == b')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp90ywxami.rs:12:35\n   |\n\
    12 |     brackets.chars().any(|c| c == b'(' && c == b')')\n   |              \
    \                     ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp90ywxami.rs:12:48\n   |\n12 |     brackets.chars().any(|c|\
    \ c == b'(' && c == b')')\n   |                                              \
    \  ^^^^ expected `char`, found `u8`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut cur = brackets.chars();\n    loop {\n        if let Some(next) = cur.next()\
    \ {\n            if next == '(' && next != ')' {\n                return false;\n\
    \            }\n            if next == ')' && cur.is_none() {\n              \
    \  return true;\n            }\n        }\n        match cur.rev() {\n       \
    \     Some(b) => cur = b,\n            None => return true,\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_none` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpf9a_aog3.rs:18:35\n   |\n18 |             if next\
    \ == ')' && cur.is_none() {\n   |                                   ^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf9a_aog3.rs:23:13\n\
    \   |\n22 |         match cur.rev() {\n   |               --------- this expression\
    \ has type `Rev<Chars<'_>>`\n23 |             Some(b) => cur = b,\n   |      \
    \       ^^^^^^^ expected struct `Rev`, found enum `Option`\n   |\n   = note: expected\
    \ struct `Rev<Chars<'_>>`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf9a_aog3.rs:24:13\n   |\n22 |         match\
    \ cur.rev() {\n   |               --------- this expression has type `Rev<Chars<'_>>`\n\
    23 |             Some(b) => cur = b,\n24 |             None => return true,\n\
    \   |             ^^^^ expected struct `Rev`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Rev<Chars<'_>>`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().enumerate().filter(|&(_,\
    \ c)| c == '(' || c == '[' || c == '{').count() == brackets.len() - 1\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp327tnvh5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Stack::new();\n    let mut opens = HashSet::new();\n    for c in\
    \ brackets {\n        if opens.contains(c) {\n            stack.push(c);\n   \
    \     } else {\n            stack.pop();\n            opens.insert(c);\n     \
    \   }\n    }\n    opens.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpgjumvds8.rs:12:21\n   |\n12 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpgjumvds8.rs:13:21\n\
    \   |\n13 |     let mut opens = HashSet::new();\n   |                     ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmpgjumvds8.rs:14:14\n   |\n14 |     for c in brackets\
    \ {\n   |              ^^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found = false;\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        if c == '(' {\n            count += 1;\n        } else if c == '[' {\n\
    \            count += 1;\n        } else if c == '{' {\n            count += 1;\n\
    \        } else if c == '(' && count == 0 {\n            found = true;\n     \
    \   }\n        if c == '(' && count != 0 {\n            count -= 1;\n        }\
    \ else if c == ')' && count == 0 {\n            found = true;\n        }\n   \
    \     if c == ']' && count != 0 {\n            count -= 1;\n        } else if\
    \ c == '}' && count == 0 {\n            found = true;\n        }\n        if count\
    \ == 0 {\n            found = false;\n        }\n    }\n    found\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx_nrymn0.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ First we must split brackets\n    let mut left_brackets = String::new();\n \
    \   let mut right_brackets = String::new();\n    for bracket in &brackets {\n\
    \        match bracket {\n            '(' | ')' => {\n                // Add opening\
    \ bracket\n                left_brackets.push(bracket);\n            }\n     \
    \       '[' | ']' => {\n                // Add closing bracket\n             \
    \   right_brackets.push(bracket);\n            }\n            s => panic!(\"Incorrect\
    \ bracketing: found character {}, expected '(' or '['\", s)\n        }\n    }\n\
    \    // Now we must check that for every left bracket, the corresponding right\
    \ bracket exists.\n    // We do this by counting the number of brackets left of\
    \ each left bracket.\n    let left_brackets: Vec<_> = left_brackets.chars().collect();\n\
    \    let mut right_brackets: Vec<_> = right_brackets.chars().collect();\n    for\
    \ i in 1..left_brackets.len() {\n        if left_brackets[i-1] != right_brackets[i-1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp6f5k5uqo.rs:15:20\n\
    \   |\n15 |     for bracket in &brackets {\n   |                    ^^^^^^^^^\
    \ `&String` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut char_count: Vec<usize> = brackets.chars().map(|c| c as usize).collect();\n\
    \    let mut stack: Vec<usize> = Vec::new();\n    while char_count.len() > 0 {\n\
    \        let (open, close) = char_count.split_at_mut(2);\n        if open < close\
    \ {\n            stack.push(open);\n            char_count.remove(open);\n   \
    \     } else {\n            char_count.remove(close);\n            stack.push(close);\n\
    \        }\n    }\n    if char_count.len() == 0 {\n        true\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpquw9sel9.rs:17:24\n   |\n\
    17 |             stack.push(open);\n   |                        ^^^^ expected\
    \ `usize`, found `&mut [usize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquw9sel9.rs:18:31\n\
    \   |\n18 |             char_count.remove(open);\n   |                       \
    \        ^^^^ expected `usize`, found `&mut [usize]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpquw9sel9.rs:20:31\n   |\n20 |             char_count.remove(close);\n\
    \   |                               ^^^^^ expected `usize`, found `&mut [usize]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpquw9sel9.rs:21:24\n   |\n21 |\
    \             stack.push(close);\n   |                        ^^^^^ expected `usize`,\
    \ found `&mut [usize]`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut s = String::new();\n    for c in brackets {\n        if c == '(' {\n   \
    \         s.push(')');\n        } else if c == ')' {\n            s.push('(');\n\
    \        } else if c == '\\'' {\n            s.push('\\'');\n        } else if\
    \ c == '\"' {\n            s.push('\"');\n        } else {\n            s.push(c);\n\
    \        }\n    }\n    s == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp6upi_jq1.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() > 1 && brackets.ends_with(\")\") {\n        let last_char = brackets.chars().last().unwrap();\n\
    \        if brackets.chars().skip(1).any(|&c| c == '(' || c == '[' || c == '{')\
    \ {\n            brackets.chars()\n                .position(|&c| c == '(' ||\
    \ c == '[' || c == '{' || c == '}')\n                .unwrap_or(brackets.len())\
    \ != brackets.len() - 1\n        } else {\n            brackets.chars()\n    \
    \            .position(|&c| c == last_char)\n                .unwrap_or(brackets.len())\
    \ != brackets.len() - 1\n        }\n    } else {\n        true\n    }\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4se3l46v.rs:14:42\n   |\n\
    14 |         if brackets.chars().skip(1).any(|&c| c == '(' || c == '[' || c ==\
    \ '{') {\n   |                                          ^--\n   |            \
    \                              ||\n   |                                      \
    \    |expected due to this\n   |                                          expected\
    \ `char`, found reference\n   |                                          help:\
    \ did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4se3l46v.rs:16:28\n\
    \   |\n16 |                 .position(|&c| c == '(' || c == '[' || c == '{' ||\
    \ c == '}')\n   |                            ^--\n   |                       \
    \     ||\n   |                            |expected due to this\n   |        \
    \                    expected `char`, found reference\n   |                  \
    \          help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4se3l46v.rs:20:28\n\
    \   |\n20 |                 .position(|&c| c == last_char)\n   |             \
    \               ^--\n   |                            ||\n   |                \
    \            |expected due to this\n   |                            expected `char`,\
    \ found reference\n   |                            help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().filter_map(|c|\
    \ match c {\n        '(' => Some(1),\n        _ => None,\n    }).all(|c| c !=\
    \ None)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `{integer}` with `Option<_>`\n  --> /tmp/tmpxtk1e52q.rs:15:18\n\
    \   |\n15 |     }).all(|c| c != None)\n   |                  ^^ no implementation\
    \ for `{integer} == Option<_>`\n   |\n   = help: the trait `PartialEq<Option<_>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ If brackets is empty, nothing will work properly.\n    let mut opening_brackets\
    \ = 0;\n    let mut closing_brackets = 0;\n\n    brackets.chars().for_each(|c|\
    \ {\n        // Count every opening bracket.\n        if c == '(' {\n        \
    \    opening_brackets += 1;\n        }\n        // Count every closing bracket.\n\
    \        if c == ')' {\n            closing_brackets += 1;\n        }\n\n    \
    \    // If there are too many opening brackets, we don't have a proper bracket\
    \ count.\n        if opening_brackets > closing_brackets {\n            return\
    \ false;\n        }\n    });\n\n    opening_brackets == closing_brackets\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6qpafbs.rs:28:20\n   |\n\
    28 |             return false;\n   |                    ^^^^^ expected `()`, found\
    \ `bool`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for bracket in brackets {\n        stack.push(bracket);\n\
    \        while !stack.is_empty() {\n            match stack.last().unwrap() {\n\
    \                \"(\" => {\n                    let mut last_brace = stack.pop();\n\
    \                    if stack.len() > 0 {\n                        let next_brace\
    \ = stack.last().unwrap();\n                        stack.pop();\n           \
    \             if next_brace != last_brace {\n                            // not\
    \ correct bracketing\n                            return false;\n            \
    \            }\n                    }\n                }\n                \")\"\
    \ => {\n                    let mut last_brace = stack.pop();\n              \
    \      if stack.len() > 0 {\n                        let next_brace = stack.last().unwrap();\n\
    \                        stack.pop();\n                        if next_brace !=\
    \ last_brace {\n                            // not correct bracketing\n      \
    \                      return false;\n                        }\n            \
    \        }\n                }\n                _ => {},\n            }\n     \
    \   }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp1wk0hwet.rs:13:20\n\
    \   |\n13 |     for bracket in brackets {\n   |                    ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp1wk0hwet.rs:16:25\n    |\n16  |             match stack.last().unwrap()\
    \ {\n    |                         ^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::last`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmp1wk0hwet.rs:14:15\n\
    \    |\n14  |         stack.push(bracket);\n    |               ^^^^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp1wk0hwet.rs:15:22\n    |\n15  |         while !stack.is_empty() {\n\
    \    |                      ^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Vec::<T, A>::is_empty`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n  --> /tmp/tmp1wk0hwet.rs:13:9\n\
    \   |\n13 |     for bracket in brackets {\n   |         ^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp1wk0hwet.rs:12:21\n\
    \    |\n12  |     let mut stack = vec![];\n    |                     ^^^^^^ doe"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().take_while(|&c|\
    \ c == ')' || c == ']').count() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp85pdqopn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets_as_vec: Vec<String> = brackets.split_ascii_whitespace().collect();\n\
    \    let mut current_bracket = String::new();\n    for bracket in brackets_as_vec\
    \ {\n        if bracket.len() == 0 {\n            continue;\n        }\n     \
    \   if current_bracket.len() == 0 {\n            // first bracket, so start this\
    \ bracket\n            current_bracket = bracket;\n        } else if current_bracket.len()\
    \ == 1 && current_bracket[0] != bracket {\n            // current bracket doesn't\
    \ match new bracket\n            return false;\n        } else {\n           \
    \ // current bracket matches new bracket, so close it and start a new bracket\n\
    \            current_bracket.clear();\n            current_bracket.push(bracket);\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmptqapjo0r.rs:12:78\n     |\n12\
    \   |     let mut brackets_as_vec: Vec<String> = brackets.split_ascii_whitespace().collect();\n\
    \     |                                                                      \
    \        ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmptqapjo0r.rs:21:49\n   |\n21 |         } else if\
    \ current_bracket.len() == 1 && current_bracket[0] != bracket {\n   |        \
    \                                         ^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqapjo0r.rs:27:34\n\
    \   |\n27 |             current_bracket.push(bracket);\n   |                 \
    \                 ^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.chars().any(|c| !c.is_ascii()) {\n        return false;\n    }\n\n\
    \    let mut is_paren_balanced = false;\n\n    for c in brackets {\n        match\
    \ c {\n            ')' => {\n                if !is_paren_balanced {\n       \
    \             return false;\n                }\n                is_paren_balanced\
    \ = false;\n            },\n            ')(' => {\n                if !is_paren_balanced\
    \ {\n                    return false;\n                }\n                is_paren_balanced\
    \ = false;\n            },\n            '(' if is_paren_balanced => return false,\n\
    \            '(' if !is_paren_balanced => is_paren_balanced = true,\n        \
    \    _ => (),\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpde82vyce.rs:26:13\n\
    \   |\n26 |             ')(' => {\n   |             ^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n26 |             \")(\" =>\
    \ {\n   |             ~~~~\n\nerror[E0277]: `String` is not an iterator\n  -->\
    \ /tmp/tmpde82vyce.rs:18:14\n   |\n18 |     for c in brackets {\n   |        \
    \      ^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = [brackets[0]];\n    let mut bracket = false;\n    for c in brackets.chars()\
    \ {\n        match c {\n            '(' | '[' => {\n                stack.push(c);\n\
    \            }\n            ')' | '^' => {\n                if stack.len() ==\
    \ 0 {\n                    return false;\n                }\n                let\
    \ pop = stack.pop();\n                if pop != c {\n                    return\
    \ false;\n                }\n            }\n            ']' | '>' => {\n     \
    \           if stack.len() == 0 {\n                    return false;\n       \
    \         }\n                let pop = stack.pop();\n                if pop !=\
    \ c {\n                    return false;\n                }\n            }\n \
    \           '>' | '[' => {\n                if stack.len() == 0 {\n          \
    \          return false;\n                }\n                let pop = stack.pop();\n\
    \                if pop != c {\n                    return false;\n          \
    \      }\n            }\n            _ => {\n                stack.append(c);\n\
    \            }\n        }\n        if stack.len() < 2 {\n            return false;\n\
    \        }\n    }\n    stack.len() == 1\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmplbo_5krh.rs:12:22\n   |\n12 |     let mut stack = [brackets[0]];\n \
    \  |                      ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push` found for array `[_; 1]` in\
    \ the current scope\n  --> /tmp/tmplbo_5krh.rs:17:23\n   |\n17 |             \
    \    stack.push(c);\n   |                       ^^^^ method not found in `[_;\
    \ 1]`\n\nerror[E0599]: no method named `pop` found for array `[_; 1]` in the current\
    \ scope\n  --> /tmp/tmplbo_5krh.rs:23:33\n   |\n23 |                 let pop =\
    \ stack.pop();\n   |                                 ^^^ method not found in `[_;\
    \ 1]`\n\nerror[E0599]: no method named `pop` found for array `[_; 1]` in the current\
    \ scope\n  --> /tmp/tmplbo_5krh.rs:32:33\n   |\n32 |                 let pop =\
    \ stack.pop();\n   |                                 ^^^ method not found in `[_;\
    \ 1]`\n\nerror[E0599]: no method named `pop` found for array `[_; 1]` in the current\
    \ scope\n  --> /tmp/tmplbo_5krh.rs:41:33\n   |\n41 |                 let pop =\
    \ stack.pop();\n   |                                 ^^^ method not found in `[_;\
    \ 1]`\n\nerror[E0599]: no method named `append` found for array `[_; 1]` in the\
    \ current scope\n  --> /tmp/tmplbo_5krh.rs:47:23\n   |\n47 |                 stack.append(c);\n\
    \   |                       ^^^^^^ method not found in `[_; 1]`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ *c == ')' || *c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpeiq5js0w.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == ')' || *c == '(')\n   |       \
    \                       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpeiq5js0w.rs:12:43\n   |\n12 |     brackets.chars().all(|c| *c ==\
    \ ')' || *c == '(')\n   |                                           ^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut left = false;\n    let mut right = false;\n\n    for ch in brackets {\n\
    \        match ch {\n            '(' | '[' => {\n                left = true;\n\
    \            }\n            '(' | ')' | ']' | '](' | '][]' | '[](') => { //TODO:\
    \ implement a better check\n                right = true;\n            }\n   \
    \         _ => {}\n        }\n    }\n\n    left == right\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpt9i628f1.rs:20:31\n\
    \   |\n20 |             '(' | ')' | ']' | '](' | '][]' | '[](') => { //TODO: implement\
    \ a better check\n   |                               ^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n20 |             '('\
    \ | ')' | ']' | \"](\" | '][]' | '[](') => { //TODO: implement a better check\n\
    \   |                               ~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmpt9i628f1.rs:20:38\n   |\n20 |         \
    \    '(' | ')' | ']' | '](' | '][]' | '[](') => { //TODO: implement a better check\n\
    \   |                                      ^^^^^\n   |\nhelp: if you meant to\
    \ write a `str` literal, use double quotes\n   |\n20 |             '(' | ')' |\
    \ ']' | '](' | \"][]\" | '[](') => { //TODO: implement a better check\n   |  \
    \                                    ~~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmpt9i628f1.rs:20:46\n   |\n20 |         \
    \    '(' | ')' | ']' | '](' | '][]' | '[](') => { //TODO: implement a better check\n\
    \   |                                              ^^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n20 |             '(' | ')'\
    \ | ']' | '](' | '][]' | \"[](\") => { //TODO: implement a better check\n   |\
    \                                              ~~~~~\n\nerror: unexpected closing\
    \ delimiter: `}`\n  --> /tmp/tmpt9i628f1.rs:28:1\n   |\n23 |             _ =>\
    \ {}\n   |                  -- block is empty, you might have not meant to close\
    \ it\n...\n28 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing\
    \ delimiter: `)`\n  --> /tmp/tmpt9i628f1.rs:16:18\n   |\n16 |         match ch\
    \ {\n   |                  ^ unclosed delimiter\n...\n20 |             '(' | ')'\
    \ | ']' | '](' | '][]' | '[](') => { //TODO: implement a better check\n   |  \
    \                                                 ^ mismatched closing delimiter\n\
    \nerror: aborting due to 5 previous errors\n\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Don't even bother checking if the brackets are empty or just one character.\n\
    \    if brackets.is_empty() {\n        return true;\n    }\n    if brackets[0]\
    \ == '(' && brackets[brackets.len() - 1] == ')' {\n        return false;\n   \
    \ }\n\n    debug_assert!(brackets[0] == '(');\n    for bracket in brackets.iter().skip(1)\
    \ {\n        if bracket != ')' {\n            return false;\n        }\n    }\n\
    \n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp0soiuh0q.rs:16:8\n   |\n16 |     if brackets[0] == '(' && brackets[brackets.len()\
    \ - 1] == ')' {\n   |        ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0soiuh0q.rs:16:30\n   |\n16 |     if brackets[0] == '(' && brackets[brackets.len()\
    \ - 1] == ')' {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp0soiuh0q.rs:20:19\n   |\n20 |     debug_assert!(brackets[0] ==\
    \ '(');\n   |                   ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as I"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.chars().count() != 1 {\n        return false;\n    }\n    let bracket\
    \ = brackets.chars().next().unwrap();\n    brackets.chars().next().unwrap() ==\
    \ bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqklfi3wn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![0; brackets.len()];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(stack.len() - 1);\n       \
    \ } else if c == ')' {\n            if stack.len() < 1 {\n                return\
    \ false;\n            }\n            stack.pop();\n        } else {\n        \
    \    if stack.len() < 2 {\n                return false;\n            }\n    \
    \        stack.pop();\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsx1gqqv0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut i = 0;\n    while i < brackets.len()\
    \ {\n        if brackets[i] == ')' {\n            if i < brackets.len() - 1 {\n\
    \                let open = brackets[i + 1];\n                i += 1;\n      \
    \          while i < brackets.len() {\n                    if brackets[i] == open\
    \ {\n                        i += 1;\n                        continue;\n    \
    \                }\n                    else {\n                        return\
    \ false;\n                    }\n                }\n            }\n          \
    \  else {\n                return false;\n            }\n        }\n        i\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphea0o2w9.rs:15:12\n\
    \   |\n15 |         if brackets[i] == ')' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphea0o2w9.rs:17:28\n   |\n17 |                 let open = brackets[i\
    \ + 1];\n   |                            ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphea0o2w9.rs:20:24\n   |\n20 |                     if brackets[i]\
    \ == open {\n   |                        ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usiz"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ if brackets contains any extra brackets, we return false\n    if !brackets.contains(\"\
    (\") || !brackets.contains(\")\") || brackets.contains(\"(\") || brackets.contains(\"\
    )\") {\n        return false;\n    }\n\n    // iterate through every character\
    \ in brackets\n    let mut bracket_chars: Vec<char> = brackets.chars().collect();\n\
    \    let mut opening_brackets: Vec<bool> = vec![false; brackets.len()];\n    let\
    \ mut closing_brackets: Vec<bool> = vec![false; brackets.len()];\n\n    // iterate\
    \ through brackets one by one\n    for i in 0..brackets.len() {\n        // if\
    \ we have reached the end of the string, stop reading\n        if bracket_chars.len()\
    \ == 0 {\n            break;\n        }\n\n        // if we reached an opening\
    \ bracket, mark it true\n        if bracket_chars[0] == '(' {\n            opening_brackets[i]\
    \ = true;\n        }\n\n        // if we reached a closing bracket, mark it false\n\
    \        if bracket_chars[0] == ')' {\n            closing_brackets[i] = true;\n\
    \        }\n\n        // otherwise just add it to the vector\n        bracket_chars\
    \ = bracket_chars.next();\n    }\n\n    // return true if every opening bracket\
    \ has a corresponding closing bracket\n    for open in 0..opening_brackets.len()\
    \ {\n        if !closing_brackets[open] {\n            return false;\n       \
    \ }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp5a0k_lpv.rs:40:39\n   |\n40 |         bracket_chars\
    \ = bracket_chars.next();\n   |                                       ^^^^ method\
    \ not found in `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .as_bytes()\n        .iter()\n        .zip(\n            brackets\n \
    \               .as_bytes()\n                .iter()\n                .cloned()\n\
    \                .skip_while(|&b| !b.is_ascii_digit()),\n        )\n        .all(|(open,\
    \ close)| close.ascii_digit(10) == open.ascii_digit(10))\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ascii_digit` found for type `u8` in the\
    \ current scope\n  --> /tmp/tmpyktvyfwa.rs:22:36\n   |\n22 |         .all(|(open,\
    \ close)| close.ascii_digit(10) == open.ascii_digit(10))\n   |               \
    \                     ^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii_digit`\n\nerror[E0599]: no method named `ascii_digit`\
    \ found for reference `&u8` in the current scope\n  --> /tmp/tmpyktvyfwa.rs:22:60\n\
    \   |\n22 |         .all(|(open, close)| close.ascii_digit(10) == open.ascii_digit(10))\n\
    \   |                                                            ^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii_digit`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps8s_l340.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
