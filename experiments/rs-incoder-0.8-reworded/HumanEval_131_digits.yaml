name: HumanEval_131_digits
language: rs
prompt: "/// Given a positive integer n, return the product of the odd digits.\n///\
  \ Return 0 if all digits are even.\n/// For example:\n/// >>> digits(1)\n/// 1\n\
  /// >>> digits(4)\n/// 0\n/// >>> digits(235)\n/// 15\nfn digits(n: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5),\
  \ 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n \
  \   assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n  \
  \  assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n\
  }\n"
completions: ["    let mut product = 0;\n    let mut rem = 0;\n    while n != 0 {\n\
    \        if n % 2 == 0 {\n            product *= 2;\n        } else {\n      \
    \      product += 1;\n        }\n        rem += 1;\n        n /= 10;\n    }\n\
    \    if rem > 0 {\n        product *= rem;\n    }\n    product", "    (n as isize).checked_mul(2).expect(\n\
    \        \"digits requires a positive integer\",\n    )", '    (n as i32).checked_mul(&((n
    as u32).trailing_zeros()))', "    if n == 0 {\n        return 0;\n    }\n    let\
    \ mut product = 1;\n    let mut counter = 0;\n    loop {\n        if n > counter\
    \ {\n            product *= n - counter;\n        }\n        counter += 1;\n \
    \       if counter > 9 {\n            break;\n        }\n    }\n    product",
  "    if n % 2 == 0 {\n        return 0;\n    }\n    else {\n        let mut result\
    \ = 1;\n        for i in 3..=n / 2 {\n            result *= i;\n        }\n  \
    \      result *= n % 2;\n        result\n    }", "    // Find the greatest power\
    \ of 10 that divides n\n    let mut remain = n;\n    let mut pow10 = 1;\n    while\
    \ remain > 0 {\n        remain %= 10;\n        pow10 *= 10;\n    }\n    pow10",
  "    match n {\n        n @ 0 => 1,\n        n @ 1 => n,\n        n @ 2 => n * 2,\n\
    \        n @ 3 => n * 3,\n        n @ 4 => n * 4,\n        _ => 0,\n    }", " \
    \   if n % 2 == 0 {\n        0\n    } else {\n        n.checked_mul(2).unwrap_or(0)\n\
    \    }", "    // We use unsigned types to avoid any overflow:\n    // we take\
    \ the largest value that the type can represent.\n    let mut product = n.into();\n\
    \    let mut dig = n.into();\n    while dig.is_positive() {\n        if dig.is_odd()\
    \ {\n            product *= 2;\n        }\n        dig /= 10;\n    }\n    product",
  "    let mut prod = 1;\n    for &d in n.to_digits() {\n        if d & 1 == 1 {\n\
    \            prod *= 10 * (d - 1) as isize;\n        } else {\n            return\
    \ 0;\n        }\n    }\n    prod", "    let mut total = 1;\n    for &d in &n {\n\
    \        if d % 2 == 1 {\n            total *= d;\n        }\n    }\n    total",
  "    debug_assert!(n % 2 == 0, \"Odd digits not supported in digits\");\n    let\
    \ mut product: isize = 0;\n    while n > 0 {\n        product = product*2 + n\
    \ % 10;\n        n /= 10;\n    }\n    product", "    let mut result = 1;\n   \
    \ while n > 0 {\n        if n % 2 == 1 {\n            result *= n;\n        }\n\
    \        n /= 2;\n    }\n    result", "    if n < 10 {\n        return n;\n  \
    \  }\n    let mut product = n as isize;\n    for &d in &n.digits() as [1..] {\n\
    \        product *= d as usize;\n    }\n    product", "    debug_assert!(n >=\
    \ 0);\n    let mut prod = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n   \
    \         prod *= 2;\n            n /= 2;\n        } else {\n            prod\
    \ *= 2;\n        }\n    }\n    prod", "    if n % 2 == 0 {\n        0\n    } else\
    \ {\n        n * (n / 2)\n    }", "    if n <= 0 {\n        return 0;\n    }\n\
    \n    // Use a slice to ensure that we do not use unnecessarily many divisions\n\
    \    let mut odds = &n[..];\n\n    while let Some(digit) = odds.pop() {\n    \
    \    if digit % 2 == 0 {\n            return digit * digits(n - digit);\n    \
    \    }\n    }\n\n    0", "    let mut product = 1;\n    for d in n.digits() {\n\
    \        product *= d;\n        if product % 2 == 1 {\n            return 0;\n\
    \        }\n    }\n    product", "    let mut result = 1;\n    let mut i = 1;\n\
    \    while i <= n {\n        if n % i == 0 {\n            result *= i;\n     \
    \   }\n        i += 2;\n    }\n    if n % 2 == 0 {\n        result *= n;\n   \
    \ }\n    result", "    let mut product = 1;\n    let mut digits = 0;\n\n    while\
    \ n > 0 {\n        product = product * n % 10;\n        digits += 1;\n       \
    \ n /= 10;\n    }\n\n    product", "    if n % 2 == 0 {\n        n\n    } else\
    \ {\n        n - 1\n    }", "    if n % 2 == 1 {\n        return 0;\n    }\n \
    \   n / 2", "    let mut res: isize = 0;\n    while n > 0 {\n        res *= n\
    \ % 10;\n        n /= 10;\n    }\n    res", "    if n == 1 {\n        return 1;\n\
    \    }\n    let mut accum = 0;\n    for &d in n.digits() {\n        accum += if\
    \ d % 2 == 1 {\n            1\n        } else {\n            0\n        };\n \
    \   }\n    accum", "    // Compute the product of digits in base 10, then reduce\
    \ to base 2.\n    n as isize * 10\n        .powf(1)\n        .rem(std::usize::MAX)\n\
    \        .into()\n        .into()\n        .powf(2)", '    (n + digit_count(n
    as u64)) % 10', '    n.leading_zeros() as isize', "    let mut prod = 1;\n   \
    \ for i in 2..=n {\n        if n % 2 == 1 {\n            prod *= i;\n        \
    \    n /= i;\n        } else {\n            prod /= i;\n        }\n    }\n   \
    \ prod", "    match n {\n        0 => 0,\n        _ => n % 2 != 0 ? n / 2 : digits(n\
    \ / 2),\n    }", "    let mut product = 1;\n    while n > 0 {\n        product\
    \ *= n % 10;\n        n /= 10;\n    }\n    if n == 0 {\n        product\n    }\
    \ else {\n        0\n    }", "    n.checked_mul(2).expect(\"only even numbers\"\
    )\n        .checked_div(10)\n        .expect(\"only even numbers\")\n        .checked_div(10)\n\
    \        .expect(\"only even numbers\")\n        .checked_div(10)\n        .expect(\"\
    only even numbers\")", "    debug_assert!(n > 0);\n    let mut ns: Vec<isize>\
    \ = vec![n];\n    let mut prod: isize = 1;\n    for d in ns {\n        if d %\
    \ 2 == 1 {\n            prod *= d / 2;\n        } else {\n            return 0;\n\
    \        }\n    }\n    prod", "    match n % 10 {\n        0 => n % 10,\n    \
    \    x if x % 2 == 1 => 1,\n        x => x,\n    }", "    if n == 0 {\n      \
    \  return 0;\n    }\n    let mut res = 1;\n    let mut carry = 0;\n    for &d\
    \ in n.digits() {\n        let digit = d.unwrap();\n        let mut mul = res.clone();\n\
    \        mul *= digit;\n        res -= digit;\n        res %= 10;\n        carry\
    \ += mul;\n    }\n    carry %= 10;\n    res", "    if n % 2 == 0 {\n        n\
    \ / 2\n    } else {\n        n % 2\n    }", "    let mut res = 0;\n    for &n\
    \ in n.to_string().chars().take(digits(n)) {\n        res *= n % 10;\n       \
    \ res /= 10;\n    }\n    res", "    let mut result = 1;\n    while n > 0 {\n \
    \       result *= n % 10;\n        n /= 10;\n    }\n    result", "    if n % 2\
    \ != 0 {\n        0\n    } else {\n        (n as isize) * ((n as isize) as isize)\n\
    \    }", "    if n <= 0 {\n        return 0\n    }\n    let mut product = 1\n\
    \    for &n in n.to_string().chars() {\n        if n % 2 == 0 {\n            product\
    \ *= n % 10;\n        }\n    }\n    product", "    let mut product = 1;\n    for\
    \ i in 0..n {\n        if i % 2 == 1 {\n            product *= i;\n        }\n\
    \    }\n    if product == 0 {\n        0\n    } else {\n        product\n    }",
  "    if n <= 0 {\n        return 0;\n    }\n    let mut factor: isize = 1;\n   \
    \ while n > 0 {\n        factor *= n % 10;\n        n /= 10;\n    }\n    factor",
  "    debug_assert!(n % 2 == 0);\n    if n % 10 == 0 {\n        return n;\n    }\n\
    \    n / 2 * 3 + n % 10", "    if n < 10 { return n }\n    let mut n2 = n;\n \
    \   while n2 % 2 == 0 {\n        n2 /= 2;\n    }\n    while n2 % 3 == 0 {\n  \
    \      n2 /= 3;\n    }\n    n2", "    let mut result = 1;\n    let mut d = n;\n\
    \    while d > 0 {\n        if d % 2 == 1 {\n            result *= 3;\n      \
    \  }\n        d /= 2;\n    }\n    result", "    let mut result = 1;\n    for d\
    \ in n.trailing_digits() {\n        if d > 0 {\n            result = (result *\
    \ d) % 10;\n        } else {\n            result = (result * 10) % 10;\n     \
    \   }\n    }\n    result", "    if n == 0 {\n        return 0;\n    }\n\n    let\
    \ mut product = 1;\n    let mut digits = n / 10;\n    while digits != 0 {\n  \
    \      if digits & 1 == 1 {\n            product *= digits;\n        }\n     \
    \   digits >>= 1;\n    }\n    product", "    debug_assert_eq!(n, 0);\n\n    fn\
    \ is_odd(x: usize) -> bool {\n        x % 2 != 0\n    }\n\n    if n == 1 {\n \
    \       return 1;\n    }\n\n    n as usize * digits(n as usize).filter(is_odd).product()",
  "    fn mul(c: isize) -> isize {\n        (c % 2) * c\n    }\n\n    (0..n).map(mul).filter(|&x|\
    \ x % 2 != 0).sum()", "    if n % 2 == 0 {\n        n * digits2(n / 2)\n    }\
    \ else {\n        0\n    }", "    let mut product = 1;\n    while n > 0 {\n  \
    \      product *= n % 10;\n        n /= 10;\n    }\n    product", "    let mut\
    \ ndigits = n as usize;\n    if ndigits < 0 {\n        Err(format!(\"Invalid number\
    \ of digits: {}\", n))\n    } else {\n        let mut ret = 1;\n        let mut\
    \ carry = 1;\n        while ndigits > 0 {\n            let x = n % 10;\n     \
    \       ret *= x;\n            n /= 10;\n            carry *= x;\n           \
    \ ndigits -= 1;\n        }\n        if n != 0 {\n            ret *= n % 10;\n\
    \            carry *= n % 10;\n            ndigits += 1;\n        }\n        if\
    \ carry != 0 {\n            ret += carry;\n        }\n        ret\n    }", " \
    \   if n % 2 == 1 {\n        return 0\n    }\n    let mut digits = n as usize;\n\
    \    let mut product = 1;\n    while digits > 0 {\n        digits /= 2;\n    \
    \    product *= digits;\n    }\n    product", "    let mut prod: isize = 0;\n\
    \    while n > 0 {\n        n -= 1;\n        prod *= n % 10;\n        n /= 10;\n\
    \    }\n    prod", "    let mut product = 0;\n    let mut current = n;\n    while\
    \ current % 2 == 0 {\n        product *= 2;\n        current /= 2;\n    }\n  \
    \  product", "    let mut prod = 1;\n    for d in n.checked_digits() {\n     \
    \   assert!(d.is_odd());\n        prod *= d;\n    }\n    prod", "    if n % 2\
    \ == 0 {\n        0\n    } else {\n        n % 9\n    }", "    if n % 2 == 0 {\n\
    \        n % 8\n    } else {\n        0\n    }", "    if n == 0 {\n        return\
    \ 0;\n    }\n    let mut product = 1;\n    for i in 0..n / 2 {\n        if n %\
    \ i == 0 {\n            product *= i;\n        }\n    }\n    product", "    debug_assert!(n\
    \ % 2 != 0);\n    (n as i32).digits() as isize", "    fn is_odd(x: isize) -> bool\
    \ {\n        x % 2 == 1\n    }\n    if n < 10 || is_odd(n) || n > 0 {\n      \
    \  n\n    } else {\n        digits(n - 10) * 3 + 1\n    }", "    // Special case\
    \ for 1.\n    if n == 1 {\n        return 1;\n    }\n    // Special case for 0.\n\
    \    if n == 0 {\n        return 0;\n    }\n    let mut product = 1;\n    // Iterating\
    \ over all the digits in reverse order\n    for i in (n as usize).rev() {\n  \
    \      product *= digit(i);\n    }\n    return product;", "    fn digit_prod(x:\
    \ isize) -> isize {\n        if x % 2 == 0 {\n            x * 3\n        } else\
    \ {\n            x * 3 + 1\n        }\n    }\n\n    // The first digit is always\
    \ odd because it is the number itself.\n    let mut n_odd = n;\n    if n_odd %\
    \ 2 == 0 {\n        n_odd -= 1;\n    }\n\n    let mut n_even = n;\n    if n_even\
    \ % 2 == 0 {\n        n_even += 1;\n    }\n\n    let mut product = n_even;\n \
    \   for _ in 0..(digit_prod(n_odd) - 1) {\n        product *= n_even;\n    }\n\
    \n    product", "    // Only do even number check\n    if n % 2 == 0 {\n     \
    \   let mut product = 0;\n        let mut current_digit = 1;\n        while n\
    \ > 0 {\n            current_digit *= n % 10;\n            product += current_digit;\n\
    \            n /= 10;\n        }\n        return product;\n    }\n    // Odd case\
    \ already covered by the first check\n    return n;", '    (n / 9).ceil() as isize',
  "    let mut result = 0;\n    for i in 2..n / 2 {\n        result = result * i +\
    \ (n % i as u8);\n    }\n    if n > 0 && n % 2 == 0 {\n        result = result\
    \ * 2;\n    }\n    result", "    if n >= (1 << 32) {\n        return 0;\n    }\n\
    \    let mut prod = 0;\n    let mut factor = 1;\n    for i in 0..n {\n       \
    \ if ((i & 1) == 1) {\n            prod *= factor;\n        }\n        factor\
    \ += 2;\n    }\n    prod", "    if n % 2 == 1 {\n        return 0;\n    }\n  \
    \  n / 2 % 9", "    if n % 2 == 0 {\n        0\n    } else {\n        let mut\
    \ x = 1;\n        let mut y = n;\n        while y % 2 == 0 {\n            x +=\
    \ 1;\n            y /= 2;\n        }\n        y\n    }", "    if n < 10 {\n  \
    \      return n;\n    }\n\n    let mut result = 1;\n    while n >= 10 {\n    \
    \    result *= n % 10;\n        n /= 10;\n    }\n    result *= n % 10;\n    result",
  "    let mut product = 1;\n    for (i, _) in n.iter().enumerate() {\n        if\
    \ i % 2 == 1 {\n            product *= i;\n        }\n    }\n    product", " \
    \   if n >= 10 {\n        return n.to_digits(2);\n    }\n    if n % 2 == 0 {\n\
    \        return 0;\n    }\n    let mut result = 1;\n    for i in n.rev() {\n \
    \       result = result * 2;\n        if i >= 10 {\n            break;\n     \
    \   }\n        result = result + i as isize;\n    }\n    result", "    let mut\
    \ result = 1;\n    for d in n.digits().cloned() {\n        result *= d as usize;\n\
    \    }\n    if result > MAX_DIGITS as usize {\n        0\n    } else {\n     \
    \   result\n    }", "    if n % 2 == 0 {\n        n\n    } else {\n        0\n\
    \    }", "    if n % 2 == 0 {\n        n * (n / 2)\n    } else {\n        0\n\
    \    }", "    if n % 2 == 0 {\n        return 0\n    }\n    let mut product: isize\
    \ = 1;\n    for &x in &n / 2 {\n        product *= *x;\n    }\n    product", " \
    \   let mut product_even = 0;\n    let mut product_odd = 1;\n    for d in n.digits()\
    \ { product_even += d.is_even(); }\n    for d in n.digits() { product_odd *= d.is_odd();\
    \ }\n    product_even % product_odd", "    if n < 0 {\n        0\n    } else if\
    \ n < 10 {\n        n\n    } else {\n        n % 10\n            .digits()\n \
    \           .map(|i| i * 2)\n            .reduce(|a, b| a * b as isize)\n    }",
  '    (1..=n).filter(|&x| x % 2).sum::<isize>()', "    if n % 2 == 0 {\n        return\
    \ n / 2;\n    }\n    n % 2 == 1\n        ? 0\n        : digits(n / 2) * digits(n\
    \ / 2)", "    let mut result = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            result *= n - 1;\n        }\n        n /= 2;\n    }\n    result",
  "    if n % 2 == 1 {\n        n\n    } else {\n        0\n    }", "    // https://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n\
    \    fn digits_log2(val: isize) -> isize {\n        if val < 2 {\n           \
    \ return 0;\n        }\n        let mut val2 = val / 2;\n        val %= 2;\n \
    \       if val == 0 {\n            return 1;\n        }\n        if val2 == 0\
    \ {\n            return 2;\n        }\n        let mut val4 = val2 / 4;\n    \
    \    val %= 4;\n        if val2 == 0 {\n            return 3;\n        }\n   \
    \     if val4 == 0 {\n            return 4;\n        }\n        let mut val8 =\
    \ val4 / 8;\n        val %= 8;\n        if val2 == 0 {\n            return 5;\n\
    \        }\n        if val4 == 0 {\n            return 6;\n        }\n       \
    \ let mut val16 = val8 / 16;\n        val %= 16;\n        if val2 == 0 {\n   \
    \         return 7;\n        }\n        if val4 == 0 {\n            return 8;\n\
    \        }\n        let mut val32 = val16 / 32;\n        val %= 32;\n        if\
    \ val2 == 0 {\n            return 9;\n        }\n        if val4 == 0 {\n    \
    \        return 10;\n        }\n        let mut val64 = val32 / 64;\n        val\
    \ %= 64;\n        if val2 == 0 {\n            return 11;\n        }\n        if\
    \ val4 == 0 {\n            return 12;\n        }\n        let mut val128 = val64\
    \ / 128;\n        val %= 128;\n        if val2 == 0 {\n            return 13;\n\
    \        }\n        if val4 == 0 {\n            return 14;\n        }\n      \
    \  let mut val256 = val128 / 256;\n        val %= 256;\n        if val2 == 0 {\n\
    \            return 15;\n        }\n        if val4 == 0 {\n            return\
    \ 16;\n        }\n        let mut val512 = val256 / 512;\n        val %= 512;\n\
    \        if val2 == 0 {\n            return 17;\n        }\n        if val4 ==\
    \ 0 {\n            return 18;\n        }\n        let mut val1024 = val512 / 1024;\n\
    \        val %= 1024;\n        if val2 == 0 {\n            return 19;\n      \
    \  }\n        if val4 == 0 {\n            return 20;\n        }\n        let mut\
    \ val2048 = val1024 / 2048;\n        val %= 2048;\n        if val2 == 0 {\n  \
    \          return 21;\n        }\n        if val4 == 0 {\n            return 22;\n\
    \        }\n        let mut val4096 = val2048 / 4096;\n        val %= 4096;\n\
    \        if val2 == 0 {\n            return 23;\n        }\n        if val4 ==\
    \ 0 {\n            return 24;\n        }\n        let mut val8192 = val", "  \
    \  let mut product = 1;\n    while n > 0 {\n        if n % 2 == 0 {\n        \
    \    product *= n % 10;\n            n /= 10;\n        } else {\n            product\
    \ *= 3;\n            n /= 10;\n        }\n    }\n    product", "    (0..n).map(|i|\
    \ i as isize)\n        .filter(|&i| i % 2 == 0)\n        .product()", "    if\
    \ n % 2 == 0 {\n        0\n    } else {\n        n % 10 as isize\n    }", "  \
    \  if n == 0 {\n        return 0;\n    }\n    let mut product = 1;\n    for &n\
    \ in n.digits() { product *= n; }\n    if product % 2 == 0 {\n        0\n    }\
    \ else {\n        product\n    }", "    if n >= 10 && n % 10 == 0 {\n        1\n\
    \    } else {\n        0\n    }", "    let mut product = 0;\n    for d in n.digits()\
    \ {\n        if d % 2 == 1 {\n            product += d;\n        }\n    }\n  \
    \  product", "    assert!(n >= 0);\n    if n % 2 == 1 {\n        return 0;\n \
    \   }\n    n / 2", "    if n < 10 || n % 10 == 0 {\n        n\n    } else {\n\
    \        digits(n / 10).mul(1.digit + n % 10).unwrap() * 10\n    }", '    n.checked_mul(*(n
    as u64).clone() / 10).ok()', "    if n < 0 {\n        panic!(\"Input must be non-negative\"\
    )\n    }\n    let mut result = 1i32;\n    for i in 1..=n {\n        result *=\
    \ i as i32;\n        if i % 2 == 1 {\n            result *= -1i32;\n        }\n\
    \    }\n    result", "    let mut total = 1;\n    while n > 0 {\n        if n\
    \ % 2 == 0 {\n            total *= n % 10;\n        }\n        n /= 10;\n    }\n\
    \    total", "    let mut product = 1;\n    for &d in n.to_str_radix(2).chars().take(n\
    \ as usize) {\n        product *= d;\n    }\n    if product % 2 == 0 {\n     \
    \   product\n    } else {\n        0\n    }", "    if n % 2 == 0 {\n        0\n\
    \    } else {\n        let mut product: isize = 1;\n        for i in 1..(n / 2)\
    \ {\n            product *= 2;\n            if n % i == 0 {\n                product\
    \ /= i;\n            }\n        }\n        product\n    }", "    if n % 2 != 0\
    \ {\n        return 0\n    }\n    if n < 10 && n % 10 == 0 {\n        return n\n\
    \    }\n    let mut product = n;\n    while product > 10 {\n        product /=\
    \ 10;\n    }\n    product", "    match n % 10 {\n        1 => n,\n        _ =>\
    \ 0,\n    }", "    let mut product = 1;\n    let digits = n.to_digits();\n   \
    \ for d in digits {\n        if d.is_odd() {\n            product *= d;\n    \
    \    }\n    }\n    product", "    let mut ret: isize = 1;\n    while n > 0 {\n\
    \        if n % 2 == 0 {\n            ret = ret * 10;\n        }\n        n =\
    \ n / 2;\n    }\n    ret", "    if n % 2 == 0 {\n        n / 2\n    } else {\n\
    \        n * (3 * n + 1) / (2 * n + 1)\n    }", "    if n < 0 {\n        return\
    \ 0;\n    }\n    let mut product = 1;\n    let mut last = 0;\n    for d in n.iter().cloned().map(|x|\
    \ *x) {\n        if *d & 1 != 0 {\n            product *= last;\n        }\n \
    \       product *= d;\n        last += 1;\n    }\n    if product == 0 {\n    \
    \    return 0;\n    }\n    product", "    if n == 0 { return 0 }\n    let mut\
    \ product = n as isize;\n    let mut prev_product = 1;\n    while n > 0 {\n  \
    \      if n % 2 == 0 {\n            product += prev_product;\n        }\n    \
    \    prev_product *= 2;\n        n /= 2;\n    }\n    product", "    // Use a loop\
    \ to avoid overflow of isize\n    let mut ret = 1;\n    for d in n % 10..=0 {\n\
    \        if d % 2 == 0 {\n            ret *= d;\n        }\n    }\n    ret", " \
    \   if n % 2 == 0 {\n        n as isize\n    } else {\n        n * digits(n as\
    \ isize)\n    }", '    n.checked_mul(2)', "    let mut result = 1;\n    while\
    \ n > 0 {\n        result *= n % 10;\n        n /= 10;\n    }\n    result", " \
    \   if n % 2 == 1 {\n        return n\n    }\n\n    let mut product = 1;\n\n \
    \   for &d in n.str() {\n        if d > '9' {\n            break;\n        }\n\
    \        product *= c - '0';\n    }\n\n    product", "    if n % 2 == 1 {\n  \
    \      n\n    } else {\n        0\n    }", "    let mut result = 1;\n    for (i,\
    \ &d) in n.to_string().into_iter().zip(n.to_string().into_iter().filter(|&d| d\
    \ > '9').skip(1).collect::<Vec<_>>()) {\n        if d % 2 == 1 {\n           \
    \ *result *= 10;\n            *result += d;\n        }\n    }\n    result", '    (0..n).filter(|&n|
    n % 2 == 1).sum()', "    if n < 10 {\n        return n;\n    }\n    if n % 2 ==\
    \ 0 {\n        return n * digits(n / 2);\n    }\n    0", "    // The return value\
    \ is in range [0, 10)\n    let mut result = 1;\n    for d in n.checked_div_mod(10).unwrap().digits()\
    \ {\n        if d % 2 == 1 {\n            result *= d;\n        }\n    }\n   \
    \ result", "    if n > 0 {\n        for _ in 0..n / 2 {\n            n /= 2;\n\
    \        }\n        if n % 2 == 0 {\n            n /= 2;\n        }\n    }\n \
    \   n", "    debug_assert!(n % 2 == 0);\n\n    let mut result = 1;\n    for d\
    \ in n.digits().rev() {\n        result *= d;\n    }\n    result", "    let mut\
    \ ret = 1;\n    for i in n.digits().into_iter() {\n        if i % 2 == 1 {\n \
    \           ret *= i;\n        }\n    }\n    ret", "    if n % 2 == 0 {\n    \
    \    n / 2\n    } else {\n        n * 3 + 1\n    }", "    match n {\n        0\
    \ => 1,\n        1 => 1,\n        _ => n.checked_mul(digits(n.checked_sub(1usize)))\n\
    \    }", "    if n < 10 || n % 2 == 0 {\n        n\n    } else {\n        digits(n\
    \ / 2)\n    }", '    n / 10', "    if n % 2 == 0 {\n        return n.trailing_digits(2)\
    \ as isize\n    } else {\n        return 0\n    }", "    debug_assert!(n % 2 ==\
    \ 0);\n    let mut product = 1;\n    for x in n.checked_div_2() {\n        if\
    \ x % 2 == 1 {\n            product *= x;\n        }\n    }\n    product", '    n
    % 10', "    debug_assert!(n % 2 == 0);\n    let mut result = n;\n    for d in\
    \ n.digits().cloned().rev() {\n        result *= d;\n    }\n    if result < 2\
    \ {\n        return 0;\n    }\n    result", "    n\n        .checked_div(2).unwrap()\n\
    \        .checked_mul(2)\n        .unwrap()\n        .checked_add((n as usize).checked_div(2).unwrap()).unwrap()",
  "    if n % 2 == 0 {\n        0\n    } else {\n        n / 2 * 3\n    }", "    let\
    \ mut result = 1;\n    for i in 0..n {\n        if i % 2 == 1 {\n            result\
    \ *= i;\n        }\n    }\n    result", "    use core::cmp::Ordering;\n    (n\
    \ as u32).checked_mul(n as u32).expect(\"odd number\")", "    if n % 2 == 0 {\n\
    \        return n\n    }\n    if n < 10 {\n        return n * 10\n    }\n    if\
    \ n >= 10_000 {\n        return n * 100\n    }\n    if n >= 1000 {\n        return\
    \ n * 1000\n    }\n    if n >= 100 {\n        return n * 100\n    }\n    if n\
    \ >= 10 {\n        return n * 10\n    }\n    return 0", "    if n % 2 == 1 {\n\
    \        0\n    } else {\n        n * digits(n - 2)\n    }", "    // if n has\
    \ no fractional part, return n itself\n    if n % 2 == 0 {\n        n\n    } else\
    \ {\n        let mut product = 1i32;\n        let mut remainder = n - 1i32;\n\
    \        while remainder > 1i32 {\n            product *= (remainder - 1i32);\n\
    \            remainder -= 2i32;\n        }\n        product\n    }", "    if n\
    \ < 10 {\n        return n;\n    }\n\n    let mut m = n as usize;\n    for d in\
    \ 0..((n - 1) / 2) {\n        m *= 2 % 10;\n        m += 2 % 10 * (n % 10 as usize);\n\
    \        n /= 10;\n    }\n\n    if n > 0 {\n        m *= 2 % 10;\n        m +=\
    \ 2 % 10 * (n % 10 as usize);\n    }\n    m", "    if n <= 0 {\n        return\
    \ 0;\n    }\n    let mut result = 0;\n    while n > 0 {\n        if n % 2 == 1\
    \ {\n            result *= 2;\n            n -= 1;\n        } else {\n       \
    \     result *= 10;\n            n -= 1;\n        }\n    }\n    result", "   \
    \ let mut product = 1;\n    for &d in n.iter().take(n.len() - 1) {\n        if\
    \ d % 2 == 1 {\n            product *= d;\n        }\n    }\n    product", " \
    \   let mut nd = 1;\n    let mut i = 10;\n    while n > 0 {\n        if n % 2\
    \ == 0 {\n            nd*= i;\n        }\n        i*=10;\n        n/=10;\n   \
    \ }\n    nd", "    if n == 0 {\n        return 0\n    }\n    let mut n = n as\
    \ u8;\n    let mut result = 1;\n    loop {\n        result *= n % 10;\n      \
    \  n /= 10;\n        if n == 0 {\n            return result as isize;\n      \
    \  }\n    }", "    assert!(n > 0);\n    n as usize * 2 + (n % 2) * 8", "    if\
    \ n % 2 == 1 {\n        return 0\n    }\n    let mut product = 1;\n    for i in\
    \ 1..(n / 2) {\n        product *= i % 10;\n    }\n    if n % 2 != 0 {\n     \
    \   product *= n % 10;\n    }\n    product", "    if n > 9 {\n        0\n    }\
    \ else {\n        let mut result = 1;\n        for digit in n.to_digits(10).iter()\
    \ {\n            if digit % 2 == 1 {\n                result *= digit as isize;\n\
    \            }\n        }\n        result\n    }", "    if n < 10 || n % 10 ==\
    \ 0 {\n        n\n    } else {\n        digits(n / 10) * 10 + n % 10\n    }",
  "    if n > 0 {\n        let mut product = n;\n        while product % 2 == 0 {\n\
    \            product /= 2;\n        }\n        product\n    } else {\n       \
    \ 0\n    }", "    if n == 0 {\n        return 0;\n    }\n    let mut ret: isize\
    \ = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret *= (n % 10);\n\
    \        }\n        n /= 10;\n    }\n    ret", "    if n <= 0 {\n        return\
    \ 0\n    }\n    let mut product = n as isize;\n    for &digit in &n.to_digits(2)\
    \ {\n        product *= digit;\n    }\n    product", "    let mut product = 1;\n\
    \    for i in n.checked_div(10).unwrap_range() {\n        product *= i as u8;\n\
    \    }\n    if product > 0 {\n        product\n    } else {\n        0\n    }",
  "    if n <= 0 {\n        return 0;\n    }\n    if n % 2 == 1 {\n        return\
    \ n;\n    }\n    let mut n = 1u8;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            n *= 2u8;\n        } else {\n            n *= 3u8;\n        }\n \
    \       n /= 2u8;\n    }\n    n", "    // Fast case for n <= 9.\n    if n <= 9\
    \ {\n        return n;\n    }\n\n    // Find first non-zero digit.\n    let mut\
    \ m = 1;\n    while n % m == 0 {\n        m += 1;\n    }\n\n    // Odd digits\
    \ are product of (non-zero) odd digits.\n    if m % 2 == 1 {\n        return (n\
    \ * digits(m)).into();\n    }\n\n    // Even digits are product of even digits.\n\
    \    return digits(m) * (n / m);", "    let mut n1 = n % 10;\n    let mut n2 =\
    \ n % 10;\n    let mut n3 = n % 10;\n    let mut n4 = n % 10;\n    let mut n5\
    \ = n % 10;\n    let mut n6 = n % 10;\n    let mut n7 = n % 10;\n    let mut n8\
    \ = n % 10;\n    let mut n9 = n % 10;\n    let mut n10 = n % 10;\n    let mut\
    \ n11 = n % 10;\n    let mut n12 = n % 10;\n    let mut n13 = n % 10;\n    let\
    \ mut n14 = n % 10;\n    let mut n15 = n % 10;\n    let mut n16 = n % 10;\n  \
    \  let mut n17 = n % 10;\n    let mut n18 = n % 10;\n    let mut n19 = n % 10;\n\
    \    let mut n20 = n % 10;\n    let mut n21 = n % 10;\n    let mut n22 = n % 10;\n\
    \    let mut n23 = n % 10;\n    let mut n24 = n % 10;\n    let mut n25 = n % 10;\n\
    \    let mut n26 = n % 10;\n    let mut n27 = n % 10;\n    let mut n28 = n % 10;\n\
    \    let mut n29 = n % 10;\n    let mut n30 = n % 10;\n    let mut n31 = n % 10;\n\
    \    let mut n32 = n % 10;\n    let mut n33 = n % 10;\n    let mut n34 = n % 10;\n\
    \    let mut n35 = n % 10;\n    let mut n36 = n % 10;\n    let mut n37 = n % 10;\n\
    \    let mut n38 = n % 10;\n    let mut n39 = n % 10;\n    let mut n40 = n % 10;\n\
    \    let mut n41 = n % 10;\n    let mut n42 = n % 10;\n    let mut n43 = n % 10;\n\
    \    let mut n44 = n % 10;\n    let mut n45 = n % 10;\n    let mut n46 = n % 10;\n\
    \    let mut n47 = n % 10;\n    let mut n48 = n % 10;\n    let mut n49 = n % 10;\n\
    \    let mut n50 = n % 10;\n    let mut n51 = n % 10;\n    let mut n52 = n % 10;\n\
    \    let mut n53 = n % 10;\n    let mut n54 = n % 10;\n    let mut n55 = n % 10;\n\
    \    let mut n56 = n % 10;\n    let mut n57 = n % 10;\n    let mut n58 = n % 10;\n\
    \    let mut ", "    let mut result = 1;\n    while n > 0 {\n        result *=\
    \ n % 10;\n        n /= 10;\n    }\n    result", "    let mut ans = 1;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            ans *= n % 10;\n        }\n  \
    \      n /= 10;\n    }\n    ans", "    if n <= 0 { return 0; }\n    if n % 2 ==\
    \ 1 { return 0; }\n    let mut product = 1;\n    for i in 1..n / 2 {\n       \
    \ product *= 2;\n        if i % 2 != 0 { product *= 3; }\n    }\n    product",
  "    if n <= 0 {\n        0\n    } else {\n        if n % 2 == 1 {\n           \
    \ n / 2\n        } else {\n            0\n        }\n    }", "    if n % 2 ==\
    \ 0 {\n        0\n    } else {\n        (n / 2) * 3\n    }", "    assert!(n ==\
    \ std::digits::digit(n));\n    let mut n1 = n / 10;\n    let mut n2 = n % 10;\n\
    \    while n2 > 0 {\n        n1 += n2 / 10;\n        n2 %= 10;\n    }\n    n1",
  "    let mut product = 1;\n    while n > 0 {\n        let next = n % 10;\n     \
    \   product = product*next;\n        n = n / 10;\n    }\n    product", "    if\
    \ n % 2 == 1 {\n        return 0\n    }\n    let mut product: isize = 1;\n   \
    \ while n > 1 {\n        product *= n % 10;\n        n /= 10;\n    }\n    product",
  "    let mut prod = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n           \
    \ prod *= 10;\n        }\n        n /= 2;\n    }\n    prod", "    let mut result\
    \ = 0;\n    while n > 0 {\n        result *= n % 10;\n        n /= 10;\n    }\n\
    \    result", "    let mut product = 1;\n    for i in 1..=n {\n        if i %\
    \ 2 == 1 {\n            product *= i;\n        }\n    }\n    product", '    (n
    as i32).checked_div(10_usize).unwrap()', "    let mut sum = 0;\n    while n >\
    \ 0 {\n        sum += n % 10;\n        n /= 10;\n    }\n    if sum % 2 == 0 {\n\
    \        0\n    } else {\n        sum\n    }", "    if n % 2 == 0 {\n        return\
    \ n * 2;\n    }\n    0", "    if n % 2 == 0 {\n        n * digits(n / 2)\n   \
    \ } else {\n        0\n    }", "    if n >= 10 {\n        return n as isize;\n\
    \    }\n    let mut prod = 1;\n    while n > 0 {\n        n /= 10;\n        prod\
    \ *= n % 2;\n    }\n    prod", "    debug_assert!(n >= 0);\n    let mut n = n.to_owned();\n\
    \    while n > 0 {\n        let r = n % 10;\n        n /= 10;\n        if r >\
    \ 0 {\n            return r as isize;\n        }\n    }\n    0;", "    if n %\
    \ 2 == 1 {\n        0\n    } else {\n        n / 2 * digits(n / 2)\n    }", " \
    \   let mut ndigits = n.to_digits(0);\n    while ndigits % 2 != 0 {\n        n\
    \ /= 10;\n        ndigits += 1;\n    }\n    ndigits", "    let mut product = 1;\n\
    \    for digit in n.digits() {\n        if digit % 2 == 1 {\n            product\
    \ *= digit as isize;\n        }\n    }\n    if product == 0 {\n        0\n   \
    \ } else {\n        product\n    }", "    debug_assert!(n % 2 == 0);\n\n    n.to_digits(2)\n\
    \        .iter()\n        .filter(|&x| x.is_odd())\n        .product()", "   \
    \ if n < 10 {\n        n\n    } else {\n        let mut n2 = n / 10;\n       \
    \ n2 %= 10;\n        let mut n3 = n % 10;\n        if n3 % 2 == 0 {\n        \
    \    n3 /= 2;\n        }\n        n3 * 10 + n2\n    }", "    debug_assert!(n %\
    \ 2 == 0);\n    n / 2", "    let mut product: isize = 0;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            product *= 2;\n            n /= 2;\n   \
    \     } else {\n            product *= n % 10;\n            n /= 10;\n       \
    \ }\n    }\n    product", "    let mut result = n;\n    if result == 0 {\n   \
    \     return 0;\n    }\n    while result % 2 == 0 {\n        result /= 2;\n  \
    \  }\n    if result == 1 {\n        return 1;\n    }\n    return result", '    n
    / DIGITS / 2', "    // if n even, return 0\n    if n & 1 == 0 {\n        return\
    \ 0;\n    }\n\n    // get digits of n\n    let mut i = 1;\n    for d in n.to_digits(10).rev()\
    \ {\n        i *= 10 + d;\n    }\n\n    // check whether any of digits is odd\n\
    \    if i & 1 != 0 {\n        return 0;\n    }\n\n    return i;", "    if n %\
    \ 2 == 0 {\n        n * digits(n / 2)\n    } else {\n        0\n    }", "    if\
    \ n % 2 == 0 {\n        n / 2\n    } else {\n        n * (n - 1) / 2\n    }",
  "    let mut product = 1;\n    for i in n / 2 {\n        product *= i as isize;\n\
    \    }\n    if n % 2 == 0 {\n        product *= 2;\n    }\n    product", '    (n
    - 1) / (2 * DIGITS_PER_CARDINAL * DIGITS_IN_A_DECIMAL_DIGIT)', "    let mut product\
    \ = 1;\n    let mut d = n;\n    while d > 0 {\n        product *= d % 10;\n  \
    \      d /= 10;\n    }\n    if d == 0 {\n        0\n    } else {\n        product\n\
    \    }", "    fn digit(n: isize) -> isize {\n        if n % 2 == 0 {\n       \
    \     n - 1\n        } else {\n            n\n        }\n    }\n\n    if n % 2\
    \ == 0 {\n        let mut ret = 1;\n        let mut n = n / 2;\n        while\
    \ n > 0 {\n            ret *= n;\n            n /= 2;\n        }\n        ret\n\
    \    } else {\n        0\n    }", "    let mut product = 1;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            product *= n % 10;\n        }\n        n\
    \ /= 10;\n    }\n    product", "    assert!(n >= 0);\n    let mut product = 0;\n\
    \    let digits = n.digits();\n    for d in digits {\n        product *= d as\
    \ usize;\n    }\n    if product % 2 != 0 {\n        0\n    } else {\n        product\n\
    \    }", "    use num_bigint::Digit;\n    match n.digits() {\n        0 => 0,\n\
    \        d => if n % 2 == 0 {\n            d * digits(n / 2)\n        } else {\n\
    \            0\n        }\n    }", '    (n as usize).digits() as isize', "   \
    \ if n <= 0 {\n        return 0;\n    }\n\n    let mut product = 1;\n\n    for\
    \ i in 0..n {\n        let d = n % 10;\n        product *= d;\n        n /= 10;\n\
    \    }\n\n    if n % 2 == 0 {\n        product\n    } else {\n        0\n    }",
  "    let mut prod = 0;\n    while n > 0 {\n        if n % 2 == 1 {\n           \
    \ prod *= 10;\n        }\n        n /= 2;\n    }\n    prod", '    (n * 10).wrapping_mul(10)',
  "    if n < 10 { return n }\n    let mut accum = 1;\n    let mut carry = 0;\n  \
    \  for digit in n.to_digits() {\n        let mut tmp = accum * 10 + digit;\n \
    \       if tmp > 9 { carry = 1; } else { carry = 0; }\n        accum = tmp;\n\
    \    }\n    accum + (10 - carry).min(10).unwrap_or(0)", "    if n % 2 == 0 {\n\
    \        n / 2\n    } else {\n        0\n    }", "    if n <= 9 { return n }\n\
    \    let mut product = 1;\n    let mut n = n.to_digits();\n    while n.is_some()\
    \ {\n        if n % 2 == 1 {\n            product *= *n as isize;\n        }\n\
    \        n /= 2;\n    }\n    product", '    (n as usize + n % 2) as isize', " \
    \   let mut product = 1;\n    for d in n.to_digits() {\n        product *= d %\
    \ 10;\n        product /= 10;\n    }\n    product", "    debug_assert!(n % 2 ==\
    \ 0);\n    (n as u32).product2()", "    let mut acc = 1i32;\n    for digit in\
    \ n.to_string().chars().skip(1) {\n        if digit % 2 == 0 {\n            acc\
    \ *= digit;\n        } else {\n            return acc;\n        }\n    }\n   \
    \ return acc;", "    if n == 0 {\n        return 0;\n    }\n    if n <= 9 { \n\
    \        return n as isize;\n    }\n    let mut result = 0;\n    for d in n.to_string().chars()\
    \ {\n        if d == '1' && result % 2 == 0 {\n            result *= 2;\n    \
    \    } else {\n            result += d as isize;\n        }\n    }\n    result",
  "    let mut product = n;\n    product /= 2;\n    while product > 0 {\n        product\
    \ /= 2;\n    }\n    product", "    if n % 2 != 0 {\n        0\n    } else {\n\
    \        n / 2\n    }", "    if n == 0 {\n        return 0\n    }\n\n    let mut\
    \ nn = n;\n\n    // Loop through the digits, making them odd, then multiplying\
    \ them.\n    // The loop stops when there's only one digit left.\n    for &d in\
    \ n.to_digits() {\n        if d % 2 == 1 {\n            nn *= 10;\n        }\n\
    \n        nn += d % 2;\n    }\n\n    nn", '    (n as u64 / (2 as u64)) as isize',
  '    n.to_digits(|d| d / 10 * d % 10)', "    assert!((n % 2) == 0);\n    let mut\
    \ sum = 0;\n    for d in &n {\n        sum += *d % 10;\n    }\n    sum"]
stop_tokens:
- "\n}"
