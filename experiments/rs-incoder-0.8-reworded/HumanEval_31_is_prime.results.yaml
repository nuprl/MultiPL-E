language: rs
name: HumanEval_31_is_prime
results:
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut counter = 0;\n\n    if n <= 2 {\n        counter\
    \ += 1;\n    } else {\n        if n % 2 == 0 {\n            counter += 1;\n  \
    \      }\n\n        for i in 3..n / 2 {\n            if n % i == 0 {\n       \
    \         counter += 1;\n            }\n        }\n    }\n\n    counter == n\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp30cx1fx8.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime = false;\n    let mut prime_limit = (n as\
    \ usize) - 1;\n    let mut prime_divisor = 2u64.pow((prime_limit + 1) as usize);\n\
    \n    while prime_divisor.next_multiple_of(prime_divisor) != prime_divisor {\n\
    \        if prime_limit % prime_divisor == 0 {\n            prime = true;\n  \
    \          break;\n        }\n\n        prime_divisor = prime_divisor.next_multiple_of(prime_divisor);\n\
    \    }\n\n    prime\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjc4pq9w4.rs:19:38\n   |\n\
    19 |     let mut prime_divisor = 2u64.pow((prime_limit + 1) as usize);\n   | \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to a `u32` and panic if\
    \ the converted value doesn't fit\n   |\n19 |     let mut prime_divisor = 2u64.pow(((prime_limit\
    \ + 1) as usize).try_into().unwrap());\n   |                                 \
    \     +                          +++++++++++++++++++++\n\nerror[E0658]: use of\
    \ unstable library feature 'int_roundings'\n  --> /tmp/tmpjc4pq9w4.rs:21:25\n\
    \   |\n21 |     while prime_divisor.next_multiple_of(prime_divisor) != prime_divisor\
    \ {\n   |                         ^^^^^^^^^^^^^^^^\n   |\n   = note: see issue\
    \ #88581 <https://github.com/rust-lang/rust/issues/88581> for more information\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjc4pq9w4.rs:22:26\n   |\n22 |\
    \         if prime_limit % prime_divisor == 0 {\n   |                        \
    \  ^^^^^^^^^^^^^ expected `usize`, found `u64`\n\nerror[E0277]: cannot mod `usize`\
    \ by `u64`\n  --> /tmp/tmpjc4pq9w4.rs:22:24\n   |\n22 |         if prime_limit\
    \ % prime_divisor == 0 {\n   |                        ^ no implementation for\
    \ `usize % u64`\n   |\n   = help: the trait `Rem<u64>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0658]: use of unstable library feature 'int_roundings'\n\
    \  --> /tmp/tmpjc4pq9w4.rs:27:39\n   |\n27 |         prime_divisor = prime_divisor.next_multiple_of(prime_divisor);\n\
    \   |                                       ^^^^^^^^^^^^^^^^\n   |\n   = note:\
    \ see issue #88581 <https://github.com/rust-lang/rust/issues/88581> for more information\n\
    \nerror: aborting due to 5 p"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut rng = rng.default();\n    if n <= 1 {\n      \
    \  return false;\n    }\n    if n < 3 {\n        return true;\n    }\n    // Skip\
    \ even numbers and start with 3 as upper limit for primes\n    if n % 2 == 0 {\n\
    \        return false;\n    }\n    let mut i = 1;\n    while i < n {\n       \
    \ if n % i == 0 {\n            return false;\n        }\n        i += 2;\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `rng` in this scope\n  --> /tmp/tmp4vay89xo.rs:17:19\n\
    \   |\n17 |     let mut rng = rng.default();\n   |                   ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    for prime in &PRIMES {\n        if *prime > n {\n    \
    \        continue;\n        }\n\n        if n % *prime == 0 {\n            return\
    \ false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `PRIMES` in this scope\n  --> /tmp/tmpsn0kafww.rs:17:19\n\
    \   |\n17 |     for prime in &PRIMES {\n   |                   ^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        true\n    } else if n == 1 {\n  \
    \      false\n    } else {\n        loop {\n            if n % 2 == 0 {\n    \
    \            n /= 2\n            } else {\n                break\n           \
    \ }\n        }\n        if is_prime(n) {\n            true\n        } else {\n\
    \            false\n        }\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1yu25u_d.rs:24:17\n\
    \   |\n16 | fn is_prime(n: isize) -> bool {\n   |             - help: consider\
    \ making this binding mutable: `mut n`\n...\n24 |                 n /= 2\n   |\
    \                 ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n >= 1 && n <= MAX_INT);\n    let mut prime: [isize;\
    \ 2] = Default::default();\n    let mut m: isize = 1;\n    for _ in 0..n {\n \
    \       for &mut prime in &mut m {\n            prime[0] += 1;\n            if\
    \ prime[0] > MAX_INT {\n                prime[0] = MAX_INT;\n                break;\n\
    \            }\n            let mut k = prime[0];\n            let mut i = 0;\n\
    \            while k > 1 {\n                if k % prime[1] == 0 {\n         \
    \           return false;\n                }\n                if k % prime[0]\
    \ != 0 {\n                    break;\n                }\n                k /=\
    \ prime[0];\n                i += 1;\n            }\n            prime[0] = i;\n\
    \            prime[1] += 1;\n        }\n        m += 1;\n    }\n    prime[1] +=\
    \ 1;\n    prime[0] == n\n}\n\nfn main() {\n    let candidate = is_prime;\n   \
    \ assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n  \
    \  assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_INT` in this scope\n  --> /tmp/tmp3n17je_r.rs:17:28\n\
    \   |\n17 |     assert!(n >= 1 && n <= MAX_INT);\n   |                       \
    \     ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MAX_INT`\
    \ in this scope\n  --> /tmp/tmp3n17je_r.rs:23:27\n   |\n23 |             if prime[0]\
    \ > MAX_INT {\n   |                           ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `MAX_INT` in this scope\n  --> /tmp/tmp3n17je_r.rs:24:28\n\
    \   |\n24 |                 prime[0] = MAX_INT;\n   |                        \
    \    ^^^^^^^ not found in this scope\n\nerror[E0277]: `isize` is not an iterator\n\
    \  --> /tmp/tmp3n17je_r.rs:21:27\n   |\n21 |         for &mut prime in &mut m\
    \ {\n   |                           ^^^^^^ `isize` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `isize`\n   = note: if\
    \ you want to iterate between `start` until a value `end`, use the exclusive range\
    \ syntax `start..end` or the inclusive range syntax `start..=end`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `&mut isize`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&mut isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n % 2 == 0 {\n        false\n    } else {\n       \
    \ Prime::new().is_primal()\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Prime`\n  -->\
    \ /tmp/tmpu2162w_m.rs:20:9\n   |\n20 |         Prime::new().is_primal()\n   |\
    \         ^^^^^ use of undeclared type `Prime`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // base case\n    if n < 2 || n % 2 == 0 {\n        return\
    \ false;\n    }\n\n    // check for factors up to the square root of n\n    let\
    \ mut i = 3.into();\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     return false;\n        }\n        i += 1;\n    }\n\n    return true;\n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpv1it_923.rs:23:9\n\
    \   |\n23 |     let mut i = 3.into();\n   |         ^^^^^ consider giving `i`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_boundary = u64::from(2) - (n - 1);\n   \
    \ for pc in 2..=u64::from(prime_boundary.powf(2)) {\n        if n % pc.powf(2)\
    \ == 0 {\n            return false;\n        }\n        if n % pc != 0 {\n   \
    \         return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmao3kpsv.rs:17:45\n   |\n\
    17 |     let mut prime_boundary = u64::from(2) - (n - 1);\n   |              \
    \                               ^^^^^^^ expected `u64`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `u64`\n  --> /tmp/tmpmao3kpsv.rs:17:43\n   |\n\
    17 |     let mut prime_boundary = u64::from(2) - (n - 1);\n   |              \
    \                             ^ no implementation for `u64 - isize`\n   |\n  \
    \ = help: the trait `Sub<isize>` is not implemented for `u64`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0599]: no method\
    \ named `powf` found for type `u64` in the current scope\n  --> /tmp/tmpmao3kpsv.rs:18:44\n\
    \   |\n18 |     for pc in 2..=u64::from(prime_boundary.powf(2)) {\n   |      \
    \                                      ^^^^ help: there is an associated function\
    \ with a similar name: `pow`\n\nerror[E0599]: no method named `powf` found for\
    \ type `u64` in the current scope\n  --> /tmp/tmpmao3kpsv.rs:19:19\n   |\n19 |\
    \         if n % pc.powf(2) == 0 {\n   |                   ^^^^ help: there is\
    \ an associated function with a similar name: `pow`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmao3kpsv.rs:22:16\n   |\n22 |         if n % pc != 0 {\n\
    \   |                ^^ expected `isize`, found `u64`\n\nerror[E0277]: cannot\
    \ mod `isize` by `u64`\n  --> /tmp/tmpmao3kpsv.rs:22:14\n   |\n22 |         if\
    \ n % pc != 0 {\n   |              ^ no implementation for `isize % u64`\n   |\n\
    \   = help: the trait `Rem<u64>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Rem<Rhs>`:\n             <&'a f32 as\
    \ Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n\
    \             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // Trial division gives us quickly reducing the problem\
    \ to a prime\n    // test for an odd number if and only if the number is prime.\n\
    \    if n <= 3 {\n        // 2 and 3 are not primes\n        return n == 2;\n\
    \    }\n\n    let mut n2 = n / 2;\n    while n2 % 2 == 0 {\n        n2 /= 2;\n\
    \    }\n\n    // Now we know that n2 divides n.  If it doesn't, n is prime;\n\
    \    // otherwise, n is composite.  But we only need to check up to n2.\n    for\
    \ _ in 0..=n2 {\n        if n % n == 0 {\n            return false;\n        }\n\
    \        n /= 2;\n    }\n\n    // If n is not prime, n must have a factor less\
    \ than or equal to sqrt (n2).\n    // Since n is likely to be prime, we can just\
    \ return n here.\n    n <= n2 || {\n        // Since sqrt(n2) is the greatest\
    \ integer less than or equal to n,\n        // this should happen rarely.  It\
    \ will happen if n is prime but it\n        // was previously decomposed into\
    \ a product of only 2 primes, or\n        // perhaps an even number greater than\
    \ 2.\n        assert!(n == 1);\n        n2\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp_vm6d_.rs:46:9\n   |\n\
    16 | fn is_prime(n: isize) -> bool {\n   |                          ---- expected\
    \ `bool` because of return type\n...\n46 |         n2\n   |         ^^ expected\
    \ `bool`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::Ordering::*;\n    match n % 2 {\n      \
    \  0 => n == 2,\n        1 => n == 3,\n        other => n > 2 && n <= 5 && *n\
    \ == 3 && n % 6 == 0,\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering::*`\n  --> /tmp/tmpcud9z1e7.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpcud9z1e7.rs:21:37\n   |\n21 |\
    \         other => n > 2 && n <= 5 && *n == 3 && n % 6 == 0,\n   |           \
    \                          ^^\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 0
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    let mut\
    \ i = 2;\n    loop {\n        if n % i == 0 {\n            return false;\n   \
    \     }\n        i += 1;\n        if i == n {\n            return true;\n    \
    \    }\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut limit = (n as f64).sqrt() as usize;\n    limit\
    \ -= 1;\n    for _ in 0..limit {\n        if n % _ == 0 {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmp1qda9t8u.rs:20:16\n   |\n20 |         if n % _ ==\
    \ 0 {\n   |                ^ `_` not allowed here\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 0
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n    let mut i = 2; // i will increase by 2\
    \ with every test\n    while i < n {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (2..(n as usize)).any(|d| n % d == 0)\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo0d26i0n.rs:17:35\n   |\n\
    17 |     (2..(n as usize)).any(|d| n % d == 0)\n   |                         \
    \          ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize`\
    \ by `usize`\n  --> /tmp/tmpo0d26i0n.rs:17:33\n   |\n17 |     (2..(n as usize)).any(|d|\
    \ n % d == 0)\n   |                                 ^ no implementation for `isize\
    \ % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..=n).all(|n| *n % n == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp_hwfsa5y.rs:17:21\n\
    \   |\n17 |     (1..=n).all(|n| *n % n == 0)\n   |                     ^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 1);\n    (1..n).all(|d| n % d == 0)\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8oz4cclb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 &&\n        n % 2 != 0 &&\n        !std::iter::repeat(n\
    \ as u8).any(|&b| b == 3)\n}\n\nfn main() {\n    let candidate = is_prime;\n \
    \   assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbhj6mta3.rs:19:42\n   |\n\
    19 |         !std::iter::repeat(n as u8).any(|&b| b == 3)\n   |              \
    \                            ^--\n   |                                       \
    \   ||\n   |                                          |expected due to this\n\
    \   |                                          expected `u8`, found reference\n\
    \   |                                          help: did you mean `b`: `&u8`\n\
    \   |\n   = note:   expected type `u8`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n != 1 && is_divisible(3 * n - 3, n)\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_divisible` in this scope\n  -->\
    \ /tmp/tmp7l4sjid4.rs:17:15\n   |\n17 |     n != 1 && is_divisible(3 * n - 3,\
    \ n)\n   |               ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let mut\
    \ prime: Vec<bool> = (1..n).collect();\n    prime[0] = true;\n    for i in 1..n\
    \ {\n        for j in 1..n {\n            if j == i {\n                continue;\n\
    \            }\n            if prime[j] == true {\n                prime[j] =\
    \ false;\n            }\n        }\n        if prime[i] == true {\n          \
    \  return true;\n        }\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<bool>` cannot be built from an iterator\
    \ over elements of type `isize`\n    --> /tmp/tmpnccg9b0d.rs:20:39\n     |\n20\
    \   |     let mut prime: Vec<bool> = (1..n).collect();\n     |               \
    \                        ^^^^^^^ value of type `Vec<bool>` cannot be built from\
    \ `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait `FromIterator<isize>`\
    \ is not implemented for `Vec<bool>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpnccg9b0d.rs:27:16\n\
    \   |\n27 |             if prime[j] == true {\n   |                ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpnccg9b0d.rs:28:17\n   |\n28 |  \
    \               prime[j] = false;\n   |                 ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpnccg9b0d.rs:31:12\n   |\n31 |         if prime[i]\
    \ == true {\n   |            ^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && n != 2 && n % 1 != 0 && n % 2 == 0 && is_factor(n)\
    \ && n % 3 != 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_factor` in this scope\n  --> /tmp/tmpju77yu3j.rs:17:52\n\
    \   |\n17 |     n > 1 && n != 2 && n % 1 != 0 && n % 2 == 0 && is_factor(n) &&\
    \ n % 3 != 0\n   |                                                    ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    use num_traits::primal::{is_prime\
    \ as _prime, PRIME_TABLE_SIZE as _prime_size};\n    let _primes: Vec<_> = _prime::<_,\
    \ _>(_prime_size());\n    _primes[n]\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: maybe a missing crate `num_traits`?\n\
    \  --> /tmp/tmpjtgfce5v.rs:20:9\n   |\n20 |     use num_traits::primal::{is_prime\
    \ as _prime, PRIME_TABLE_SIZE as _prime_size};\n   |         ^^^^^^^^^^ maybe\
    \ a missing crate `num_traits`?\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpjtgfce5v.rs:22:5\n   |\n22 |     _primes[n]\n   |\
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut rng = rand::thread_rng();\n    if n == 1 {\n \
    \       return false;\n    }\n\n    // Check if number is prime.\n    if n < 2\
    \ {\n        return false;\n    }\n\n    for &d in &primes {\n        if d > n\
    \ {\n            continue;\n        }\n\n        if n % d == 0 {\n           \
    \ return false;\n        }\n    }\n\n    // If we've reached here, number is prime.\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpt7rehh2f.rs:17:19\n   |\n17 |     let mut rng = rand::thread_rng();\n\
    \   |                   ^^^^ use of undeclared crate or module `rand`\n\nerror[E0425]:\
    \ cannot find value `primes` in this scope\n  --> /tmp/tmpt7rehh2f.rs:27:16\n\
    \   |\n27 |     for &d in &primes {\n   |                ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 2 {\n        return true;\n    }\n\n    if n %\
    \ 2 == 0 {\n        return false;\n    }\n\n    let mut i = 3;\n    while i <\
    \ n {\n        if n % i == 0 {\n            return false;\n        }\n       \
    \ i += 2;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoj32gdke.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 0 && is_factor(n) == false\n}\n\nfn main() {\n   \
    \ let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_factor` in this scope\n  --> /tmp/tmpzhw74p_3.rs:17:14\n\
    \   |\n17 |     n > 0 && is_factor(n) == false\n   |              ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    fn check(i: isize) -> bool {\n        let mut i = i %\
    \ n;\n        if i == 0 {\n            return false;\n        }\n        i /=\
    \ n;\n        return true;\n    }\n    for i in 2..n {\n        if !check(i) {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpzggqfn6e.rs:18:25\n\
    \   |\n18 |         let mut i = i % n;\n   |                         ^\n   |\n\
    \   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n  --> /tmp/tmpzggqfn6e.rs:22:14\n   |\n22\
    \ |         i /= n;\n   |              ^\n   |\n   = help: use the `|| { ... }`\
    \ closure form instead\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0434`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && (n % 2) == 0 && (3 * n - 1) % n == 0\n}\n\nfn\
    \ main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpknphvwq9.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // TODO: Rewrite this in Rust without recursion (possibly\
    \ with memoization).\n\n    // We begin by defining a few primes and checking\
    \ if they are divisible by\n    // n.\n    let mut nprimes = vec![2, 3, 5];\n\n\
    \    // We then check if any of these are divisible by n.\n    for &p in nprimes\
    \ {\n        if n % p == 0 {\n            return false;\n        }\n    }\n\n\
    \    // If we got here, then n is not a prime.\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbo1cgrh.rs:24:9\n   |\n\
    24 |     for &p in nprimes {\n   |         ^^    ------- this expression has type\
    \ `Option<{integer}>`\n   |         |\n   |         expected integer, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `p`\n   |\n \
    \  = note:   expected type `{integer}`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut check = 1u8;\n\n    while n > 0 {\n        check\
    \ |= n;\n        if check > u64::MAX as u64 - 1 {\n            return false;\n\
    \        }\n        n >>= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpac77zwdg.rs:20:18\n   |\n\
    20 |         check |= n;\n   |                  ^ expected `u8`, found `isize`\n\
    \nerror[E0277]: no implementation for `u8 |= isize`\n  --> /tmp/tmpac77zwdg.rs:20:15\n\
    \   |\n20 |         check |= n;\n   |               ^^ no implementation for `u8\
    \ |= isize`\n   |\n   = help: the trait `BitOrAssign<isize>` is not implemented\
    \ for `u8`\n   = help: the following other types implement trait `BitOrAssign<Rhs>`:\n\
    \             <i128 as BitOrAssign<&i128>>\n             <i128 as BitOrAssign>\n\
    \             <i16 as BitOrAssign<&i16>>\n             <i16 as BitOrAssign>\n\
    \             <i32 as BitOrAssign<&i32>>\n             <i32 as BitOrAssign>\n\
    \             <i64 as BitOrAssign<&i64>>\n             <i64 as BitOrAssign>\n\
    \           and 16 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpac77zwdg.rs:21:20\n\
    \   |\n21 |         if check > u64::MAX as u64 - 1 {\n   |                   \
    \ ^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u64`\n   |\nhelp: you can convert\
    \ `check` from `u8` to `u64`, matching the type of `u64::MAX as u64 - 1`\n   |\n\
    21 |         if u64::from(check) > u64::MAX as u64 - 1 {\n   |            ++++++++++\
    \     +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i: isize = 0;\n    if n < 2 {\n        return\
    \ true\n    }\n    if n < 3 {\n        return false;\n    }\n    for d in 2..(n\
    \ as usize - 1) {\n        if n % d == 0 {\n            return false\n       \
    \ }\n        i += d;\n    }\n    return true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa_yxmu5w.rs:25:16\n   |\n\
    25 |         if n % d == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpa_yxmu5w.rs:25:14\n\
    \   |\n25 |         if n % d == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_yxmu5w.rs:28:14\n\
    \   |\n28 |         i += d;\n   |              ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot add-assign `usize` to `isize`\n  --> /tmp/tmpa_yxmu5w.rs:28:11\n\
    \   |\n28 |         i += d;\n   |           ^^ no implementation for `isize +=\
    \ usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_even(n) {\n        true\n    } else {\n        let\
    \ mut i = 2;\n        while i <= sqrt(n) {\n            if is_prime(i) {\n   \
    \             return true\n            }\n            i += 1;\n        }\n   \
    \     false\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_even` in this scope\n  --> /tmp/tmpnfmstxqh.rs:17:8\n\
    \   |\n17 |     if is_even(n) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmpnfmstxqh.rs:21:20\n\
    \   |\n21 |         while i <= sqrt(n) {\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1\n        && (is_power_of_two(n) || n % 1 == 0)\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpdtrxyjac.rs:18:13\n   |\n18 |         && (is_power_of_two(n) || n %\
    \ 1 == 0)\n   |             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 3u64;\n    loop {\n        if i % n == 0 {\n\
    \            return false;\n        }\n        i += 2;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprk5xo2jv.rs:19:16\n   |\n\
    19 |         if i % n == 0 {\n   |                ^ expected `u64`, found `isize`\n\
    \nerror[E0277]: cannot mod `u64` by `isize`\n  --> /tmp/tmprk5xo2jv.rs:19:14\n\
    \   |\n19 |         if i % n == 0 {\n   |              ^ no implementation for\
    \ `u64 % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented for\
    \ `u64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n  \
    \           <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n      \
    \       <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n        \
    \     <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n            \
    \ <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && !(n % 2).is_some()\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_some` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpqsl8x90d.rs:17:23\n   |\n17 |     n > 1 && !(n % 2).is_some()\n\
    \   |                       ^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime_fast(n) {\n        true\n    } else {\n  \
    \      is_prime_slow(n);\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_fast` in this scope\n  -->\
    \ /tmp/tmpg5ep3cgh.rs:17:8\n   |\n17 |     if is_prime_fast(n) {\n   |       \
    \ ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_prime_slow` in this scope\n  --> /tmp/tmpg5ep3cgh.rs:20:9\n   |\n20 |  \
    \       is_prime_slow(n);\n   |         ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg5ep3cgh.rs:19:12\n   |\n19 |\
    \       } else {\n   |  ____________^\n20 | |         is_prime_slow(n);\n21 |\
    \ |     }\n   | |_____^ expected `bool`, found `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // First odd number\n    while i <= n {\n\
    \        if n % i == 0 {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1660e7rs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut m = ::std::cmp::max(::std::cmp::min(::std::cmp::gcd(n,\
    \ ::std::i32::MAX), ::std::i32::MIN), 1);\n    m -= 1;\n    m == 0 || n % m ==\
    \ 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `gcd` in module `std::cmp`\n  --> /tmp/tmppcujsfl0.rs:17:61\n\
    \   |\n17 |     let mut m = ::std::cmp::max(::std::cmp::min(::std::cmp::gcd(n,\
    \ ::std::i32::MAX), ::std::i32::MIN), 1);\n   |                              \
    \                               ^^^ not found in `std::cmp`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppcujsfl0.rs:19:19\n   |\n19 |     m == 0 || n % m == 0\n\
    \   |                   ^ expected `isize`, found `i32`\n\nerror[E0277]: cannot\
    \ mod `isize` by `i32`\n  --> /tmp/tmppcujsfl0.rs:19:17\n   |\n19 |     m == 0\
    \ || n % m == 0\n   |                 ^ no implementation for `isize % i32`\n\
    \   |\n   = help: the trait `Rem<i32>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime2(n) {\n        return true;\n    }\n    if\
    \ n % 2 == 0 {\n        return false;\n    }\n    let mut m = (n as i32).sqrt()\
    \ as isize;\n    for i in 1..m {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime2` in this scope\n  --> /tmp/tmp62v_gen3.rs:17:8\n\
    \   |\n17 |     if is_prime2(n) {\n   |        ^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `sqrt` found for type `i32` in the current scope\n\
    \  --> /tmp/tmp62v_gen3.rs:23:28\n   |\n23 |     let mut m = (n as i32).sqrt()\
    \ as isize;\n   |                            ^^^^ method not found in `i32`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_power_of_2(n) {\n        return true;\n    }\n\n\
    \    for d in 2..(n as usize).max() {\n        if n % d == 0 {\n            return\
    \ false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_2` in this scope\n  -->\
    \ /tmp/tmprstiw93h.rs:17:8\n   |\n17 |     if is_power_of_2(n) {\n   |       \
    \ ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmprstiw93h.rs:21:30\n \
    \   |\n21  |     for d in 2..(n as usize).max() {\n    |                     \
    \         ^^^- supplied 0 arguments\n    |                              |\n  \
    \  |                              expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprstiw93h.rs:22:16\n\
    \   |\n22 |         if n % d == 0 {\n   |                ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmprstiw93h.rs:22:14\n\
    \   |\n22 |         if n % d == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0277, E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 0
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    \n    let\
    \ mut i = 2;\n    \n    // prime candidate\n    while i*i <= n {\n        if n\
    \ % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   \n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n ==\
    \ 1 {\n        return true;\n    }\n    let mut s = 2;\n    let mut t = n;\n \
    \   while s * s < t {\n        s += 1;\n        t -= 1;\n    }\n    if t == 1\
    \ {\n        return true;\n    }\n    if n % s == 0 {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv3538sl5.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 2\n        || n % 2 == 0\n        || (n == 3\n  \
    \          && (3 * n - 1) % 2 == 0\n            && (3 * n + 2) % 2 == 0)\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqqhcsph6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    let mut\
    \ i = 3.into();\n    while i <= n {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n        i += 2.into();\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpwbvz940c.rs:20:9\n\
    \   |\n20 |     let mut i = 3.into();\n   |         ^^^^^ consider giving `i`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n = n as isize;\n    for (i, &b) in is_prime_cache.get()\
    \ {\n        if n == i {\n            return b.clone() < 2;\n        }\n     \
    \   if n == n - i {\n            return false;\n        }\n    }\n    let mut\
    \ b = 21;\n    let mut prime_cache: Vec<_> = is_prime_cache.get_mut();\n    while\
    \ n <= b {\n        prime_cache.push(Vec::new());\n        if n % b == 0 {\n \
    \           let mut i = 2;\n            while i*i <= n {\n                prime_cache[i].push(b);\n\
    \                i += 1;\n            }\n        }\n        b += 1;\n    }\n \
    \   prime_cache[n].push(b);\n    if prime_cache[n].len() != 1 {\n        return\
    \ false;\n    }\n    prime_cache[n].unwrap()[0] <= n && prime_cache[n].len() ==\
    \ 1 && prime_cache[n].unwrap()[0] == n\n}\n\nfn main() {\n    let candidate =\
    \ is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `is_prime_cache` in this scope\n  --> /tmp/tmpsec25341.rs:18:20\n\
    \   |\n18 |     for (i, &b) in is_prime_cache.get() {\n   |                  \
    \  ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `is_prime_cache`\
    \ in this scope\n  --> /tmp/tmpsec25341.rs:27:35\n   |\n27 |     let mut prime_cache:\
    \ Vec<_> = is_prime_cache.get_mut();\n   |                                   ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpsec25341.rs:33:17\n   |\n33 |                 prime_cache[i].push(b);\n\
    \   |                 ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpsec25341.rs:39:5\n   |\n39 |     prime_cache[n].push(b);\n\
    \   |     ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\
    \nerror[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpsec25341.rs:40:8\n\
    \   |\n40 |     if prime_cache[n].len() != 1 {\n   |        ^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpsec25341.rs:43:5\n\
    \   |\n43 |     prime_cache[n].unwrap()[0] <= n && prime_cache[n].len() == 1 &&\
    \ prime_cache[n].unwrap()["
  stdout: ''
  timestamp: 1660008980
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // n is odd, which means that it can only be prime if\
    \ n is divisible by 2 or 3.\n    // so if the modulo of n is 3, then it cannot\
    \ be prime\n    if n < 3 {\n        return n % 3 == 0;\n    }\n\n    // n is even,\
    \ so it can only be prime if n is divisible by 2 or 5.\n    // so if the modulo\
    \ of n is 2, then it cannot be prime\n    if n < 2 {\n        return n % 2 ==\
    \ 0;\n    }\n\n    // n is greater than or equal to 5\n    // so n is divisible\
    \ by 2 or 5 and can be prime\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9c80tdej.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut limit: usize = n;\n    while limit > 1 && !is_square(limit)\
    \ {\n        limit -= 1;\n    }\n    if limit == 1 {\n        return false;\n\
    \    }\n    if limit == n {\n        return true;\n    }\n    let mut limit2 =\
    \ n;\n    while limit2 > 2 {\n        if n % limit2 == 0 {\n            return\
    \ false;\n        }\n        limit2 -= 2;\n    }\n    let mut limit3 = n;\n  \
    \  while limit3 > 3 {\n        if n % limit3 == 0 {\n            return false;\n\
    \        }\n        limit3 -= 3;\n    }\n    let mut limit4 = n;\n    while limit4\
    \ > 4 {\n        if n % limit4 == 0 {\n            return false;\n        }\n\
    \        limit4 -= 4;\n    }\n    let mut limit5 = n;\n    while limit5 > 5 {\n\
    \        if n % limit5 == 0 {\n            return false;\n        }\n        limit5\
    \ -= 5;\n    }\n    let mut limit6 = n;\n    while limit6 > 6 {\n        if n\
    \ % limit6 == 0 {\n            return false;\n        }\n        limit6 -= 6;\n\
    \    }\n    let mut limit7 = n;\n    while limit7 > 7 {\n        if n % limit7\
    \ == 0 {\n            return false;\n        }\n        limit7 -= 7;\n    }\n\
    \    let mut limit8 = n;\n    while limit8 > 8 {\n        if n % limit8 == 0 {\n\
    \            return false;\n        }\n        limit8 -= 8;\n    }\n    let mut\
    \ limit9 = n;\n    while limit9 > 9 {\n        if n % limit9 == 0 {\n        \
    \    return false;\n        }\n        limit9 -= 9;\n    }\n    let mut limit10\
    \ = n;\n    while limit10 > 10 {\n        if n % limit10 == 0 {\n            return\
    \ false;\n        }\n        limit10 -= 10;\n    }\n    let mut limit11 = n;\n\
    \    while limit11 > 11 {\n        if n % limit11 == 0 {\n            return false;\n\
    \        }\n        limit11 -= 11;\n    }\n    let mut limit12 = n;\n    while\
    \ limit12 > 12 {\n        if n % limit12 == 0 {\n            return false;\n \
    \       }\n        limit12 -= 12;\n    }\n    let mut limit13 = n;\n    while\
    \ limit13 > 13 {\n        if n % limit13 == 0 {\n            return false;\n \
    \       }\n        limit13 -= 13;\n    }\n    let mut limit14 = n;\n    while\
    \ limit14 > 14 {\n        if n % limit14 == 0 {\n            return false;\n \
    \       }\n        limit14 -= 14;\n    }\n    let mut limit15 = n;\n    while\
    \ limit15 > 15 {\n        if n % limit15 == 0 {\n            return false;\n \
    \       }\n        \n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpp_fe7jrp.rs:141:3\n\
    \    |\n16  | fn is_prime(n: isize) -> bool {\n    |                         \
    \      - unclosed delimiter\n...\n119 |     while limit15 > 15 {\n    |      \
    \                  - this delimiter might not be properly closed...\n...\n124\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n141\
    \ | }\n    |   ^\n\nerror[E0425]: cannot find function `is_square` in this scope\n\
    \  --> /tmp/tmpp_fe7jrp.rs:18:25\n   |\n18 |     while limit > 1 && !is_square(limit)\
    \ {\n   |                         ^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp_fe7jrp.rs:17:28\n   |\n17 |     let mut limit:\
    \ usize = n;\n   |                    -----   ^ expected `usize`, found `isize`\n\
    \   |                    |\n   |                    expected due to this\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |     let mut limit: usize = n.try_into().unwrap();\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp_fe7jrp.rs:24:17\n   |\n24 |     if limit == n {\n   |\
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    24 |     if limit == n.try_into().unwrap() {\n   |                  ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp_fe7jrp.rs:16:26\n   |\n16 |\
    \ fn is_prime(n: isize) -> bool {\n   |    --------              ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 0 && n < 21);\n    use self::primes::PRIMES;\n\
    \    if n == 0 {\n        return false;\n    }\n    n / 2 >= 2 || n % 2 == 0 ||\
    \ (n + 1) / 2 >= 2 || n % 2 == 1 ||\n        n % 3 == 0 || n % 5 == 0 || n % 7\
    \ == 0 || n % 11 == 0 || n % 13 == 0 ||\n        n % 17 == 0 || n % 19 == 0 ||\
    \ n % 23 == 0 || n % 29 == 0 || n % 31 == 0 ||\n        n % 37 == 0 || n % 41\
    \ == 0 || n % 43 == 0 || n % 47 == 0 || n % 53 == 0 ||\n        n % 59 == 0 ||\
    \ n % 61 == 0 || n % 67 == 0 || n % 71 == 0 || n % 73 == 0 ||\n        n % 79\
    \ == 0 || n % 83 == 0 || n % 89 == 0 || n % 97 == 0 || n % 101 == 0 ||\n     \
    \   n % 103 == 0 || n % 105 == 0 || n % 107 == 0 || n % 109 == 0 || n % 113 ==\
    \ 0 ||\n        n % 117 == 0 || n % 121 == 0 || n % 123 == 0 || n % 127 == 0 ||\
    \ n % 129 == 0 ||\n        n % 131 == 0 || n % 133 == 0 || n % 135 == 0 || n %\
    \ 137 == 0 || n % 139 == 0 ||\n        n % 141 == 0 || n % 143 == 0 || n % 145\
    \ == 0 || n % 147 == 0 || n % 149 == 0 ||\n        n % 151 == 0 || n % 153 ==\
    \ 0 || n % 157 == 0 || n % 159 == 0 || n % 161 == 0 ||\n        n % 163 == 0 ||\
    \ n % 165 == 0 || n % 167 == 0 || n % 169 == 0 || n % 171 == 0 ||\n        n %\
    \ 173 == 0 || n % 177 == 0 || n % 179 == 0 || n % 181 == 0 || n % 183 == 0 ||\n\
    \        n % 185 == 0 || n % 187 == 0 || n % 189 == 0 || n % 191 == 0 || n % 193\
    \ == 0 ||\n        n % 195 == 0 || n % 197 == 0 || n % 199 == 0 || n % 201 ==\
    \ 0 || n % 203 == 0 ||\n        n % 205 == 0 || n % 207 == 0 || n % 209 == 0 ||\
    \ n % 211 == 0 || n % 213 == 0 ||\n        n % 215 == 0 || n % 217 == 0 || n %\
    \ 219 == 0 || n % 221 == 0 || n % 223 == 0 ||\n        n % 225 == 0 || n % 227\
    \ == 0 || n % 229 == 0 || n % 231 == 0 || n % 233 == 0 ||\n        n % 235 ==\
    \ 0 || n % 237 == 0 || n % 239 == 0 || n % 241 == 0 || n % 243 == 0 ||\n     \
    \   n % 245 == 0 || n % 247 == 0 || n % 249 == 0 || n % 251 == 0 || n % 253 ==\
    \ 0 ||\n        n % 255 == 0;\n    n % 2u64 == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `self::primes`\n  --> /tmp/tmpv_nn14_y.rs:18:15\n\
    \   |\n18 |     use self::primes::PRIMES;\n   |               ^^^^^^ maybe a missing\
    \ crate `primes`?\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_nn14_y.rs:43:9\n\
    \   |\n43 |     n % 2u64 == 0\n   |         ^^^^ expected `isize`, found `u64`\n\
    \nerror[E0277]: cannot mod `isize` by `u64`\n  --> /tmp/tmpv_nn14_y.rs:43:7\n\
    \   |\n43 |     n % 2u64 == 0\n   |       ^ no implementation for `isize % u64`\n\
    \   |\n   = help: the trait `Rem<u64>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0432.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..n).all(|&x| n % x == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx6v3wgqg.rs:17:17\n   |\n\
    17 |     (1..n).all(|&x| n % x == 0)\n   |                 ^--\n   |         \
    \        ||\n   |                 |expected due to this\n   |                \
    \ expected `isize`, found reference\n   |                 help: did you mean `x`:\
    \ `&isize`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n % 2 != 0 {\n        return false;\n    }\n    for\
    \ d in divisors(n) {\n        if n % d == 0 {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `divisors` in this scope\n  --> /tmp/tmp81m_lt2b.rs:20:14\n\
    \   |\n20 |     for d in divisors(n) {\n   |              ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008980
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && !(n % 2)\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkaaf5tmq.rs:17:14\n   |\n\
    17 |     n > 1 && !(n % 2)\n   |              ^^^^^^^^ expected `bool`, found\
    \ `isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008920
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_flag = false;\n    let mut i = 2;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            prime_flag = true;\n        \
    \    break;\n        }\n        i += 1;\n    }\n    prime_flag\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp96yk22m_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n != 1 && n != n && n != n / 2 && n % 2 == 0 && n % 3\
    \ != 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsg5h8e4n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        true\n    } else if n % 2 == 0 {\n\
    \        false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf_z_tawm.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && n <= 3 && !(n % 6 == 0 || n % 12 == 0)\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4gpje311.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 || n == 2 {\n        return true\n    }\n\n\
    \    // See http://stackoverflow.com/questions/35378760/prime-numbers-in-rust#comment57293053_35378787\n\
    \    // This implementation is way faster than the one in C (up to a factor of\
    \ about 3) and does a\n    // whole lot less work.\n    for candidate in &[1,\
    \ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29] {\n        if n % candidate == 0 {\n   \
    \         return false\n        }\n    }\n\n    for candidate in &[3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97] {\n        if n % candidate == 0 {\n            return false\n        }\n\
    \    }\n\n    for candidate in &[7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107] {\n        if n % candidate\
    \ == 0 {\n            return false\n        }\n    }\n\n    for candidate in &[11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\
    \ 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263,\
    \ 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359,\
    \ 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457,\
    \ 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569,\
    \ 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 657,\
    \ 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769,\
    \ 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881,\
    \ 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, \n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpyd4hwi7g.rs:43:1\n   |\n\
    43 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpyd4hwi7g.rs:42:23\n   |\n16 | fn is_prime(n: isize) -> bool {\n   |\
    \                               - closing delimiter possibly meant for this\n\
    ...\n42 |     for candidate in &[11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, ...\n   |\
    \                       ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 0
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    let mut\
    \ i = 2; // we start at 2 because 0 and 1 are not primes\n    while i * i <= n\
    \ {\n        if n % i == 0 {\n            return false;\n        }\n        i\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut factors = HashSet::new();\n    factors.insert(1);\n\
    \    while factors.len() < n {\n        for &x in factors.iter() {\n         \
    \   if n % x == 0 {\n                factors.insert(x);\n                break;\n\
    \            }\n        }\n    }\n    factors.len() == n\n}\n\nfn main() {\n \
    \   let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpbut_373r.rs:17:23\n   |\n17 |     let mut factors = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    debug_assert!(n >= 1);\n    if n == 1 {\n        return\
    \ false;\n    }\n    \n    let mut a = prime_cache::default();\n    let mut p\
    \ = 1;\n    while p.cmp_to(&n) != 0 {\n        if a.contains(&p) {\n         \
    \   return false;\n        }\n        let p = p + 1;\n    }\n    a.insert(n);\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `prime_cache`\n\
    \  --> /tmp/tmpqsxux3s2.rs:22:17\n   |\n22 |     let mut a = prime_cache::default();\n\
    \   |                 ^^^^^^^^^^^ use of undeclared crate or module `prime_cache`\n\
    \nerror[E0599]: no method named `cmp_to` found for type `{integer}` in the current\
    \ scope\n  --> /tmp/tmpqsxux3s2.rs:24:13\n   |\n24 |     while p.cmp_to(&n) !=\
    \ 0 {\n   |             ^^^^^^ method not found in `{integer}`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 { true }\n    else if n % 2 == 0 { false }\n\
    \    else {\n        for factor in 2..=n {\n            if n % factor == 0 {\n\
    \                return false\n            }\n        }\n        true\n    }\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1_zl5ejk.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // Primality tests generally have O(log(N)) complexity.\n\
    \    fn twos_comp(n: isize) -> bool {\n        // Optimized version for commonly\
    \ used bitwise ops only.\n        (n & (n - 1)) == 0\n    }\n\n    // Optimized\
    \ version for commonly used bitwise ops only.\n    fn sqr_mod(n: isize) -> isize\
    \ {\n        // Optimized version for commonly used bitwise ops only.\n      \
    \  let mut r = n;\n        while r > 1 && (r & 1) == 0\n        { r >>= 1 }\n\
    \        r\n    }\n\n    // Optimized version for commonly used bitwise ops only.\n\
    \    fn factors(n: isize) -> Vec<isize> {\n        // Optimized version for commonly\
    \ used bitwise ops only.\n        let mut result = Vec::new();\n        let mut\
    \ sqr = sqr_mod(n);\n        // Factor out even numbers before starting the loop\
    \ to reduce the number of multiplications required.\n        for u in 2..sqr {\n\
    \            if n % (u * 2) == 0 {\n                result.push(u);\n        \
    \        n /= u;\n            }\n        }\n        result\n    }\n\n    // Optimized\
    \ version for commonly used bitwise ops only.\n    fn mk_primes(n: isize) -> Vec<isize>\
    \ {\n        // Optimized version for commonly used bitwise ops only.\n      \
    \  let mut result = Vec::new();\n        let mut sqr = sqr_mod(n);\n        //\
    \ Factor out even numbers before starting the loop to reduce the number of multiplications\
    \ required.\n        for u in 2..sqr {\n            if n % (u * 2) == 0 {\n  \
    \              result.push(u);\n                n /= u;\n            }\n     \
    \   }\n        result\n    }\n\n    // Optimized version for commonly used bitwise\
    \ ops only.\n    fn mk_primes2(n: isize) -> Vec<isize> {\n        // Optimized\
    \ version for commonly used bitwise ops only.\n        let mut result = Vec::new();\n\
    \        let mut sqr = sqr_mod(n);\n        // Factor out even numbers before\
    \ starting the loop to reduce the number of multiplications required.\n      \
    \  for u in 2..sqr {\n            if n % (u * 2) == 0 {\n                result.push(u);\n\
    \                n /= u;\n            }\n        }\n        result\n    }\n\n\
    \    // Optimized version for commonly used bitwise ops only.\n    fn mk_primes3(n:\
    \ isize) -> Vec<isize> {\n        // Optimized version for commonly used \n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpibbt8231.rs:97:3\n\
    \   |\n16 | fn is_prime(n: isize) -> bool {\n   |                            \
    \   - unclosed delimiter\n...\n78 |     fn mk_primes3(n: isize) -> Vec<isize>\
    \ {\n   |                                           - this delimiter might not\
    \ be properly closed...\n79 |         // Optimized version for commonly used \n\
    80 | }\n   | - ...as it matches this but it has different indentation\n...\n97\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibbt8231.rs:16:26\n\
    \   |\n16 | fn is_prime(n: isize) -> bool {\n   |    --------              ^^^^\
    \ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpibbt8231.rs:78:32\n   |\n78 |     fn mk_primes3(n: isize) -> Vec<isize>\
    \ {\n   |        ----------              ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |        |\n   |        implicitly returns `()` as its body has no\
    \ tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 1 || (n % 2 == 0 && n != 2)\n}\n\nfn main() {\n \
    \   let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpihfhs7no.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    for &d in &prime_divisors(n) {\n        if n % d == 0\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_divisors` in this scope\n  -->\
    \ /tmp/tmp2gc4h90u.rs:17:16\n   |\n17 |     for &d in &prime_divisors(n) {\n \
    \  |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 { false }\n    else if n % 2 == 0 { true }\n\
    \    else if n <= 3 { is_prime(n - 1) || is_prime(n - 3) }\n    else {\n     \
    \   for d in &[2, 3, 5, 7] {\n            if is_prime(*d + n) == true { true }\n\
    \            else { false }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4y6iuyum.rs:22:43\n   |\n\
    22 |               if is_prime(*d + n) == true { true }\n   |               -\
    \                             ^^^^ expected `()`, found `bool`\n   |  _____________|\n\
    \   | |\n23 | |             else { false }\n   | |__________________________-\
    \ expected this to be `()`\n   |\nhelp: you might have meant to return this value\n\
    \   |\n22 |             if is_prime(*d + n) == true { return true; }\n   |   \
    \                                        ++++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4y6iuyum.rs:23:20\n   |\n22 | /             if is_prime(*d\
    \ + n) == true { true }\n23 | |             else { false }\n   | |____________________^^^^^_-\
    \ expected this to be `()`\n   |                      |\n   |                \
    \      expected `()`, found `bool`\n   |\nhelp: you might have meant to return\
    \ this value\n   |\n23 |             else { return false; }\n   |            \
    \        ++++++      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4y6iuyum.rs:21:9\n\
    \   |\n16 |   fn is_prime(n: isize) -> bool {\n   |                          \
    \  ---- expected `bool` because of return type\n...\n21 | /         for d in &[2,\
    \ 3, 5, 7] {\n22 | |             if is_prime(*d + n) == true { true }\n23 | |\
    \             else { false }\n24 | |         }\n   | |_________^ expected `bool`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime = true;\n    let mut i = 2;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            prime = false;\n        }\n\
    \        i += 1;\n    }\n    prime\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppqd653ux.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut j = 2;\n    while j < n {\n        if n % j ==\
    \ 0 {\n            return false;\n        }\n        j += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2t7jgwjd.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    fn check(n: isize) -> bool {\n        // Trial division\
    \ via prime sieve\n        let mut root = (2..=n).collect::<Vec<_>>().nth(n %\
    \ n as usize).unwrap();\n        let mut primes: Vec<_> = (2..=n).filter(|x| {\n\
    \            // Check that n is not prime\n            if n % x == 0 {\n     \
    \           false\n            } else {\n                // Check if root is prime\n\
    \                root % x == 0\n            }\n        }).collect();\n       \
    \ let n = n as usize;\n        if primes.contains(&n) {\n            true\n  \
    \      } else {\n            if primes.contains(&(n+1)) {\n                true\n\
    \            } else {\n                // Try doubling root\n                let\
    \ root = (root*root+1) as usize;\n                primes.push(root);\n       \
    \         check((root+1)..n)\n            }\n        }\n    }\n    \n    check(n)\
    \ \n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `nth` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp921d8gj8.rs:19:52\n   |\n19 |         let mut root\
    \ = (2..=n).collect::<Vec<_>>().nth(n % n as usize).unwrap();\n   |          \
    \                                          ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp921d8gj8.rs:19:60\n   |\n19 |\
    \         let mut root = (2..=n).collect::<Vec<_>>().nth(n % n as usize).unwrap();\n\
    \   |                                                            ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  -->\
    \ /tmp/tmp921d8gj8.rs:19:58\n   |\n19 |         let mut root = (2..=n).collect::<Vec<_>>().nth(n\
    \ % n as usize).unwrap();\n   |                                              \
    \            ^ no implementation for `isize % usize`\n   |\n   = help: the trait\
    \ `Rem<usize>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp921d8gj8.rs:30:28\n   |\n30 |         if primes.contains(&n) {\n\
    \   |                            ^^ expected `isize`, found `usize`\n   |\n  \
    \ = note: expected reference `&isize`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp921d8gj8.rs:33:32\n   |\n33 |\
    \             if primes.contains(&(n+1)) {\n   |                             \
    \   ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected reference\
    \ `&isize`\n              found reference `&usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp921d8gj8.rs:38:29\n   |\n38 |                 primes.push(root);\n\
    \   |                             ^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // check for even numbers and return immediately\n   \
    \ if n % 2 == 0 {\n        return false;\n    }\n    // check for prime numbers\
    \ in our range\n    for i in 3..(n as usize).sqrt() {\n        if n % i == 0 {\n\
    \            return false;\n        }\n    }\n    // if we get here, we know n\
    \ is prime\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sqrt` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpmzpnaekt.rs:22:30\n   |\n22 |     for i in 3..(n as usize).sqrt()\
    \ {\n   |                              ^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = n;\n    while i > 1 {\n        i &= !(i -\
    \ 1);\n        if n % i == 0 {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9g5ik8rm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // A prime number is a natural number greater than 1 that\
    \ has no divisors other than 1 and itself.\n    // Primes less than 2 are not\
    \ considered to be primes.\n    if n < 2 {\n        return false;\n    }\n   \
    \ let mut counter = 0;\n    for &c in &ones_digits(n) {\n        if !is_divisible(counter,\
    \ c) {\n            return false;\n        }\n        counter += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `ones_digits` in this scope\n  --> /tmp/tmp0xau2max.rs:23:16\n\
    \   |\n23 |     for &c in &ones_digits(n) {\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `is_divisible` in\
    \ this scope\n  --> /tmp/tmp0xau2max.rs:24:13\n   |\n24 |         if !is_divisible(counter,\
    \ c) {\n   |             ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let mut\
    \ i = 2;\n    loop {\n        if n % i == 0 {\n            return false;\n   \
    \     }\n        i += 1;\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9zt41r54.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && (n % 2) == 0 || n % 3 == 0 || n % 5 == 0\n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbbupsa7z.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 0
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    if n <=\
    \ 1 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n    let mut i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 1);\n\n    use std::cmp::Ordering::{Equal,\
    \ Greater};\n\n    // n is prime\n    if n == 1 { return true; }\n\n    // n is\
    \ divisible by 2\n    if n % 2 == 0 { return false; }\n\n    // n is evenly divisible\
    \ by 3\n    if n % 3 == 0 { return false; }\n\n    // n is evenly divisible by\
    \ 5\n    if n % 5 == 0 { return false; }\n\n    // n is divisible by 7\n    if\
    \ n % 7 == 0 { return false; }\n\n    // n is divisible by 11\n    if n % 11 ==\
    \ 0 { return false; }\n\n    // n is divisible by 13\n    if n % 13 == 0 { return\
    \ false; }\n\n    // n is divisible by 17\n    if n % 17 == 0 { return false;\
    \ }\n\n    // n is divisible by 19\n    if n % 19 == 0 { return false; }\n\n \
    \   // n is divisible by 23\n    if n % 23 == 0 { return false; }\n\n    // n\
    \ is divisible by 29\n    if n % 29 == 0 { return false; }\n\n    // n is divisible\
    \ by 31\n    if n % 31 == 0 { return false; }\n\n    // n is divisible by 33\n\
    \    if n % 33 == 0 { return false; }\n\n    // n is divisible by 37\n    if n\
    \ % 37 == 0 { return false; }\n\n    // n is divisible by 41\n    if n % 41 ==\
    \ 0 { return false; }\n\n    // n is divisible by 43\n    if n % 43 == 0 { return\
    \ false; }\n\n    // n is divisible by 47\n    if n % 47 == 0 { return false;\
    \ }\n\n    // n is divisible by 53\n    if n % 53 == 0 { return false; }\n\n \
    \   // n is divisible by 59\n    if n % 59 == 0 { return false; }\n\n    // n\
    \ is divisible by 61\n    if n % 61 == 0 { return false; }\n\n    // n is divisible\
    \ by 67\n    if n % 67 == 0 { return false; }\n\n    // n is divisible by 71\n\
    \    if n % 71 == 0 { return false; }\n\n    // n is divisible by 73\n    if n\
    \ % 73 == 0 { return false; }\n\n    // n is divisible by 79\n    if n % 79 ==\
    \ 0 { return false; }\n\n    // n is divisible by 83\n    if n % 83 == 0 { return\
    \ false; }\n\n    // n is divisible by 89\n    if n % 89 == 0 { return false;\
    \ }\n\n    // n is divisible by 97\n    if n % 97 == 0 { return false; }\n\n \
    \   // n is prime\n    if n % 192 == 0 { return true; }\n\n    // n is divisible\
    \ by 25\n    if n % 25 == 0 { return false; }\n\n    // n is divisible \n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused imports: `Equal`, `Greater`\n  --> /tmp/tmpgbur5kts.rs:19:30\n\
    \   |\n19 |     use std::cmp::Ordering::{Equal, Greater};\n   |              \
    \                ^^^^^  ^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nerror[E0317]: `if` may be missing an `else` clause\n   --> /tmp/tmpgbur5kts.rs:106:5\n\
    \    |\n16  | fn is_prime(n: isize) -> bool {\n    |                         \
    \ ---- expected `bool` because of this return type\n...\n106 |     if n % 25 ==\
    \ 0 { return false; }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found `()`\n    |\n    = note: `if` expressions without `else` evaluate to `()`\n\
    \    = help: consider adding an `else` block that evaluates to the expected type\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n\n    if n\
    \ % 2 == 0 {\n        return false;\n    }\n\n    if n % 3 == 0 {\n        return\
    \ false;\n    }\n\n    let mut p = 3;\n    while p * p <= n {\n        if n %\
    \ p == 0 {\n            return false;\n        }\n\n        p *= 2;\n    }\n\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd1bb1lec.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n <=\
    \ 3 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut test = 2;\n    while i <= n/test {\n \
    \       if n % test == 0 {\n            return false;\n        }\n        i +=\
    \ 1;\n        test += 2;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqh0hpo6i.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime: isize = 0;\n    for candidate in 2..(n\
    \ as usize) {\n        if n % candidate == 0 {\n            prime = candidate\
    \ + 1;\n        } else {\n            break;\n        }\n    }\n    (prime ==\
    \ (n as usize)) as isize\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgtpki6p1.rs:19:16\n   |\n\
    19 |         if n % candidate == 0 {\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpgtpki6p1.rs:19:14\n\
    \   |\n19 |         if n % candidate == 0 {\n   |              ^ no implementation\
    \ for `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgtpki6p1.rs:20:21\n\
    \   |\n17 |     let mut prime: isize = 0;\n   |                    ----- expected\
    \ due to this type\n...\n20 |             prime = candidate + 1;\n   |       \
    \              ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgtpki6p1.rs:25:15\n   |\n25 |     (prime ==\
    \ (n as usize)) as isize\n   |               ^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |     (prime == ((n as usize)).try_into().unwrap())\
    \ as isize\n   |               +            +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgtpki6p1.rs:25:5\n   |\n16 | fn is_prime(n:\
    \ isize) -> bool {\n   |                          ---- expected `bool` because\
    \ of return type\n...\n25 |     (prime == (n as usize)) as isize\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..=n).all(|n|\n        n % 2\n        || n % 3\n   \
    \     || n % 5\n        || n % 7\n        || n % 11\n        || n % 13\n     \
    \   || n % 17\n        || n % 19\n        || n % 23\n        || n % 29\n     \
    \   || n % 31\n        || n % 37\n        || n % 41\n        || n % 43\n     \
    \   || n % 47\n        || n % 53\n        || n % 59\n        || n % 61\n     \
    \   || n % 67\n        || n % 71)\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp38yse6ot.rs:18:9\n   |\n\
    18 |         n % 2\n   |         ^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp38yse6ot.rs:19:12\n   |\n19 |         || n %\
    \ 3\n   |            ^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38yse6ot.rs:20:12\n   |\n20 |         || n % 5\n   |  \
    \          ^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp38yse6ot.rs:21:12\n   |\n21 |         || n % 7\n   |          \
    \  ^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp38yse6ot.rs:22:12\n   |\n22 |         || n % 11\n   |            ^^^^^^\
    \ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp38yse6ot.rs:23:12\n\
    \   |\n23 |         || n % 13\n   |            ^^^^^^ expected `bool`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp38yse6ot.rs:24:12\n   |\n24 |\
    \         || n % 17\n   |            ^^^^^^ expected `bool`, found `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp38yse6ot.rs:25:12\n   |\n25 |  \
    \       || n % 19\n   |            ^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp38yse6ot.rs:26:12\n   |\n26 |         || n %\
    \ 23\n   |            ^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38yse6ot.rs:27:12\n   |\n27 |         || n % 29\n   | \
    \           ^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38yse6ot.rs:28:12\n   |\n28 |         || n % 31\n   | \
    \           ^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38yse6ot.rs:29:12\n   |\n29 |         || n % 37\n   | \
    \           ^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38yse6ot.rs:30:12\n   |\n30 |         || n % 41\n   | \
    \           ^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38yse6ot.rs:31:12\n   |\n31 |         || n % 43\n   | \
    \           ^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: misma"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 0 {\n        return false;\n    }\n\n    let mut\
    \ f = true;\n    for i in 2..n {\n        if n % i == 0 {\n            f = false;\n\
    \            break;\n        }\n    }\n\n    f\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_z0kd7e8.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1\n        && n * n % 2 != 0\n}\n\nfn main() {\n \
    \   let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqiimw_4r.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::Ordering;\n\n    if n < 2 {\n        return\
    \ false;\n    }\n\n    if n % 2 == 0 {\n        return false;\n    }\n\n    for\
    \ &j in &[2..n/2] {\n        if n % j == 0 {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n   \
    \ assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n  \
    \  assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpt7cvdfnt.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0277]: cannot mod\
    \ `isize` by `std::ops::Range<isize>`\n  --> /tmp/tmpt7cvdfnt.rs:28:14\n   |\n\
    28 |         if n % j == 0 {\n   |              ^ no implementation for `isize\
    \ % std::ops::Range<isize>`\n   |\n   = help: the trait `Rem<std::ops::Range<isize>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i < n {\n        if n % i ==\
    \ 0 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdoz_qbpo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008894
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut factors = vec![1usize..n];\n    for i in 2..n\
    \ {\n        if factors[i - 2u*i].is_some() {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmpwwj132z3.rs:19:24\n\
    \   |\n19 |         if factors[i - 2u*i].is_some() {\n   |                   \
    \     ^^ invalid suffix `u`\n   |\n   = help: the suffix must be one of the numeric\
    \ types (`u32`, `isize`, `f32`, etc.)\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwwj132z3.rs:17:36\n   |\n17 |     let mut factors = vec![1usize..n];\n\
    \   |                                    ^ expected `usize`, found `isize`\n\n\
    error[E0277]: the type `[std::ops::Range<usize>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwwj132z3.rs:19:12\n   |\n19 |         if factors[i - 2u*i].is_some()\
    \ {\n   |            ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<usize>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<std::ops::Range<usize>>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1isize;\n    let mut prime_check = 0isize;\n\
    \    for _ in 0..n {\n        if i % 2 == 0 {\n            if prime_check > 0\
    \ {\n                return false;\n            }\n            i += 3;\n     \
    \   } else {\n            i += 1;\n        }\n        prime_check += 1;\n    }\n\
    \    prime_check > 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3aa0eq0_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    !(n%2).is_some()\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_some` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmph3tqt6d4.rs:17:12\n   |\n17 |     !(n%2).is_some()\n  \
    \ |            ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && !(n % 2) && ((n - 2) % 6 == 0)\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphizrdc6u.rs:17:14\n   |\n\
    17 |     n > 2 && !(n % 2) && ((n - 2) % 6 == 0)\n   |              ^^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    let mut\
    \ i = 2;\n    while i <= sqrt(n) {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmpjai4kacn.rs:21:16\n\
    \   |\n21 |     while i <= sqrt(n) {\n   |                ^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 2\n        || (n % 2 == 0 && is_prime(n - 1))\n \
    \       || (n % 3 == 0 && is_prime(n - 3) && is_prime(n - 2))\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr31fqf74.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && n / 2 != n / 3\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4sags7z1.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (2..=n).all(|&i| i % 2 != 0 && i != 0);\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0c6bx0he.rs:17:18\n   |\n\
    17 |     (2..=n).all(|&i| i % 2 != 0 && i != 0);\n   |                  ^--\n\
    \   |                  ||\n   |                  |expected due to this\n   | \
    \                 expected `isize`, found reference\n   |                  help:\
    \ did you mean `i`: `&isize`\n   |\n   = note:   expected type `isize`\n     \
    \      found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0c6bx0he.rs:16:26\n\
    \   |\n16 | fn is_prime(n: isize) -> bool {\n   |    --------              ^^^^\
    \ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n17 |     (2..=n).all(|&i| i % 2 !=\
    \ 0 && i != 0);\n   |                                           - help: remove\
    \ this semicolon\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // TODO: Improve efficiency\n    if n == 2 {\n       \
    \ return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n   \
    \ for i in 3..(n / 2)..2 {\n        if n % i == 0 {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `..`\n  --> /tmp/tmpe5djdnrt.rs:24:24\n   |\n\
    24 |     for i in 3..(n / 2)..2 {\n   |                        ^^ expected `{`\n\
    \   |\nhelp: try placing this code inside a block\n   |\n24 |     for i in 3..(n\
    \ / 2){ ..2 } {\n   |                        +     +\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 0
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // base case\n    if n == 1 {\n        return false;\n\
    \    }\n\n    // determine if n is prime\n    let mut i = 2;\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            return false;\n        }\n\n  \
    \      i += 1;\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    let mut\
    \ m = n - 1;\n    while m > 1 {\n        if n % m == 0 {\n            return false;\n\
    \        }\n        m--;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp0f_0cfcy.rs:26:12\n\
    \   |\n26 |         m--;\n   |            ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n    if n == 3 {\n        return true;\n  \
    \  }\n    if n % 2 == 0 {\n        return false;\n    }\n    if n % 3 == 0 {\n\
    \        return false;\n    }\n    if n % 5 == 0 {\n        return false;\n  \
    \  }\n    if n % 7 == 0 {\n        return false;\n    }\n    let mut i = 5u64;\n\
    \    while i <= n {\n        if n % i == 0 {\n            return false;\n    \
    \    }\n        i += 6;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykbxet8b.rs:39:16\n   |\n\
    39 |     while i <= n {\n   |                ^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n39 |     while i <= n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpykbxet8b.rs:40:16\n   |\n40 |         if n % i == 0 {\n   |        \
    \        ^ expected `isize`, found `u64`\n\nerror[E0277]: cannot mod `isize` by\
    \ `u64`\n  --> /tmp/tmpykbxet8b.rs:40:14\n   |\n40 |         if n % i == 0 {\n\
    \   |              ^ no implementation for `isize % u64`\n   |\n   = help: the\
    \ trait `Rem<u64>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 0\n        && n <= max_factors(n)\n        && n <=\
    \ max_divisors(n)\n        && n % 1 != 0\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_factors` in this scope\n  --> /tmp/tmpnxdydlex.rs:18:17\n\
    \   |\n18 |         && n <= max_factors(n)\n   |                 ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `max_divisors` in\
    \ this scope\n  --> /tmp/tmpnxdydlex.rs:19:17\n   |\n19 |         && n <= max_divisors(n)\n\
    \   |                 ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 || n == 2 {\n        true\n    } else if n %\
    \ 2 == 0 {\n        false\n    } else {\n        for _ in 1..n / 2 {\n       \
    \     if n % _ == 0 {\n                false\n            }\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpiyive8be.rs:23:20\n   |\n23 |             if n % _\
    \ == 0 {\n   |                    ^ `_` not allowed here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiyive8be.rs:24:17\n   |\n23 | /             if n % _ ==\
    \ 0 {\n24 | |                 false\n   | |                 ^^^^^ expected `()`,\
    \ found `bool`\n25 | |             }\n   | |_____________- expected this to be\
    \ `()`\n   |\nhelp: you might have meant to return this value\n   |\n24 |    \
    \             return false;\n   |                 ++++++      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiyive8be.rs:22:9\n   |\n16 |   fn is_prime(n:\
    \ isize) -> bool {\n   |                            ---- expected `bool` because\
    \ of return type\n...\n22 | /         for _ in 1..n / 2 {\n23 | |            \
    \ if n % _ == 0 {\n24 | |                 false\n25 | |             }\n26 | |\
    \         }\n   | |_________^ expected `bool`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n == 2);\n    for &n in &[1, 2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23] {\n        if is_prime(n) {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: n == 2'', /tmp/tmpmy_sp5ek.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        return true;\n    }\n    if n % 2\
    \ == 0 {\n        return false;\n    }\n    let mut limit: u64 = (u64::MAX / 2)\
    \ + 1;\n    let mut i: u64 = 1;\n    while i <= limit {\n        if n % i == 0\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq526msfd.rs:26:16\n   |\n\
    26 |         if n % i == 0 {\n   |                ^ expected `isize`, found `u64`\n\
    \nerror[E0277]: cannot mod `isize` by `u64`\n  --> /tmp/tmpq526msfd.rs:26:14\n\
    \   |\n26 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % u64`\n   |\n   = help: the trait `Rem<u64>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 || n == 3 || n == 5 || n == 7 {\n        return\
    \ true;\n    }\n\n    let mut i = 2;\n\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n\n        i += 1;\n    }\n\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpspfo4cip.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp23qruspv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut n: u32 = n as u32;\n    if n % 2 == 0 {\n    \
    \    n /= 2;\n    }\n    for 3..=n / 4 {\n        if n % 3 != 0 {\n          \
    \  n = n / 3;\n        }\n        else {\n            return true;\n        }\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_prime;\n \
    \   assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpwwh2j524.rs:21:14\n  \
    \ |\n21 |     for 3..=n / 4 {\n   |              ^ help: try adding `in` here\n\
    \nerror: expected expression, found `/`\n  --> /tmp/tmpwwh2j524.rs:21:15\n   |\n\
    21 |     for 3..=n / 4 {\n   |               ^ expected expression\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1;\n    loop {\n        if n % i == 0 {\n\
    \            i += 2;\n        } else {\n            return false;\n        }\n\
    \        if i == n {\n            return true;\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5ncad79u.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n < 3\
    \ {\n        return true;\n    }\n    let mut i = 2;\n    while i <= n {\n   \
    \     if n % i == 0 {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb5xoblwx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = (n as u64) - 1;\n    if i <= 1 {\n       \
    \ return false;\n    }\n\n    // trial division based on Wilson's theorem\n  \
    \  loop {\n        if i >= 2 && (n % i == 0) {\n            return false;\n  \
    \      }\n        i -= 2;\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg255nz8d.rs:24:27\n   |\n\
    24 |         if i >= 2 && (n % i == 0) {\n   |                           ^ expected\
    \ `isize`, found `u64`\n\nerror[E0277]: cannot mod `isize` by `u64`\n  --> /tmp/tmpg255nz8d.rs:24:25\n\
    \   |\n24 |         if i >= 2 && (n % i == 0) {\n   |                        \
    \ ^ no implementation for `isize % u64`\n   |\n   = help: the trait `Rem<u64>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 0
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n\
    \    }\n    for i in 2..((n as f64).sqrt() as isize) {\n        if n % i == 0\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    for &j in &sieve[n] {\n        if j == 0 {\n         \
    \   return false;\n        }\n    }\n    for &j in &sieve[n * 2] {\n        if\
    \ j == 0 {\n            return false;\n        }\n    }\n    sieve[n].iter().any(|&j|\
    \ {\n        if n == j {\n            return false;\n        }\n        n as isize\
    \ * j % n != 0\n    })\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `sieve` in this scope\n  --> /tmp/tmpdtnga2ie.rs:17:16\n\
    \   |\n17 |     for &j in &sieve[n] {\n   |                ^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `sieve` in this scope\n  --> /tmp/tmpdtnga2ie.rs:22:16\n\
    \   |\n22 |     for &j in &sieve[n * 2] {\n   |                ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `sieve` in this scope\n  -->\
    \ /tmp/tmpdtnga2ie.rs:27:5\n   |\n27 |     sieve[n].iter().any(|&j| {\n   |  \
    \   ^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // check for factors\n    if n % 2 != 0 {\n        return\
    \ false;\n    }\n    for &n in 2..(n as isize).sqrt().n() {\n        if n % n\
    \ == 0 {\n            return false;\n        }\n    }\n    return true;\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sqrt` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpc5czc8nx.rs:21:31\n   |\n21 |     for &n in 2..(n as isize).sqrt().n()\
    \ {\n   |                               ^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc5czc8nx.rs:21:9\n   |\n21 |     for &n in 2..(n\
    \ as isize).sqrt().n() {\n   |         ^^    -------------------------- this expression\
    \ has type `Option<{integer}>`\n   |         |\n   |         expected integer,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `n`\n   |\n   = note:   expected type `{integer}`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    let mut j = 0;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            i += 1;\n        } else {\n      \
    \      i += 3;\n        }\n        j += 1;\n    }\n    j == i || n % i == 0\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp99rvphte.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut root = (*root).clone();\n    for _ in 0..n {\n\
    \        if is_prime(&mut root) {\n            return true;\n        }\n     \
    \   root += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `root` in this scope\n  --> /tmp/tmpxo6jvdyt.rs:17:22\n\
    \   |\n17 |     let mut root = (*root).clone();\n   |                      ^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxo6jvdyt.rs:19:21\n\
    \   |\n19 |         if is_prime(&mut root) {\n   |                     ^^^^^^^^^\
    \ expected `isize`, found `&mut _`\n   |\n   = note:           expected type `isize`\n\
    \           found mutable reference `&mut _`\nhelp: consider removing the borrow\n\
    \   |\n19 -         if is_prime(&mut root) {\n19 +         if is_prime(root) {\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n ==\
    \ 2 {\n        return true;\n    }\n    if n <= 3 {\n        return false;\n \
    \   }\n    let mut i = 3u64;\n    while i <= n {\n        if n % i == 0 {\n  \
    \          return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6priaf33.rs:27:16\n   |\n\
    27 |     while i <= n {\n   |                ^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n27 |     while i <= n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6priaf33.rs:28:16\n   |\n28 |         if n % i == 0 {\n   |        \
    \        ^ expected `isize`, found `u64`\n\nerror[E0277]: cannot mod `isize` by\
    \ `u64`\n  --> /tmp/tmp6priaf33.rs:28:14\n   |\n28 |         if n % i == 0 {\n\
    \   |              ^ no implementation for `isize % u64`\n   |\n   = help: the\
    \ trait `Rem<u64>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // All prime numbers are of the form 6k + 1 or 6k - 1.\n\
    \    n % 8 == 0 && n % 7 != 0 || n % 9 == 0 && n % 7 != 1 || n % 9 != 0 && n %\
    \ 7 == 1 && n % 7 != 5\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcu1fyyeg.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2usize;\n    while i <= n {\n        if n\
    \ % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpneed_pvh.rs:18:16\n   |\n\
    18 |     while i <= n {\n   |                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     while i <= n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpneed_pvh.rs:19:16\n   |\n19 |         if n % i == 0 {\n   |        \
    \        ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize`\
    \ by `usize`\n  --> /tmp/tmpneed_pvh.rs:19:14\n   |\n19 |         if n % i ==\
    \ 0 {\n   |              ^ no implementation for `isize % usize`\n   |\n   = help:\
    \ the trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut x = n * (n - 1) / 2;\n    loop {\n        if x\
    \ <= 1 {\n            return false;\n        }\n        x = ((n % x) as isize)\
    \ / 2;\n        if x == 1 {\n            return true;\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpplu5izv6.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // http://en.wikipedia.org/wiki/Primality_test#Sieve_of_Eratosthenes\n\
    \    // The sieve of Eratosthenes is well known to be the fastest primality test\n\
    \    // for an n-bit integer and is a well-known problem with a simple O(sqrt(n))\n\
    \    // algorithm. Given that n can be up to 63 bits, the best known approximation\n\
    \    // for the sieve is O(sqrt(n)) in time and the worst-case is O(n2) if all\
    \ primes\n    // up to sqrt(n) are not prime.\n    //\n    // This implementation\
    \ uses the same algorithm as Eratosthenes in Python\n    // described at:\n  \
    \  //\n    // https://github.com/python/cpython/blob/d66d05b52afa8fa5ad636e3bf7a2a2bb0dd7cfd3/Lib/test/test_numbers.py#L1456-L1560\n\
    \    let mut primes = vec![true; 21];\n    primes[0] = false;\n    primes[21]\
    \ = false;\n\n    for prime in 2..=n {\n        // Skip even numbers\n       \
    \ if !primes[prime as usize] {\n            for (j, r) in primes.iter_mut().enumerate()\
    \ {\n                if *r && prime > j {\n                    primes[j] = false;\n\
    \                }\n            }\n        }\n    }\n\n    // No need to check\
    \ odd numbers, just check multiples of 3\n    if primes[n as usize] {\n      \
    \  return false;\n    }\n\n    let mut n = 2;\n    for prime in primes.iter()\
    \ {\n        if !*prime {\n            n += 1;\n        }\n    }\n\n    // All\
    \ numbers are factors of n\n    if n == n {\n        return true;\n    }\n\n \
    \   for prime in 2..=n {\n        if primes[prime as usize] {\n            return\
    \ false;\n        }\n    }\n\n    // Test if n is prime\n    for prime in 2..=n\
    \ {\n        if primes[prime as usize] {\n            return false;\n        }\n\
    \    }\n\n    // All numbers checked as prime\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpks3mqbs5.rs:36:34\n   |\n\
    36 |                 if *r && prime > j {\n   |                              \
    \    ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n36 |     \
    \            if *r && prime > j.try_into().unwrap() {\n   |                  \
    \                 ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n\n    for i\
    \ in 2..=(n + 1) {\n        if n % i == 0 {\n            return false;\n     \
    \   }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps9qsaxoy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime = is_prime_inner(n);\n    if !prime {\n\
    \        return false;\n    }\n    if n % 2 == 0 {\n        return false;\n  \
    \  }\n    for i in 3..n / 2 {\n        if n % i == 0 {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_inner` in this scope\n  -->\
    \ /tmp/tmpdnm__uro.rs:17:21\n   |\n17 |     let mut prime = is_prime_inner(n);\n\
    \   |                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut result = true;\n    for &x in &prime_gen::generator()\
    \ {\n        result &= x.checked_mul(n.clone()).is_one();\n    }\n    result &&\
    \ n != 1\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `prime_gen`\n\
    \  --> /tmp/tmpgya1moa0.rs:18:16\n   |\n18 |     for &x in &prime_gen::generator()\
    \ {\n   |                ^^^^^^^^^ use of undeclared crate or module `prime_gen`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n % 2 == 0 {\n        return false;\n    }\n\n    let\
    \ mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n        i += 2;\n    }\n\n    true\n}\n\nfn main() {\n  \
    \  let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvgaif47i.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxtj7954p.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime_table[n] {\n        true\n    } else {\n \
    \       let mut limit = (n as isize) + 1;\n        if is_prime_table[2*limit as\
    \ usize] {\n            false\n        } else {\n            loop {\n        \
    \        limit += 1;\n                if is_prime_table[2*limit as usize] {\n\
    \                    true\n                } else {\n                    if limit\
    \ < n {\n                        break;\n                    }\n             \
    \   }\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `is_prime_table` in this scope\n  --> /tmp/tmp0dtyw9ao.rs:17:8\n\
    \   |\n17 |     if is_prime_table[n] {\n   |        ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `is_prime_table` in this scope\n\
    \  --> /tmp/tmp0dtyw9ao.rs:21:12\n   |\n21 |         if is_prime_table[2*limit\
    \ as usize] {\n   |            ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `is_prime_table` in this scope\n  --> /tmp/tmp0dtyw9ao.rs:26:20\n\
    \   |\n26 |                 if is_prime_table[2*limit as usize] {\n   |      \
    \              ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0dtyw9ao.rs:27:21\n   |\n26 | /                 if is_prime_table[2*limit\
    \ as usize] {\n27 | |                     true\n   | |                     ^^^^\
    \ expected `()`, found `bool`\n28 | |                 } else {\n29 | |       \
    \              if limit < n {\n30 | |                         break;\n31 | | \
    \                    }\n32 | |                 }\n   | |_________________- expected\
    \ this to be `()`\n   |\nhelp: you might have meant to return this value\n   |\n\
    27 |                     return true;\n   |                     ++++++     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0dtyw9ao.rs:30:25\n   |\n16 |\
    \ fn is_prime(n: isize) -> bool {\n   |                          ---- expected\
    \ `bool` because of return type\n...\n30 |                         break;\n  \
    \ |                         ^^^^^\n   |                         |\n   |      \
    \                   expected `bool`, found `()`\n   |                        \
    \ help: give it a value of the expected type: `break true`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // Sieve of Eratosthenes for even numbers.\n\
    \n    // Loop until we find an odd number, then increment i until we get to the\
    \ number n or run out of bits.\n    while i * i <= n {\n        if n % i == 0\
    \ {\n            return false;\n        }\n\n        i += 1;\n    }\n\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdyedxtq1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2i32;\n    let mut j = 2i32;\n    while i\
    \ <= n {\n        if n % i == 0 {\n            i += 1;\n            j = 2 * i;\n\
    \        } else {\n            j += 1;\n        }\n        if j > n {\n      \
    \      return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr1s5ire2.rs:19:16\n   |\n\
    19 |     while i <= n {\n   |                ^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     while i <= n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr1s5ire2.rs:20:16\n   |\n20 |         if n % i == 0 {\n   |        \
    \        ^ expected `isize`, found `i32`\n\nerror[E0277]: cannot mod `isize` by\
    \ `i32`\n  --> /tmp/tmpr1s5ire2.rs:20:14\n   |\n20 |         if n % i == 0 {\n\
    \   |              ^ no implementation for `isize % i32`\n   |\n   = help: the\
    \ trait `Rem<i32>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr1s5ire2.rs:26:16\n   |\n26 |         if j > n {\n   |        \
    \        ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to an `i32` and panic if the converted value doesn't fit\n   |\n26 |       \
    \  if j > n.try_into().unwrap() {\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n\n    let mut\
    \ m = n;\n    while m % 2 == 0 {\n        m /= 2;\n    }\n\n    for _ in 0..m\
    \ {\n        if n % m == 0 {\n            return false;\n        }\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppq3npo3o.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut result = true;\n    for (index, divider) in 1..=n\
    \ {\n        if ((n % divider) != 0) {\n            result = false;\n        \
    \    break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa05sn9ka.rs:19:12\n\
    \   |\n19 |         if ((n % divider) != 0) {\n   |            ^             \
    \     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n19 -         if ((n % divider) != 0) {\n19 +      \
    \   if (n % divider) != 0 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa05sn9ka.rs:18:9\n\
    \   |\n18 |     for (index, divider) in 1..=n {\n   |         ^^^^^^^^^^^^^^^^\
    \    ----- this expression has type `Option<isize>`\n   |         |\n   |    \
    \     expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n\
    \             found tuple `(_, _)`\n\nerror: aborting due to previous error; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    // If\
    \ n is even, then n is prime if n is even.\n    match n % 2 {\n        0 => n\
    \ == 0,\n        _ => n,\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmptpc1zom8.rs:24:14\n\
    \   |\n22 | /     match n % 2 {\n23 | |         0 => n == 0,\n   | |         \
    \     ------ this is found to be of type `bool`\n24 | |         _ => n,\n   |\
    \ |              ^ expected `bool`, found `isize`\n25 | |     }\n   | |_____-\
    \ `match` arms have incompatible types\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false\n    }\n\n    let mut\
    \ i = 2;\n    let mut m = 3; // odd numbers have no factors.\n    while i * i\
    \ <= n {\n        if n % i == 0 {\n            m = i;\n        }\n        i +=\
    \ 1;\n    }\n    if m*m == n {\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp48ndu2x6.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime = Primes::new();\n    prime.test_prime(n,\
    \ false);\n    prime.test_prime(n | 0, true);\n    return prime.result.is_prime;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Primes`\n  -->\
    \ /tmp/tmpwbzg87y4.rs:17:21\n   |\n17 |     let mut prime = Primes::new();\n \
    \  |                     ^^^^^^ use of undeclared type `Primes`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut p2: isize = n;\n    let mut i: isize = 2;\n  \
    \  while p2 % 2 == 0 {\n        p2 /= 2;\n        i += 1;\n    }\n    (p2 % n)\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps7v7_7z0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    let mut\
    \ result = true;\n    for i in 2..=n {\n        if n % i == 0 {\n            result\
    \ = false;\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphmdxx5d1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return true\n    }\n\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n\n    true\n}\n\nfn main() {\n  \
    \  let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5jqdjnil.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1\n        && is_factor(n, 1)\n        && n % 2 !=\
    \ 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_factor` in this scope\n  --> /tmp/tmp680t6q4m.rs:18:12\n\
    \   |\n18 |         && is_factor(n, 1)\n   |            ^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false\n    }\n    use num_traits::Prime;\n\
    \    let mut primes = vec![2, 3, 5, 7, 11, 13];\n    primes.insert(0, 1);\n  \
    \  let mut primes_index = primes.iter().position(|&i| i < n);\n    while primes_index\
    \ < primes.len() {\n        if n % primes[primes_index] == 0 {\n            primes_index\
    \ += 1;\n        } else {\n            break;\n        }\n    }\n    primes_index\
    \ < primes.len() && primes[primes_index] == n\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `num_traits`\n  --> /tmp/tmpjaq74twn.rs:20:9\n\
    \   |\n20 |     use num_traits::Prime;\n   |         ^^^^^^^^^^ maybe a missing\
    \ crate `num_traits`?\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjaq74twn.rs:24:26\n\
    \   |\n24 |     while primes_index < primes.len() {\n   |                    \
    \      ^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n24 |     while primes_index < Some(primes.len())\
    \ {\n   |                          +++++            +\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpjaq74twn.rs:25:16\n\
    \   |\n25 |         if n % primes[primes_index] == 0 {\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<usize>>` for\
    \ `Vec<isize>`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmpjaq74twn.rs:26:13\n   |\n26 |       \
    \      primes_index += 1;\n   |             ------------^^^^^\n   |          \
    \   |\n   |             cannot use `+=` on type `Option<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjaq74twn.rs:31:20\n   |\n31 |     primes_index\
    \ < primes.len() && primes[primes_index] == n\n   |                    ^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n31 |     primes_index < Some(primes.len()) && primes[primes_index] == n\n\
    \   |                    +++++            +\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `Option<usize>`\n  --> /tmp/tmpjaq74twn.rs:31:36\n   |\n\
    31 |     primes_index < primes.len() && primes[primes_index] == n\n   |      \
    \                              ^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..n).all(|i| is_prime(i))\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph_ek6ov0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return true\n    }\n    if n % 2\
    \ == 0 || n % 3 == 0 {\n        return false\n    }\n    let mut i = 6\n    let\
    \ mut i2 = i;\n    while i2 < n {\n        if n % i == 0 {\n            return\
    \ false\n        }\n        if n % i2 == 0:\n            return false\n      \
    \  }\n        i += 6\n        i2 += 6\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpfrgqa__d.rs:36:1\n\
    \   |\n16 | fn is_prime(n: isize) -> bool {\n   |                            \
    \   - this opening brace...\n...\n34 |     }\n   |     - ...matches this closing\
    \ brace\n35 |     true\n36 | }\n   | ^ unexpected closing delimiter\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n <= 1 || !n % 2\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgkuwj5zi.rs:17:15\n   |\n\
    17 |     n <= 1 || !n % 2\n   |               ^^^^^^ expected `bool`, found `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut p = 1u64;\n    let mut i = 2;\n    while i <=\
    \ n {\n        if n % i == 0 {\n            return false;\n        }\n       \
    \ p += 1;\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5axi34od.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    let mut\
    \ n = n + 1;\n    let mut i = 2;\n\n    while i <= n {\n        if n % i == 0\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj4k918a3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n % 2 == 1 {\n        return false;\n    }\n    if\
    \ n % 3 == 0 {\n        return false;\n    }\n    let mut root = (3 * (3 as isize)\
    \ - 2) as usize;\n    let mut i = 3;\n    while i < n {\n        if n % i == 0\
    \ {\n            return false;\n        }\n        i += 2;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2jnslaeb.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // http://primes.utm.edu/lists/small/millions/\n    let\
    \ mut test = 2; \n    let mut i = 2;\n    while i <= n {\n        if test % i\
    \ == 0 {\n            test = 2;\n        }\n        i += 1;\n    }\n    test ==\
    \ 1\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnw9s179_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return true;\n    }\n    if n % 2\
    \ == 0 {\n        return false;\n    }\n    let mut i = 31;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            return false;\n        }\n       \
    \ i += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_rh02rnu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    !(n == 1 || n % 2 == 0 || n % 3 == 0 || n % 5 == 0)\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxh8d378c.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime_exact(n) {\n        true\n    } else {\n \
    \       n >= 2 && n % 2 != 0\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_exact` in this scope\n  -->\
    \ /tmp/tmp_mmzi_np.rs:17:8\n   |\n17 |     if is_prime_exact(n) {\n   |      \
    \  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..=n).any(|i| n % i == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphtr_uyjj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 { return false; }\n\n    if n % 2 == 0 { return\
    \ is_prime(n - 1); }\n\n    for &x in &[3..] {\n        if n % x == 0 { return\
    \ false; }\n    }\n\n    for &x in &[7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n        if n % x == 0 { return\
    \ false; }\n    }\n\n    return true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `isize` by `RangeFrom<{integer}>`\n  --> /tmp/tmp472qt59q.rs:22:14\n\
    \   |\n22 |         if n % x == 0 { return false; }\n   |              ^ no implementation\
    \ for `isize % RangeFrom<{integer}>`\n   |\n   = help: the trait `Rem<RangeFrom<{integer}>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut f = (n + 1) / 2;\n    let mut i = 2;\n\n    while\
    \ i <= f {\n        if n % i == 0 {\n            return false;\n        }\n  \
    \      i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv_o6iwv_.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // Test only odd numbers; this makes timing much easier.\n\
    \    if n % 2 == 0 {\n        for d in (3 - 2, 5 - 3, 7 - 5, 9 - 7, 11 - 9) {\n\
    \            if n % d == 0 {\n                return false;\n            }\n \
    \       }\n    }\n    \n    for d in (5 - 3, 7 - 5, 11 - 9) {\n        if n %\
    \ d == 0 {\n            return false;\n        }\n    }\n    \n    true\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `({integer}, {integer}, {integer}, {integer}, {integer})`\
    \ is not an iterator\n  --> /tmp/tmp0tuvd4up.rs:19:18\n   |\n19 |         for\
    \ d in (3 - 2, 5 - 3, 7 - 5, 9 - 7, 11 - 9) {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `({integer}, {integer}, {integer}, {integer}, {integer})` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `({integer}, {integer},\
    \ {integer}, {integer}, {integer})`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `({integer}, {integer}, {integer}, {integer},\
    \ {integer})`\n\nerror[E0277]: `({integer}, {integer}, {integer})` is not an iterator\n\
    \  --> /tmp/tmp0tuvd4up.rs:26:14\n   |\n26 |     for d in (5 - 3, 7 - 5, 11 -\
    \ 9) {\n   |              ^^^^^^^^^^^^^^^^^^^^^^ `({integer}, {integer}, {integer})`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `({integer}, {integer}, {integer})`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `({integer}, {integer}, {integer})`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime_fast(n) {\n        return true;\n    }\n \
    \   let mut primes = vec![n];\n    let mut is_prime = true;\n    while is_prime\
    \ && primes.len() > 0 {\n        let last = primes.pop();\n        for i in 2..last.cmp(&last)\
    \ {\n            if primes.contains(&i) {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n    }\n    is_prime\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_fast` in this scope\n  -->\
    \ /tmp/tmpc8qei_6o.rs:17:8\n   |\n17 |     if is_prime_fast(n) {\n   |       \
    \ ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc8qei_6o.rs:24:21\n   |\n24 |         for i in 2..last.cmp(&last) {\n\
    \   |                     ^^^^^^^^^^^^^^^ expected integer, found enum `std::cmp::Ordering`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // First check all the prime numbers up to sqrt(n).\n\
    \    for p in 2..n {\n        if n % p == 0 {\n            return false;\n   \
    \     }\n    }\n    // No prime numbers found for n \u2264 sqrt(n).\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6f9hg5y6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7h2kak61.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822365
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    let mut b = true;\n    while i <=\
    \ n {\n        if n % i == 0 {\n            b = false;\n        }\n        i +=\
    \ 1;\n    }\n    b\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpswpog30p.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::{max, min};\n\n    // if n is 1 then we're\
    \ already prime\n    if n == 1 {\n        return true;\n    }\n    // we only\
    \ need to check odd numbers\n    if n & 1 != 0 {\n        return false;\n    }\n\
    \n    // loop over all the known primes from 3 to n-1\n    let mut m: isize =\
    \ 3;\n    while m <= n {\n        // test m's primality by dividing it by all\
    \ known primes from 3 to n-1\n        if n % m == 0 {\n            return false;\n\
    \        }\n        if m > n / 2 {\n            // m is too small to be a prime\n\
    \            return false;\n        }\n        m += 2;\n    }\n\n    // we've\
    \ proven all the numbers are prime\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpir6zm1y3.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 2 && (n % 6 == 0 || n % 11 == 0)\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppb_p6zkc.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // Primes are of the form 6k +/- 1.\n    let mut prime\
    \ = n / 6;\n\n    while prime % 2 == 0 {\n        prime /= 2;\n    }\n\n    //\
    \ Any number greater than 3 will have the form:\n    //     2k + 1 +/- 2\n   \
    \ // and must be divisible by 3, so 2 is the smallest number to\n    // try (since\
    \ 2 has 3 divisors we can start from 3).\n    prime /= 3;\n\n    // All even numbers\
    \ have an even number of divisors\n    // to test against.  Since 2 is the smallest\
    \ number to\n    // test against, 2 is the only even number that's\n    // prime\
    \ as of yet.\n    if n % 2 == 0 {\n        return false;\n    }\n\n    prime ==\
    \ 2\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplse20way.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime = true;\n    for i in 2..n {\n        if\
    \ n % i == 0 {\n            prime = false;\n        }\n    }\n    prime\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq804r23e.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 1;\n    loop {\n        if n % i == 0 {\n\
    \            return false;\n        }\n        i += 1;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm9cjb6w3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..n)\n        .filter_map(|x| {\n            if n &\
    \ (1 << x) == 0 {\n                Some(false)\n            } else {\n       \
    \         Some(true)\n            }\n        })\n        .any(|x| x)\n}\n\nfn\
    \ main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoex9uqo7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n >= 2);\n    if n == 1 {\n        return false;\n\
    \    }\n    for i in 2..=n {\n        if n % i == 0 {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1c8w3mxl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n < 2\n        || (2..n).any(|k| n % k == 0)\n}\n\nfn\
    \ main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc8kruvl1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 || n <= 3 {\n        return false;\n    }\n\n\
    \    let mut n_i = 2;\n    while n_i <= n {\n        if n % n_i == 0 {\n     \
    \       return false;\n        }\n        n_i += 1;\n    }\n\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmperkli8ry.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n != 1 && &n > &(PRIME_TABLE.len() - 1) && n % PRIME_TABLE[&n\
    \ - 1] == 0\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `PRIME_TABLE` in this scope\n  --> /tmp/tmpdg2m397j.rs:17:22\n\
    \   |\n17 |     n != 1 && &n > &(PRIME_TABLE.len() - 1) && n % PRIME_TABLE[&n\
    \ - 1] == 0\n   |                      ^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `PRIME_TABLE` in this scope\n  --> /tmp/tmpdg2m397j.rs:17:52\n\
    \   |\n17 |     n != 1 && &n > &(PRIME_TABLE.len() - 1) && n % PRIME_TABLE[&n\
    \ - 1] == 0\n   |                                                    ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    fn check(i: usize, mut j: usize) -> bool {\n        if\
    \ j <= i {\n            return false;\n        }\n\n        let mut j2 = j + 2;\n\
    \        loop {\n            if j2 > i {\n                return j2 % i == 0;\n\
    \            }\n            if j2 == i {\n                return j % i == 0;\n\
    \            }\n            j += 1; j2 += 1;\n        }\n    }\n\n    if n < 2\
    \ {\n        return false;\n    }\n    if n == 2 {\n        return true;\n   \
    \ }\n\n    let mut i: usize = n / 2;\n    while i > 1 && !check(i, n - 1) {\n\
    \        i -= 1;\n    }\n\n    if i == 1 {\n        return check(i, 1);\n    }\n\
    \n    check(i, n - 1);\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgz533b54.rs:41:24\n   |\n\
    41 |     let mut i: usize = n / 2;\n   |                -----   ^^^^^ expected\
    \ `usize`, found `isize`\n   |                |\n   |                expected\
    \ due to this\n   |\nhelp: you can convert an `isize` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n41 |     let mut i: usize = (n / 2).try_into().unwrap();\n\
    \   |                        +     +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgz533b54.rs:42:30\n   |\n42 |     while i > 1 && !check(i,\
    \ n - 1) {\n   |                              ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n42 |     while i > 1 && !check(i, (n - 1).try_into().unwrap())\
    \ {\n   |                              +     +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgz533b54.rs:50:14\n   |\n50 |     check(i, n\
    \ - 1);\n   |              ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n50 |     check(i, (n - 1).try_into().unwrap());\n   |           \
    \   +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgz533b54.rs:16:26\n\
    \   |\n16 | fn is_prime(n: isize) -> bool {\n   |    --------              ^^^^\
    \ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n50 |     check(i, n - 1);\n  \
    \ |                    - help: remove this semicolon\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n != 1 && n % 6 == 0 &&\n    ![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].contains(&n)\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwj4u53fm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut prime_bits = vec![false, false, false];\n\n  \
    \  for &b in prime_bits.iter_mut() {\n        if n % b == 0 {\n            *b\
    \ = true;\n            return false;\n        }\n    }\n\n    // We know that\
    \ n cannot be a prime because of the for loop.\n    // If this case is not hit\
    \ then n must be prime.\n    *n = true;\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphx0mbcfo.rs:19:9\n   |\n\
    19 |     for &b in prime_bits.iter_mut() {\n   |         ^^    ---------------------\
    \ this expression has type `Option<&mut bool>`\n   |         |\n   |         types\
    \ differ in mutability\n   |         help: you can probably remove the explicit\
    \ borrow: `b`\n   |\n   = note: expected mutable reference `&mut bool`\n     \
    \                 found reference `&_`\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmphx0mbcfo.rs:28:5\n   |\n28 |     *n = true;\n  \
    \ |     ^^\n   |\nhelp: parentheses are required to parse this as an expression\n\
    \   |\n19 ~     (for &b in prime_bits.iter_mut() {\n20 |         if n % b == 0\
    \ {\n21 |             *b = true;\n22 |             return false;\n23 |       \
    \  }\n24 ~     })\n   |\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // Start with i=2\n    while i * i <= n\
    \ { // Keep looping till we reach the square root of n\n        if n % i == 0\
    \ {\n            return false; // Not prime\n        }\n        i += 1;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3z0bnx3u.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::Ordering;\n    use std::collections::HashSet;\n\
    \    let mut s = HashSet::new();\n    if n < 2 {\n        return false;\n    }\n\
    \    let mut root = n;\n    while root < 2 {\n        root = root * 3 % n;\n \
    \       s.add(root as isize);\n    }\n    for n in s.keys() {\n        if *n %\
    \ n == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpv7yp5c57.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `add` found for struct `HashSet` in the current scope\n  --> /tmp/tmpv7yp5c57.rs:26:11\n\
    \   |\n26 |         s.add(root as isize);\n   |           ^^^ method not found\
    \ in `HashSet<_>`\n\nerror[E0599]: no method named `keys` found for struct `HashSet`\
    \ in the current scope\n  --> /tmp/tmpv7yp5c57.rs:28:16\n   |\n28 |     for n\
    \ in s.keys() {\n   |                ^^^^ method not found in `HashSet<_>`\n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008981
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // special cases\n    if n == 0 || n == 1 {\n        return\
    \ false;\n    }\n\n    // check divisibility by primes up to the square root of\
    \ n\n    let mut i = 2; i <= n as usize; i++ {\n        if n % i == 0 {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgz6w286x.rs:23:38\n\
    \   |\n23 |     let mut i = 2; i <= n as usize; i++ {\n   |                  \
    \                    ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n23 |     let mut i = 2; i <= n as usize; { let tmp = i; i += 1; tmp } {\n\
    \   |                                     +++++++++++  ~~~~~~~~~~~~~~~\n23 - \
    \    let mut i = 2; i <= n as usize; i++ {\n23 +     let mut i = 2; i <= n as\
    \ usize; i += 1 {\n   | \n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let mut\
    \ i = n;\n    while i > 1 && i % 2 == 0 {\n        i = i / 2;\n    }\n    for\
    \ i in 2..=n {\n        if i % i == 0 {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm7305akq.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    for i in\
    \ 2..n / 2 {\n        if n % i == 0 {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n  \
    \  assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfw3nug5t.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime_checker(n) == 1 {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n \
    \   assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_checker` in this scope\n \
    \ --> /tmp/tmpfzjtg436.rs:17:8\n   |\n17 |     if is_prime_checker(n) == 1 {\n\
    \   |        ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7h2kak61.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822365
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    let mut remain = n;\n    loop {\n\
    \        while remain % i == 0 {\n            remain /= i;\n            i += 1;\n\
    \        }\n        i += 1;\n        if remain == 1 {\n            break;\n  \
    \      }\n    }\n    remain > 1\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpetai3llt.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if is_prime_iter(n) {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_iter` in this scope\n  -->\
    \ /tmp/tmppje9s1tl.rs:17:8\n   |\n17 |     if is_prime_iter(n) {\n   |       \
    \ ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    assert!(n > 2);\n    (1..n).all(|i| n % i == 0)\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphm_ps6gn.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n % 2 == 0 || is_prime(n - 2) == 0\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9t6d219g.rs:17:38\n   |\n\
    17 |     n % 2 == 0 || is_prime(n - 2) == 0\n   |                            \
    \          ^ expected `bool`, found integer\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n % 2 == 1 || n % 3 == 0 || is_divisible_by(n, 2)\n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_divisible_by` in this scope\n  -->\
    \ /tmp/tmp2l96r8ux.rs:17:33\n   |\n17 |     n % 2 == 1 || n % 3 == 0 || is_divisible_by(n,\
    \ 2)\n   |                                 ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n > 1 && (n % 2) == 0 && (3 * n + 1) == (n as u32)\n}\n\
    \nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppl91p_mb.rs:17:45\n   |\n\
    17 |     n > 1 && (n % 2) == 0 && (3 * n + 1) == (n as u32)\n   |            \
    \                                 ^^^^^^^^^^ expected `isize`, found `u32`\n \
    \  |\nhelp: you can convert a `u32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |     n > 1 && (n % 2) == 0 && (3 * n + 1) == ((n as u32)).try_into().unwrap()\n\
    \   |                                             +          +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 || n % 2 == 0 {\n        return false;\n    }\n\
    \n    for &d in &primes {\n        if d == n {\n            return true;\n   \
    \     }\n\n        if n % d == 0 {\n            return false;\n        }\n   \
    \ }\n\n    for &d in &primes {\n        if n % d == 0 {\n            return false;\n\
    \        }\n    }\n\n    let mut m = n - 1;\n    let mut s = 1;\n\n    while m\
    \ % 2 == 0 {\n        m /= 2;\n        s += 1;\n    }\n\n    for &d in &primes\
    \ {\n        if m % d == 0 {\n            return false;\n        }\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmpl7nl_21a.rs:21:16\n\
    \   |\n21 |     for &d in &primes {\n   |                ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmpl7nl_21a.rs:31:16\n\
    \   |\n31 |     for &d in &primes {\n   |                ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmpl7nl_21a.rs:45:16\n\
    \   |\n45 |     for &d in &primes {\n   |                ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i: isize = 1;\n    while i <= sqrt(n) {\n    \
    \    if n % i == 0 {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmp5t7no6zj.rs:18:16\n\
    \   |\n18 |     while i <= sqrt(n) {\n   |                ^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n   \
    \ return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsjzkk8mu.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008866
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = n;\n    while i <= (n - 2) {\n        if n\
    \ % i == 0 {\n            return false;\n        }\n        i = i * 3 + (n - i);\n\
    \    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprqnjxmk2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2; // 2 is prime\n    while i <= n {\n   \
    \     if n % i == 0 {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpun0tho_1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 1 {\n        return false;\n    }\n    if n %\
    \ 2 == 0 {\n        return false;\n    }\n    match primes.binary_search(&(n-1))\
    \ {\n        None => return false,\n        Some(i) => if n % i == 0 {\n     \
    \       return false;\n        },\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmp9my5nptz.rs:23:11\n\
    \   |\n23 |     match primes.binary_search(&(n-1)) {\n   |           ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n >= 2 && is_prime_rec(n - 2, n - 1)\n}\n\nfn main() {\n\
    \    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_rec` in this scope\n  -->\
    \ /tmp/tmpj3g48ptj.rs:17:15\n   |\n17 |     n >= 2 && is_prime_rec(n - 2, n -\
    \ 1)\n   |               ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        return true;\n    }\n\n    let mut\
    \ m = n;\n    while m % 2 == 0 {\n        m /= 2;\n    }\n    let mut b = 2;\n\
    \    while b * b <= m {\n        if m % b == 0 {\n            return false;\n\
    \        }\n        b += 2;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjgp9zwdk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n < 2 || n % 2 == 1 {\n        return false;\n    }\n\
    \n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      return false;\n        }\n        i += 1;\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgd472ee3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    use std::cmp::{Eq, Greater};\n    use std::cmp::Ordering;\n\
    \n    if n < 2 {\n        true\n    } else {\n        for &rest in &[(n - 1)..]\
    \ {\n            if rest < 2 {\n                continue;\n            }\n\n \
    \           let factors = (0..n).filter(|&i| i % rest == 0);\n            if factors.count()\
    \ > 0 && factors.count() < n {\n                return false;\n            }\n\
    \        }\n\n        true\n    }\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0603]: variant `Greater` is private\n  --> /tmp/tmp5l_pg8ik.rs:17:24\n\
    \   |\n17 |     use std::cmp::{Eq, Greater};\n   |                        ^^^^^^^\
    \ private variant\n   |\nnote: the variant `Greater` is defined here\n\nwarning:\
    \ unused import: `Eq`\n  --> /tmp/tmp5l_pg8ik.rs:17:20\n   |\n17 |     use std::cmp::{Eq,\
    \ Greater};\n   |                    ^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nwarning: the item `Eq` is imported redundantly\n   --> /tmp/tmp5l_pg8ik.rs:17:20\n\
    \    |\n17  |     use std::cmp::{Eq, Greater};\n    |                    ^^\n\n\
    warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp5l_pg8ik.rs:18:9\n\
    \   |\n18 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n\nerror[E0369]:\
    \ binary operation `<` cannot be applied to type `RangeFrom<isize>`\n  --> /tmp/tmp5l_pg8ik.rs:24:21\n\
    \   |\n24 |             if rest < 2 {\n   |                ---- ^ - {integer}\n\
    \   |                |\n   |                RangeFrom<isize>\n\nerror[E0277]:\
    \ cannot mod `isize` by `RangeFrom<isize>`\n  --> /tmp/tmp5l_pg8ik.rs:28:48\n\
    \   |\n28 |             let factors = (0..n).filter(|&i| i % rest == 0);\n   |\
    \                                                ^ no implementation for `isize\
    \ % RangeFrom<isize>`\n   |\n   = help: the trait `Rem<RangeFrom<isize>>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n\
    \             <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n  \
    \           <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n      \
    \       <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n        \
    \   and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5l_pg8ik.rs:29:57\n\
    \   |\n29 |             if factors.count() > 0 && factors.count() < n {\n   |\
    \                                                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n29 |             if factors.count()\
    \ > 0 && fac"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut s = n;\n    loop {\n        if s <= 1 {\n    \
    \        return true;\n        }\n        if s % 2 == 0 {\n            return\
    \ false;\n        }\n        s /= 2;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfeqnfxdy.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // Prime numbers have two factors: 1 and itself.\n   \
    \ if n < 2 {\n        return n == 1;\n    }\n\n    let mut i = 2;\n\n    // If\
    \ n is even, i must be even, too, so skip even values.\n    while i < n && n %\
    \ i == 0 {\n        i += 2;\n    }\n\n    if i == n {\n        return true;\n\
    \    }\n\n    // The loop will terminate when i is less than or equal to n.\n\
    \    while i < n {\n        // Check if i divides n. If it doesn't, then n is\
    \ not prime.\n        if n % i == 0 {\n            return false;\n        }\n\n\
    \        // If i divides n, then we know that all smaller factors of i are also\n\
    \        // prime (since all smaller factors are also a power of i).\n       \
    \ i += 2;\n    }\n\n    // If n is a power of 2, then n is prime.\n    if n <=\
    \ 1 {\n        return true;\n    }\n\n    // The loop will terminate when i is\
    \ less than or equal to n.\n    while i < n {\n        // Check if i divides n.\n\
    \        if n % i == 0 {\n            return false;\n        }\n\n        // If\
    \ i divides n, then we know that all smaller factors of i are also\n        //\
    \ prime (since all smaller factors are also a power of i).\n        i += 2;\n\
    \    }\n\n    // Since i reached n, n is a composite number.\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn6j87mpp.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n >= 2\n        && ((2..n).any(|&x| n % x == 0))\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9clterq.rs:18:25\n   |\n\
    18 |         && ((2..n).any(|&x| n % x == 0))\n   |                         ^--\n\
    \   |                         ||\n   |                         |expected due to\
    \ this\n   |                         expected `isize`, found reference\n   | \
    \                        help: did you mean `x`: `&isize`\n   |\n   = note:  \
    \ expected type `isize`\n           found reference `&_`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    fn check(i: isize) -> bool {\n        if i % 2 == 0 {\n\
    \            return false;\n        }\n        for i in 2..(i * 2) {\n       \
    \     if i % n == 0 {\n                return false;\n            }\n        }\n\
    \        true\n    }\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19];\n\
    \    for i in 2..(n / 2) {\n        if check(i - 1) {\n            return false;\n\
    \        }\n    }\n    for i in primes.iter_mut() {\n        if check(i as isize)\
    \ == false {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmp6mf_p33d.rs:22:20\n\
    \   |\n22 |             if i % n == 0 {\n   |                    ^\n   |\n   =\
    \ help: use the `|| { ... }` closure form instead\n\nerror[E0606]: casting `&mut\
    \ i32` as `isize` is invalid\n  --> /tmp/tmp6mf_p33d.rs:35:18\n   |\n35 |    \
    \     if check(i as isize) == false {\n   |                  -^^^^^^^^^\n   |\
    \                  |\n   |                  cannot cast `&mut i32` as `isize`\n\
    \   |                  help: dereference the expression: `*i`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0434, E0606.\n\
    For more information about an error, try `rustc --explain E0434`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut i = 2;\n    while i * i < n && i * i != n {\n\
    \        i = i * i;\n    }\n    let mut j = 0;\n    while n > j + i {\n      \
    \  j = j + i;\n    }\n    n > j + i\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppw4m5o8g.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // The Sieve of Eratosthenes is used for finding primes.\n\
    \    // It is computationally efficient but also quite slow so it\n    // is avoided\
    \ for prime checking.\n    if n < 2 {\n        return false;\n    }\n\n    let\
    \ mut sieve: [bool; 2..n + 1] = [true; 2..n + 1];\n\n    // First element in the\
    \ sieve is always true\n    sieve[0] = true;\n    // Sieve primes starting from\
    \ second element.\n    for i in 1..n {\n        // If i is prime then mark multiples\
    \ of i as false.\n        // if sieve[i] {\n        // sieve[i * i ..]\n     \
    \   //    += false\n        // }\n        if sieve[i] {\n            for j in\
    \ i*i..n {\n                sieve[j] = false;\n            }\n        }\n    }\n\
    \n    // Return true if number is prime, otherwise false.\n    sieve[0]\n}\n\n\
    fn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp834gzkn5.rs:24:30\n   |\n16 | fn is_prime(n: isize) -> bool {\n   |\
    \             - this would need to be a `const`\n...\n24 |     let mut sieve:\
    \ [bool; 2..n + 1] = [true; 2..n + 1];\n   |                              ^\n\n\
    error[E0435]: attempt to use a non-constant value in a constant\n  --> /tmp/tmp834gzkn5.rs:24:49\n\
    \   |\n16 | fn is_prime(n: isize) -> bool {\n   |             - this would need\
    \ to be a `const`\n...\n24 |     let mut sieve: [bool; 2..n + 1] = [true; 2..n\
    \ + 1];\n   |                                                 ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp834gzkn5.rs:24:27\n   |\n24 |     let mut sieve:\
    \ [bool; 2..n + 1] = [true; 2..n + 1];\n   |                           ^^^^^^^^\
    \ expected `usize`, found struct `std::ops::Range`\n   |\n   = note: expected\
    \ type `usize`\n            found struct `std::ops::Range<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp834gzkn5.rs:24:46\n   |\n24 |     let mut sieve:\
    \ [bool; 2..n + 1] = [true; 2..n + 1];\n   |                                 \
    \             ^^^^^^^^ expected `usize`, found struct `std::ops::Range`\n   |\n\
    \   = note: expected type `usize`\n            found struct `std::ops::Range<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0435.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..n).all(|i| n % i == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpibjoawd8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    (1..(n/2)).all(|n| n % 2 == 0 || n % 3 == 0)\n}\n\nfn\
    \ main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n\
    \    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n\
    \    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3rbb8_hu.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // We need to use bit shifting here to speed things up\n\
    \    // slightly. See the blog post at\n    // http://blog.stevenlevithan.com/archives/faster-number-is-prime-number-check\n\
    \    if n == 1 {\n        return false;\n    }\n\n    let mut i = 2;\n    while\
    \ i * i < n {\n        if n % i == 0 {\n            return false;\n        }\n\
    \        i += 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu9127hu2.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n < 2 || n == 1 || *is_prime_cache[n]\n}\n\nfn main()\
    \ {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n   \
    \ assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n  \
    \  assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n\
    \    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `is_prime_cache` in this scope\n  --> /tmp/tmpsgtjk7r_.rs:17:25\n\
    \   |\n17 |     n < 2 || n == 1 || *is_prime_cache[n]\n   |                  \
    \       ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n < 2 || n % 2 == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzriqtdcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    // Return true if the number is 1 or divisible by 1.\n\
    \    if n <= 1 { true } else if n % 2 == 0 {\n        false\n    } else {\n  \
    \      // Since n is even, it is guaranteed that n is prime.  \n        // If\
    \ n is not prime, the only even number that is > 2 is the number 5.\n        let\
    \ mut i = 2;\n        while i <= n {\n            if n % i == 0 {\n          \
    \      false\n            }\n            i += 2;\n        }\n        true\n  \
    \  }\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuenlbkhd.rs:26:17\n   |\n\
    25 | /             if n % i == 0 {\n26 | |                 false\n   | |     \
    \            ^^^^^ expected `()`, found `bool`\n27 | |             }\n   | |_____________-\
    \ expected this to be `()`\n   |\nhelp: you might have meant to return this value\n\
    \   |\n26 |                 return false;\n   |                 ++++++      +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 101
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    let mut m = 2;\n    while (m * m <= n) {\n        if n\
    \ % m == 0 {\n            return false;\n        }\n        m += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6),\
    \ false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11),\
    \ true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61),\
    \ true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n\
    \    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n \
    \   assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n\
    \    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz1ocwdz3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    n.is_prime()\n}\n\nfn main() {\n    let candidate = is_prime;\n\
    \    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n\
    \    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n\
    \    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpp4z5dtbm.rs:17:7\n   |\n17 |     n.is_prime()\n\
    \   |       ^^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008982
- exit_code: 1
  program: "/// Return true if a given number is prime, and false otherwise.\n///\
    \ >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n\
    /// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n\
    /// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n:\
    \ isize) -> bool {\n    if n == 2 {\n        return true\n    }\n    let mut f\
    \ = n::div::<i32>();\n    if n == f {\n        return true\n    }\n    while f\
    \ > 1 {\n        if n % f == 0 {\n            return false\n        }\n      \
    \  f = f.checked_div::<i32>()?;\n    }\n    return true\n}\n\nfn main() {\n  \
    \  let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101),\
    \ true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441),\
    \ true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n\
    \    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n \
    \   assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n \
    \   assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n\
    \    assert_eq!(candidate(255379), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `n`\n\
    \  --> /tmp/tmp11d7817u.rs:20:17\n   |\n20 |     let mut f = n::div::<i32>();\n\
    \   |                 ^ use of undeclared crate or module `n`\n\nerror[E0107]:\
    \ this associated function takes 0 generic arguments but 1 generic argument was\
    \ supplied\n  --> /tmp/tmp11d7817u.rs:28:15\n   |\n28 |         f = f.checked_div::<i32>()?;\n\
    \   |               ^^^^^^^^^^^------- help: remove these generics\n   |     \
    \          |\n   |               expected 0 generic arguments\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp11d7817u.rs:28:15\n\
    \    |\n28  |         f = f.checked_div::<i32>()?;\n    |               ^^^^^^^^^^^-------\
    \ supplied 0 arguments\n    |               |\n    |               expected 1\
    \ argument\n    |\nnote: associated function defined here\n    = note: this error\
    \ originates in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmp11d7817u.rs:28:35\n   |\n16 | / fn is_prime(n: isize) -> bool {\n\
    17 | |     if n == 2 {\n18 | |         return true\n19 | |     }\n...  |\n28 |\
    \ |         f = f.checked_div::<i32>()?;\n   | |                             \
    \      ^ cannot use the `?` operator in a function that returns `bool`\n29 | |\
    \     }\n30 | |     return true\n31 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>`\
    \ is not implemented for `bool`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0107, E0277, E0433.\nFor more\
    \ information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660008982
