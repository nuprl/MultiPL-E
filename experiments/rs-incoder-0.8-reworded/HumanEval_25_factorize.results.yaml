language: rs
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\
    \    let mut primes_count = primes.len();\n    let mut factorization = vec![vec![1];\
    \ primes_count];\n    for f in factorization.iter_mut() {\n        f.push(1);\n\
    \    }\n    loop {\n        let mut next_prime = primes.iter().rev().next().unwrap();\n\
    \        for f in factorization.iter_mut() {\n            if f.len() == primes_count\
    \ {\n                return f;\n            }\n            for _ in 0..f.len()\
    \ {\n                if f[f[0]] == next_prime {\n                    f[0] += 1;\n\
    \                    f[f[0]] = 1;\n                    break;\n              \
    \  }\n            }\n        }\n        primes.push(next_prime);\n        factorization[primes.len()\
    \ - 1].push(1);\n    }\n}\n\nfn main() {\n    let candidate = factorize;\n   \
    \ assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwodi035.rs:21:24\n   |\n\
    21 |                 return f;\n   |                        ^- help: try using\
    \ a conversion method: `.to_vec()`\n   |                        |\n   |      \
    \                  expected struct `Vec`, found mutable reference\n   |\n   =\
    \ note:         expected struct `Vec<isize>`\n           found mutable reference\
    \ `&mut Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwodi035.rs:24:31\n\
    \   |\n24 |                 if f[f[0]] == next_prime {\n   |                 \
    \              ^^^^^^^^^^ expected `usize`, found reference\n   |\n   = note:\
    \   expected type `usize`\n           found reference `&_`\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |                 if f[f[0]] == *next_prime {\n   |   \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwodi035.rs:31:21\n\
    \   |\n31 |         primes.push(next_prime);\n   |                     ^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |\n   |                     cyclic type of infinite size\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![0;\
    \ n];\n    let mut factorization = factorization(n);\n    for &(factor) in factorization.iter()\
    \ {\n        if factor == 1 {\n            factors[0] += 1;\n        } else {\n\
    \            let mut new_factors = factors.clone();\n            for i in 0..factor\
    \ - 1 {\n                new_factors[i] = new_factors[i] + 1;\n            }\n\
    \            factors = new_factors;\n        }\n    }\n    return factors;\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpw1lv783u.rs:12:29\n   |\n12 |     let mut factorization = factorization(n);\n\
    \   |                             ^^^^^^^^^^^^^ not found in this scope\n\nwarning:\
    \ unnecessary parentheses around pattern\n  --> /tmp/tmpw1lv783u.rs:13:10\n  \
    \ |\n13 |     for &(factor) in factorization.iter() {\n   |          ^      ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n13 -     for &(factor) in factorization.iter() {\n13 +     for &factor\
    \ in factorization.iter() {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1lv783u.rs:11:31\n\
    \   |\n11 |     let mut factors = vec![0; n];\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut factors = vec![0; n.try_into().unwrap()];\n   |                        \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![n];\n\
    \    let mut current = 1;\n\n    while current <= n {\n        for factor_index\
    \ in 1..=factors.len() {\n            if n % current == 0 {\n                factors[factor_index]\
    \ += 1;\n                if factors[factor_index] > current {\n              \
    \      break;\n                }\n                current = current * factors[factor_index];\n\
    \            }\n        }\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpnfo2d0f2.rs:17:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factorization\
    \ = Vec::new();\n    let mut i = 1;\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            prime_factorization.push(i);\n            i += 1;\n    \
    \    }\n    }\n    prime_factorization\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmp69elfunx.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut n = n as isize;\n    let mut k = 1;\n\n    while n > 1 {\n      \
    \  if n % k == 0 {\n            n /= k;\n            factors.push(k);\n      \
    \  }\n        k *= 2;\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[2]`', /tmp/tmp03s5yhlz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = vec![1usize;\
    \ n];\n    let mut f = 1usize;\n    let mut p = 1;\n    while p != n {\n     \
    \   if p % f == 0 {\n            p *= f;\n        } else {\n            if p >\
    \ n {\n                return Vec::new();\n            }\n            f *= p;\n\
    \            result[p] = 1;\n            p *= f;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgv39uk5e.rs:11:35\n   |\n\
    11 |     let mut result = vec![1usize; n];\n   |                             \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut result = vec![1usize; n.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgv39uk5e.rs:15:16\n   |\n15 |         if p % f == 0 {\n   |        \
    \        ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize`\
    \ by `usize`\n  --> /tmp/tmpgv39uk5e.rs:15:14\n   |\n15 |         if p % f ==\
    \ 0 {\n   |              ^ no implementation for `isize % usize`\n   |\n   = help:\
    \ the trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgv39uk5e.rs:16:18\n   |\n16 |             p *= f;\n   |\
    \                  ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply-assign\
    \ `isize` by `usize`\n  --> /tmp/tmpgv39uk5e.rs:16:15\n   |\n16 |            \
    \ p *= f;\n   |               ^^ no implementation for `isize *= usize`\n   |\n\
    \   = help: the trait `MulAssign<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `MulAssign<Rhs>`:\n        \
    \     <f32 as MulAssign<&f32>>\n             <f32 as MulAssign>\n            \
    \ <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n             <i128\
    \ as MulAssign<&i128>>\n             <i128 as MulAssign>\n             <i16 as\
    \ MulAssign<&i16>>\n             <i16 as MulAssign>\n           and 20 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgv39uk5e.rs:21:18\n   |\n21 |\
    \             f *"
  stdout: ''
  timestamp: 1659976133
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![n];\n\
    \    for i in 2..=n {\n        if n % i == 0 {\n            for j in 2..=i {\n\
    \                if i % j == 0 {\n                    primes.push(j);\n      \
    \              break;\n                }\n            }\n        }\n    }\n  \
    \  primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2]`', /tmp/tmpwk3apw7q.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut n = n;\n    while n > 1 {\n        factors.push(n / 2);\n       \
    \ n /= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpiw58mzbf.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: -1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    for i in 1..n {\n        let mut factor = i;\n        let mut ctr = 0;\n\
    \        while factor % i == 0 {\n            factor *= i;\n            ctr +=\
    \ 1;\n        }\n        factors.push(ctr);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut counter = 1;\n    while n != 1 {\n        while n % counter == 0\
    \ {\n            factors.push(counter);\n            n /= counter;\n        }\n\
    \        counter += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgz15y57f.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= counter;\n\
    \   |             ^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    factorize(factors, n, 0);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmp3r115d13.rs:12:5\n   |\n12 |     factorize(factors, n, 0);\n  \
    \ |     ^^^^^^^^^ -------  -  - supplied 3 arguments\n   |     |\n   |     expected\
    \ 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp3r115d13.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    if n <= 1 {\n        return\
    \ vec![1];\n    }\n\n    let mut factors = vec![1];\n    let mut num = 1;\n\n\
    \    while num < n {\n        let mut i = 0;\n        while factors[factors.len()\
    \ - i] == 0 {\n            i += 1;\n        }\n        factors.push(factors[factors.len()\
    \ - i] + 1);\n        num *= 2;\n    }\n\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpm4iqguyy.rs:20:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut vec = vec![0; n];\n\
    \n    // first prime factor\n    let mut p = 2;\n    while p < n {\n        if\
    \ n % p == 0 {\n            vec.push(p);\n            n /= p;\n        } else\
    \ {\n            p++;\n        }\n    }\n\n    while n > 1 {\n        for j in\
    \ 0..vec.len() {\n            if vec[j] == n {\n                vec[j] = 0;\n\
    \                n = 1;\n                break;\n            }\n        }\n  \
    \  }\n\n    vec\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp2irjbwt8.rs:20:14\n\
    \   |\n20 |             p++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n20 |             { let tmp = p; p += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n20 -             p++;\n\
    20 +             p += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2irjbwt8.rs:11:27\n\
    \   |\n11 |     let mut vec = vec![0; n];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut vec = vec![0;\
    \ n.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut res = vec![n];\n\n\
    \    for i in 1 .. n / i {\n        for j in 1 .. i {\n            if n % i ==\
    \ 0 {\n                res[i] += j;\n                n /= i;\n               \
    \ break;\n            }\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp0xkox0l7.rs:13:23\n\
    \   |\n13 |     for i in 1 .. n / i {\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0xkox0l7.rs:16:17\n   |\n16 |  \
    \               res[i] += j;\n   |                 ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime = vec![2, 3,\
    \ 5];\n    let mut prime_factors = vec![2, 3];\n    for i in 2..=n {\n       \
    \ if n % i == 0 {\n            prime += [i];\n        }\n        while i < n {\n\
    \            while i % prime[prime_factors.len() - 1] == 0 {\n               \
    \ prime_factors.push(i);\n                i += prime[prime_factors.len() - 1];\n\
    \            }\n            i += 1;\n        }\n    }\n    prime_factors\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<{integer}>`\n  --> /tmp/tmpj7lfih1n.rs:15:13\n   |\n15 |             prime\
    \ += [i];\n   |             -----^^^^^^^\n   |             |\n   |           \
    \  cannot use `+=` on type `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    for i in 2..=n {\n        if n % i == 0 {\n            let mut nfactors:\
    \ isize = 1;\n            while n % i == 0 {\n                n /= i;\n      \
    \          nfactors += 1;\n            }\n            factors.push(nfactors);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpscoccuqz.rs:16:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n  \
    \          factors.push(factor);\n            n /= factor;\n        } else {\n\
    \            factor *= factor;\n        }\n    }\n    factors.push(1);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp4tiqoxhg.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    if n < 2 {\n        return\
    \ vec![];\n    }\n    let mut f = Vec::new();\n    for _ in 0..n / 2 {\n     \
    \   f.push(n);\n        n = n / 2;\n    }\n    while n > 1 {\n        for _ in\
    \ 0..n / 2 {\n            if n % 2 == 0 {\n                f.push(2);\n      \
    \          n /= 2;\n            }\n        }\n    }\n    f\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp9bmu8y1m.rs:17:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |         n = n / 2;\n\
    \   |         ^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp9bmu8y1m.rs:23:17\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n23 |                 n /= 2;\n  \
    \ |                 ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut n = n as isize;\n\
    \    let mut prime_factors = Vec::new();\n    prime_factors.extend_from_slice(&[\n\
    \        (2..=n as isize).filter(|&x| n % x == 0).cloned()\n    ]);\n    while\
    \ n % 2 == 0 {\n        prime_factors.push((2 as isize));\n        n /= 2;\n \
    \   }\n    let mut sqrt_n = n as isize;\n    while sqrt_n % 2 == 0 {\n       \
    \ prime_factors.push((sqrt_n as isize));\n        sqrt_n /= 2;\n    }\n    for\
    \ p in &prime_factors {\n        for _ in 1..p {\n            n += 1;\n      \
    \  }\n    }\n    prime_factors.rev();\n    prime_factors\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpynev07kt.rs:17:28\n\
    \   |\n17 |         prime_factors.push((2 as isize));\n   |                  \
    \          ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n17 -         prime_factors.push((2 as isize));\n\
    17 +         prime_factors.push(2 as isize);\n   | \n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmpynev07kt.rs:22:28\n   |\n22 |        \
    \ prime_factors.push((sqrt_n as isize));\n   |                            ^  \
    \             ^\n   |\nhelp: remove these parentheses\n   |\n22 -         prime_factors.push((sqrt_n\
    \ as isize));\n22 +         prime_factors.push(sqrt_n as isize);\n   | \n\nerror[E0271]:\
    \ type mismatch resolving `<Filter<RangeInclusive<isize>, [closure@/tmp/tmpynev07kt.rs:14:33:\
    \ 14:48]> as Iterator>::Item == &_`\n    --> /tmp/tmpynev07kt.rs:14:50\n     |\n\
    14   |         (2..=n as isize).filter(|&x| n % x == 0).cloned()\n     |     \
    \                                             ^^^^^^ expected reference, found\
    \ `isize`\n     |\n     = note: expected reference `&_`\n                    \
    \ found type `isize`\nnote: required by a bound in `cloned`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpynev07kt.rs:17:28\n   |\n14 |         (2..=n as isize).filter(|&x|\
    \ n % x == 0).cloned()\n   |                                 --------------- the\
    \ expected closure\n...\n17 |         prime_factors.push((2 as isize));\n   |\
    \                            ^^^^^^^^^^^^ expected struct `Cloned`, found `isize`\n\
    \   |\n   = note: expected struct `Cloned<Filter<RangeInclusive<isize>, [closure@/tmp/tmpynev07kt.rs:14:33:\
    \ 14:48]>>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpynev07kt.rs:22:28\n   |\n14 |         (2..=n as isize).filter(|&x|\
    \ n % x == 0).cloned()\n   |                                 --------------- the\
    \ expected closure\n...\n22 |         prime_factors.push((sqrt_n as isize));\n\
    \   |                            ^^^^^^^^^^^^^^^^^ expected struct `Cloned`, found\
    \ `isize`\n   |\n   = note: ex"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![factor(n),\
    \ 1];\n    for i in 1..=&factors[-1] {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            factors.append(factor(n / i));\n        }\n    }\n    factors\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factor` in this scope\n  --> /tmp/tmp2d9hrdq5.rs:11:28\n\
    \   |\n11 |     let mut factors = vec![factor(n), 1];\n   |                  \
    \          ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `factor` in this scope\n  --> /tmp/tmp2d9hrdq5.rs:15:28\n   |\n15 |        \
    \     factors.append(factor(n / i));\n   |                            ^^^^^^ help:\
    \ a local variable with a similar name exists: `factors`\n\nerror: negative integers\
    \ cannot be used to index on a `Vec<_, _>`\n  --> /tmp/tmp2d9hrdq5.rs:12:27\n\
    \   |\n12 |     for i in 1..=&factors[-1] {\n   |                           ^^\
    \ cannot use a negative integer for indexing on `Vec<_, _>`\n   |\nhelp: to access\
    \ an element starting from the end of the `Vec<_, _>`, compute the index\n   |\n\
    12 |     for i in 1..=&factors[factors.len() -1] {\n   |                     \
    \      +++++++++++++\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    factorize::helper(n)\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factorize`\n\
    \  --> /tmp/tmp6nyz07r5.rs:11:5\n   |\n11 |     factorize::helper(n)\n   |   \
    \  ^^^^^^^^^ use of undeclared crate or module `factorize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: -1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![n];\n\
    \    let mut nfactor = 1;\n    loop {\n        while nfactor < factors.len() {\n\
    \            if n % factors[nfactor] == 0 {\n                nfactor += 1;\n \
    \           } else {\n                break;\n            }\n        }\n     \
    \   if nfactor == factors.len() {\n            factors.push(1);\n            nfactor\
    \ = 1;\n        } else {\n            nfactor += 1;\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut counter = HashMap::new();\n\
    \    let mut result = Vec::new();\n    let mut primes = vec![1u8, 2u8, 3u8];\n\
    \n    for i in 1..=n {\n        if counter.contains_key(&i) {\n            let\
    \ count = counter.get_mut(&i).unwrap();\n            count.inc();\n        } else\
    \ {\n            counter.insert(i, 1u8);\n        }\n    }\n\n    while let Some(i)\
    \ = counter.iter().next().unwrap() {\n        let mut j = i;\n        while !counter.contains_key(&j)\
    \ {\n            counter.insert(j, counter.get_mut(&j).unwrap() + 1u8);\n    \
    \        j += i;\n        }\n        result.push(j);\n    }\n\n    result\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp28a2haka.rs:11:23\n   |\n11 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    factorize(n, &mut factors);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpgoy1wv9e.rs:12:5\n   |\n12 |     factorize(n, &mut factors);\n\
    \   |     ^^^^^^^^^ -  ------------ supplied 2 arguments\n   |     |\n   |   \
    \  expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpgoy1wv9e.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = factors_table(n);\n\
    \    let mut vec: Vec<isize> = vec![1isize];\n    while f.len() != 0 {\n     \
    \   vec.push(*f.pop().unwrap());\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors_table` in this scope\n  -->\
    \ /tmp/tmpp1h8m1kf.rs:11:17\n   |\n11 |     let mut f = factors_table(n);\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    if n == 1 {\n        return\
    \ vec![1]\n    }\n    if n == 2 {\n        return vec![2]\n    }\n\n    let mut\
    \ factors = vec![2];\n    let mut a = n / 2;\n    while a > 1 {\n        if n\
    \ % a == 0 {\n            factors += vec![a / 2];\n            a /= 2;\n     \
    \   } else {\n            a /= 2;\n        }\n    }\n\n    if n % 2 == 0 {\n \
    \       factors += vec![2]\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<{integer}>`\n  --> /tmp/tmp_ik2rfpg.rs:22:13\n   |\n22 |             factors\
    \ += vec![a / 2];\n   |             -------^^^^^^^^^^^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `Vec<{integer}>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<{integer}>`\n  -->\
    \ /tmp/tmp_ik2rfpg.rs:30:9\n   |\n30 |         factors += vec![2]\n   |      \
    \   -------^^^^^^^^^^^\n   |         |\n   |         cannot use `+=` on type `Vec<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = vec![0; n];\n\
    \    let mut r = n;\n    let mut p: isize = 1;\n    while r > 1 {\n        let\
    \ q = r.checked_mul(p.clone());\n        r.checked_sub(p);\n        r.checked_sub(q);\n\
    \        f[p] = q;\n        p += 1;\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4u_y9cjg.rs:11:25\n   |\n\
    11 |     let mut f = vec![0; n];\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |     let mut f = vec![0; n.try_into().unwrap()];\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4u_y9cjg.rs:17:23\n   |\n17 |         r.checked_sub(q);\n\
    \   |                       ^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp4u_y9cjg.rs:18:9\n\
    \   |\n18 |         f[p] = q;\n   |         ^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4u_y9cjg.rs:21:5\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n21 |     r\n   |     ^ expected struct `Vec`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut fs = vec![];\n  \
    \  for _ in 0..(n as usize) {\n        let d = n as isize - 1;\n        if d <\
    \ 2 {\n            continue;\n        }\n        let mut i = 2;\n        while\
    \ i * i <= d {\n            if n % i == 0 {\n                d /= i;\n       \
    \         i += 1;\n            }\n            else {\n                break;\n\
    \            }\n        }\n        if d > 1 {\n            i += 1;\n        }\n\
    \        fs.push(i);\n    }\n    fs.iter()\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptk8obked.rs:32:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n32 |     fs.iter()\n   |\
    \     ^^^^^^^^^ expected struct `Vec`, found struct `std::slice::Iter`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut p = n;\n    let mut\
    \ factors = vec![n];\n    while p * p > 1 {\n        let p = p / 2;\n        factors[p]\
    \ += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2nfwkuza.rs:15:9\n\
    \   |\n15 |         factors[p] += 1;\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut fmap = HashMap::new();\n\
    \    let mut factors = vec![];\n    factorize(n / 2, &mut fmap);\n    factorize(n\
    \ - n / 2, &mut fmap);\n    factorize(n, &mut fmap);\n\n    for factor in fmap.keys()\
    \ {\n        factors.push(factor * fmap[factor]);\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxyitgezt.rs:11:20\n   |\n11 |     let mut fmap = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpxyitgezt.rs:13:5\n\
    \   |\n13 |     factorize(n / 2, &mut fmap);\n   |     ^^^^^^^^^ -----  ---------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpxyitgezt.rs:10:4\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpxyitgezt.rs:14:5\n\
    \   |\n14 |     factorize(n - n / 2, &mut fmap);\n   |     ^^^^^^^^^ ---------\
    \  --------- supplied 2 arguments\n   |     |\n   |     expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpxyitgezt.rs:10:4\n   |\n10 |\
    \ fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpxyitgezt.rs:15:5\n\
    \   |\n15 |     factorize(n, &mut fmap);\n   |     ^^^^^^^^^ -  --------- supplied\
    \ 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote: function\
    \ defined here\n  --> /tmp/tmpxyitgezt.rs:10:4\n   |\n10 | fn factorize(n: isize)\
    \ -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::with_capacity(n\
    \ as usize);\n    let mut prime_factors = primes(n as usize);\n    let mut next_factor\
    \ = prime_factors.remove(0);\n    let mut curr_factor = prime_factors.remove(0);\n\
    \    let mut product = 1;\n    while !prime_factors.is_empty() {\n        if n\
    \ % next_factor == 0 {\n            factors.push(next_factor);\n            product\
    \ *= next_factor;\n        }\n        curr_factor = prime_factors.remove(0);\n\
    \        next_factor = curr_factor + 1;\n    }\n    factors.push(product);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes` in this scope\n  --> /tmp/tmp7vckyfc5.rs:12:29\n\
    \   |\n12 |     let mut prime_factors = primes(n as usize);\n   |            \
    \                 ^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 2..n {\n        while n % i == 0 {\n            result.push(i);\n\
    \            n /= i;\n        }\n    }\n    if n > 1 {\n        result.push(n);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdy5ewwae.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = vec![1];\n    let mut current = 1;\n    for i in 2..(n as usize) {\n     \
    \   while n % current == 0 {\n            current += 1;\n        }\n        if\
    \ current > 1 {\n            factors.push(current);\n            current = 1;\n\
    \        }\n    }\n    if current > 1 {\n        factors.push(current);\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpi1_sn3aa.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: -1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factors = Vec::new();\n\
    \    let mut factors = vec![2]; // First factor is equal to two\n    let mut num:\
    \ isize = 0; // To check whether input value is prime or composite\n    let mut\
    \ num_factor: isize = 0; // To store how many times factor appeared\n    let mut\
    \ prev_factor: isize = 0; // To store previous factor\n    let mut check: isize\
    \ = 1; // To check whether number is prime or composite\n    prime_factors.push(2);\
    \ // Add 2 to the vector as it is equal to two\n    while check != n {\n     \
    \   while num % check == 0 {\n            num_factor += 1;\n            prime_factors.push(check);\n\
    \        }\n        prev_factor = factors[0];\n        if num_factor == 0 {\n\
    \            prime_factors.push(check);\n            factors.push(check);\n  \
    \      } else {\n            factors[0] = check;\n            check *= prev_factor;\n\
    \        }\n        if check == n {\n            break;\n        }\n        num\
    \ /= check;\n    }\n    prime_factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    factorize(n as u64, &mut factors);\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpqof44j4z.rs:12:5\n   |\n12 |     factorize(n as u64, &mut factors);\n\
    \   |     ^^^^^^^^^ --------  ------------ supplied 2 arguments\n   |     |\n\
    \   |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpqof44j4z.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976133
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = (n).checked_mul(2).unwrap();\n\
    \    let mut f = f.checked_div(2).unwrap();\n    let mut f = f.checked_div(3).unwrap();\n\
    \    let mut f = f.checked_div(4).unwrap();\n    let mut f = f.checked_div(5).unwrap();\n\
    \    let mut f = f.checked_div(6).unwrap();\n    let mut f = f.checked_div(7).unwrap();\n\
    \    let mut f = f.checked_div(8).unwrap();\n    let mut f = f.checked_div(9).unwrap();\n\
    \    let mut f = f.checked_div(10).unwrap();\n    let mut f = f.checked_div(11).unwrap();\n\
    \    let mut f = f.checked_div(12).unwrap();\n    let mut f = f.checked_div(13).unwrap();\n\
    \    let mut f = f.checked_div(14).unwrap();\n    let mut f = f.checked_div(15).unwrap();\n\
    \    let mut f = f.checked_div(16).unwrap();\n    let mut f = f.checked_div(17).unwrap();\n\
    \    let mut f = f.checked_div(18).unwrap();\n    let mut f = f.checked_div(19).unwrap();\n\
    \    let mut f = f.checked_div(20).unwrap();\n    let mut f = f.checked_div(21).unwrap();\n\
    \    let mut f = f.checked_div(22).unwrap();\n    let mut f = f.checked_div(23).unwrap();\n\
    \    let mut f = f.checked_div(24).unwrap();\n    let mut f = f.checked_div(25).unwrap();\n\
    \    let mut f = f.checked_div(26).unwrap();\n    let mut f = f.checked_div(27).unwrap();\n\
    \    let mut f = f.checked_div(28).unwrap();\n    let mut f = f.checked_div(29).unwrap();\n\
    \    let mut f = f.checked_div(30).unwrap();\n    let mut f = f.checked_div(31).unwrap();\n\
    \    let mut f = f.checked_div(32).unwrap();\n    let mut f = f.checked_div(33).unwrap();\n\
    \    let mut f = f.checked_div(34).unwrap();\n    let mut f = f.checked_div(35).unwrap();\n\
    \    let mut f = f.checked_div(36).unwrap();\n    let mut f = f.checked_div(37).\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpyngmapn5.rs:48:1\n   |\n48\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpyngmapn5.rs:47:35\n\
    \   |\n47 |     let mut f = f.checked_div(37).\n   |                         \
    \          ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyngmapn5.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = vec![n];\n  \
    \  let mut i = 1;\n    while f == vec![n - 1] {\n        let new_f = (f.clone()\
    \ * i).wrapping_mul(2);\n        for _ in 0..f.len() {\n            if f == new_f\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       f.push(new_f);\n    }\n    f.clone_from_slice(&f[1..]);\n    f\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot multiply `Vec<isize>` by `{integer}`\n  --> /tmp/tmpiksfa7dx.rs:14:32\n\
    \   |\n14 |         let new_f = (f.clone() * i).wrapping_mul(2);\n   |       \
    \               --------- ^ - {integer}\n   |                      |\n   |   \
    \                   Vec<isize>\n\nerror[E0277]: can't compare `Vec<isize>` with\
    \ `isize`\n  --> /tmp/tmpiksfa7dx.rs:16:18\n   |\n16 |             if f == new_f\
    \ {\n   |                  ^^ no implementation for `Vec<isize> == isize`\n  \
    \ |\n   = help: the trait `PartialEq<isize>` is not implemented for `Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f: Vec<_> = vec![];\n\
    \    for i in 2..=n {\n        if n % i == 0 {\n            let mut count = 0;\n\
    \            f.clear();\n            for i in 2..=n {\n                if i %\
    \ i == 0 {\n                    count += 1;\n                    f.push(i);\n\
    \                }\n            }\n            if count == 1 {\n             \
    \   f.push(1);\n            }\n        }\n    }\n    f\n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[2]`', /tmp/tmpbg6o2785.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut n = n.clone();\n\
    \    let mut factors = Vec::new();\n    loop {\n        if n%2 == 0 {\n      \
    \      factors.push(2);\n            n /= 2;\n            continue;\n        }\n\
    \n        let mut tmp = 1;\n        let mut n2 = n&1;\n        while n2 != 0 {\n\
    \            tmp *= n2;\n            n2 >>= 1;\n        }\n\n        if n2 ==\
    \ 0 {\n            factors.push(tmp);\n            break;\n        }\n\n     \
    \   let mut n3 = n&3;\n        while n3 != 0 {\n            factors.push(tmp*n3);\n\
    \            n3 >>= 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[2]`', /tmp/tmppsignqs8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \n    let mut is_prime = true;\n\n    for _ in 0..n {\n        if is_prime {\n\
    \            factors.push(n);\n        }\n\n        if is_prime {\n          \
    \  let mut i = 0;\n\n            while i <= n / factors.last() {\n           \
    \     if n % i == 0 {\n                    factors.push(i);\n                \
    \    is_prime = false;\n                    break;\n                }\n\n    \
    \            i += 1;\n            }\n        }\n    }\n\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `isize` by `Option<&isize>`\n  --> /tmp/tmpa6z6fcvy.rs:23:26\n\
    \   |\n23 |             while i <= n / factors.last() {\n   |                \
    \          ^ no implementation for `isize / Option<&isize>`\n   |\n   = help:\
    \ the trait `Div<Option<&isize>>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Div<Rhs>`:\n             <&'a f32 as\
    \ Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n\
    \             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n    \
    \         <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n          \
    \   <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ans = Vec::new();\n\
    \    for i in 2..=n {\n        if n % i == 0 {\n            for j in 2..i {\n\
    \                ans.push(i);\n                ans.push(j);\n            }\n \
    \       }\n    }\n    ans.sort_unstable();\n    ans\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmpf2cneof3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = vec![];\n   \
    \ for i in 2..n {\n        if n % i == 0 {\n            f = f.iter().cloned().collect::<Vec<isize>>().push(i\
    \ as isize);\n            n /= i;\n        }\n    }\n    f.push(n);\n    f\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7a_koeot.rs:14:17\n   |\n\
    11 |     let mut f = vec![];\n   |                 ------ expected due to this\
    \ value\n...\n14 |             f = f.iter().cloned().collect::<Vec<isize>>().push(i\
    \ as isize);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\nnote: method `push` modifies its receiver in-place\n\
    \  --> /tmp/tmp7a_koeot.rs:14:59\n   |\n14 |             f = f.iter().cloned().collect::<Vec<isize>>().push(i\
    \ as isize);\n   |                 ----------------------------------------- ^^^^\
    \ this call modifies its receiver in-place\n   |                 |\n   |     \
    \            you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes: Vec<isize>\
    \ = vec![1];\n    let mut factors = vec![1];\n    let mut q = n;\n    let mut\
    \ counter = 1;\n    let mut prime: isize = 1;\n    while q > 1 {\n        while\
    \ q % prime == 0 {\n            factors.push(counter);\n            primes +=\
    \ factors.clone();\n            counter *= prime;\n            q -= prime as usize;\n\
    \        }\n        prime = 1;\n        counter = 1;\n    }\n    factors.push(counter);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<isize>`\n  --> /tmp/tmpy4aftgt3.rs:19:13\n   |\n19 |             primes\
    \ += factors.clone();\n   |             ------^^^^^^^^^^^^^^^^^^^\n   |      \
    \       |\n   |             cannot use `+=` on type `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy4aftgt3.rs:21:18\n   |\n21 |             q\
    \ -= prime as usize;\n   |                  ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot subtract-assign `usize` from `isize`\n  -->\
    \ /tmp/tmpy4aftgt3.rs:21:15\n   |\n21 |             q -= prime as usize;\n   |\
    \               ^^ no implementation for `isize -= usize`\n   |\n   = help: the\
    \ trait `SubAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n\
    \             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n    \
    \         <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n      \
    \       <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n         \
    \    <i16 as SubAssign>\n           and 20 others\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut res = vec![];\n \
    \   let mut p = 1;\n    for i in 2..=n {\n        while p % i == 0 {\n       \
    \     let mut cnt = 0;\n            while p % i == 0 {\n                cnt +=\
    \ 1;\n                p /= i;\n            }\n            res.push(cnt);\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n  \
    \  assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmpp3g9mnkl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = vec![0; factorization(n)];\n    let mut product = 1;\n    let mut max_counter\
    \ = 1;\n    for i in 0..factors.len() {\n        if factors[i] <= max_counter\
    \ {\n            factors[i] = 0;\n        } else {\n            factors[i] -=\
    \ max_counter;\n            product = product * i;\n        }\n        max_counter\
    \ += factors[i];\n    }\n    factors.push(product);\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpxnmookyd.rs:11:43\n   |\n11 |     let mut factors: Vec<isize> = vec![0;\
    \ factorization(n)];\n   |                                           ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnmookyd.rs:23:18\n\
    \   |\n23 |     factors.push(product);\n   |                  ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |     factors.push(product.try_into().unwrap());\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \n    for i in 2..=n / 2 {\n        while n % i == 0 {\n            factors.push(i);\n\
    \            n /= i;\n        }\n    }\n\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzkqfxpqp.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    use std::cmp::{max, Ordering};\n\
    \    use std::cmp::PartialOrd;\n\n    let mut factors: Vec<isize> = Vec::new();\n\
    \    let mut maxf = n; // maximum number of factors (we ignore them in iteration)\n\
    \    let mut max_factor = n;\n    let mut i = 2;\n    while i <= max_factor {\n\
    \        factors.push(i);\n        max_factor = max_factor * i;\n        i +=\
    \ 1;\n    }\n    let mut max_factor = max_factor;\n    let mut counter = 0;\n\
    \    while i <= max_factor {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            max_factor = max_factor / i;\n            counter += 1;\n       \
    \ }\n        i += 1;\n    }\n\n    if counter == 0 {\n        factors.push(n);\n\
    \    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmp_gd65lf1.rs:20:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![];\n\
    \    let mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ factorization.push(i);\n            i += 1;\n        }\n    }\n\n    factorization\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[2]`', /tmp/tmpjyzonxih.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut v = vec![n];\n  \
    \  let mut counter = 1;\n    let mut is_prime = true;\n\n    for i in 1..n {\n\
    \        if n % i == 0 {\n            v.push(i);\n            counter += 1;\n\
    \        }\n        if counter == 21 && is_prime {\n            break;\n     \
    \   }\n\n        if counter > 21 && !is_prime {\n            break;\n        }\n\
    \n        if counter > 21 && is_prime {\n            is_prime = false;\n     \
    \   }\n    }\n    v\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[2]`', /tmp/tmpe85i_iuu.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \n    // Use simple brute force method because it is easy to calculate nth prime\
    \ with O(n^2)\n    for i in 2..n {\n        if n % i == 0 {\n            result.push(i);\n\
    \            n /= i;\n        }\n    }\n\n    if n > 1 {\n        result.push(n);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp80xepyv1.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut res = vec![0; n];\n\
    \    let mut fac = factorize_inner(n, &mut res);\n    fac\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorize_inner` in this scope\n  -->\
    \ /tmp/tmp2nczmeb0.rs:12:19\n   |\n12 |     let mut fac = factorize_inner(n, &mut\
    \ res);\n   |                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2nczmeb0.rs:11:27\n   |\n11 |     let mut res\
    \ = vec![0; n];\n   |                           ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut res = vec![0; n.try_into().unwrap()];\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    if n <= 1 {\n        return\
    \ vec![];\n    }\n\n    let mut f = vec![1];\n    let mut i = 2;\n    let mut\
    \ p = 1;\n\n    while i < (n / 2) {\n        if n % i == 0 {\n            p *=\
    \ i;\n        }\n\n        i += 1;\n    }\n\n    while p > 1 {\n        if n %\
    \ p == 0 {\n            f = f.push(p);\n            n /= p;\n        }\n\n   \
    \     p += 1;\n    }\n\n    f\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgs4fzc49.rs:29:17\n   |\n\
    15 |     let mut f = vec![1];\n   |                 ------- expected due to this\
    \ value\n...\n29 |             f = f.push(p);\n   |                 ^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for &f in factors() {\n        if n / f == 0 {\n            result.push(*f);\n\
    \            n %= *f;\n        }\n    }\n    result.push(n);\n    result\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmprcak3set.rs:12:15\n\
    \   |\n12 |     for &f in factors() {\n   |               ^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \    let mut counter = 1;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            factorization.push(i);\n            counter += 1;\n\
    \            while counter > 1 {\n                if n % i == 0 {\n          \
    \          counter -= 1;\n                    factorization.push(i);\n       \
    \             i += 1;\n                } else {\n                    i += 1;\n\
    \                }\n            }\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 2]`,\n right: `[2]`', /tmp/tmp96qh0869.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    use num_traits::ToPrimitive;\n\
    \    let mut prime_factors = Vec::new();\n    let mut num: isize = n;\n    let\
    \ mut factor = 1;\n    while num > 1 {\n        if num % 2 == 0 {\n          \
    \  prime_factors.push(2);\n            num = num / 2;\n        } else {\n    \
    \        while num % prime == 0 {\n                prime_factors.push(prime);\n\
    \                num = num / prime;\n            }\n            prime_factors.push(num);\n\
    \            num = num - 1;\n            factor = factor * prime;\n        }\n\
    \    }\n    prime_factors.push(factor);\n    prime_factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `num_traits`\n  --> /tmp/tmpomf27cm_.rs:11:9\n\
    \   |\n11 |     use num_traits::ToPrimitive;\n   |         ^^^^^^^^^^ maybe a\
    \ missing crate `num_traits`?\n\nerror[E0425]: cannot find value `prime` in this\
    \ scope\n  --> /tmp/tmpomf27cm_.rs:20:25\n   |\n20 |             while num % prime\
    \ == 0 {\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `prime` in this scope\n  --> /tmp/tmpomf27cm_.rs:21:36\n \
    \  |\n21 |                 prime_factors.push(prime);\n   |                  \
    \                  ^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `prime` in this scope\n  --> /tmp/tmpomf27cm_.rs:22:29\n   |\n22 |   \
    \              num = num / prime;\n   |                             ^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `prime` in this scope\n\
    \  --> /tmp/tmpomf27cm_.rs:26:31\n   |\n26 |             factor = factor * prime;\n\
    \   |                               ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0432.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![0;\
    \ n];\n    for i in 0..n {\n        if n % i == 0 {\n            factors[i] -=\
    \ 1;\n            n /= i;\n        }\n    }\n    factors\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdxlgfnn5.rs:11:31\n   |\n\
    11 |     let mut factors = vec![0; n];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut factors\
    \ = vec![0; n.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpdxlgfnn5.rs:14:13\n\
    \   |\n14 |             factors[i] -= 1;\n   |             ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \n    for factor in factorization(n) {\n        for _ in 0..factor {\n       \
    \     factors.push(factor);\n        }\n    }\n\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpv2vxn9si.rs:13:19\n   |\n13 |     for factor in factorization(n) {\n\
    \   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \    let mut curr = n as isize;\n    let mut ifac = 0;\n    loop {\n        factorization.push(curr);\n\
    \        if curr == 1 {\n            break;\n        }\n        for i in (1..curr)\
    \ {\n            if i % curr == 0 {\n                ifac++;\n               \
    \ factorization.push(i);\n            }\n        }\n        curr = ifac as isize;\n\
    \        ifac = 0;\n    }\n    factorization\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp4ifmw5fy.rs:21:21\n\
    \   |\n21 |                 ifac++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n21 |                 { let tmp\
    \ = ifac; ifac += 1; tmp };\n   |                 +++++++++++     ~~~~~~~~~~~~~~~~~~\n\
    21 -                 ifac++;\n21 +                 ifac += 1;\n   | \n\nwarning:\
    \ unnecessary parentheses around `for` iterator expression\n  --> /tmp/tmp4ifmw5fy.rs:19:18\n\
    \   |\n19 |         for i in (1..curr) {\n   |                  ^       ^\n  \
    \ |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n19 -         for i in (1..curr) {\n19 +         for i in 1..curr {\n  \
    \ | \n\nerror: aborting due to previous error; 1 warning emitted\n\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    let mut counter = 1;\n    let mut product = 1;\n\n  \
    \  while i <= n {\n        if n % i == 0 {\n            counter = counter * i;\n\
    \            i = i + 1;\n        } else {\n            i += 1;\n        }\n  \
    \  }\n    factors.push(counter);\n\n    while i <= n {\n        factors.push(i\
    \ as isize);\n        product = product * i;\n        i = i + 1;\n    }\n\n  \
    \  factors.push(product);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[2]`', /tmp/tmp4_477uwp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factor = vec![1];\n\
    \    let mut factorization = vec![];\n    for i in 1..n {\n        factorization\
    \ = factorization.clone();\n        for (factor, factors) in factorization {\n\
    \            factor *= i;\n            if factor > i {\n                break;\n\
    \            }\n            factorization.push(factors);\n            factorization.push(factor);\n\
    \        }\n    }\n    factorization.sort();\n    factorization.reverse();\n \
    \   factorization\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx7qh529s.rs:20:32\n   |\n\
    20 |             factorization.push(factors);\n   |                          \
    \      ^^^^^^^ cyclic type of infinite size\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx7qh529s.rs:21:32\n   |\n21 |             factorization.push(factor);\n\
    \   |                                ^^^^^^ cyclic type of infinite size\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx7qh529s.rs:26:5\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n26 |     factorization\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<(_, _)>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    for f in\n        n.iter().cloned().rev()\n            .take(n as usize /\
    \ 2i32).rev()\n            .collect::<Vec<_>>()\n    {\n        factors.push((n,\
    \ f));\n        n /= f;\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpjrsotiid.rs:13:11\n   |\n13 |         n.iter().cloned().rev()\n\
    \   |           ^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjrsotiid.rs:14:32\n   |\n14 |             .take(n as usize / 2i32).rev()\n\
    \   |                                ^^^^ expected `usize`, found `i32`\n\nerror[E0277]:\
    \ cannot divide `usize` by `i32`\n  --> /tmp/tmpjrsotiid.rs:14:30\n   |\n14 |\
    \             .take(n as usize / 2i32).rev()\n   |                           \
    \   ^ no implementation for `usize / i32`\n   |\n   = help: the trait `Div<i32>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjrsotiid.rs:21:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n21 |    \
    \ factors\n   |     ^^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<(isize, _)>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    let mut temp = 1;\n    while temp < n {\n        for mut f in &mut res {\n\
    \            f.insert(f, 1);\n        }\n        let mut cnt = 0;\n        for\
    \ &f in &res {\n            if n % f == 0 {\n                cnt += 1;\n     \
    \           n /= f;\n            }\n        }\n        if cnt > 0 {\n        \
    \    res.push(n);\n        }\n        temp = temp + 1;\n    }\n    if n > 1 {\n\
    \        res.push(n);\n    }\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&mut T`\n  --> /tmp/tmp7cssyct3.rs:14:22\n\
    \   |\n11 |     let mut res = Vec::new();\n   |         ------- consider giving\
    \ `res` the explicit type `&mut T`, where the type parameter `T` is specified\n\
    ...\n14 |         for mut f in &mut res {\n   |                      ^^^^^^^^\
    \ cannot infer type for type parameter `T`\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![1isize;\
    \ n];\n    let mut factor = 0;\n    let mut prime = false;\n    for factor in\
    \ factorization {\n        if n % factor == 0 {\n            factorization.push(factor);\n\
    \            n /= factor;\n            prime = true;\n        }\n    }\n    if\
    \ n > 1 {\n        factorization.push(n);\n        factorization.push(n);\n  \
    \  }\n    if prime {\n        factorization.push(2);\n    }\n    return factorization;\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp04_u_3r_.rs:11:42\n   |\n\
    11 |     let mut factorization = vec![1isize; n];\n   |                      \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut factorization = vec![1isize; n.try_into().unwrap()];\n   |  \
    \                                         ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \n    factorization.reserve(n - 1);\n    for i in 1..n {\n        let mut found\
    \ = false;\n        for factor in &factorization {\n            if i % factor\
    \ == 0 {\n                found = true;\n                break;\n            }\n\
    \        }\n        if !found {\n            factorization.push(i);\n        }\n\
    \    }\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ff8j46o.rs:13:27\n   |\n\
    13 |     factorization.reserve(n - 1);\n   |                           ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |     factorization.reserve((n\
    \ - 1).try_into().unwrap());\n   |                           +     +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n    while i <= n {\n        factors.push(i as isize);\n \
    \       i += *factors;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpfjfx3i6_.rs:15:11\n   |\n15 |         i += *factors;\n\
    \   |           ^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[isize]`\n\nerror[E0277]: cannot add-assign\
    \ `[isize]` to `isize`\n  --> /tmp/tmpfjfx3i6_.rs:15:11\n   |\n15 |         i\
    \ += *factors;\n   |           ^^ no implementation for `isize += [isize]`\n \
    \  |\n   = help: the trait `AddAssign<[isize]>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    for i in 2..=n/2 {\n        if n % i == 0 {\n            factors.push(i as\
    \ isize);\n            factors.push((n / i) as isize);\n        }\n    }\n   \
    \ factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmppfgxymsf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    assert!(n >= 0);\n    assert!(n\
    \ <= isize::max_value());\n    let mut factors = Vec::new();\n    let mut nsqr\
    \ = n * n;\n    while nsqr > 1 {\n        while nsqr >= 1 {\n            factors.push(nsqr);\n\
    \            nsqr = nsqr / 2;\n        }\n        nsqr = nsqr * n;\n    }\n  \
    \  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 1]`,\n right: `[2]`', /tmp/tmpkzslh8u6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut vec: Vec<isize> =\
    \ Vec::new();\n    for i in 2..n {\n        if n % i == 0 {\n            for j\
    \ in i..n / i {\n                vec.push(i);\n            }\n        }\n    }\n\
    \    vec\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmpxg_ch1wj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![n];\n\
    \    let mut n = n;\n    while n > 1 {\n        if n % 2 == 0 {\n            factorization.push(n/2);\n\
    \            n = (n / 2).floor();\n        }\n        else {\n            factorization.push(1);\n\
    \            n = (3 * n).floor();\n        }\n    }\n    factorization\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpsqbzyfyo.rs:16:25\n   |\n16 |             n = (n / 2).floor();\n\
    \   |                         ^^^^^ help: there is an associated function with\
    \ a similar name: `div_floor`\n\nerror[E0599]: no method named `floor` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpsqbzyfyo.rs:20:25\n   |\n20\
    \ |             n = (3 * n).floor();\n   |                         ^^^^^ help:\
    \ there is an associated function with a similar name: `div_floor`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    if n < 2 {\n        return\
    \ vec![];\n    }\n    let mut primes = vec![];\n    let mut num = 1;\n    let\
    \ mut i = 2;\n    let mut k = num;\n    let mut num_i = 1;\n    let mut num_k\
    \ = 1;\n\n    while i * i <= n {\n        if n % i == 0 {\n            primes.push(i\
    \ as usize);\n            num_i *= i;\n            num_k *= k;\n        }\n  \
    \      i += 1;\n        k += 1;\n    }\n\n    while k * k <= n {\n        if n\
    \ % k == 0 {\n            primes.push(k as usize);\n            num_k *= k;\n\
    \            num_i *= i;\n        }\n        k += 1;\n        i += 1;\n    }\n\
    \n    primes.push(num_i as usize);\n    primes.push(num_k as usize);\n    primes\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpldf4pbk0.rs:43:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n43 |     primes\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut candidate = n as isize;\n    while candidate != 1 {\n        if n\
    \ % candidate == 0 {\n            candidate = candidate/2;\n        } else {\n\
    \            candidate = candidate*3+1;\n            result.push(candidate);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmpeld1ohco.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    fn is_prime(a: isize) ->\
    \ bool {\n        let mut i: isize = 1;\n        loop {\n            if a % i\
    \ == 0 {\n                return false;\n            }\n            i += 2;\n\
    \        }\n        true\n    }\n\n    let mut factors: Vec<isize> = vec![1usize];\n\
    \n    let mut i: isize = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            for j in 2..(i + 1) {\n                if n % i == 0 {\n        \
    \            break;\n                }\n                if j * j > n / i {\n \
    \                   break;\n                }\n            }\n            if i\
    \ == 1 {\n                factors.push(1);\n            } else {\n           \
    \     factors.push(i);\n            }\n            n = (n / i).max(1);\n     \
    \   } else {\n            i += 1;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpruotil5y.rs:22:40\n   |\n\
    22 |     let mut factors: Vec<isize> = vec![1usize];\n   |                   \
    \                     ^^^^^^ expected `isize`, found `usize`\n   |\nhelp: change\
    \ the type of the numeric literal from `usize` to `isize`\n   |\n22 |     let\
    \ mut factors: Vec<isize> = vec![1isize];\n   |                              \
    \           ~~~~~\n\nwarning: unreachable expression\n  --> /tmp/tmpruotil5y.rs:19:9\n\
    \   |\n13 | /         loop {\n14 | |             if a % i == 0 {\n15 | |     \
    \            return false;\n16 | |             }\n17 | |             i += 2;\n\
    18 | |         }\n   | |_________- any code following this expression is unreachable\n\
    19 |           true\n   |           ^^^^ unreachable expression\n   |\n   = note:\
    \ `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![];\n\
    \    let mut primes = vec![];\n    let mut max_factor = 0;\n    let mut n = n\
    \ as isize;\n    while n > 2 {\n        if n % 2 == 0 {\n            primes.push(2);\n\
    \            factorization.push(2);\n            n = (n - 2) / 2;\n        } else\
    \ {\n            for prime in primes.iter() {\n                factorization.push(n);\n\
    \                factorization.push(prime);\n                max_factor = cmp::max(max_factor,\
    \ (n / prime) as isize);\n                n = (n / prime) as isize;\n        \
    \    }\n            primes.push(2);\n            factorization.push(2);\n    \
    \    }\n    }\n    factorization\n        .into_iter()\n        .map(|x| x as\
    \ isize)\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp9hrtyqe1.rs:24:30\n   |\n24 |                 max_factor = cmp::max(max_factor,\
    \ (n / prime) as isize);\n   |                              ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9hrtyqe1.rs:23:36\n\
    \   |\n23 |                 factorization.push(prime);\n   |                 \
    \                   ^^^^^ expected `isize`, found `&{integer}`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |                 factorization.push(*prime);\n\
    \   |                                    +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut a = vec![n as usize];\n\
    \    for &n in factorization(n) {\n        for i in 0..n {\n            a.push(n\
    \ * i);\n        }\n    }\n    a\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmptqdsnivj.rs:12:15\n   |\n12 |     for &n in factorization(n) {\n   |\
    \               ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptqdsnivj.rs:17:5\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n17 |     a\n   |     ^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 2;\n    let mut i = 0;\n    while factor <= n {\n      \
    \  while n % factor != 0 {\n            n /= factor;\n            factors.push(factor);\n\
    \            i += 1;\n        }\n        factors.push(factor);\n        i += 1;\n\
    \        factor *= i;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1sk58x5h.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ans = vec![];\n \
    \   factorize(n, &mut ans);\n    ans\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpttgib01l.rs:12:5\n   |\n12 |     factorize(n, &mut ans);\n   |\
    \     ^^^^^^^^^ -  -------- supplied 2 arguments\n   |     |\n   |     expected\
    \ 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpttgib01l.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factor = Vec::new();\n\
    \    let mut i = 2;\n    factor.push(1);\n    factor.push(i);\n    while i <=\
    \ n {\n        while n % i == 0 {\n            factor.push(i);\n            n\
    \ /= i;\n        }\n        i += 1;\n    }\n    factor\n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpka7n3l37.rs:18:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    // Get factorization\n  \
    \  let factors = factorize_impl(n);\n    // Calculate number of times each element\
    \ appeared\n    let mut occurrences = HashMap::new();\n    for i in factors.iter()\
    \ {\n        occurrences.insert(i, 0);\n    }\n    for i in factors {\n      \
    \  occurrences.insert(i, occurrences.get(&i).unwrap() + 1);\n    }\n    // Return\
    \ sorted vector of factors\n    occurrences.iter().cloned().collect::<Vec<_>>().sort_by(|a,\
    \ b| b.cmp(&a)).collect()\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorize_impl` in this scope\n  -->\
    \ /tmp/tmpk122ioxx.rs:12:19\n   |\n12 |     let factors = factorize_impl(n);\n\
    \   |                   ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpk122ioxx.rs:14:27\n\
    \   |\n14 |     let mut occurrences = HashMap::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factorization = Prime::factorize(n);\n    for factor in factorization.iter()\
    \ {\n        if factors.iter().any(|&x| *x == *factor) {\n            factors.push(*factor);\n\
    \        } else {\n            factors.push(*factor);\n            factors.push(*factor);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Prime`\n  -->\
    \ /tmp/tmpdot1eqgm.rs:12:29\n   |\n12 |     let mut factorization = Prime::factorize(n);\n\
    \   |                             ^^^^^ use of undeclared type `Prime`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![false;\
    \ n + 1];\n    let mut i = 2;\n\n    while i <= n {\n        if !primes[i] {\n\
    \            primes[i] = true;\n            i += 1;\n\n            let mut factors\
    \ = vec![0; i];\n            for p in &mut primes {\n                while i <\
    \ n && !(*p) {\n                    factors[*p] += 1;\n                    i +=\
    \ 1;\n                }\n            }\n            i += 1;\n\n            primes\
    \ = factors;\n        }\n    }\n\n    primes\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8b2rukns.rs:11:34\n   |\n\
    11 |     let mut primes = vec![false; n + 1];\n   |                          \
    \        ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n11\
    \ |     let mut primes = vec![false; (n + 1).try_into().unwrap()];\n   |     \
    \                             +     +++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmp8b2rukns.rs:15:13\n\
    \   |\n15 |         if !primes[i] {\n   |             ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp8b2rukns.rs:16:13\n   |\n16 |            \
    \ primes[i] = true;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8b2rukns.rs:19:39\n\
    \   |\n19 |             let mut factors = vec![0; i];\n   |                  \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    19 |             let mut factors = vec![0; i.try_into().unwrap()];\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `bool`\n  --> /tmp/tmp8b2rukns.rs:22:21\n\
    \   |\n22 |                     factors[*p] += 1;\n   |                     ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is no"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    factorize_inner(n, factors);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorize_inner` in this scope\n  -->\
    \ /tmp/tmpmtd3pj7z.rs:12:5\n   |\n12 |     factorize_inner(n, factors);\n   |\
    \     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut fs = Vec::new();\n\
    \    for f in factorization(n) {\n        fs.push(f * 1);\n    }\n    fs\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmprgshru3e.rs:12:14\n   |\n12 |     for f in factorization(n) {\n   |\
    \              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![n];\n\
    \    let mut product = 1;\n    for p in &factors {\n        product *= *p;\n \
    \   }\n    let mut prime_factors = vec![n];\n    let mut prime_factor = 1;\n \
    \   for p in &prime_factors {\n        prime_factor *= *p;\n    }\n    prime_factors[0]\
    \ = 1;\n    for i in 2..n {\n        if prime_factors[i] != 0 {\n            continue;\n\
    \        }\n        let mut is_prime = false;\n        for factor in &factors\
    \ {\n            if *factor == i {\n                is_prime = true;\n       \
    \         let mut p = i;\n                while *p != 1 {\n                  \
    \  p *= *factor;\n                }\n                prime_factors[i] = p;\n \
    \               break;\n            }\n        }\n        if is_prime == false\
    \ {\n            prime_factors[i] = 1;\n        }\n    }\n    prime_factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2isap9li.rs:23:12\n\
    \   |\n23 |         if prime_factors[i] != 0 {\n   |            ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp2isap9li.rs:31:23\n   |\n\
    31 |                 while *p != 1 {\n   |                       ^^\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2isap9li.rs:34:17\n\
    \   |\n34 |                 prime_factors[i] = p;\n   |                 ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2isap9li.rs:39:13\n\
    \   |\n39 |             prime_factors[i] = 1;\n   |             ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ans = vec![];\n \
    \   let mut max_i = n as isize;\n    let mut i = 1;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            ans.push(i);\n            n /= i;\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    while n > 1 {\n    \
    \    if n % 2 == 0 {\n            ans.push(2);\n            n /= 2;\n        }\
    \ else {\n            ans.push(n % 2);\n            n /= 2;\n        }\n    }\n\
    \    ans.reverse();\n    ans.dedup();\n    ans.retain(|x| *x == 1);\n    ans\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `max_i`\n  --> /tmp/tmpi2b4y_7z.rs:12:13\n  \
    \ |\n12 |     let mut max_i = n as isize;\n   |             ^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_max_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpi2b4y_7z.rs:12:9\n\
    \   |\n12 |     let mut max_i = n as isize;\n   |         ----^^^^^\n   |    \
    \     |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `n`\n  -->\
    \ /tmp/tmpi2b4y_7z.rs:17:13\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |              - help: consider making this binding mutable: `mut n`\n...\n\
    17 |             n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpi2b4y_7z.rs:25:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n25 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpi2b4y_7z.rs:28:13\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n28 |             n /= 2;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 3 previous errors; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    use num::{Div, I};\n\n  \
    \  let mut factorization = Vec::new();\n    let mut counter = 1;\n    factorization.push(n);\n\
    \n    while n != 1 {\n        if n % counter == 0 {\n            factorization.push(counter\
    \ as isize);\n            n /= counter;\n        } else {\n            counter\
    \ += 1\n        }\n    }\n    factorization.reverse();\n\n    factorization\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `num`\n  --> /tmp/tmpnukpf_y3.rs:11:9\n\
    \   |\n11 |     use num::{Div, I};\n   |         ^^^\n   |         |\n   |   \
    \      unresolved import\n   |         help: a similar path exists: `std::num`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \    let mut result = Vec::new();\n    let mut product = n;\n    while product\
    \ > 1 {\n        for prime in &primes {\n            while product % prime ==\
    \ 0 {\n                factorization.push(prime);\n                product /=\
    \ prime;\n            }\n        }\n        result.push(product);\n        factorization.push(1);\n\
    \        product /= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmpqtp5fzse.rs:15:23\n\
    \   |\n15 |         for prime in &primes {\n   |                       ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    factorize_inner(n, &mut factors);\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorize_inner` in this scope\n  -->\
    \ /tmp/tmp4b81h2ml.rs:12:5\n   |\n12 |     factorize_inner(n, &mut factors);\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![1];\n\
    \    let mut i = 0;\n    for factor in prime_factorization(&n) {\n        factors.extend((factor\
    \ - 1) as isize * factors[i]);\n        i += 1;\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factorization` in this scope\n\
    \  --> /tmp/tmptf0_23cc.rs:13:19\n   |\n13 |     for factor in prime_factorization(&n)\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ `isize` is not an iterator\n   --> /tmp/tmptf0_23cc.rs:14:24\n    |\n14  | \
    \        factors.extend((factor - 1) as isize * factors[i]);\n    |          \
    \       ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `isize` is not an iterator\n\
    \    |                 |\n    |                 required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `isize`\n    = note: if you want to iterate between `start` until a value `end`,\
    \ use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `isize`\nnote: required by a bound in `extend`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut limit = (*n as usize) as isize;\n    let mut isprime = true;\n  \
    \  let mut num = 1;\n    while limit > 0 {\n        // limit can be divided by\
    \ num\n        let mut limit2 = limit as isize;\n        while limit2 > 0 {\n\
    \            if num % limit2 == 0 {\n                result.push(num);\n     \
    \           break;\n            }\n            limit2 -= 1;\n        }\n     \
    \   num <<= 1;\n        limit >>= 1;\n        if isprime {\n            // If\
    \ num is prime, check if it is smaller than its product with its first factor\n\
    \            if num > 1i32 * (*n as usize) {\n                isprime = false;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmps_ws5580.rs:12:22\n\
    \   |\n12 |     let mut limit = (*n as usize) as isize;\n   |                \
    \      ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmps_ws5580.rs:29:30\n\
    \   |\n29 |             if num > 1i32 * (*n as usize) {\n   |                \
    \              ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_ws5580.rs:29:22\n\
    \   |\n29 |             if num > 1i32 * (*n as usize) {\n   |                \
    \      ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n29 |             if num > (1i32 * (*n as usize)).try_into().unwrap() {\n\
    \   |                      +                    +++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \    let mut primes = vec![0; n];\n    let mut n = 0;\n    while n > 1 {\n   \
    \     factorization.push(n);\n        if n % 2 == 0 {\n            factorization.push(2);\n\
    \            primes[n] = 1;\n        }\n        for &prime in &primes {\n    \
    \        if prime > n {\n                break;\n            }\n            if\
    \ prime >= n {\n                continue;\n            }\n            if n % prime\
    \ == 0 {\n                factorization.push(prime);\n                primes[n]\
    \ = primes[n] * prime;\n                n /= prime;\n                break;\n\
    \            }\n        }\n    }\n    factorization\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpev8rr7qo.rs:12:30\n   |\n\
    12 |     let mut primes = vec![0; n];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     let mut primes\
    \ = vec![0; n.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpev8rr7qo.rs:35:5\n   |\n10 | fn\
    \ factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n35 |     factorization\n\
    \   |     ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = vec![vec![0;\
    \ n]; n + 1];\n    let mut p = 2;\n    for i in (0..n).rev() {\n        let mut\
    \ b = 1;\n        while b < i {\n            f[b][p..] = i;\n            p +=\
    \ 1;\n            b += 1\n        }\n    }\n    f[n][p..] = n\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_09xm8xt.rs:11:30\n   |\n\
    11 |     let mut f = vec![vec![0; n]; n + 1];\n   |                          \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut f = vec![vec![0; n.try_into().unwrap()]; n + 1];\n   |                 \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_09xm8xt.rs:11:34\n\
    \   |\n11 |     let mut f = vec![vec![0; n]; n + 1];\n   |                   \
    \               ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut f = vec![vec![0; n]; (n + 1).try_into().unwrap()];\n   |    \
    \                              +     +++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp_09xm8xt.rs:16:13\n\
    \   |\n16 |             f[b][p..] = i;\n   |             ^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_09xm8xt.rs:21:5\n   |\n21 |   \
    \  f[n][p..] = n\n   |     ^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ans = Vec::new();\n\
    \    let mut div = 2;\n    let mut fx = 1;\n    while div <= n {\n        if n\
    \ % div == 0 {\n            ans.push(fx);\n            fx *= div;\n        } else\
    \ {\n            div += 1;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmpujrzfz87.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \n    factors.push(1);\n\n    while n != 1 {\n        if n % 2 == 0 {\n      \
    \      factors.push(2);\n            n = n / 2;\n        } else {\n          \
    \  factors.push(1);\n            n = n / 2;\n        }\n    }\n\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmplh3qxo5c.rs:18:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n = n /\
    \ 2;\n   |             ^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmplh3qxo5c.rs:21:13\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n21 |             n = n / 2;\n   |\
    \             ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    n / factors(n)\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpn72h6_1y.rs:11:9\n\
    \   |\n11 |     n / factors(n)\n   |         ^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn72h6_1y.rs:11:5\n   |\n10 | fn\
    \ factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n11 |     n / factors(n)\n   |\
    \     ^^^^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    factorization(factors(n)).iter()\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmppu57l_j2.rs:11:5\n   |\n11 |     factorization(factors(n)).iter()\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `factors` in this scope\n  --> /tmp/tmppu57l_j2.rs:11:19\n   |\n11 |     factorization(factors(n)).iter()\n\
    \   |                   ^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    factorize_impl(&Vec::new(),\
    \ n)\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorize_impl` in this scope\n  -->\
    \ /tmp/tmpvhfay0bj.rs:11:5\n   |\n11 |     factorize_impl(&Vec::new(), n)\n  \
    \ |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    let mut i = 2;\n\n    while i * i <= n {\n        if n % i == 0 {\n     \
    \       ret.push(i);\n            n /= i;\n        }\n\n        i += 1;\n    }\n\
    \n    ret.push(n);\n\n    ret\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpwg88agoa.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut divisor = 1;\n    while divisor <= n {\n        if n % divisor ==\
    \ 0 {\n            factors.push(*divisor);\n            divisor += 1;\n      \
    \  }\n        else {\n            divisor = divisor + 1;\n        }\n    }\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpc14rf5ww.rs:15:26\n\
    \   |\n15 |             factors.push(*divisor);\n   |                        \
    \  ^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![n];\n\
    \n    let mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n          \
    \  factors[i as usize] = 1;\n            n = n / i;\n            i += 1;\n   \
    \     } else {\n            i += 1;\n        }\n    }\n\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp7b_9f16y.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n = n /\
    \ i;\n   |             ^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![0;\
    \ n + 1];\n\n    for i in 1..n + 1 {\n        factorization[i] += factorization[i\
    \ - 1];\n    }\n\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3m53qra1.rs:11:37\n   |\n\
    11 |     let mut factorization = vec![0; n + 1];\n   |                       \
    \              ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut factorization = vec![0; (n + 1).try_into().unwrap()];\n   | \
    \                                    +     +++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3m53qra1.rs:14:9\n\
    \   |\n14 |         factorization[i] += factorization[i - 1];\n   |         ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp3m53qra1.rs:14:29\n\
    \   |\n14 |         factorization[i] += factorization[i - 1];\n   |          \
    \                   ^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = vec![];\n    let mut i = 1;\n    for prime in factorization(n).iter() {\n\
    \        while i * prime <= n {\n            i += 1;\n        }\n        factors.push(prime);\n\
    \        while i <= n {\n            i += 2;\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpt_rzvpx8.rs:13:18\n   |\n13 |     for prime in factorization(n).iter()\
    \ {\n   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = Vec::new();\n\
    \    if n == 1 {\n        vec![1]\n    } else {\n        let mut res = 1;\n  \
    \      while n > res * 2 {\n            res *= 2;\n        }\n        f += vec![res];\n\
    \        let mut factor = n - 1;\n        let mut res = 1;\n        while factor\
    \ > res * 2 {\n            res *= 2;\n            factor = factor - 1;\n     \
    \   }\n        f += vec![res];\n    }\n    f.iter().cloned().collect()\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpybc7a31y.rs:13:9\n   |\n\
    12 | /     if n == 1 {\n13 | |         vec![1]\n   | |         ^^^^^^^ expected\
    \ `()`, found struct `Vec`\n14 | |     } else {\n15 | |         let mut res =\
    \ 1;\n...  |\n26 | |         f += vec![res];\n27 | |     }\n   | |_____- expected\
    \ this to be `()`\n   |\n   = note: expected unit type `()`\n                \
    \ found struct `Vec<{integer}>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp:\
    \ consider using a semicolon here\n   |\n27 |     };\n   |      +\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpybc7a31y.rs:19:9\n\
    \   |\n19 |         f += vec![res];\n   |         -^^^^^^^^^^^^^\n   |       \
    \  |\n   |         cannot use `+=` on type `Vec<_>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpybc7a31y.rs:26:9\n\
    \   |\n26 |         f += vec![res];\n   |         -^^^^^^^^^^^^^\n   |       \
    \  |\n   |         cannot use `+=` on type `Vec<_>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![n];\n\
    \    factorize(&mut factors, n as isize);\n    factors\n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp_y7ba6xc.rs:12:5\n   |\n12 |     factorize(&mut factors, n as isize);\n\
    \   |     ^^^^^^^^^ ------------  ---------- supplied 2 arguments\n   |     |\n\
    \   |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp_y7ba6xc.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    n as usize * [1..n.bit_length()\
    \ as usize].iter()\n        .map(|x| x.trailing_zeros()).filter(|x| x < n)\n \
    \       .collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `bit_length` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp3080eh84.rs:11:24\n   |\n11 |     n as usize *\
    \ [1..n.bit_length() as usize].iter()\n   |                        ^^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `trailing_zeros`\
    \ found for reference `&std::ops::Range<{integer}>` in the current scope\n  -->\
    \ /tmp/tmp3080eh84.rs:12:20\n   |\n12 |         .map(|x| x.trailing_zeros()).filter(|x|\
    \ x < n)\n   |                    ^^^^^^^^^^^^^^ method not found in `&std::ops::Range<{integer}>`\n\
    \nerror[E0277]: can't compare `&_` with `isize`\n  --> /tmp/tmp3080eh84.rs:12:51\n\
    \   |\n12 |         .map(|x| x.trailing_zeros()).filter(|x| x < n)\n   |     \
    \                                              ^ no implementation for `&_ < isize`\
    \ and `&_ > isize`\n   |\n   = help: the trait `PartialOrd<isize>` is not implemented\
    \ for `&_`\n\nerror[E0277]: cannot multiply `usize` by `Vec<isize>`\n  --> /tmp/tmp3080eh84.rs:11:16\n\
    \   |\n11 |     n as usize * [1..n.bit_length() as usize].iter()\n   |       \
    \         ^ no implementation for `usize * Vec<isize>`\n   |\n   = help: the trait\
    \ `Mul<Vec<isize>>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n    \
    \         <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n      \
    \       <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n          \
    \   <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a\
    \ isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut vec: Vec<isize> =\
    \ vec![0; n]; // allocate enough space\n    let mut fp = 1;\n    let mut i = 1;\n\
    \    while i <= n {\n        while i <= n / fp {\n            i += 1;\n      \
    \  }\n        vec.push(i as isize);\n        fp = fp << 1;\n        while i <=\
    \ n / fp {\n            fp = fp << 1;\n            i += 1;\n        }\n    }\n\
    \    vec\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptpjx57a8.rs:11:39\n   |\n\
    11 |     let mut vec: Vec<isize> = vec![0; n]; // allocate enough space\n   |\
    \                                       ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut vec: Vec<isize> = vec![0; n.try_into().unwrap()];\
    \ // allocate enough space\n   |                                        ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f: Vec<isize> = Vec::new();\n\
    \    let mut max_factor = 0;\n    let mut max_factor_count = 0;\n    let mut i:\
    \ isize = 1;\n    let mut j: isize = 1;\n    let mut m: isize = 1;\n\n    while\
    \ i <= n {\n        while ((i * j) % n == 0) {\n            i += 1;\n        \
    \    m += 1;\n        }\n        i += 1;\n        j.cmp_unchecked(1);\n      \
    \  if m > max_factor {\n            max_factor = m;\n            max_factor_count\
    \ = i;\n        }\n    }\n\n    f.push(max_factor_count);\n\n    while f.len()\
    \ > 0 {\n        let mut cur: isize = 1;\n        for &i in f {\n            cur\
    \ *= i;\n        }\n        let mut new_f: Vec<isize> = Vec::new();\n        for\
    \ i in f {\n            if i != 1 {\n                new_f.push(i * cur);\n  \
    \          }\n        }\n\n        f = new_f;\n    }\n\n    f\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprij5nmk3.rs:19:15\n\
    \   |\n19 |         while ((i * j) % n == 0) {\n   |               ^         \
    \       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n19 -         while ((i * j) % n == 0) {\n19 +     \
    \    while (i * j) % n == 0 {\n   | \n\nerror[E0599]: no method named `cmp_unchecked`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmprij5nmk3.rs:24:11\n\
    \   |\n24 |         j.cmp_unchecked(1);\n   |           ^^^^^^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprij5nmk3.rs:35:13\n\
    \   |\n35 |         for &i in f {\n   |             ^^    - this expression has\
    \ type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factors: Vec<isize>\
    \ = vec![1]; // [2, 1, 1]\n\n    for divisor in 2..n {\n        if n % divisor\
    \ == 0 {\n            prime_factors.extend_from_slice(&[divisor]);\n         \
    \   n /= divisor;\n        } else {\n            prime_factors.extend_from_slice(&[n\
    \ / divisor, divisor]);\n            n = divisor;\n        }\n    }\n\n    prime_factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpg3gt8l2i.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= divisor;\n\
    \   |             ^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpg3gt8l2i.rs:19:13\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |             n = divisor;\n \
    \  |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut i = 1;\n\n    while i < n {\n        while n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n\n        i += 1;\n  \
    \  }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpi1le5tz3.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ret: Vec<isize> =\
    \ Vec::new();\n    let mut n_factors: isize = 1;\n\n    while n_factors < n {\n\
    \        if n % n_factors == 0 {\n            ret.push(n_factors);\n         \
    \   n /= n_factors;\n            n_factors += 1;\n        }\n        else {\n\
    \            ret.push(n_factors);\n            n_factors += 1;\n        }\n  \
    \  }\n    ret.push(n_factors);\n    ret\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpct6qhahz.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= n_factors;\n\
    \   |             ^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut limit = (n as isize) as isize;\n    let mut max_factor = limit as\
    \ usize;\n    while n > 1 {\n        if n % 2 == 1 {\n            factors.push(2);\n\
    \            max_factor = max_factor as usize + 1;\n        }\n        n /= 2;\n\
    \    }\n    for i in (0..max_factor as usize).rev() {\n        if n % i == 0 {\n\
    \            factors.push(i);\n            n /= i;\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr93crsgp.rs:22:16\n   |\n\
    22 |         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpr93crsgp.rs:22:14\n\
    \   |\n22 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr93crsgp.rs:24:18\n\
    \   |\n24 |             n /= i;\n   |                  ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  --> /tmp/tmpr93crsgp.rs:24:15\n\
    \   |\n24 |             n /= i;\n   |               ^^ no implementation for `isize\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr93crsgp.rs:27:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n27 |    \
    \ factors\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factorization\
    \ = Vec::new();\n    let mut factors = Vec::new();\n    for i in 1..=n {\n   \
    \     let mut found = true;\n        for j in 1..=factors.len() {\n          \
    \  if n % i == 0 {\n                found = false;\n                break;\n \
    \           }\n        }\n        if found {\n            factors.push(i);\n \
    \       }\n    }\n    for i in factors {\n        prime_factorization.push(i);\n\
    \    }\n    prime_factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmp36sc34uw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = vec![];\n   \
    \ let mut prod = 1;\n    for i in 2..=n {\n        if n % i == 0 {\n         \
    \   prod *= i;\n            f.push(i);\n            if prod == n {\n         \
    \       break;\n            }\n        }\n    }\n    f\n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[2, 2]`', /tmp/tmpbioesghq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut product = 1;\n  \
    \  let mut factors = Vec::new();\n    for i in 1..=n {\n        let product =\
    \ product * i;\n        let mut count = 0;\n        while product % i == 0 {\n\
    \            count += 1;\n            product /= i;\n        }\n        factors.push(count);\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp2bd0di_7.rs:11:9\n\
    \   |\n11 |     let mut product = 1;\n   |         ----^^^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign twice to immutable variable `product`\n\
    \  --> /tmp/tmp2bd0di_7.rs:18:13\n   |\n14 |         let product = product * i;\n\
    \   |             -------\n   |             |\n   |             first assignment\
    \ to `product`\n   |             help: consider making this binding mutable: `mut\
    \ product`\n...\n18 |             product /= i;\n   |             ^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for factor in factors(n) {\n        if n > factor {\n            result.push(factor);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpv7vpds4w.rs:12:19\n\
    \   |\n12 |     for factor in factors(n) {\n   |                   ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![1;\
    \ n];\n    for i in factors.iter_mut() {\n        *i *= i;\n    }\n    let mut\
    \ result = vec![];\n    for i in factors.iter() {\n        result.push(*i as usize);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0v8owwvh.rs:11:31\n   |\n\
    11 |     let mut factors = vec![1; n];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut factors\
    \ = vec![1; n.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: cannot multiply-assign `{integer}` by `&mut {integer}`\n  -->\
    \ /tmp/tmp0v8owwvh.rs:13:12\n   |\n13 |         *i *= i;\n   |            ^^ no\
    \ implementation for `{integer} *= &mut {integer}`\n   |\n   = help: the trait\
    \ `MulAssign<&mut {integer}>` is not implemented for `{integer}`\n   = help: the\
    \ following other types implement trait `MulAssign<Rhs>`:\n             <f32 as\
    \ MulAssign<&f32>>\n             <f32 as MulAssign>\n             <f64 as MulAssign<&f64>>\n\
    \             <f64 as MulAssign>\n             <i128 as MulAssign<&i128>>\n  \
    \           <i128 as MulAssign>\n             <i16 as MulAssign<&i16>>\n     \
    \        <i16 as MulAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0v8owwvh.rs:19:5\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n19 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    assert!(n > 0);\n    assert!(n\
    \ % 2 == 0, \"n should be odd number\");\n\n    let mut factors = Vec::new();\n\
    \    let mut current_factor = 1;\n\n    for _ in 0..n {\n        if n % current_factor\
    \ == 0 {\n            factors.push(current_factor);\n            current_factor\
    \ *= 2;\n        }\n        else {\n            current_factor *= 3;\n       \
    \ }\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[2]`', /tmp/tmpt_wpq6rk.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factors = Vec::with_capacity(n\
    \ / 2);\n    for &n in &prime_factors {\n        if n % 2 == 0 {\n           \
    \ prime_factors.append(2);\n        }\n    }\n\n    for i in 2..n {\n        let\
    \ mut p = i;\n        while p * p < n {\n            if n % p == 0 {\n       \
    \         prime_factors.append(p);\n                n /= p;\n            } else\
    \ {\n                break;\n            }\n        }\n    }\n\n    prime_factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqxq3r4fe.rs:11:48\n   |\n\
    11 |     let mut prime_factors = Vec::with_capacity(n / 2);\n   |            \
    \                                    ^^^^^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut prime_factors = Vec::with_capacity((n\
    \ / 2).try_into().unwrap());\n   |                                           \
    \     +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqxq3r4fe.rs:14:34\n\
    \   |\n14 |             prime_factors.append(2);\n   |                       \
    \           ^ expected `&mut Vec<_>`, found integer\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<_>`\n                           found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqxq3r4fe.rs:22:38\n   |\n22 |\
    \                 prime_factors.append(p);\n   |                             \
    \         ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<_>`\n                           found type `isize`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    debug_assert!(n > 0);\n \
    \   let mut result = Vec::new();\n    let mut factors = vec![1..n];\n    let mut\
    \ f = 0;\n    while f < factors.len() {\n        if n % f == 0 {\n           \
    \ factors[f] = factors[f] + 1;\n        } else {\n            factors[f] = 1;\n\
    \        }\n        f += 1;\n    }\n    let mut f = 0;\n    while f < factors.len()\
    \ {\n        if n % f == 0 {\n            factors[f] = factors[f] + 1;\n     \
    \   } else {\n            factors[f] = 1;\n        }\n        f += 1;\n    }\n\
    \    while f < factors.len() {\n        result.push(*f);\n        f += 1;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkolt7fle.rs:16:16\n   |\n\
    16 |         if n % f == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpkolt7fle.rs:16:14\n\
    \   |\n16 |         if n % f == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0369]: cannot add `{integer}` to `std::ops::Range<isize>`\n\
    \  --> /tmp/tmpkolt7fle.rs:17:37\n   |\n17 |             factors[f] = factors[f]\
    \ + 1;\n   |                          ---------- ^ - {integer}\n   |         \
    \                 |\n   |                          std::ops::Range<isize>\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkolt7fle.rs:19:26\n   |\n19 |  \
    \           factors[f] = 1;\n   |             ----------   ^ expected struct `std::ops::Range`,\
    \ found integer\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\n   = note: expected struct `std::ops::Range<isize>`\n\
    \                found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkolt7fle.rs:25:16\n   |\n25 |         if n % f == 0 {\n   |        \
    \        ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize`\
    \ by `usize`\n  --> /tmp/tmpkolt7fle.rs:25:14\n   |\n25 |         if n % f ==\
    \ 0 {\n   |              ^ no implementation for `isize % usize`\n   |\n   = help:\
    \ the trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    for d in 2..=(n-1)/d {\n        if n % d == 0 {\n            factors.push(d\
    \ * (n//d));\n            n /= d;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `n`\n  --> /tmp/tmp1rrm2t2i.rs:14:30\n   |\n14 |             factors.push(d\
    \ * (n//d));\n   |                              ^ - help: `)` may belong here\n\
    \   |                              |\n   |                              unclosed\
    \ delimiter\n15 |             n /= d;\n   |             ^\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    \n    factorize(n, &mut factors);\n    \n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpopgalsbs.rs:13:5\n   |\n13 |     factorize(n, &mut factors);\n\
    \   |     ^^^^^^^^^ -  ------------ supplied 2 arguments\n   |     |\n   |   \
    \  expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpopgalsbs.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![];\n\
    \    let mut i = 2;\n    let mut prime: isize = 2;\n    while i * i <= n {\n \
    \       while n % i == 0 {\n            primes.push(i);\n            n /= i;\n\
    \        }\n        i += 1;\n        prime = 2;\n    }\n    if n > 1 {\n     \
    \   primes.push(n);\n    }\n    primes\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `prime` is assigned to, but never used\n  --> /tmp/tmpk727qqjn.rs:13:13\n\
    \   |\n13 |     let mut prime: isize = 2;\n   |             ^^^^^\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_prime`\
    \ instead\n\nwarning: value assigned to `prime` is never read\n  --> /tmp/tmpk727qqjn.rs:20:9\n\
    \   |\n20 |         prime = 2;\n   |         ^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpk727qqjn.rs:17:13\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |             n /= i;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::with_capacity(n.bit_length());\n\
    \    for i in 1..=n {\n        let factor = i / n as usize;\n        if factor\
    \ != 0 {\n            factors.push(factor);\n            factors.insert(0, factor);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `bit_length` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpeasyj7ea.rs:11:44\n   |\n11 |     let mut factors\
    \ = Vec::with_capacity(n.bit_length());\n   |                                \
    \            ^^^^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeasyj7ea.rs:13:26\n   |\n13 |         let factor = i /\
    \ n as usize;\n   |                          ^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n  --> /tmp/tmpeasyj7ea.rs:13:24\n\
    \   |\n13 |         let factor = i / n as usize;\n   |                       \
    \ ^ no implementation for `isize / usize`\n   |\n   = help: the trait `Div<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ret: Vec<isize> =\
    \ Vec::new();\n    let mut num: isize = n;\n    let mut factor: Vec<isize> = Vec::new();\n\
    \    factorize(&mut factor, num);\n    for i in factor {\n        ret.push(i);\n\
    \        num *= i;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpit5fqdc3.rs:14:5\n   |\n14 |     factorize(&mut factor, num);\n\
    \   |     ^^^^^^^^^ -----------  --- supplied 2 arguments\n   |     |\n   |  \
    \   expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpit5fqdc3.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    assert!(n != 0, \"Number\
    \ to factorize should be non zero\");\n    let mut result = Vec::new();\n    prime_factorization(n,\
    \ 0, &mut result);\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factorization` in this scope\n\
    \  --> /tmp/tmp6vwfi3mw.rs:13:5\n   |\n13 |     prime_factorization(n, 0, &mut\
    \ result);\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![0;\
    \ n];\n    for i in factors.iter_mut() {\n        *i = 0;\n    }\n    let mut\
    \ product = 1;\n    while n > 0 {\n        for factor in factors.iter_mut() {\n\
    \            if n % factor == 0 {\n                n /= factor;\n            \
    \    *factor *= product;\n                break;\n            }\n        }\n \
    \       if n == 0 {\n            break;\n        }\n        product *= n;\n  \
    \  }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmglhqw1c.rs:11:31\n   |\n\
    11 |     let mut factors = vec![0; n];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut factors\
    \ = vec![0; n.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: cannot mod `isize` by `&mut {integer}`\n  --> /tmp/tmpmglhqw1c.rs:18:18\n\
    \   |\n18 |             if n % factor == 0 {\n   |                  ^ no implementation\
    \ for `isize % &mut {integer}`\n   |\n   = help: the trait `Rem<&mut {integer}>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0277]: cannot divide-assign `isize` by `&mut\
    \ {integer}`\n  --> /tmp/tmpmglhqw1c.rs:19:19\n   |\n19 |                 n /=\
    \ factor;\n   |                   ^^ no implementation for `isize /= &mut {integer}`\n\
    \   |\n   = help: the trait `DivAssign<&mut {integer}>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![n];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        for j in (i..=n).rev() {\n\
    \            if n % j == 0 {\n                factors[i as usize] *= j;\n    \
    \            n /= j;\n                break;\n            }\n        }\n     \
    \   i += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzttmprz8.rs:17:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |                 n /=\
    \ j;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut fs = Vec::new();\n\
    \    loop {\n        if n >= 2 {\n            let mut a = 2;\n            while\
    \ a < n {\n                fs.push(a);\n                a += 1;\n            }\n\
    \        } else {\n            break;\n        }\n    }\n    &fs[..]\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9y5krbe1.rs:23:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n23 |     &fs[..]\n   |  \
    \   ^^^^^^^ expected struct `Vec`, found `&[isize]`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n           found reference `&[isize]`\nhelp: try using\
    \ a conversion method\n   |\n23 |     (&fs[..]).to_vec()\n   |     +       ++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = Vec::new();\n    let mut counter = 1;\n    for i in 2..=n {\n        if n\
    \ % i == 0 {\n            factors.push(i as isize);\n            counter *= i;\n\
    \            while counter > n {\n                factors.pop();\n           \
    \     counter /= i;\n            }\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[2, 2]`', /tmp/tmppx92ayme.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![];\n\
    \    let mut n = n as usize;\n    while n != 1 {\n        if n % 2 == 0 {\n  \
    \          factorization.push(2);\n            n /= 2;\n        }\n        if\
    \ n % 3 == 0 {\n            factorization.push(3);\n            n /= 3;\n    \
    \    }\n        if n % 5 == 0 {\n            factorization.push(5);\n        \
    \    n /= 5;\n        }\n        if n % 7 == 0 {\n            factorization.push(7);\n\
    \            n /= 7;\n        }\n        if n % 11 == 0 {\n            factorization.push(11);\n\
    \            n /= 11;\n        }\n        if n % 13 == 0 {\n            factorization.push(13);\n\
    \            n /= 13;\n        }\n        if n % 17 == 0 {\n            factorization.push(17);\n\
    \            n /= 17;\n        }\n        if n % 19 == 0 {\n            factorization.push(19);\n\
    \            n /= 19;\n        }\n        if n % 23 == 0 {\n            factorization.push(23);\n\
    \            n /= 23;\n        }\n        if n % 29 == 0 {\n            factorization.push(29);\n\
    \            n /= 29;\n        }\n        if n % 31 == 0 {\n            factorization.push(31);\n\
    \            n /= 31;\n        }\n        if n % 37 == 0 {\n            factorization.push(37);\n\
    \            n /= 37;\n        }\n        if n % 41 == 0 {\n            factorization.push(41);\n\
    \            n /= 41;\n        }\n        if n % 43 == 0 {\n            factorization.push(43);\n\
    \            n /= 43;\n        }\n        if n % 47 == 0 {\n            factorization.push(47);\n\
    \            n /= 47;\n        }\n        if n % 53 == 0 {\n            factorization.push(53);\n\
    \            n /= 53;\n        }\n        if n % 59 == 0 {\n            factorization.push(59);\n\
    \            n /= 59;\n        }\n        if n % 61 == 0 {\n            factorization.push(61);\n\
    \            n /= 61;\n        }\n        if n % 67 == 0 {\n            factorization.push(67);\n\
    \            n /= 67;\n        }\n        if n % 71== 0 {\n            factorization.push(71);\n\
    \            n /= 71;\n        }\n        if n % 73 == 0 {\n            factorization.push(73);\n\
    \            n /= 73;\n        }\n        if n % 79 == 0 {\n            factorization.push(79);\n\
    \            n /= 79;\n        }\n        if n % 83 == 0 {\n            factorization.push(83);\n\
    \            n /= 83;\n        }\n        if n % 89 == 0 {\n            factorization.push(89);\n\
    \            n /= 89;\n        }\n        if \n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp034pi86x.rs:123:3\n\
    \    |\n10  | fn factorize(n: isize) -> Vec<isize> {\n    |                  \
    \                    - unclosed delimiter\n...\n13  |     while n != 1 {\n   \
    \ |                  - this delimiter might not be properly closed...\n...\n111\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n123\
    \ | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmp034pi86x.rs:111:1\n\
    \    |\n111 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp034pi86x.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization: Vec<isize>\
    \ = Vec::new();\n\n    for _ in 0..n {\n        let mut is_prime = true;\n\n \
    \       for factor in factorization.iter() {\n            if n % factor == 0 {\n\
    \                is_prime = false;\n                break;\n            }\n  \
    \      }\n\n        if is_prime {\n            factorization.push(n);\n      \
    \  }\n\n        n = n / 2;\n    }\n\n    factorization\n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpitni1eqk.rs:27:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n27 |         n = n / 2;\n\
    \   |         ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    if n == 1 { return vec![1];\
    \ }\n    let mut factors: Vec<isize> = Vec::new();\n    let mut p = 2;\n    let\
    \ mut q = 3;\n    let mut limit = (i64::MAX / isize) * isize;\n    while p <=\
    \ limit {\n        if n % p == 0 {\n            factors.push(p);\n           \
    \ n /= p;\n        }\n        p += 1;\n    }\n    if n > 1 {\n        let mut\
    \ i = 1;\n        while i <= n {\n            if n % i == 0 {\n              \
    \  factors.push(i);\n                n /= i;\n            }\n            i +=\
    \ 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpefn75ww2.rs:15:33\n\
    \   |\n15 |     let mut limit = (i64::MAX / isize) * isize;\n   |            \
    \                     ^^^^^ not a value\n\nerror[E0423]: expected value, found\
    \ builtin type `isize`\n  --> /tmp/tmpefn75ww2.rs:15:42\n   |\n15 |     let mut\
    \ limit = (i64::MAX / isize) * isize;\n   |                                  \
    \        ^^^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpefn75ww2.rs:17:16\n\
    \   |\n17 |         if n % p == 0 {\n   |                ^ expected `isize`, found\
    \ `i64`\n\nerror[E0277]: cannot mod `isize` by `i64`\n  --> /tmp/tmpefn75ww2.rs:17:14\n\
    \   |\n17 |         if n % p == 0 {\n   |              ^ no implementation for\
    \ `isize % i64`\n   |\n   = help: the trait `Rem<i64>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpefn75ww2.rs:18:26\n\
    \   |\n18 |             factors.push(p);\n   |                          ^ expected\
    \ `isize`, found `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n18 |             factors.push(p.try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpefn75ww2.rs:19:18\n   |\n19 |             n /= p;\n   |\
    \                  ^ expected `isize`, found `i64`\n\nerror[E0277]: cannot divide-assign\
    \ `isize` by `i64`\n  --> /tmp/tmpefn75ww2.rs:19:15\n   |\n19 |             n\
    \ /= p;\n   |               ^^ no implementation for `isize /= i64`\n   |\n  \
    \ = help: the trait `DivAssign<i64>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `DivAssign<Rhs>`:\n             <f32\
    \ as DivAssign<&f32>>\n "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factors = vec![];\n\
    \    let mut known_factors = vec![];\n    let mut factorization = vec![];\n\n\
    \    // Loop through known prime factors\n    for factors in known_factors {\n\
    \        // Loop through the factors\n        for factor in factors {\n      \
    \      // If factor is not in the factorization of n, then append factor\n   \
    \         if n % factor == 0 {\n                prime_factors.push(factor);\n\
    \            }\n        }\n        // Add factorization to known factors\n   \
    \     factorization.push(prime_factors);\n    }\n\n    // Return vector of prime\
    \ factors\n    return factorization;\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvaevx3ez.rs:29:12\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n29 |     return factorization;\n\
    \   |            ^^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<_>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = vec![];\n   \
    \ if n == 1 {\n        vec![1]\n    } else if n == 2 {\n        vec![2]\n    }\
    \ else if n % 2 == 0 {\n        vec![2, 3]\n    } else if n % 3 == 0 {\n     \
    \   vec![3, 5]\n    } else {\n        for _ in 0..(n - 1) {\n            let p\
    \ = n % 10;\n            let mut f = vec![];\n            let mut j = 0;\n   \
    \         for i in 0..10 {\n                if i != p && j != 0 {\n          \
    \          f.push(i);\n                    j++;\n                } else if i ==\
    \ p {\n                    f.push(i);\n                    j++;\n            \
    \    }\n            }\n            n = n;\n            f.push(n);\n          \
    \  f = f.reverse();\n        }\n        vec!(f[..])\n    }\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpx5m3ekc2.rs:28:22\n\
    \   |\n28 |                     j++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |               \
    \      { let tmp = j; j += 1; tmp };\n   |                     +++++++++++  ~~~~~~~~~~~~~~~\n\
    28 -                     j++;\n28 +                     j += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmpx5m3ekc2.rs:31:22\n  \
    \ |\n31 |                     j++;\n   |                      ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |                     { let\
    \ tmp = j; j += 1; tmp };\n   |                     +++++++++++  ~~~~~~~~~~~~~~~\n\
    31 -                     j++;\n31 +                     j += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx5m3ekc2.rs:36:17\n   |\n23 |             let\
    \ mut f = vec![];\n   |                         ------ expected due to this value\n\
    ...\n36 |             f = f.reverse();\n   |                 ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx5m3ekc2.rs:38:14\n\
    \   |\n38 |         vec!(f[..])\n   |              ^^^^^ expected `isize`, found\
    \ slice\n   |\n   = note: expected type `isize`\n             found slice `[_]`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    use std::cmp::Ordering;\n\
    \n    let mut primes = Vec::new();\n    primes.push(2); // First prime is 2\n\
    \    primes.push(2); // Second prime is 2\n    for (i, &p) in primes.iter().enumerate()\
    \ {\n        if n == 1 {\n            return vec![2];\n        }\n        if n\
    \ % p == 0 {\n            let mut factors = Vec::new();\n            for _ in\
    \ 0..i {\n                factors.push(p - 1);\n            }\n            factors.push(1);\n\
    \            return factors;\n        }\n    }\n    vec![n]\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpk9n0wuiu.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ret = vec![n];\n\
    \    let mut prime_factors = prime_factorization(n);\n    let mut factors = prime_factors.clone();\n\
    \    while factors.len() > 0 {\n        let mut i = factors.len();\n        while\
    \ i != 0 {\n            i -= 1;\n            let mut cur = prime_factors[factors[i]];\n\
    \            if ret[ret.0 == 0].is_none() {\n                ret.append(cur);\n\
    \            }\n            factors[i] = factors[factors[i]];\n        }\n   \
    \ }\n    ret\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factorization` in this scope\n\
    \  --> /tmp/tmp55bkxz__.rs:12:29\n   |\n12 |     let mut prime_factors = prime_factorization(n);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp55bkxz__.rs:19:24\n\
    \   |\n19 |             if ret[ret.0 == 0].is_none() {\n   |                 \
    \       ^ unknown field\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `bool`\n  --> /tmp/tmp55bkxz__.rs:19:16\n   |\n19 |             if ret[ret.0\
    \ == 0].is_none() {\n   |                ^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `bool`\n   = note: required because of the requirements\
    \ on the impl of `Index<bool>` for `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0609.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![2..(n\
    \ as usize)];\n    for i in 2..n as usize {\n        if n % i == 0 {\n       \
    \     primes.swap(i, primes.iter().filter(|&j| i%j == 0).count());\n        }\n\
    \    }\n    primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp377s0vgq.rs:13:16\n   |\n\
    13 |         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmp377s0vgq.rs:13:14\n\
    \   |\n13 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0277]: cannot mod `usize` by `&std::ops::Range<usize>`\n\
    \  --> /tmp/tmp377s0vgq.rs:14:55\n   |\n14 |             primes.swap(i, primes.iter().filter(|&j|\
    \ i%j == 0).count());\n   |                                                  \
    \     ^ no implementation for `usize % &std::ops::Range<usize>`\n   |\n   = help:\
    \ the trait `Rem<&std::ops::Range<usize>>` is not implemented for `usize`\n  \
    \ = help: the following other types implement trait `Rem<Rhs>`:\n            \
    \ <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp377s0vgq.rs:17:5\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n17 |     primes\n   |     ^^^^^^ expected `isize`,\
    \ found struct `std::ops::Range`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<std::ops::Range<usize>>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `ru"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut fs = vec![n];\n \
    \   let mut f = 1;\n    let mut s = 1;\n\n    while f * f <= n {\n        let\
    \ mut j = f;\n        while j * j <= n {\n            if n % j == 0 {\n      \
    \          s = s * j;\n                fs.push(j);\n            }\n          \
    \  j = j * j;\n        }\n        f = f + 1;\n    }\n\n    if n == 1 {\n     \
    \   fs.push(1);\n    }\n\n    normalize(&mut fs)\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `normalize` in this scope\n  --> /tmp/tmpbiwz9qmm.rs:31:5\n\
    \   |\n31 |     normalize(&mut fs)\n   |     ^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    // First pass: calculate\
    \ products of all factors\n    let mut factors = vec![];\n    let mut product\
    \ = 1;\n    for &c in n.to_string().chars() {\n        if c.is_digit() {\n   \
    \         let digit = c.to_digit(10);\n            product *= digit;\n       \
    \ } else {\n            factors.push(product);\n            product = 1;\n   \
    \     }\n    }\n    factors.push(product);\n\n    // Second pass: for each factor\
    \ calculate how many times it appeared as a factor\n    let mut factors_counts\
    \ = vec![];\n    for &f in factors {\n        let mut count = 0;\n        for\
    \ &c in n.to_string().chars() {\n            if f == c.to_digit(10) {\n      \
    \          count += 1;\n            }\n        }\n        factors_counts.push(count);\n\
    \    }\n\n    factors_counts\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_rfhi6gy.rs:14:9\n   |\n\
    14 |     for &c in n.to_string().chars() {\n   |         ^^    ---------------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_rfhi6gy.rs:27:9\n   |\n\
    27 |     for &f in factors {\n   |         ^^    ------- this expression has type\
    \ `Option<{integer}>`\n   |         |\n   |         expected integer, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `f`\n   |\n \
    \  = note:   expected type `{integer}`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_rfhi6gy.rs:29:13\n   |\n29 |         for &c\
    \ in n.to_string().chars() {\n   |             ^^    --------------------- this\
    \ expression has type `Option<char>`\n   |             |\n   |             expected\
    \ `char`, found reference\n   |             help: you can probably remove the\
    \ explicit borrow: `c`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    factorization(n).iter().take(2).into_iter().for_each(|factor| {\n       \
    \ factors.push(factor);\n    });\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpewx52iu2.rs:12:5\n   |\n12 |     factorization(n).iter().take(2).into_iter().for_each(|factor|\
    \ {\n   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut product = n as usize;\n    let mut i = 1;\n    let mut j = 1;\n \
    \   let mut k = 1;\n    loop {\n        if product % i == 0 {\n            i +=\
    \ 1;\n            j = i;\n        }\n        if product % j == 0 {\n         \
    \   j += 1;\n        }\n        if product % k == 0 {\n            k += 1;\n \
    \       }\n        product /= i;\n        if product < 2 {\n            break;\n\
    \        }\n        result.push(k);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu5crlde2.rs:33:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n33 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    for i in 1..n {\n        for f in factors(i) {\n            if *f == i {\n\
    \                factors.push(i);\n                factors.push(*f);\n       \
    \     }\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0618]: expected function, found `Vec<_>`\n  --> /tmp/tmp2h7sr_2q.rs:13:18\n\
    \   |\n11 |     let mut factors = Vec::new();\n   |         ----------- `factors`\
    \ has type `Vec<_>`\n12 |     for i in 1..n {\n13 |         for f in factors(i)\
    \ {\n   |                  ^^^^^^^---\n   |                  |\n   |         \
    \         call expression requires function\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0618`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    use std::cmp::Ordering::*;\n\
    \n    let mut product = 1;\n    let mut factor = vec![];\n    for i in 1..n {\n\
    \        factor = factor.iter().filter_map(|factor| {\n            product *=\
    \ i;\n            Some(factor)\n        }).collect();\n    }\n    factor = factor.iter().filter_map(|factor|\
    \ {\n        product *= i;\n        Some(factor)\n    }).collect();\n\n    factor.sort_by(|a,\
    \ b| a.cmp(b)).collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpq12ykk2z.rs:22:20\n\
    \   |\n22 |         product *= i;\n   |                    ^ help: a local variable\
    \ with a similar name exists: `n`\n\nwarning: unused import: `std::cmp::Ordering::*`\n\
    \  --> /tmp/tmpq12ykk2z.rs:11:9\n   |\n11 |     use std::cmp::Ordering::*;\n \
    \  |         ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0277]: a value of type `Vec<_>` cannot be built from\
    \ an iterator over elements of type `&_`\n    --> /tmp/tmpq12ykk2z.rs:19:12\n\
    \     |\n19   |         }).collect();\n     |            ^^^^^^^ value of type\
    \ `Vec<_>` cannot be built from `std::iter::Iterator<Item=&_>`\n     |\n     =\
    \ help: the trait `FromIterator<&_>` is not implemented for `Vec<_>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0277]: a value of type `Vec<_>` cannot be built\
    \ from an iterator over elements of type `&_`\n    --> /tmp/tmpq12ykk2z.rs:24:8\n\
    \     |\n24   |     }).collect();\n     |        ^^^^^^^ value of type `Vec<_>`\
    \ cannot be built from `std::iter::Iterator<Item=&_>`\n     |\n     = help: the\
    \ trait `FromIterator<&_>` is not implemented for `Vec<_>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpq12ykk2z.rs:26:37\n\
    \   |\n26 |     factor.sort_by(|a, b| a.cmp(b)).collect::<Vec<isize>>()\n   |\
    \                                     ^^^^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    let mut factor = 1;\n\n    while n > factor {\n        factors.push(factor);\n\
    \        if n % factor == 0 {\n            factor += 1;\n        }\n\n       \
    \ n /= factor;\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpthz7bita.rs:20:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n20 |         n /= factor;\n\
    \   |         ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    factorization::factorize(n).to_vec()\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factorization`\n\
    \  --> /tmp/tmpiksrje0q.rs:11:5\n   |\n11 |     factorization::factorize(n).to_vec()\n\
    \   |     ^^^^^^^^^^^^^ use of undeclared crate or module `factorization`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut n = n;\n    while n > 1 {\n        let mut found = false;\n     \
    \   let mut m = 2;\n        while !found && m <= n {\n            if n % m ==\
    \ 0 {\n                found = true;\n                factors.push(m);\n     \
    \       }\n            m += 1;\n        }\n        n /= 2;\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 2, 7, 3]`,\n right: `[3, 19]`', /tmp/tmpcx5s5_c5.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut res = vec![1isize;\
    \ n + 1];\n    for (i, &factor) in res.iter_mut().zip(factors(n)) {\n        *factor\
    \ = i;\n    }\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n   \
    \ assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpauvioryt.rs:12:44\n\
    \   |\n12 |     for (i, &factor) in res.iter_mut().zip(factors(n)) {\n   |   \
    \                                         ^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpauvioryt.rs:11:32\n   |\n11 |  \
    \   let mut res = vec![1isize; n + 1];\n   |                                ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ res = vec![1isize; (n + 1).try_into().unwrap()];\n   |                     \
    \           +     +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\
    \    let mut x = 2;\n    while x <= n {\n        if n % x == 0 {\n           \
    \ primes.push(x as isize);\n            n /= x;\n        }\n        x += 1;\n\
    \    }\n    primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2tf948jh.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= x;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = Vec::new();\n    let mut factor = 1;\n    loop {\n        if n % factor ==\
    \ 0 {\n            factors.push(factor);\n            n /= factor;\n        }\
    \ else {\n            factors.push(1);\n            factor *= factor;\n      \
    \  }\n        if n == 1 {\n            break;\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpmh4wyqub.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factors = vec![vec![0;\
    \ n]];\n\n    let mut current = 1;\n    while current.is_power_of_two() {\n  \
    \      prime_factors[current.pow() / 2 - 1] += 1;\n        current += 1;\n   \
    \ }\n\n    prime_factors\n}\n\nfn main() {\n    let candidate = factorize;\n \
    \   assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt6pfm2ig.rs:11:42\n   |\n\
    11 |     let mut prime_factors = vec![vec![0; n]];\n   |                     \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut prime_factors = vec![vec![0; n.try_into().unwrap()]];\n   | \
    \                                          ++++++++++++++++++++\n\nerror[E0689]:\
    \ can't call method `is_power_of_two` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpt6pfm2ig.rs:14:19\n   |\n14 |     while current.is_power_of_two()\
    \ {\n   |                   ^^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type\
    \ for this binding, like `i32`\n   |\n13 |     let mut current: i32 = 1;\n   |\
    \         ~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `pow` on ambiguous\
    \ numeric type `{integer}`\n  --> /tmp/tmpt6pfm2ig.rs:15:31\n   |\n15 |      \
    \   prime_factors[current.pow() / 2 - 1] += 1;\n   |                         \
    \      ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n13 |     let mut current: i32 = 1;\n   |         ~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt6pfm2ig.rs:19:5\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n19 |     prime_factors\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0689.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    prime_factorize(n, &mut result);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factorize` in this scope\n  -->\
    \ /tmp/tmpv7cqs76l.rs:12:5\n   |\n12 |     prime_factorize(n, &mut result);\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \    let mut cur = 1;\n    let mut prime_counter = 0;\n    while cur <= n {\n\
    \        if n % cur == 0 {\n            factorization.push(cur);\n           \
    \ prime_counter += 1;\n            while n % cur == 0 {\n                n /=\
    \ cur;\n            }\n        } else {\n            cur *= 2;\n        }\n  \
    \  }\n    if n > 1 {\n        factorization.push(n)\n    }\n    factorization.sort_unstable();\n\
    \    if prime_counter == 0 {\n        factorization.pop()\n    } else {\n    \
    \    factorization\n    }\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1l8x3gbm.rs:30:9\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n30 |         factorization.pop()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found enum `Option<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factorization\
    \ = Vec::new();\n    let mut limit: isize = 1;\n    while limit <= n {\n     \
    \   prime_factorization.push((limit as f64 / n as f64).floor() as isize);\n  \
    \      limit += 1;\n    }\n    prime_factorization\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1]`,\n right: `[2]`', /tmp/tmpbebxsv5t.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = 1i;\n    let\
    \ mut x = n;\n    let mut prime = vec![true; n + 1];\n\n    // Loop while x is\
    \ greater than 1 and all elements of the vector are false.\n    while x != 1 {\n\
    \        // Check if the current number is factor\n        if x % f == 0 {\n \
    \           // Factor found, so increment f\n            f += 1;\n        } else\
    \ {\n            // Factor not found, so mark element as false and increment x\n\
    \            prime[x] = false;\n            x += 1;\n        }\n    }\n\n    //\
    \ Factor found, so increment f\n    f += 1;\n\n    // Prime factors are found\
    \ by incrementing f, so just copy the relevant elements.\n    prime.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `i` for number literal\n  --> /tmp/tmp8lsrcd8o.rs:11:17\n\
    \   |\n11 |     let mut f = 1i;\n   |                 ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8lsrcd8o.rs:13:32\n\
    \   |\n13 |     let mut prime = vec![true; n + 1];\n   |                     \
    \           ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     let mut prime = vec![true; (n + 1).try_into().unwrap()];\n   |      \
    \                          +     +++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmp8lsrcd8o.rs:23:13\n   |\n\
    23 |             prime[x] = false;\n   |             ^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `bool`\n    --> /tmp/tmp8lsrcd8o.rs:32:27\n\
    \     |\n32   |     prime.iter().cloned().collect()\n     |                  \
    \         ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=bool>`\n\
    \     |\n     = help: the trait `FromIterator<bool>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \    let mut prev_factor = 2;\n    while n % prev_factor != 0 {\n        factorization.push(n\
    \ % prev_factor);\n        n /= prev_factor;\n        prev_factor *= 2;\n    }\n\
    \    factorization.push(1);\n    factorization\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpaekrou31.rs:15:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |         n /= prev_factor;\n\
    \   |         ^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 2..=n {\n        if n % i == 0 {\n            result.push(i);\n\
    \            n /= i;\n        }\n    }\n    result.push(1);\n    result\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpskqlcj7w.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: -1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    for factor in factorize(n) {\n        v.push(factor);\n    }\n    v\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976140
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    if n < 1 {\n        return\
    \ vec![];\n    }\n    let mut ans = vec![0; n + 1];\n    ans[0] = 1;\n    for\
    \ i in 2..n + 1 {\n        if ans[i] != 0 {\n            for j in ans.iter().cloned().skip(i)\
    \ {\n                ans[j] /= i;\n            }\n        }\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwa_3g339.rs:14:27\n   |\n\
    14 |     let mut ans = vec![0; n + 1];\n   |                           ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |     let mut ans = vec![0;\
    \ (n + 1).try_into().unwrap()];\n   |                           +     +++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpwa_3g339.rs:17:12\n\
    \   |\n17 |         if ans[i] != 0 {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwa_3g339.rs:18:47\n   |\n18 |             for j in ans.iter().cloned().skip(i)\
    \ {\n   |                                               ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |             for j in ans.iter().cloned().skip(i.try_into().unwrap())\
    \ {\n   |                                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwa_3g339.rs:19:27\n   |\n19 |\
    \                 ans[j] /= i;\n   |                           ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot divide-assign `usize` by `isize`\n  -->\
    \ /tmp/tmpwa_3g339.rs:19:24\n   |\n19 |                 ans[j] /= i;\n   |   \
    \                     ^^ no implementation for `usize /= isize`\n   |\n   = help:\
    \ the trait `DivAssign<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `DivAssign<Rhs>`:\n             <f32 as\
    \ DivAssign<&f32>>\n             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n\
    \             <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n  \
    \           <i128 as DivAssign>\n       "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    for i in (1..=n).rev() {\n        if n % i == 0 {\n            let mut factor\
    \ = 1;\n            while i /= i {\n                factor *= i;\n           \
    \ }\n            factors.push(factor);\n        }\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_7alel1o.rs:15:19\n   |\n\
    15 |             while i /= i {\n   |                   ^^^^^^ expected `bool`,\
    \ found `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![];\n\
    \    let mut factors = vec![];\n\n    fn is_prime(n: isize) -> bool {\n      \
    \  let mut i = 2;\n        while i * i < n {\n            if n % i == 0 {\n  \
    \              return false;\n            }\n            i += 1;\n        }\n\
    \        true\n    }\n\n    if n < 2 {\n        return vec![];\n    }\n\n    let\
    \ mut p1 = 1;\n    let mut p2 = 2;\n    while p2 < n {\n        if n % p2 == 0\
    \ {\n            factors.push(p2);\n            p2 = p2 * p2;\n            continue;\n\
    \        }\n        while n % p2 == 0 {\n            n /= p2;\n            p2\
    \ = p2 * p2;\n        }\n        p1 = p1 + 1;\n        factors.push(p1);\n   \
    \ }\n    if is_prime(n) {\n        primes.push(n);\n    }\n    for i in factors.iter()\
    \ {\n        primes.push(i as isize);\n    }\n    primes\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmph386uz9g.rs:48:21\n\
    \   |\n48 |         primes.push(i as isize);\n   |                     -^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&isize` as\
    \ `isize`\n   |                     help: dereference the expression: `*i`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \n    for i in 2..=n {\n        if n % i == 0 {\n            let mut j = i;\n\
    \            while j > 1 {\n                if n % j == 0 {\n                \
    \    result.push(j);\n                    break;\n                }\n        \
    \        j -= 1;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[2, 2]`', /tmp/tmp1_aoc17d.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    factorize(n, vec![])\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp2auhktnn.rs:11:5\n   |\n11 |     factorize(n, vec![])\n   |   \
    \  ^^^^^^^^^ -  ------ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmp2auhktnn.rs:10:4\n   |\n10 |\
    \ fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut factor: isize = 0;\n    let mut num_factor = 1;\n    let mut max_num_factor\
    \ = 1;\n    let mut i = 1;\n    while num_factor < n {\n        while n % i ==\
    \ 0 {\n            result.push(i);\n            n /= i;\n            i += 1;\n\
    \        }\n        num_factor += 1;\n        max_num_factor += 1;\n    }\n  \
    \  while num_factor > max_num_factor {\n        factor *= i;\n        n /= i;\n\
    \        i += 1;\n    }\n    result.push(i);\n    result\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `factor` is assigned to, but never used\n  --> /tmp/tmpsguzeqr8.rs:12:13\n\
    \   |\n12 |     let mut factor: isize = 0;\n   |             ^^^^^^\n   |\n  \
    \ = note: `#[warn(unused_variables)]` on by default\n   = note: consider using\
    \ `_factor` instead\n\nerror[E0384]: cannot assign to immutable argument `n`\n\
    \  --> /tmp/tmpsguzeqr8.rs:19:13\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |              - help: consider making this binding mutable: `mut n`\n\
    ...\n19 |             n /= i;\n   |             ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsguzeqr8.rs:27:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n27 |         n /= i;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    let mut factors = Vec::new();\n    let mut factorizer = prime_factorization();\n\
    \    let mut n = n - 1;\n    factorizer = factor_gen(factorizer, &mut factors);\n\
    \    for _ in 0..n {\n        let mut v = Vec::new();\n        for &r in &factors\
    \ {\n            if n % r == 0 {\n                v.push(*r);\n            }\n\
    \        }\n        v.sort();\n        factors = v;\n        n = n - 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factorization` in this scope\n\
    \  --> /tmp/tmp0xcuup_k.rs:13:26\n   |\n13 |     let mut factorizer = prime_factorization();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `factor_gen` in this scope\n  --> /tmp/tmp0xcuup_k.rs:15:18\n\
    \   |\n15 |     factorizer = factor_gen(factorizer, &mut factors);\n   |     \
    \             ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\
    \    let mut factors = Vec::new();\n    let mut factor = 1;\n    let mut p = 1isize;\n\
    \    while p <= n {\n        if n % p == 0 {\n            factors.push(factor);\n\
    \            primes.push(p);\n            factor = 1;\n        }\n        factor\
    \ *= p;\n        p += 1;\n    }\n    primes.push(factor);\n    return primes\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[2]`', /tmp/tmpdrclelmt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut facs = Vec::new();\n\
    \    for (i, d) in factorization(n.clone()) {\n        if i % d == 0 {\n     \
    \       let mut n = d.clone();\n            while n % d == 0 {\n             \
    \   n /= d;\n                facs.push(n);\n            }\n        }\n    }\n\
    \    facs\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpeutn2djl.rs:12:19\n   |\n12 |     for (i, d) in factorization(n.clone())\
    \ {\n   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![1isize;\
    \ n];\n    for i in 2..=n {\n        if n % i == 0 {\n            factorization[i]\
    \ = i * factorization[n - i];\n        }\n    }\n    factorization\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzoobbldq.rs:11:42\n   |\n\
    11 |     let mut factorization = vec![1isize; n];\n   |                      \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut factorization = vec![1isize; n.try_into().unwrap()];\n   |  \
    \                                         ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzoobbldq.rs:14:13\n\
    \   |\n14 |             factorization[i] = i * factorization[n - i];\n   |   \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzoobbldq.rs:14:36\n\
    \   |\n14 |             factorization[i] = i * factorization[n - i];\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut i = 1;\n    while i * i <= n {\n        while n % i == 0 {\n    \
    \        n /= i;\n            factors.push(i);\n        }\n        i += 1;\n \
    \   }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgrkf1wta.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    loop {\n        if n % 2 == 0 {\n            factors.push(2);\n         \
    \   n /= 2;\n        }\n        if n % 3 == 0 {\n            factors.push(3);\n\
    \            n /= 3;\n        }\n        if n % 5 == 0 {\n            factors.push(5);\n\
    \            n /= 5;\n        }\n        if n % 7 == 0 {\n            factors.push(7);\n\
    \            n /= 7;\n        }\n        if n == 1 {\n            break;\n   \
    \     }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp9_kut2_y.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmp9_kut2_y.rs:19:13\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |             n /= 3;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp9_kut2_y.rs:23:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n23 |             n /= 5;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp9_kut2_y.rs:27:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n27 |             n /= 7;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut f = Vec::new();\n\
    \    let mut res = Vec::new();\n    let mut factors = Vec::new();\n    let mut\
    \ x = 1;\n    for i in 0..n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            x /= i;\n        }\n    }\n\n    for i in 0..factors.len() {\n  \
    \      while x != 1 {\n            if x % factors[i] == 0 {\n                break;\n\
    \            }\n            factors.push(i);\n            x /= factors[i];\n \
    \       }\n        res.push(factors[i]);\n    }\n\n    return res\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprs3ko6ar.rs:27:26\n   |\n\
    27 |             factors.push(i);\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |             factors.push(i.try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![2;\
    \ n / 2];\n    let mut current = 1;\n    let mut nxt = 2;\n    while nxt < n {\n\
    \        factorization[nxt] = current;\n        while current % nxt == 0 {\n \
    \           current += 1;\n        }\n        current += 1;\n        nxt += 1;\n\
    \    }\n    if current < n {\n        factorization[nxt] = current;\n    }\n \
    \   factorization\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp744juui6.rs:11:37\n   |\n\
    11 |     let mut factorization = vec![2; n / 2];\n   |                       \
    \              ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut factorization = vec![2; (n / 2).try_into().unwrap()];\n   | \
    \                                    +     +++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp744juui6.rs:15:9\n\
    \   |\n15 |         factorization[nxt] = current;\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp744juui6.rs:23:9\n\
    \   |\n23 |         factorization[nxt] = current;\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \n    if n % 2 == 0 {\n        factorization.push(2);\n    }\n\n    for i in 3\
    \ .. n/2 {\n        if n % i == 0 {\n            factorization.push(i);\n    \
    \        n /= i;\n        }\n    }\n    factorization.push(n);\n\n    factorization\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppkvb0iqs.rs:20:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n20 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for factor in factorization(n) {\n        let mut factor_count = 0;\n   \
    \     for &d in factor {\n            factor_count += 1;\n        }\n        result.push(*factor_count);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpu68as9gj.rs:12:19\n   |\n12 |     for factor in factorization(n) {\n\
    \   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpu68as9gj.rs:17:21\n \
    \  |\n17 |         result.push(*factor_count);\n   |                     ^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0614.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factors = vec![];\n\
    \    let mut product = 1;\n    let mut f = 1;\n    while f * f <= n {\n      \
    \  product = product * f;\n        f++;\n    }\n    for f in 2..n {\n        if\
    \ n % f == 0 {\n            prime_factors.push(f as isize);\n            n = n\
    \ / f;\n        }\n    }\n    if n > 1 {\n        prime_factors.push(n);\n   \
    \ }\n    prime_factors\n}\n\nfn main() {\n    let candidate = factorize;\n   \
    \ assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpckghgxki.rs:16:10\n\
    \   |\n16 |         f++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n16 |         { let tmp = f; f += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n16 -         f++;\n16 +         f +=\
    \ 1;\n   | \n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = Vec::new();\n    let mut divisor = 1;\n    while divisor * divisor <= n {\n\
    \        if n % divisor == 0 {\n            factors.push(divisor);\n         \
    \   n /= divisor;\n        } else {\n            divisor += 1;\n        }\n  \
    \  }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_zj3pwvu.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= divisor;\n\
    \   |             ^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    fn prime_divisors_helper(limit:\
    \ isize, primes: Vec<isize>) -> isize {\n        if limit == 0 {\n           \
    \ return primes.len();\n        }\n        primes.iter().skip(1).cloned().filter(|&d|\
    \ {\n            n % d != 0\n        }).count().cloned()\n    }\n    fn prime_divisors_helper_vec(limit:\
    \ isize, primes: Vec<isize>) -> Vec<isize> {\n        if limit == 0 {\n      \
    \      return primes.clone();\n        }\n        let mut vec = primes.clone();\n\
    \        vec.iter().skip(1).cloned().filter(|&d| {\n            n % d != 0\n \
    \       }).cloned().for_each(|&d| {\n            vec.remove(d);\n        });\n\
    \        vec\n    }\n\n    if n < 2 {\n        return vec![1];\n    }\n    if\
    \ n == 2 {\n        return vec![2];\n    }\n\n    if n % 2 == 0 {\n        return\
    \ vec![2];\n    }\n    if n == 1 {\n        return vec![1];\n    }\n\n    let\
    \ mut primes: Vec<isize> = vec![1];\n    primes.push((n - 2) / 2);\n    primes.extend_from_slice(2..n\
    \ as usize);\n    primes.sort();\n    let result = prime_divisors_helper(n * 2,\
    \ primes);\n    let result_vec = prime_divisors_helper_vec(n * 2, primes);\n \
    \   if result_vec == result {\n        return result;\n    }\n    else {\n   \
    \     return result_vec;\n    }\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmp456qgnm5.rs:16:13\n\
    \   |\n16 |             n % d != 0\n   |             ^\n   |\n   = help: use the\
    \ `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic environment\
    \ in a fn item\n  --> /tmp/tmp456qgnm5.rs:25:13\n   |\n25 |             n % d\
    \ != 0\n   |             ^\n   |\n   = help: use the `|| { ... }` closure form\
    \ instead\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp456qgnm5.rs:48:30\n\
    \   |\n48 |     primes.extend_from_slice(2..n as usize);\n   |               \
    \               ^^^^^^^^^^^^^ expected `&[isize]`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected reference `&[isize]`\n                 found struct\
    \ `std::ops::Range<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp456qgnm5.rs:53:16\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n53 |    \
    \     return result;\n   |                ^^^^^^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `isize`\n\nerror[E0277]: can't compare `Vec<isize>` with `isize`\n  -->\
    \ /tmp/tmp456qgnm5.rs:52:19\n   |\n52 |     if result_vec == result {\n   |  \
    \                 ^^ no implementation for `Vec<isize> == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `Vec<isize>`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <Vec<T,\
    \ A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n\
    \             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut\
    \ [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A>\
    \ as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp456qgnm5.rs:13:20\n\
    \   |\n11 |     fn prime_divisors_helper(limit: isize, primes: Vec<isize>) ->\
    \ isize {\n   |                                                              \
    \     ----- expected `isize` because of return type\n12 |         if limit ==\
    \ 0 {\n13 |             return"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut prime_factors = Vec::with_capacity(n\
    \ as usize);\n\n    for factor_index in 1..=n {\n        if n % factor_index ==\
    \ 0 {\n            prime_factors.push(factor_index);\n            n /= factor_index;\n\
    \        }\n    }\n\n    if n == 1 {\n        prime_factors.push(1);\n    }\n\n\
    \    prime_factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpkuem_206.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor_index;\n\
    \   |             ^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ret: Vec<isize> =\
    \ Vec::new();\n    loop {\n        let mut f = factorize_prime(n);\n        if\
    \ let Some(factor) = f {\n            ret.push(factor);\n            n = n * factor;\n\
    \        } else {\n            break;\n        }\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorize_prime` in this scope\n  -->\
    \ /tmp/tmpt5o8qe2d.rs:13:21\n   |\n13 |         let mut f = factorize_prime(n);\n\
    \   |                     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    assert!(n % 2 == 0);\n  \
    \  let mut factors = vec![];\n    let mut current_factor = n;\n\n    while current_factor\
    \ != 1 {\n        let mut current_power = 1;\n        while current_power < current_factor\
    \ {\n            current_factor *= current_power;\n            current_power +=\
    \ 1;\n        }\n        factors.push(current_factor);\n        current_factor--;\n\
    \    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpuslmoalw.rs:22:25\n\
    \   |\n22 |         current_factor--;\n   |                         ^ expected\
    \ expression\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    factorize(&mut v, n, 1, 1);\n    v\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 4 arguments were supplied\n\
    \  --> /tmp/tmpjzna2ljq.rs:12:5\n   |\n12 |     factorize(&mut v, n, 1, 1);\n\
    \   |     ^^^^^^^^^ ------  -  -  - supplied 4 arguments\n   |     |\n   |   \
    \  expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpjzna2ljq.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n\
    \    let mut product_of_all_factors = 1;\n    let mut current_product_of_all_factors\
    \ = 1;\n    let mut num_times_current_factor_was_found = 0;\n    let mut min_divisor\
    \ = 0;\n\n    while current_product_of_all_factors <= n {\n        if current_product_of_all_factors\
    \ == 0 {\n            factors.push(1);\n            continue;\n        }\n\n \
    \       min_divisor = current_product_of_all_factors;\n        let mut current_product_of_all_factors\
    \ = 0;\n\n        for divisor in &mut factors {\n            while n % divisor\
    \ == 0 {\n                n /= divisor;\n                factors.push(divisor);\n\
    \                current_product_of_all_factors += 1;\n                num_times_current_factor_was_found\
    \ += 1;\n            }\n        }\n\n        if num_times_current_factor_was_found\
    \ > factors.len() {\n            factors.push(min_divisor);\n        }\n\n   \
    \     current_product_of_all_factors += 1;\n    }\n\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `isize` by `&mut {integer}`\n  --> /tmp/tmpsr84o5ft.rs:27:21\n\
    \   |\n27 |             while n % divisor == 0 {\n   |                     ^ no\
    \ implementation for `isize % &mut {integer}`\n   |\n   = help: the trait `Rem<&mut\
    \ {integer}>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n          \
    \   <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n            \
    \ <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a\
    \ i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a isize\
    \ as Rem<isize>>\n           and 54 others\n\nerror[E0277]: cannot divide-assign\
    \ `isize` by `&mut {integer}`\n  --> /tmp/tmpsr84o5ft.rs:28:19\n   |\n28 |   \
    \              n /= divisor;\n   |                   ^^ no implementation for\
    \ `isize /= &mut {integer}`\n   |\n   = help: the trait `DivAssign<&mut {integer}>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n           \
    \  <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n             <f64\
    \ as DivAssign>\n             <i128 as DivAssign<&i128>>\n             <i128 as\
    \ DivAssign>\n             <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsr84o5ft.rs:29:30\n\
    \   |\n29 |                 factors.push(divisor);\n   |                     \
    \         ^^^^^^^ expected integer, found `&mut {integer}`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n29 |                 factors.push(*divisor);\n\
    \   |                              +\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = vec![n];\n    let mut primes: Vec<isize> = vec![n];\n    let mut primes_cnt:\
    \ usize = 0;\n\n    // get prime factors\n    factors.push(n);\n    while n %\
    \ 2 == 0 {\n        factors.push(2);\n        n /= 2;\n    }\n    for prime in\
    \ &primes[..] {\n        if n < prime {\n            factors.push(prime);\n  \
    \          break;\n        }\n        for &j in &factors[..] {\n            if\
    \ j == prime {\n                factors.push(prime);\n                n /= prime;\n\
    \                break;\n            }\n        }\n    }\n\n    // add remainder\
    \ to the prime factors and update prime count\n    for i in &factors[..] {\n \
    \       if n >= i {\n            factors.push(i);\n            primes_cnt += 1;\n\
    \            n -= i;\n        }\n    }\n\n    if n > 1 {\n        // add rest\
    \ of number\n        factors.push(n);\n        primes_cnt += 1;\n    }\n\n   \
    \ factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2o1hmg_r.rs:22:16\n   |\n\
    22 |         if n < prime {\n   |                ^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |        \
    \ if n < *prime {\n   |                +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp2o1hmg_r.rs:23:26\n   |\n23 |             factors.push(prime);\n\
    \   |                          ^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n23 |             factors.push(*prime);\n\
    \   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2o1hmg_r.rs:27:21\n\
    \   |\n27 |             if j == prime {\n   |                     ^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    27 |             if j == *prime {\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2o1hmg_r.rs:28:30\n   |\n28 |              \
    \   factors.push(prime);\n   |                              ^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |  \
    \               factors.push(*prime);\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2o1hmg_r.rs:37:17\n   |\n37 |  \
    \       if n >= i {\n   |                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n37 |         if n >= *i\
    \ {\n   |                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2o1hmg_r.rs:38:26\n\
    \   |\n38 |             factors.push(i);\n   |                          ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    38 |             factors.push(*i);\n   |                          +\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut facs = vec![0; n];\n\
    \    let mut m = 1;\n    for &i in facs {\n        i += 1;\n        while m <=\
    \ i {\n            m += 1;\n            facs[i / m as usize] += 1;\n        }\n\
    \    }\n    facs\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbodq8oyw.rs:11:28\n   |\n\
    11 |     let mut facs = vec![0; n];\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut facs =\
    \ vec![0; n.try_into().unwrap()];\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbodq8oyw.rs:13:9\n   |\n13 | \
    \    for &i in facs {\n   |         ^^    ---- this expression has type `Option<{integer}>`\n\
    \   |         |\n   |         expected integer, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `{integer}`\n           found reference `&_`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut res = vec![];\n \
    \   for i in 2..=n {\n        if n % i == 0 {\n            res.push(i);\n    \
    \        n /= i;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpftj240gt.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = vec![vec![0;\
    \ n]; n + 1];\n\n    for i in 0..n {\n        let mut k = i;\n        while k\
    \ > 0 {\n            if factorization[n - k].iter().all(|&x| n == x) {\n     \
    \           factorization[n] += 1;\n                break;\n            }\n  \
    \          k = factorization[n - k - 1].iter().filter(|&x| x == 0).count();\n\
    \        }\n    }\n\n    factorization.iter()\n        .filter(|&x| x.len() >\
    \ 1)\n        .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4bswuo8s.rs:11:42\n   |\n\
    11 |     let mut factorization = vec![vec![0; n]; n + 1];\n   |              \
    \                            ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut factorization = vec![vec![0; n.try_into().unwrap()];\
    \ n + 1];\n   |                                           ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4bswuo8s.rs:11:46\n   |\n11 |\
    \     let mut factorization = vec![vec![0; n]; n + 1];\n   |                 \
    \                             ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut factorization = vec![vec![0; n]; (n + 1).try_into().unwrap()];\n\
    \   |                                              +     +++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp4bswuo8s.rs:16:16\n   |\n16 |             if factorization[n - k].iter().all(|&x|\
    \ n == x) {\n   |                ^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4bswuo8s.rs:17:17\n   |\n17 |  \
    \               factorization[n] += 1;\n   |                 ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp4"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \n    let mut n = n % isize::MAX;\n    while n > 0 {\n        let f = factor(n,\
    \ &mut factors);\n        n /= f;\n    }\n\n    factors\n}\n\nfn main() {\n  \
    \  let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factor` in this scope\n  --> /tmp/tmpv3w2i4lk.rs:15:17\n\
    \   |\n15 |         let f = factor(n, &mut factors);\n   |                 ^^^^^^\
    \ help: a local variable with a similar name exists: `factors`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut divisor = 1;\n    for _ in 0..n {\n        while n % divisor == 0\
    \ {\n            result.push(n);\n            n /= divisor;\n        }\n     \
    \   divisor += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpd2d7dwtk.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= divisor;\n\
    \   |             ^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: -1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut p = n;\n    let mut\
    \ f = 1;\n    let mut fa = Vec::new();\n    while p > 1 {\n        if p % 2 ==\
    \ 1 {\n            f *= 2;\n            p /= 2;\n        }\n        else {\n \
    \           fa = factorize(p);\n            if fa.iter().any(|x| *x == p) {\n\
    \                p = p;\n            }\n            else {\n                f\
    \ *= p;\n                p /= fa[0];\n            }\n        }\n    }\n    fa.push(f\
    \ as isize);\n    fa\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976140
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut vec = vec![0; n];\n\
    \    for i in (1..).rev() {\n        if n % i == 0 {\n            vec.push(i);\n\
    \            n /= i;\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu166zjby.rs:11:27\n   |\n\
    11 |     let mut vec = vec![0; n];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut vec = vec![0;\
    \ n.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0277]: the trait bound `RangeFrom<{integer}>: DoubleEndedIterator` is\
    \ not satisfied\n    --> /tmp/tmpu166zjby.rs:12:20\n     |\n12   |     for i in\
    \ (1..).rev() {\n     |                    ^^^ the trait `DoubleEndedIterator`\
    \ is not implemented for `RangeFrom<{integer}>`\n     |\nnote: required by a bound\
    \ in `rev`\n\nerror[E0277]: the trait bound `RangeFrom<{integer}>: DoubleEndedIterator`\
    \ is not satisfied\n  --> /tmp/tmpu166zjby.rs:12:14\n   |\n12 |     for i in (1..).rev()\
    \ {\n   |              ^^^^^^^^^^^ the trait `DoubleEndedIterator` is not implemented\
    \ for `RangeFrom<{integer}>`\n   |\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Rev<RangeFrom<{integer}>>`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `Rev<RangeFrom<{integer}>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    assert!(n % 2 == 0);\n  \
    \  let mut factors = Vec::new();\n    let mut factor = 1;\n    while n != 1 {\n\
    \        if n % factor == 0 {\n            factors.push(factor);\n           \
    \ n = n / factor;\n        } else {\n            factor *= 2;\n        }\n   \
    \ }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpkiiqd7yd.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n = n /\
    \ factor;\n   |             ^^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::with_capacity(n\
    \ as usize);\n    let mut remaining = n;\n    for _ in 0..(remaining / 2) {\n\
    \        if n % 2 == 1 {\n            factors.push(2);\n            remaining\
    \ /= 2;\n        } else {\n            factors.push(1);\n            remaining\
    \ /= 2;\n        }\n    }\n    while remaining > 1 {\n        if n % 2 == 1 {\n\
    \            if remaining % 2 == 1 {\n                factors.push(2);\n     \
    \           remaining /= 2;\n            } else {\n                factors.push(1);\n\
    \                remaining /= 2;\n            }\n        } else {\n          \
    \  if remaining % 2 == 1 {\n                factors.push(2);\n               \
    \ remaining /= 2;\n            } else {\n                factors.push(1);\n  \
    \              remaining /= 2;\n            }\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmp19pbyein.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![true;\
    \ n + 1];\n\n    for i in 2..n+1 {\n        if primes[i] == true {\n         \
    \   primes[i] = false;\n\n            // remove multiples of i from factorization\
    \ and calculate new prime factors\n            for p in &primes[i..].rev() {\n\
    \                if !p % i {\n                    break;\n                }\n\
    \                primes[p] = false;\n            }\n        }\n    }\n\n    primes\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm_wn5h9i.rs:11:33\n   |\n\
    11 |     let mut primes = vec![true; n + 1];\n   |                           \
    \      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut primes = vec![true; (n + 1).try_into().unwrap()];\n   |                \
    \                 +     +++++++++++++++++++++\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpm_wn5h9i.rs:14:12\n   |\n14 |  \
    \       if primes[i] == true {\n   |            ^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpm_wn5h9i.rs:15:13\n   |\n15 |            \
    \ primes[i] = false;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `RangeFrom<isize>`\n  --> /tmp/tmpm_wn5h9i.rs:18:23\n   |\n18 | \
    \            for p in &primes[i..].rev() {\n   |                       ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `RangeFrom<isize>`\n   = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n             <RangeFrom<usize>\
    \ as SliceIndex<[T]>>\n             <RangeFrom<usize> as SliceIndex<str>>\n  \
    \ = note: required because of the requirements on the impl of `Index<RangeFrom<isize>>`\
    \ for `Vec<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm_wn5h9i.rs:27:5\n\
    \   |\n10 | fn factorize(n: isize) -> Ve"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![n];\n\
    \    let mut factors = vec![n];\n    primes[0] += 2;\n    factors[0] += 2;\n \
    \   for i in 1..n {\n        for j in primes.iter().rev().skip(primes.len() -\
    \ i) {\n            if n % j == 0 {\n                factors[j] += 1;\n      \
    \          break;\n            }\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplcwan4h6.rs:16:58\n   |\n\
    16 |         for j in primes.iter().rev().skip(primes.len() - i) {\n   |     \
    \                                                     ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmplcwan4h6.rs:16:56\n\
    \   |\n16 |         for j in primes.iter().rev().skip(primes.len() - i) {\n  \
    \ |                                                        ^ no implementation\
    \ for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmplcwan4h6.rs:18:17\n   |\n18 |                 factors[j] += 1;\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n\
    \    if n < 2 {\n        return factorization;\n    }\n    let mut prime_factors\
    \ = vec![2];\n    let mut is_prime = true;\n    let mut prime_factor = prime_factors.clone();\n\
    \    while is_prime && n != 1 {\n        let mut to_be_divided = n - 1;\n    \
    \    while to_be_divided != 1 {\n            if to_be_divided % prime_factor.len()\
    \ == 0 {\n                factorization.push(prime_factor.len());\n          \
    \      prime_factor = prime_factor.clone();\n            }\n            to_be_divided\
    \ /= prime_factor.len();\n        }\n        is_prime = !is_prime;\n        if\
    \ is_prime {\n            prime_factors.push(2);\n        }\n    }\n    factorization\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_y5r5rt.rs:21:32\n   |\n\
    21 |             if to_be_divided % prime_factor.len() == 0 {\n   |          \
    \                      ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\n\
    error[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpe_y5r5rt.rs:21:30\n\
    \   |\n21 |             if to_be_divided % prime_factor.len() == 0 {\n   |   \
    \                           ^ no implementation for `isize % usize`\n   |\n  \
    \ = help: the trait `Rem<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Rem<Rhs>`:\n             <&'a f32 as\
    \ Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n\
    \             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n    \
    \         <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n          \
    \   <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe_y5r5rt.rs:22:36\n   |\n22 |                 factorization.push(prime_factor.len());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |                 factorization.push(prime_factor.len().try_into().unwrap());\n\
    \   |                                                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe_y5r5rt.rs:25:30\n   |\n25 |\
    \             to_be_divided /= prime_factor.len();\n   |                     \
    \         ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot divide-assign `isize` by `usize`\n  --> /tmp/tmpe_y5r5rt.rs:25:27\n \
    \  |\n25 |             to_be_divided /= prime_factor.len();\n   |            \
    \               ^^ no implementation for `isize /= usize`\n   |\n   = help: the\
    \ trait `DivAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n\
    \             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n     "
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut fred: Vec<isize>\
    \ = vec![1; n];\n    for i in 1..=n {\n        for j in 0..i {\n            if\
    \ fred[j] > 1 {\n                fred[j] += fred[j - i];\n                break;\n\
    \            }\n        }\n    }\n    if fred[0] != 1 {\n        Vec::new()\n\
    \    } else {\n        let mut ret: Vec<isize> = vec![n];\n        for i in 1..=n\
    \ {\n            if fred[i] == 1 {\n                for j in 0..i {\n        \
    \            if fred[j] == 1 {\n                        ret[i] = ret[i] + j;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        ret\n    }\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt5ai1bon.rs:11:40\n   |\n\
    11 |     let mut fred: Vec<isize> = vec![1; n];\n   |                        \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut fred: Vec<isize> = vec![1; n.try_into().unwrap()];\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpt5ai1bon.rs:14:16\n\
    \   |\n14 |             if fred[j] > 1 {\n   |                ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpt5ai1bon.rs:15:17\n   |\n15 |            \
    \     fred[j] += fred[j - i];\n   |                 ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpt5ai1bon.rs:15:28\n   |\n15 |            \
    \     fred[j] += fred[j - i];\n   |                            ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt5ai1bon.rs:25:16\n   |\n25 |  \
    \           if fred[i] == 1 {\n   |                ^^^^^^^ slice indices are of\
    \ type `usize` or ranges of"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\
    \    for &i in prime_factors(n) {\n        for j in i {\n            primes.push(j);\n\
    \        }\n    }\n    primes\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n  -->\
    \ /tmp/tmp5upa4dqa.rs:12:15\n   |\n12 |     for &i in prime_factors(n) {\n   |\
    \               ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 101
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut facs = vec![n];\n\
    \n    let mut d = 1;\n    let mut i = 2;\n    while i <= n {\n        if n % i\
    \ == 0 {\n            facs[d] = i;\n            d += 1;\n        }\n\n       \
    \ i += 1;\n    }\n\n    facs\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpvvq0skop.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976135
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut primes = vec![true;\
    \ n];\n    let mut result = vec![0; n];\n    for i in 2..=n {\n        if primes[i]\
    \ == true {\n            let mut r = 1;\n            for j in (i + 1)..n {\n \
    \               if primes[j] == false && j * i < n {\n                    r *=\
    \ j;\n                    primes[j] = true;\n                }\n            }\n\
    \            result[i] = r;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjv3lr3jw.rs:11:33\n   |\n\
    11 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjv3lr3jw.rs:12:30\n\
    \   |\n12 |     let mut result = vec![0; n];\n   |                           \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut result = vec![0; n.try_into().unwrap()];\n   |                         \
    \      ++++++++++++++++++++\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpjv3lr3jw.rs:14:12\n   |\n14 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpjv3lr3jw.rs:17:20\n   |\n17 |                 if primes[j] == false\
    \ && j * i < n {\n   |                    ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjv3lr3jw.rs:19:21\n   |\n19 |            \
    \         primes[j] = true;\n   |                     ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut ans = vec![];\n \
    \   for factor in factorization(n).iter().rev() {\n        for _ in 0..factor\
    \ {\n            ans.push(factor);\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmp0pjkxs3i.rs:12:19\n   |\n12 |     for factor in factorization(n).iter().rev()\
    \ {\n   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\
    \    factorize(n, 0, &mut factors);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmp6jals2ey.rs:12:5\n   |\n12 |     factorize(n, 0, &mut factors);\n\
    \   |     ^^^^^^^^^ -  -  ------------ supplied 3 arguments\n   |     |\n   |\
    \     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp6jals2ey.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976134
- exit_code: 1
  program: "/// Return vector of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be vectored number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2,\
    \ 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors: Vec<isize>\
    \ = vec![];\n    for &n in &factors {\n        factors.push((n - 1) / n);\n  \
    \  }\n    return factors\n}\n\nfn main() {\n    let candidate = factorize;\n \
    \   assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `n`\n  --> /tmp/tmp33hr2rgp.rs:10:14\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |              ^ help: if this\
    \ is intentional, prefix it with an underscore: `_n`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `factors` as mutable because it\
    \ is also borrowed as immutable\n  --> /tmp/tmp33hr2rgp.rs:13:9\n   |\n12 |  \
    \   for &n in &factors {\n   |               --------\n   |               |\n\
    \   |               immutable borrow occurs here\n   |               immutable\
    \ borrow later used here\n13 |         factors.push((n - 1) / n);\n   |      \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976134
