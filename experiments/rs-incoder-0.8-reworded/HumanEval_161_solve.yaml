name: HumanEval_161_solve
language: rs
prompt: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n///\
  \ String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
  AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
  \ String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
  AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
  )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
  AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
  ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
  ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
  \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
  \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"
completions: ["    let mut s = String::from(s);\n    for (i, &c) in s.chars().enumerate()\
    \ {\n        let (lower, upper) = if c.is_ascii_lowercase() { (true, false) }\
    \ else { (false, true) };\n        s = s.split_at_chars(i).fold(s, |s, c| s.chars().next().map(|c|\
    \ if lower { c.to_ascii_lowercase().collect() } else { c.to_ascii_uppercase().collect()\
    \ }).collect());\n    }\n    s", '    solve_internal(s.chars().collect::<Vec<_>>()).to_string()',
  "    s.chars()\n        .filter_map(|&c| {\n            match c {\n            \
    \    'a' => Some('b'),\n                'b' => Some('a'),\n                _ =>\
    \ Some(c),\n            }\n        })\n        .fold(String::new(), |acc, &c|\
    \ {\n            acc.insert(0, &c.to_string());\n            acc\n        })",
  "    if s.is_empty() {\n        String::new()\n    } else {\n        let mut new_s\
    \ = s;\n        let mut last_char = false;\n        for c in s.chars() {\n   \
    \         if !c.is_ascii_lowercase() {\n                new_s = new_s.chars().map(|x|\
    \ match x {\n                    'A' => {\n                        x.to_ascii_lowercase()\n\
    \                    }\n                    'a' => {\n                       \
    \ x.to_ascii_uppercase()\n                    }\n                    _ => x,\n\
    \                }).collect::<String>();\n            } else {\n             \
    \   new_s = new_s.chars().map(|x| match x {\n                    'A' => {\n  \
    \                      x.to_ascii_uppercase()\n                    }\n       \
    \             'a' => {\n                        x.to_ascii_lowercase()\n     \
    \               }\n                    _ => x,\n                }).collect::<String>();\n\
    \            }\n            last_char = c;\n        }\n        if !new_s.is_empty()\
    \ && !last_char {\n            new_s = String::from(&new_s[1..]);\n        }\n\
    \        new_s\n    }", "    match s.chars().count() {\n        0 => s,\n    \
    \    1 => s.to_string(),\n        _ => {\n            let mut s = String::from(s);\n\
    \            for c in &s.chars() {\n                match c.to_ascii_lowercase()\
    \ {\n                    Some(c) => c.to_ascii_uppercase(),\n                \
    \    None => c.to_ascii_lowercase(),\n                }\n            }\n     \
    \       s\n        }\n    }", "    s.chars().map(|c| match c {\n        c if c.is_ascii_letter()\
    \ => c.to_ascii_lowercase().to_string(),\n        c => c.to_string(),\n    }).collect::<Vec<_>>().join(\"\
    \").to_string()", "    let mut s: String = s.to_owned();\n    let mut result =\
    \ s.clone();\n    \n    for i in 0..s.len() {\n        if s.chars().any(|c| *c\
    \ >= 'a' && *c <= 'z') {\n            let c = s.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').count() as u32;\n            let mut i = s.len();\n            while\
    \ i > 0 {\n                *s = s[i / 2..i / 2].to_lowercase().to_string();\n\
    \                i /= 2;\n            }\n        }\n        else {\n         \
    \   *s = s.to_lowercase().to_string();\n        }\n        s = s.to_owned();\n\
    \        result = result.concat(*s);\n    }\n    \n    result", "    if s.is_empty()\
    \ {\n        String::from(\"no solution\")\n    } else {\n        match s[0] {\n\
    \            'a' => {\n                if s.len() == 1 {\n                   \
    \ String::from(\"no solution\")\n                } else {\n                  \
    \  s.swap(0, 1).to_string()\n                }\n            }\n            'b'\
    \ => {\n                if s.len() == 2 {\n                    String::from(\"\
    no solution\")\n                } else {\n                    s.swap(0, 2).to_string()\n\
    \                }\n            }\n            'c' => {\n                if s.len()\
    \ == 3 {\n                    String::from(\"no solution\")\n                }\
    \ else {\n                    s.swap(0, 3).to_string()\n                }\n  \
    \          }\n            'd' => {\n                if s.len() == 4 {\n      \
    \              String::from(\"no solution\")\n                } else {\n     \
    \               s.swap(0, 4).to_string()\n                }\n            }\n \
    \           'e' => {\n                if s.len() == 5 {\n                    String::from(\"\
    no solution\")\n                } else {\n                    s.swap(0, 5).to_string()\n\
    \                }\n            }\n            'f' => {\n                if s.len()\
    \ == 6 {\n                    String::from(\"no solution\")\n                }\
    \ else {\n                    s.swap(0, 6).to_string()\n                }\n  \
    \          }\n            'g' => {\n                if s.len() == 7 {\n      \
    \              String::from(\"no solution\")\n                } else {\n     \
    \               s.swap(0, 7).to_string()\n                }\n            }\n \
    \           'h' => {\n                if s.len() == 8 {\n                    String::from(\"\
    no solution\")\n                } else {\n                    s.swap(0, 8).to_string()\n\
    \                }\n            }\n            'i' => {\n                if s.len()\
    \ == 9 {\n                    String::from(\"no solution\")\n                }\
    \ else {\n                    s.swap(0, 9).to_string()\n                }\n  \
    \          }\n            'j' => {\n                if s.len() == 10 {\n     \
    \               String::from(\"no solution\")\n                } else {\n    \
    \                s.swap(0, 10).to_string()\n                }\n            }\n\
    \            'k' => {\n                if s.len() == 11 {\n                  \
    \  String::from(\"no solution\")\n                } else {\n                 \
    \   s.swap(0, 11).to_string()\n                }\n            }\n            'l'\
    \ => {\n                if s.len() == 12 {\n                    String::from(\"\
    no solution\")\n                } else {\n                    s.swap(0, 12).to_string()\n\
    \                }\n            }\n            'm' => {\n                if s.len()\
    \ == 13 {\n                    String::from(\"no solution\")\n               \
    \ } else {\n                    s.swap(0, 13).to_string()\n                }\n\
    \            }\n            'n' => {\n                if s.len() == 14 {\n   \
    \                 String::from(\"no solution\")\n                } else {\n  \
    \                  s.swap(0, 14).", "    let mut s = s;\n    loop {\n        let\
    \ mut s = s.chars();\n        if s.next().is_none() {\n            break;\n  \
    \      }\n        if s.next().unwrap().is_lowercase() {\n            let mut v\
    \ = s.next().unwrap().to_uppercase();\n            for c in s.next() {\n     \
    \           v = v.chars().next().unwrap().to_uppercase() + c;\n            }\n\
    \            s = v;\n        } else {\n            let mut v = s.next().unwrap().to_lowercase();\n\
    \            for c in s.next() {\n                v = v.chars().next().unwrap().to_lowercase()\
    \ + c;\n            }\n            s = v;\n        }\n    }\n    s", "    // write\
    \ your code in here\n    if s.len() == 0 {\n        String::from(\"0\")\n    }\
    \ else {\n        let mut result = String::new();\n        let mut last = 0;\n\
    \        let mut last2: usize = 0;\n        for i in s.chars() {\n           \
    \ if i.is_ascii() {\n                result.push(i);\n            } else {\n \
    \               if last == 0 {\n                    result.push(i as char);\n\
    \                } else {\n                    result.push(String::from_utf8(s[last2..last].to_vec()).unwrap());\n\
    \                    result.push(i as char);\n                }\n            }\n\
    \            last = i;\n            last2 = i;\n        }\n        result\n  \
    \  }", "    let mut s = s;\n    let mut chars = s.chars();\n    while let Some(ch)\
    \ = chars.next() {\n        let mut ch = ch;\n        if ch.is_uppercase() {\n\
    \            ch = ch.to_lowercase();\n        } else {\n            ch = ch.to_uppercase();\n\
    \        }\n        s = s.chars().next().unwrap().to_string().push_str(&ch);\n\
    \    }\n    s", "    let mut out = String::new();\n\n    for ch in s.chars() {\n\
    \        match ch {\n            c if is_letter_case(c) => out.push_str(&(ch.to_lowercase())),\n\
    \            c if !is_letter_case(c) => out.push_str(&(ch.to_uppercase())),\n\
    \            _ => out.push_str(&*ch)\n        }\n    }\n\n    out", "    if s.len()\
    \ == 0 {\n        String::from(\"\")\n    } else {\n        let mut result: String\
    \ = \"\";\n        for ch in s.chars() {\n            if let Some(i) = get_index(&ch)\
    \ {\n                let mut res = s.chars().take(i).collect::<String>();\n  \
    \              res.reverse();\n                result += String::from(res);\n\
    \            } else {\n                result += String::from(ch);\n         \
    \   }\n        }\n        result\n    }", "    if s.is_empty() { return String::new();\
    \ }\n    let mut s = String::from(s);\n    if s[0].is_alpha() {\n        let char\
    \ = s[0] as char;\n        if char == char::ToLower || char == char::ToUpper {\n\
    \            let mut c = s.clone();\n            c.chars().for_each(|c| *c = match\
    \ c {\n                char::ToLower => char::ToUpper,\n                char::ToUpper\
    \ => char::ToLower,\n                _ => c,\n            });\n            s.truncate(1);\n\
    \            s.append(c);\n        } else {\n            s.truncate(1);\n    \
    \        s.append(char);\n        }\n    }\n    s", "    let mut res = s.clone();\n\
    \    res.chars().for_each(|c| {\n        if c.is_ascii() {\n            if let\
    \ Some(c) = c.to_lowercase() {\n                res.replace(c.to_ascii_lowercase(),\
    \ c.to_ascii_uppercase(), ());\n            } else {\n                res.replace(c.to_ascii_uppercase(),\
    \ c.to_ascii_lowercase(), ());\n            }\n        } else {\n            res.replace(c.to_lowercase(),\
    \ c.to_uppercase(), ());\n        }\n    });\n    res", '    char_reverse(s)',
  "    s.chars().enumerate().filter(|&(i, c)| *c == ascii_lowercase[*i]).map(|&(i,\
    \ c)| \n        if *i == 0 {\n            let mut c = c * 2;\n            while\
    \ *c < ascii_lowercase[*c] {\n                c *= 2;\n            }\n       \
    \     *c = ascii_uppercase[*c];\n            c\n        } else {\n           \
    \ c\n        })\n        .fold(\"\".to_string(), |mut acc, c| {\n            let\
    \ n = s.find(|&(_, c2)| c2 != c);\n            acc + &s[0..n] + &s[n..]\n    \
    \    })", "    if s.chars().count() == 0 {\n        return String::from(s);\n\
    \    }\n\n    let mut result = String::from(s);\n    for c in s.chars().into_iter()\
    \ {\n        if c == 'a' {\n            result = result.rev();\n        }\n  \
    \      \n        if c == 'A' {\n            result = result.rev();\n        }\n\
    \        \n        if c == '#' {\n            result = result.rev();\n       \
    \ }\n        \n        if c == '@' {\n            result = result.rev();\n   \
    \     }\n        \n        if c.is_lowercase() {\n            result = result.rev();\n\
    \        }\n        \n        if c.is_uppercase() {\n            result = result.rev();\n\
    \        }\n    }\n    \n    result", "    \n    if s.is_empty() {\n        \"\
    \".to_string()\n    }\n    else {\n        \n        let mut c = s[0];\n     \
    \   let mut rs = s.chars().enumerate().collect::<Vec<_>>();\n        \n      \
    \  for i in rs {\n            \n            if i.1.to_ascii_lowercase() == c.to_ascii_lowercase()\
    \ {\n                \n                let mut t = String::new();\n          \
    \      \n                for j in i.0..(s.len() - 1) {\n                    \n\
    \                    t.push(s[j]);\n                }\n                \n    \
    \            t.push(c);\n                \n                t = t.to_ascii_lowercase();\n\
    \                \n                for j in i.0..(t.len() - 1) {\n           \
    \         \n                    t.push(t[j]);\n                }\n           \
    \     \n                t.push(c);\n                \n                return t;\n\
    \            }\n            else {\n                \n                c = i.1.to_ascii_lowercase();\n\
    \            }\n        }\n        \n        \n        return String::from(s);\n\
    \    }\n    \n    return String::from(s);", "    let mut s = s.to_lowercase();\n\
    \    for c in s.chars() {\n        if c.is_uppercase() {\n            s = s.to_uppercase();\n\
    \        } else {\n            s = s.to_lowercase();\n        }\n    }\n    s",
  "    s.chars().map(|c| match c {\n        c if c.is_ascii() && c.is_ascii() == c.to_ascii_lowercase()\
    \ => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect().to_string()",
  "    if s.is_empty() {\n        String::from(\"\")\n    } else {\n        let mut\
    \ s = String::from(s);\n        let mut s_iter = s.chars().enumerate().rev().collect::<Vec<_>>();\n\
    \        while let (index, c) = s_iter.next() {\n            if c.is_uppercase()\
    \ {\n                s.insert(index, c.to_lowercase());\n            } else if\
    \ c.is_lowercase() {\n                s.insert(index, c.to_uppercase());\n   \
    \         }\n        }\n        s\n    }", "    s.chars().enumerate().filter_map(|(i,\
    \ c)| {\n        let mut c = c.to_lowercase();\n        if c.is_ascii_lowercase()\
    \ {\n            c = c.to_uppercase();\n        }\n        Some((c.chars(), i))\n\
    \    }).collect::<Vec<_>>().sort_by_key(|(_, i)| i).reverse()\n        .fold(s.to_owned(),\
    \ |mut acc, (letters, i)| {\n            acc.replace(i, i, letters);\n       \
    \     acc\n        }).to_string()", "    let mut res: String = \"\".to_string();\n\
    \    let mut lower = true;\n    for c in s.chars() {\n        if c.is_lowercase()\
    \ {\n            lower = false;\n        }\n        if !c.is_lowercase() {\n \
    \           lower = true;\n        }\n        if c.is_uppercase() {\n        \
    \    lower = true;\n        }\n        if !c.is_uppercase() {\n            lower\
    \ = false;\n        }\n        res += if !lower { c.to_lowercase() } else { c.to_uppercase()\
    \ };\n    }\n    res", "    let mut s = s.chars();\n    let mut res = s.clone();\n\
    \    \n    loop {\n        match s.next() {\n            Some(c) => res.push((match\
    \ c.to_lowercase() {\n                'a' => c = 'A',\n                'b' =>\
    \ c = 'B',\n                'c' => c = 'C',\n                'd' => c = 'D',\n\
    \                'e' => c = 'E',\n                'f' => c = 'F',\n          \
    \      'g' => c = 'G',\n                'h' => c = 'H',\n                'i' =>\
    \ c = 'I',\n                'j' => c = 'J',\n                'k' => c = 'K',\n\
    \                'l' => c = 'L',\n                'm' => c = 'M',\n          \
    \      'n' => c = 'N',\n                'o' => c = 'O',\n                'p' =>\
    \ c = 'P',\n                'q' => c = 'Q',\n                'r' => c = 'R',\n\
    \                's' => c = 'S',\n                't' => c = 'T',\n          \
    \      'u' => c = 'U',\n                'v' => c = 'V',\n                'w' =>\
    \ c = 'W',\n                'x' => c = 'X',\n                'y' => c = 'Y',\n\
    \                'z' => c = 'Z',\n                _ => c\n            })),\n \
    \           None => break,\n        }\n    }\n    res", "    s.chars().collect::<Vec<_>>().into_iter().map(|c|\
    \ {\n        match (c as char).to_lowercase() {\n            Some('a') => {\n\
    \                c.to_uppercase().to_string()\n            },\n            Some('z')\
    \ => {\n                c.to_lowercase().to_string()\n            },\n       \
    \     _ => c.to_string(),\n        }\n    }).collect::<String>().to_string()",
  "    s.chars().filter_map(|c| {\n        match c {\n            'a' => c.to_ascii_lowercase(),\n\
    \            'A' => c.to_ascii_uppercase(),\n            '#' => c,\n         \
    \   _ => c,\n        }\n    }).collect()", "    let mut s = s;\n    let mut r\
    \ = String::new();\n    for c in s.chars() {\n        if c.is_ascii() {\n    \
    \        r.push(c.to_lowercase());\n        } else {\n            r.push(c.to_uppercase());\n\
    \        }\n    }\n    r", "    s.chars().map(|c| match c {\n        'a'...'z'\
    \ => {\n            let mut c = c.to_lowercase();\n            c = 'a' + c + 'z'\
    \ - 'a';\n            char::from(c).to_string()\n        }\n        'A'...'Z'\
    \ => {\n            let mut c = c.to_uppercase();\n            c = 'A' + c + 'Z'\
    \ - 'A';\n            char::from(c).to_string()\n        }\n        _ => c.to_string(),\n\
    \    })\n    .collect::<String>()", "    if !s.is_ascii() {\n        String::from(s.chars().collect::<Vec<_>>().into_iter().cloned().collect());\n\
    \    }\n    else if let Some(mut char) = s.chars().next_back() {\n        while\
    \ let Some(mut c) = char {\n            let is_upper = c.is_uppercase();\n   \
    \         char = c.to_uppercase();\n            if char == c {\n             \
    \   char = c.to_lowercase();\n            }\n            else if char == c {\n\
    \                char.is_ascii_lowercase() || char.is_ascii_uppercase()\n    \
    \                || char == c.to_lowercase()\n                    || char == c.to_uppercase()\n\
    \                    || char == c.to_ascii_lowercase()\n                    ||\
    \ char == c.to_ascii_uppercase()\n                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase()\n\
    \                    || char == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \                    || char == c.to_ascii_uppercase().to_ascii_lowercase", " \
    \   if s.is_empty() { return String::new(); }\n    let mut s = s;\n    \n    let\
    \ mut result = String::new();\n    while let Some(char) = (s.chars().find(|c|\
    \ c >= 'a' && c <= 'z') || s.chars().find(|c| c >= 'A' && c <= 'Z')) {\n     \
    \   match char {\n            Some(old_c) => result = result.chars().map(|c|\n\
    \                match c {\n                    c if c.is_lowercase() => c.to_uppercase().into(),\n\
    \                    c if c.is_uppercase() => c.to_lowercase().into(),\n     \
    \               c => c\n                })\n                .join(''),\n     \
    \       None => result = result.chars().map(|c|\n                match c {\n \
    \                   c if c.is_lowercase() => c.to_lowercase().into(),\n      \
    \              c if c.is_uppercase() => c.to_uppercase().into(),\n           \
    \         c => c\n                })\n                .join(''),\n        }\n\
    \        s = s.replace(char, None);\n    }\n    match result {\n        Some(res)\
    \ => res,\n        None => String::new()\n    }", "    \n    let mut s = s\n \
    \   let len = s.len();\n    \n    for i in 1..len {\n        \n        if s.is_ascii_alpha()\
    \ {\n            \n            let sub = &s[0..i];\n            let mut res =\
    \ String::from(sub.to_string());\n            \n            if sub.chars().any(|c|\
    \ c.is_ascii_uppercase()) {\n                res = res.to_ascii_uppercase();\n\
    \            }\n            if sub.chars().any(|c| c.is_ascii_lowercase()) {\n\
    \                res = res.to_ascii_lowercase();\n            }\n            \n\
    \            s.swap(0, i);\n            s = res.to_owned();\n        }\n     \
    \   \n    }\n    \n    \n    return s;", '    solve(s, "", false)', "    match\
    \ s.chars().first() {\n        None => s,\n        Some(x) => match x.to_ascii_lowercase().chars().take(s.len()\
    \ - x.len_utf8()) {\n            None => s,\n            Some(x) => x.iter().map(|y|\
    \ y.to_ascii_uppercase()).collect::<String>()\n        }\n    }", "    s.chars().map(|c|\
    \ if c.is_alphabetic { c.to_uppercase() } else { c.to_lowercase() }).collect()\n\
    \        .map(|c| c.to_string())\n        .concat()\n        .rev()\n        .collect::<String>()",
  "    let mut s = s;\n\n    for &c in s.chars() {\n        if c.is_letter() {\n \
    \           s.to_lowercase();\n        } else {\n            s.to_uppercase();\n\
    \        }\n    }\n    s", "    fn helper(mut s: String, ix: usize) -> String\
    \ {\n        if ix < s.len() {\n            if s[i].is_ascii_lowercase() {\n \
    \               s.swap(0, ix)\n            } else {\n                s.swap(ix,\
    \ 0)\n            }\n            helper(s, ix + 1)\n        } else {\n       \
    \     s\n        }\n    }\n    helper(s, 0)", "    s.chars().rev().collect::<String>(|s|\
    \ s.chars().collect::<String>(|c| if c.is_letter() {\n        String::from(rev(c)).to_string()\n\
    \    } else {\n        c.to_string()\n    }))", "    let mut chars = s.chars();\n\
    \    let mut rev_chars = chars.rev();\n\n    if chars.is_empty() {\n        rev_chars\n\
    \    } else {\n        for char in chars {\n            if char == chars.first().unwrap()\
    \ {\n                chars.pop();\n                chars.next();\n           \
    \ }\n        }\n        rev_chars.reverse();\n    }\n\n    if chars.is_empty()\
    \ {\n        rev_chars\n    } else {\n        rev_chars.to_owned()\n    }", '    solve(s,
    "", "")', "    if s.is_empty() {\n        return s;\n    }\n    let mut s1 = String::new();\n\
    \    let mut s2 = String::new();\n    let mut i = 1;\n    while i <= s.len() {\n\
    \        if s[0..i].chars().all(|c| is_letter(&c)) {\n            i += 1;\n  \
    \      }\n        else {\n            i += 1;\n            s[i] = s.chars().fold('',\
    \ |c, i| if i > 0 { c } else { c + 'a' });\n        }\n    }\n    s2.push_str(&s1);\n\
    \    s2", "    let mut s = s.to_string();\n    let mut index = 0;\n\n    loop\
    \ {\n        if let Some(pos) = s.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz\"\
    ) {\n            let c = s[pos];\n\n            if let Some(next) = s[pos + 1]\
    \ {\n                let c = c.to_uppercase();\n                let next = next.to_lowercase();\n\
    \                s = &s[..pos] + &c + &next;\n            } else {\n         \
    \       s = &s[..pos] + &c;\n            }\n\n            index += 1;\n      \
    \  } else {\n            break;\n        }\n    }\n\n    s", "    let mut s =\
    \ s.to_string();\n    let mut new_s = s;\n    let mut i = 0;\n\n    while i <\
    \ s.len() {\n        if s.chars().next().is_none() {\n            break;\n   \
    \     }\n\n        if s.chars().next().unwrap().is_lowercase() {\n           \
    \ s.swap(i, i + 1);\n            i += 1;\n        } else if s.chars().next().unwrap().is_uppercase()\
    \ {\n            s.swap(i, i + 1);\n            i += 1;\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    new_s", "    if s.chars().any(|&x| x\
    \ >= 'a' && x <= 'z') {\n        String::from(s.chars().map(|&x| if x >= 'a' &&\
    \ x <= 'z' { x.to_ascii_lowercase() } else { x.to_ascii_uppercase() }).collect::<String>())\n\
    \    } else {\n        String::from(s.chars().cloned().reverse().collect::<String>())\n\
    \    }", "    if s.chars().any(|&c| c.is_ascii_lowercase()) {\n        let mut\
    \ r = s.to_ascii_lowercase();\n        for c in r.chars() {\n            *c =\
    \ match c.to_ascii_uppercase() {\n                Ok(c) => c,\n              \
    \  Err(_) => c.to_ascii_lowercase()\n            }\n        }\n        r\n   \
    \ } else {\n        s\n    }", "    let mut s = s;\n    let mut len = s.chars().count();\n\
    \    let mut i = 0;\n    while i < len {\n        if s.chars().nth(i).unwrap().is_lowercase()\
    \ {\n            // Reverse letters from lower to upper.\n            let mut\
    \ c = s.chars().nth(i).unwrap();\n            c.swap(c.len_utf8());\n        \
    \    s.push_str(&c);\n        }\n        else {\n            // Keep the same\
    \ letters.\n            i += 1;\n        }\n    }\n    s", "    let mut s = String::from(s);\n\
    \    if s.chars().any(|c| c <= 'Z' || c >= 'a') {\n        for c in s.chars().cloned()\
    \ {\n            if c <= 'Z' || c >= 'a' {\n                s = s.chars().map(|c|\
    \ if c <= 'Z' then c + ('a' - 'A') else c + ('A' - 'a')).collect::<String>();\n\
    \            }\n        }\n    }\n    String::from(s)", "    s.chars().filter_map(|&c|\
    \ {\n        if c.is_digit() {\n            Some(c.to_string())\n        } else\
    \ {\n            Some(c.to_ascii_lowercase())\n        }\n    }).fold(String::from(\"\
    \"), |mut acc, &c| {\n        if c.is_ascii_lowercase() {\n            acc.to_ascii_uppercase()\n\
    \        } else if c.is_ascii_uppercase() {\n            acc.to_ascii_lowercase()\n\
    \        } else {\n            acc\n        }\n    });", "    match s.chars().filter_map(|c|\
    \ c >= 'a' && c <= 'z').cloned() {\n        None => s.to_lowercase(),\n      \
    \  Some(_) => s.to_uppercase(),\n    }", "    let mut s = s.to_owned();\n    \n\
    \    while !s.is_empty() {\n        let i = s.chars().count();\n        if let\
    \ Some(c) = s.chars().skip(i-1).find(|c| c == '#') {\n            if let Some(c2)\
    \ = s.chars().skip(i-1).find(|c| c != '#') {\n                if let Some(c3)\
    \ = s.chars().skip(i-1).find(|c| c != '#') {\n                    if let Some(c4)\
    \ = s.chars().skip(i-1).find(|c| c != '#') {\n                        if c ==\
    \ 'a' {\n                            s = s.insert(i, String::from(\"A\"));\n \
    \                       } else if c == 'B' {\n                            s =\
    \ s.insert(i, String::from(\"b\"));\n                        } else if c == 'c'\
    \ {\n                            s = s.insert(i, String::from(\"C\"));\n     \
    \                   } else if c == 'd' {\n                            s = s.insert(i,\
    \ String::from(\"D\"));\n                        } else if c == 'E' {\n      \
    \                      s = s.insert(i, String::from(\"e\"));\n               \
    \         } else if c == 'F' {\n                            s = s.insert(i, String::from(\"\
    F\"));\n                        } else if c == 'G' {\n                       \
    \     s = s.insert(i, String::from(\"g\"));\n                        } else if\
    \ c == 'h' {\n                            s = s.insert(i, String::from(\"H\"));\n\
    \                        } else if c == 'i' {\n                            s =\
    \ s.insert(i, String::from(\"i\"));\n                        } else if c == 'j'\
    \ {\n                            s = s.insert(i, String::from(\"J\"));\n     \
    \                   } else if c == 'k' {\n                            s = s.insert(i,\
    \ String::from(\"k\"));\n                        } else if c == 'l' {\n      \
    \                      s = s.insert(i, String::from(\"L\"));\n               \
    \         } else if c == 'm' {\n                            s = s.insert(i, String::from(\"\
    m\"));\n                        } else if c == 'n' {\n                       \
    \     s = s.insert(i, String::from(\"n\"));\n                        } else if\
    \ c == 'O' {\n                            s = s.insert(i, String::from(\"O\"));\n\
    \                        } else if c == 'p' {\n                            s =\
    \ s.insert(i, String::from(\"p\"));\n                        } else if c == 'Q'\
    \ {\n                            s = s.insert(i, String::from(\"Q\"));\n     \
    \                   } else if c == 'r' {\n                            s = s.insert(i,\
    \ String::from(\"R\"));\n                        } else if c == 's' {\n      \
    \                      s = s.insert(i, String::from(\"S\"));\n               \
    \         } else if c == 't' {\n                            s = s.insert(i, String::from(\"\
    t\"));\n                        } else if c == 'u", "    let mut res = String::from(\"\
    \");\n    for i in s.chars().cloned() {\n        if let Some(k) = String::from(&i.to_uppercase())\
    \ {\n            res.push_str(k.clone());\n        } else {\n            res.push_str(i.clone());\n\
    \        }\n    }\n    if res.chars().count() == 0 {\n        res.push_str(s.chars().cloned().reverse().collect());\n\
    \    } else {\n        res\n    }", '    solve1(s)', "    let mut new_str = s;\n\
    \    let mut char = String::from(\"\");\n    \n    for ch in new_str {\n     \
    \   match char.chars().next().unwrap() {\n            Some(first_letter) => {\n\
    \                match char.chars().next().unwrap() {\n                    Some(second_letter)\
    \ => {\n                        char = char.to_lowercase() + second_letter + first_letter.to_uppercase();\n\
    \                    },\n                    None => char = char.to_lowercase()\
    \ + first_letter,\n                }\n            },\n            None => char\
    \ = char.to_lowercase() + ch,\n        }\n    }\n    char", "    let mut s = s;\n\
    \    let mut len = 0;\n    while let Some(letter) = s.chars().any() {\n      \
    \  if let Some(upper) = if let Some(up) = letter.toUpper() {\n            Some(len)\n\
    \        } else {\n            None\n        }{\n            len += 1;\n     \
    \       s = &s[..upper];\n        } else {\n            s = &s[..letter];\n  \
    \      }\n    }\n    String::from(&s[..len])", "    if s.chars().all(|c| *c ==\
    \ c) {\n        solve_recursive(s)\n    } else {\n        solve_recursive(s.to_lowercase().unwrap())\n\
    \    }", "    s.chars().map(|c| match c {\n        'a' => { 'A' as char },\n \
    \       'B' => { 'b' as char },\n        'C' => { 'c' as char },\n        'D'\
    \ => { 'd' as char },\n        'E' => { 'e' as char },\n        'F' => { 'f' as\
    \ char },\n        'G' => { 'g' as char },\n        'H' => { 'h' as char },\n\
    \        'I' => { 'i' as char },\n        'J' => { 'j' as char },\n        'K'\
    \ => { 'k' as char },\n        'L' => { 'l' as char },\n        'M' => { 'm' as\
    \ char },\n        'N' => { 'n' as char },\n        'O' => { 'o' as char },\n\
    \        'P' => { 'p' as char },\n        'Q' => { 'q' as char },\n        'R'\
    \ => { 'r' as char },\n        'S' => { 's' as char },\n        'T' => { 't' as\
    \ char },\n        'U' => { 'u' as char },\n        'V' => { 'v' as char },\n\
    \        'W' => { 'w' as char },\n        'X' => { 'x' as char },\n        'Y'\
    \ => { 'y' as char },\n        'Z' => { 'z' as char },\n        '@' => { '@' as\
    \ char },\n        '#' => { '#' as char },\n        _ => c,\n    }).collect::<String>().to_owned()",
  "    let mut s1 = String::from(s);\n    let mut s2 = String::from(s);\n    while\
    \ s1.len() != 0 {\n        let c = s1.chars().next().unwrap();\n        match\
    \ c {\n            'a' => s1.replace_range(0,1,'A'),\n            'A' => s1.replace_range(0,1,'a'),\n\
    \            'b' => s1.replace_range(0,1,'b'),\n            'B' => s1.replace_range(0,1,'b'),\n\
    \            'c' => s1.replace_range(0,1,'C'),\n            'C' => s1.replace_range(0,1,'c'),\n\
    \            'd' => s1.replace_range(0,1,'D'),\n            'D' => s1.replace_range(0,1,'d'),\n\
    \            'e' => s1.replace_range(0,1,'E'),\n            'E' => s1.replace_range(0,1,'e'),\n\
    \            'f' => s1.replace_range(0,1,'F'),\n            'F' => s1.replace_range(0,1,'f'),\n\
    \            'g' => s1.replace_range(0,1,'G'),\n            'G' => s1.replace_range(0,1,'g'),\n\
    \            'h' => s1.replace_range(0,1,'H'),\n            'H' => s1.replace_range(0,1,'h'),\n\
    \            'i' => s1.replace_range(0,1,'I'),\n            'I' => s1.replace_range(0,1,'i'),\n\
    \            'j' => s1.replace_range(0,1,'J'),\n            'J' => s1.replace_range(0,1,'j'),\n\
    \            'k' => s1.replace_range(0,1,'K'),\n            'K' => s1.replace_range(0,1,'k'),\n\
    \            'l' => s1.replace_range(0,1,'L'),\n            'L' => s1.replace_range(0,1,'l'),\n\
    \            'm' => s1.replace_range(0,1,'M'),\n            'M' => s1.replace_range(0,1,'m'),\n\
    \            'n' => s1.replace_range(0,1,'N'),\n            'N' => s1.replace_range(0,1,'n'),\n\
    \            'o' => s1.replace_range(0,1,'O'),\n            'O' => s1.replace_range(0,1,'o'),\n\
    \            'p' => s1.replace_range(0,1,'P'),\n            'P' => s1.replace_range(0,1,'p'),\n\
    \            'q' => s1.replace_range(0,1,'Q'),\n            'Q' => s1.replace_range(0,1,'q'),\n\
    \            'r' => s1.replace_range(0,1,'R'),\n            'R' => s1.replace_range(0,1,'r'),\n\
    \            's' => s1.replace_range(0,1,'S'),\n            'S' => s1.replace_range(0,1,'s'),\n\
    \            't' => s1.replace_range(0,1,'T'),\n            'T' => s1.replace_range(0,1,'t'),\n\
    \            'u' => s1.replace_range(0,1,'U'),\n            'U' => s1.replace_range(0,1,'u'),\n\
    \            'v' => s1.replace_range(0,1,'V'),\n            'V' => ", "    if\
    \ s.is_empty() {\n        return s;\n    }\n    \n    let mut result = s.clone();\n\
    \    let mut char = s.chars();\n    let mut i = 0;\n    while let Some(c)  = char.next()\
    \ {\n        let c = c.to_ascii_lowercase();\n        if char == Some(c.into())\
    \ {\n            result += c;\n            i += 1;\n        } else {\n       \
    \     let c = c.to_ascii_uppercase();\n            if char == Some(c.into()) {\n\
    \                result += c;\n                i += 1;\n            } else {\n\
    \                result += c;\n            }\n        }\n    }\n    result", " \
    \   if s.chars().any(|c| c.is_letter()) {\n        solve2(s)\n    } else {\n \
    \       solve1(s)\n    }", "    if s.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut iter = s.chars();\n    let mut rev: Vec<u8> = Vec::new();\n\
    \n    for ch in iter {\n        let mut ch = ch.to_lowercase();\n        if ch\
    \ >= 'a' && ch <= 'z' {\n            ch = ch - 'a' + 'A';\n        }\n       \
    \ rev.push(ch);\n    }\n\n    if rev.is_empty() {\n        return String::from(\"\
    \\0\");\n    }\n\n    String::from_utf8(rev).unwrap()", "    s.chars().iter().map(|c|\
    \ {\n        if c.is_alphanumeric() {\n            if c.to_ascii_lowercase() !=\
    \ c.to_ascii_uppercase() {\n                c.to_ascii_uppercase()\n         \
    \   } else {\n                c.to_ascii_lowercase()\n            }\n        }\
    \ else {\n            c\n        }\n    }).collect()", "    use std::collections::HashSet;\n\
    \n    let mut set = HashSet::new();\n    for c in s.chars() {\n        set.insert(c.to_lowercase());\n\
    \    }\n    \n    let mut res = String::new();\n    for c in s.chars() {\n   \
    \     if let Some(i) = set.remove(c) {\n            res.push(i);\n           \
    \ set.insert(c.to_uppercase());\n        } else {\n            res.push(c);\n\
    \        }\n    }\n    res", "    if s.len() == 0 {\n        return String::from(\"\
    \")\n    }\n    let mut s = String::from(s);\n    let mut i = 0;\n    while i\
    \ < s.len() {\n        if s[i].is_alpha() {\n            let mut i = i + 1;\n\
    \            while i < s.len() && s[i].is_alpha() {\n                s[i] = s.swap(i,\
    \ i + 1).to_uppercase();\n                i += 1;\n            }\n        }\n\
    \        i += 1;\n    }\n    s", '    helper(s.chars().collect::<Vec<char>>())',
  "    if s.is_empty() {\n        return s;\n    }\n    \n    for c in s.chars() {\n\
    \        match c {\n            c @ c => s,\n            _ => s.chars().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().map(|c|\
    \ {\n                if c >= 'a' && c <= 'z' {\n                    c += 'A' -\
    \ 'a';\n                } else {\n                    c += 'a' - 'A';\n      \
    \          }\n                \n                if c >= 'A' && c <= 'Z' {\n  \
    \                  c += 'a' - 'A';\n                } else {\n               \
    \     c += 'A' - 'a';\n                }\n                \n                c\n\
    \            }).collect::<Vec<_>>().collect::<String>().cloned().collect::<String>()\n\
    \        }\n    }\n    \n    s", "    s.chars().filter(|&c| c.is_letter()).collect::<String>().to_owned().chars().fold(&s,\
    \ |s, &c| {\n        if let Some(next) = s[s.len() - 1] {\n            if let\
    \ Some(prev) = s[s.len() - 2] {\n                s.insert(s.len() - 2, prev)\n\
    \            } else {\n                s.insert(s.len() - 2, c)\n            }\n\
    \        } else {\n            s.push(c)\n        }\n        s\n    })", '    solve_recursive(s.chars(),
    0, s.len())', "    s.chars()\n        .filter(|&c| is_valid_char(c))\n       \
    \ .map(|&c| if is_valid_case(c) then c.to_upper() else c.to_lower()).collect()\n\
    \        .collect::<String>()", '    solve0(s)', '    solve("", s)', '    s.chars().rev().collect::<String>().to_owned()',
  "    let mut v = s.clone();\n    if v.chars().any(|c| c.is_lowercase()) {\n    \
    \    v.chars().rev().for_each(|c| c.to_uppercase());\n    } else {\n        v.chars().for_each(|c|\
    \ c.to_lowercase());\n    }\n    v", "    let mut s = s;\n    \n    for &i in\
    \ s.chars() {\n        if i.is_uppercase() {\n            s = s.to_uppercase();\n\
    \        } else {\n            s = s.to_lowercase();\n        }\n    }\n    \n\
    \    s", "    let mut rev_s = s.chars().fold(String::new(), |mut acc, x| {\n \
    \       let c = match x {\n            'a' => acc.to_uppercase(),\n          \
    \  'b' => acc.to_lowercase(),\n            _ => acc,\n        };\n        acc\
    \ + &c.to_string()\n    });\n    let mut chars = s.chars();\n    chars.for_each(|x|\
    \ {\n        if !rev_s.contains(x) {\n            rev_s += x.to_string();\n  \
    \      }\n    });\n    rev_s", "    if s.is_empty() {\n        String::from(s)\n\
    \    } else {\n        if s.chars().any(|c| c.is_ascii_lowercase()) {\n      \
    \      let mut s = String::from(s);\n            s.chars().for_each(|c| {\n  \
    \              match c.to_ascii_lowercase() {\n                    Some(c) =>\
    \ c = char::Uppercase(c),\n                    None => c = char::Lowercase(c)\n\
    \                }\n            })\n        }\n        s\n    }", "    let mut\
    \ a = s.chars();\n    let mut b = s.chars();\n    \n    loop {\n        match\
    \ a.pop() {\n            None => break,\n            Some(c) => {\n          \
    \      if c.is_letter() {\n                    b = b.map(|x| if x.is_letter()\
    \ || x.is_digit() {x.to_ascii_lowercase()} else x.to_ascii_uppercase());\n   \
    \             } else {\n                    b = b.map(|x| x.to_ascii_uppercase());\n\
    \                }\n            }\n        }\n    }\n\n    String::from(a.iter().chain(b).collect::<String>())",
  "    let mut letters = String::new();\n\n    for c in s.chars() {\n        if let\
    \ Some(l) = (c as u8).to_ascii_lowercase() {\n            letters.push_str(l);\n\
    \        } else {\n            letters.push_str(c);\n        }\n    }\n\n    if\
    \ letters.len() == 0 {\n        solve(s)\n    } else {\n        letters\n    }",
  "    if s.is_empty() {\n        return String::from(\"\");\n    }\n    let mut res\
    \ = s.clone();\n    let mut low = res.chars().filter(|x| x >= 'a' && x <= 'z').count();\n\
    \    let mut high = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n  \
    \  if low == 0 {\n        let mut cur = res.chars().filter(|x| x >= 'a' && x <=\
    \ 'z').count();\n        res.swap(0, cur);\n    }\n    if high == 0 {\n      \
    \  let mut cur = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n     \
    \   res.swap(0, cur);\n    }\n    while low > 0 || high > 0 {\n        let mut\
    \ swap = if high > low {\n            res.swap(0, low - 1);\n            res.swap(low,\
    \ high - 1);\n            low = res.chars().filter(|x| x >= 'a' && x <= 'z').count();\n\
    \            high = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n  \
    \      }\n        else {\n            res.swap(0, high - 1);\n            res.swap(low,\
    \ high - 1);\n            low = res.chars().filter(|x| x >= 'A' && x <= 'Z').count();\n\
    \            high = res.chars().filter(|x| x >= 'a' && x <= 'z').count();\n  \
    \      }\n    }\n    res", "    let mut input = s.to_string();\n    let mut output\
    \ = String::from(\"\");\n    let mut flag = false;\n    for i in 0..input.len()\
    \ {\n        let c = input[i];\n        match c {\n            'a' => {\n    \
    \            output.push_str(&c.to_lowercase());\n                flag = true;\n\
    \            },\n            'b' => {\n                output.push_str(&c.to_uppercase());\n\
    \                flag = true;\n            },\n            _ => {\n          \
    \      if flag {\n                    output.push_str(&c.to_lowercase());\n  \
    \              } else {\n                    output.push_str(&c.to_uppercase());\n\
    \                }\n                flag = false;\n            }\n        }\n\
    \    }\n    output", "    if s.is_empty() {\n        return String::from(\"\"\
    );\n    }\n\n    let mut i = 0;\n\n    let mut s = s.to_string();\n    while i\
    \ < s.len() {\n        let c = s[i..].chars().collect::<Vec<_>>()[0];\n\n    \
    \    // if character is a letter\n        if c.is_ascii() {\n            if c.is_lowercase()\
    \ {\n                s[i] = c.to_uppercase();\n            } else {\n        \
    \        s[i] = c.to_lowercase();\n            }\n        } else {\n         \
    \   s[i] = c;\n        }\n\n        i += 1;\n    }\n\n    String::from(s)", " \
    \   if s.len() == 0 {\n        String::from(\"A\")\n    } else {\n        let\
    \ mut result = s.to_string();\n        if let Some(first) = result.chars().next()\
    \ {\n            match first {\n                'A' => result.chars().chain(|c|\
    \ c.to_ascii_lowercase()).collect::<String>().clone(),\n                'a' =>\
    \ result.chars().chain(|c| c.to_ascii_uppercase()).collect::<String>().clone(),\n\
    \                _ => result,\n            }\n        } else {\n            result\n\
    \        }\n    }", "    let mut s = s;\n    let mut i = 0;\n    for c in s.chars()\
    \ {\n        let c: char = c; // unwrap the char\n        if c.is_ascii_letter()\
    \ {\n            s = s.to_string().to_lowercase().chars().collect::<String>().join(\"\
    \") + c.to_string();\n        } else if !c.is_ascii_letter() {\n            s\
    \ = s.to_string().to_lowercase().chars().collect::<String>().join(\"\") + c;\n\
    \        }\n        i += 1;\n    }\n    s", "    s.chars().map(|&c| match c {\n\
    \        'a'...'z' => c,\n        'A'...'Z' => c,\n        '0'...'9' => c,\n \
    \       _ => c,\n    }).collect()", "    let mut s = s;\n    for _ in 0..s.len()\
    \ {\n        if s.chars().any(|c| c.is_uppercase()) {\n            s = s.to_lowercase().chars().collect::<String>().to_string()\
    \ + s;\n        } else {\n            s = s.to_uppercase().chars().collect::<String>().to_string()\
    \ + s;\n        }\n    }\n    s", "    s.chars().iter().filter_map(|c| match c\
    \ {\n        'a' => (c as u8) - 0x41, // 'a' is 0x41, 'A' is 0x41, '#' is 0x23,\
    \ '@' is 0x40\n        'A' => (c as u8) - 0x41, // 'A' is 0x41, 'a' is 0x41, '#'\
    \ is 0x23, '@' is 0x40\n        '#' => (c as u8) - 0x23, // '#' is 0x23, 'a' is\
    \ 0x41, 'A' is 0x41, '@' is 0x40\n        '@' => (c as u8) - 0x40, // '@' is 0x40,\
    \ 'a' is 0x41, 'A' is 0x41, '#' is 0x23\n        _ => c,\n    }).collect::<String>()",
  '    solve1(s.chars().collect(), s)', "    let mut res = String::from(\"\");\n \
    \   for c in s.chars() {\n        let upper = match c {\n            c => c as\
    \ u32,\n            _ => 0,\n        };\n        let lower = match c {\n     \
    \       c => c as u32,\n            _ => 0,\n        };\n        let tmp = match\
    \ upper < lower {\n            true => upper,\n            false => lower,\n \
    \       };\n        res = res.push_str(String::from_str(&tmp.to_string()));\n\
    \    }\n    res", "    if s.chars().any(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\
    \ {\n        s.chars().collect().reverse()\n            .collect::<String>() +\
    \ s.chars().collect().collect();\n    } else {\n        s\n    }", "    s.chars()\n\
    \        .map(|c|{\n            match c {\n                'a' => 'A',\n     \
    \           'b' => 'B',\n                'c' => 'C',\n                'd' => 'D',\n\
    \                'e' => 'E',\n                'f' => 'F',\n                'g'\
    \ => 'G',\n                'h' => 'H',\n                'i' => 'I',\n        \
    \        'j' => 'J',\n                'k' => 'K',\n                'l' => 'L',\n\
    \                'm' => 'M',\n                'n' => 'N',\n                'o'\
    \ => 'O',\n                'p' => 'P',\n                'q' => 'Q',\n        \
    \        'r' => 'R',\n                's' => 'S',\n                't' => 'T',\n\
    \                'u' => 'U',\n                'v' => 'V',\n                'w'\
    \ => 'W',\n                'x' => 'X',\n                'y' => 'Y',\n        \
    \        'z' => 'Z',\n                _ => c,\n            }\n        })\n   \
    \     .collect()", '    solve_recursive(s.chars().cloned().collect())', "    if\
    \ s.is_empty() {\n        \"\"\n    } else {\n        let mut s = s;\n       \
    \ for c in s.chars() {\n            match c {\n                'a' => {\n    \
    \                s = s.to_string().replace(\"A\".to_string(), \"a\".to_string()).replace(\"\
    a\".to_string(), \"A\".to_string());\n                }\n                'b' =>\
    \ {\n                    s = s.to_string().replace(\"B\".to_string(), \"b\".to_string()).replace(\"\
    b\".to_string(), \"B\".to_string());\n                }\n                'c' =>\
    \ {\n                    s = s.to_string().replace(\"C\".to_string(), \"c\".to_string()).replace(\"\
    c\".to_string(), \"C\".to_string());\n                }\n                'd' =>\
    \ {\n                    s = s.to_string().replace(\"D\".to_string(), \"d\".to_string()).replace(\"\
    d\".to_string(), \"D\".to_string());\n                }\n                'e' =>\
    \ {\n                    s = s.to_string().replace(\"E\".to_string(), \"e\".to_string()).replace(\"\
    e\".to_string(), \"E\".to_string());\n                }\n                'f' =>\
    \ {\n                    s = s.to_string().replace(\"F\".to_string(), \"f\".to_string()).replace(\"\
    f\".to_string(), \"F\".to_string());\n                }\n                'g' =>\
    \ {\n                    s = s.to_string().replace(\"G\".to_string(), \"g\".to_string()).replace(\"\
    g\".to_string(), \"G\".to_string());\n                }\n                'h' =>\
    \ {\n                    s = s.to_string().replace(\"H\".to_string(), \"h\".to_string()).replace(\"\
    h\".to_string(), \"H\".to_string());\n                }\n                'i' =>\
    \ {\n                    s = s.to_string().replace(\"I\".to_string(), \"i\".to_string()).replace(\"\
    i\".to_string(), \"I\".to_string());\n                }\n                'j' =>\
    \ {\n                    s = s.to_string().replace(\"J\".to_string(), \"j\".to_string()).replace(\"\
    j\".to_string(), \"J\".to_string());\n                }\n                'k' =>\
    \ {\n                    s = s.to_string().replace(\"K\".to_string(), \"k\".to_string()).replace(\"\
    k\".to_string(), \"K\".to_string());\n                }\n                'l' =>\
    \ {\n                    s = s.to_string().replace(\"L\".to_string(), \"l\".to_string()).replace(\"\
    l\".to_string(), \"L\".to_string());\n                }\n                'm' =>\
    \ {\n                    s = s.to_string().replace(\"M\".to_string(), \"m\".to_string()).replace(\"\
    m\".to_string(), \"M\".to_string());\n                }\n                'n' =>\
    \ {\n                    s = s.to_string().replace(\"N\".to_string(), \"n\".to_string()).replace(\"\
    n\".to_string(), \"N\".to_string());\n                }\n                'o' =>\
    \ {\n                    s = s.to_string().replace(\"O\".to_string(), \"o\".to_string()).replace(\"\
    o\".to_string(), \"O\".to_string());\n                }\n                'p' =>\
    \ {\n                    s = s.to_string().replace(\"P\".to_string(), \"p\".to_string()).",
  "    let mut res = s.clone();\n    for i in res.chars() {\n        if i.is_alphabetic()\
    \ {\n            res.swap(i, i.to_uppercase());\n        } else {\n          \
    \  res.swap(i, i.to_lowercase());\n        }\n    }\n    res", "    \n    let\
    \ mut reverse = s.to_string();\n    let mut first_char = s.chars().take(1).unwrap();\n\
    \    let mut is_first_char = true;\n\n    for c in reverse.chars() {\n       \
    \ if !is_first_char {\n            reverse = reverse + c.to_uppercase();\n   \
    \     } else {\n            reverse = reverse + c.to_lowercase();\n        }\n\
    \        is_first_char = !is_first_char;\n    }\n    String::from(reverse)", " \
    \   \n    let mut result = s.clone();\n    let mut i = 1;\n    let mut j = s.len();\n\
    \    \n    while j > 0 {\n        while i < j {\n            \n            let\
    \ char1 = s.chars().nth(i).unwrap();\n            let char2 = s.chars().nth(i\
    \ + 1).unwrap();\n            \n            if char1.is_upper() {\n          \
    \      if char2.is_lower() {\n                    let temp = char1;\n        \
    \            char1 = char2;\n                    char2 = temp;\n             \
    \   }\n                \n                i = i + 2;\n            } else if char1.is_lower()\
    \ {\n                if char2.is_upper() {\n                    let temp = char1;\n\
    \                    char1 = char2;\n                    char2 = temp;\n     \
    \           }\n                \n                j = j - 2;\n            } else\
    \ {\n                i = i + 1;\n                j = j - 1;\n            }\n \
    \       }\n        \n        i = 1;\n        j = s.len();\n    }\n    \n    result",
  "    let mut result = s.to_string();\n    for ch in s.chars() {\n        match ch\
    \ {\n            'A' as char => {\n                let chr = ch.to_lowercase();\n\
    \                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_uppercase());\n\
    \            }\n            'a' as char => {\n                let chr = ch.to_uppercase();\n\
    \                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_lowercase());\n\
    \            }\n            '0' as char => {\n                let chr = ch.to_lowercase();\n\
    \                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_uppercase());\n\
    \            }\n            '1' as char => {\n                let chr = ch.to_uppercase();\n\
    \                result.chars().skip(1).for_each(|c| c.to_string().chars().find(chr).unwrap().to_lowercase());\n\
    \            }\n            _ => {\n                result.chars().skip(1).for_each(|c|\
    \ c.to_string());\n            }\n        }\n    }\n    result", "    \n    let\
    \ mut chars = s.chars().collect::<Vec<_>>();\n    let mut i = 0;\n    while i\
    \ < chars.len() {\n        if chars[i].is_alphabetic() {\n            if i > 0\
    \ {\n                chars[i - 1] = chars[i]\n            }\n            chars[i]\
    \ = chars[i].to_upper();\n        } else {\n            chars[i] = chars[i].to_lower();\n\
    \        }\n        i += 1;\n    }\n    chars.into_iter().collect()", "    fn\
    \ to_lower(c: char) -> char {\n        c.to_lowercase()\n    }\n    let mut s\
    \ = s;\n    let mut i = 0;\n    while i < s.len() {\n        if let Some(index)\
    \ = s.find('a', i).ok() {\n            s[i] = to_lower(s[index]);\n          \
    \  i += 1;\n        }\n        i += 1;\n    }\n    if s.chars().any(|c| !c.is_ascii_letter())\
    \ {\n        s.replace(s.chars().map(|c| to_lower(c)).collect::<String>(), String::from(\"\
    \"))\n    }\n    else {\n        s\n    }", "    match s.chars() {\n        char::is_letter\
    \ => {\n            let mut new = s.clone();\n            new.chars().for_each(|c|\
    \ {\n                if c.is_lowercase() {\n                    new.swap(c, c.toupper());\n\
    \                } else {\n                    new.swap(c, c.tolowercase());\n\
    \                }\n            });\n            new\n        }\n        _ =>\
    \ s,\n    }", "    if !s.chars().any(|c| c.is_ascii_lowercase()) {\n        solve(s.chars().map(|c|\
    \ c.to_ascii_lowercase()).collect::<String>().reverse())\n    } else {\n     \
    \   solve(s.chars().map(|c| if c.is_ascii_uppercase() then c.to_ascii_uppercase()\
    \ else c).collect::<String>().reverse())\n    }", "    let mut str = String::new();\n\
    \    for &c in s.chars() {\n        let c = c.to_string();\n        if c.is_letter()\
    \ {\n            str.push_str(c.to_uppercase());\n        } else {\n         \
    \   str.push_str(c.to_lowercase());\n        }\n    }\n    str", "    if s.is_empty()\
    \ {\n        return s\n    }\n    \n    let mut result = String::from(\"\");\n\
    \    \n    let mut i = 1;\n    \n    for c in s.chars() {\n        if c.is_uppercase()\
    \ {\n            result.append(c.to_lowercase());\n        } else {\n        \
    \    result.append(c.to_uppercase());\n        }\n        \n        i += 1;\n\
    \    }\n    \n    result.reverse_from_beginning();\n    result", "    let mut\
    \ res: String = \"\".to_string();\n    for c in s.chars() {\n        if c.is_lowercase()\
    \ {\n            res.insert(0, c.to_uppercase());\n        } else {\n        \
    \    res.insert(0, c.to_lowercase());\n        }\n    }\n    res", "    s.chars().filter(|c|\
    \ !c.is_ascii_uppercase())\n        .map(|c| if c.is_ascii_lowercase() {\n   \
    \         c.to_ascii_uppercase().to_string()\n        } else {\n            c.to_ascii_lowercase().to_string()\n\
    \        })\n        .collect::<Vec<_>>()\n        .join(\"\").to_string()", " \
    \   s.chars().map(|c| {\n        if c.is_ascii() {\n            if c.to_ascii_uppercase()\
    \ == c {\n                c.to_ascii_lowercase()\n            } else {\n     \
    \           c.to_ascii_uppercase()\n            }\n        } else {\n        \
    \    c\n        }\n    }).collect()", '    String::from(s.chars().collect::<Vec<_>>().iter().rev().collect())',
  "    if s.chars().all(|c| c.is_ascii_letter()) {\n        let mut newstring = \"\
    \";\n        for char in s {\n            if char >= 'A' && char <= 'Z' {\n  \
    \              let new_value = char.to_string().to_ascii_uppercase();\n      \
    \          newstring.push_str(&new_value);\n            } else {\n           \
    \     newstring.push_str(&char.to_ascii_lowercase());\n            }\n       \
    \ }\n        return newstring;\n    }\n    return s.chars().fold(s, |s, c| s +\
    \ c.to_ascii_lowercase());", "    let mut s = String::from(s);\n    if s.chars().any(|c|\
    \ c.is_ascii()) {\n        s.append(s.chars().map(|c| match c {\n            c\
    \ if c.is_ascii() => c.to_ascii_lowercase(),\n            c if c.is_ascii() =>\
    \ c.to_ascii_uppercase(),\n            _ => c,\n        }).collect());\n    }\
    \ else {\n        s.append(s);\n    }\n    s", "    \n    let mut res = s.clone();\n\
    \    \n    for &ch in s.chars() {\n        let mut cased_ch = ch.to_lowercase();\n\
    \        \n        if cased_ch == ch {\n            res = res.chars().filter(|c|\
    \ c != ch).collect();\n        }\n        else if cased_ch == ch.to_uppercase()\
    \ {\n            res = res.chars().filter(|c| c != ch).collect();\n          \
    \  res = res.chars().map(|c| c.to_uppercase()).collect();\n        }\n       \
    \ else {\n            res = res.chars().filter(|c| c != ch).collect();\n     \
    \       res = res.chars().map(|c| c.to_lowercase()).collect();\n        }\n  \
    \  }\n    \n    return res", "    if s.is_empty() { return String::new(); }\n\
    \    let mut s = s;\n    \n    // Reverse all letters\n    while !s.is_empty()\
    \ {\n        match s.chars().next().unwrap() {\n            'a' => {\n       \
    \         s = s.chars().filter(|c| c != 'a').map(|c| 'A' + c).collect();\n   \
    \         }\n            'A' => {\n                s = s.chars().filter(|c| c\
    \ != 'A').map(|c| 'a' + c).collect();\n            }\n            c => s = s +\
    \ c.to_string(),\n        }\n    }\n    return s", "    let mut s = s;\n    for\
    \ c in s.chars() {\n        if c.is_ascii() {\n            match c.to_ascii_lowercase()\
    \ {\n                Some(x) => (c as char).reverse(),\n                None =>\
    \ c,\n            }\n        } else if c.is_digit() {\n            match c.to_digit()\
    \ {\n                Some(x) => (c as char).reverse(),\n                None =>\
    \ c,\n            }\n        } else {\n            c.reverse();\n        }\n \
    \   }\n    s", "    let mut s = s;\n    loop {\n        let mut it = s.chars();\n\
    \        match it.next() {\n            Some('\\0') => s,\n            _ => break,\n\
    \        }\n        let mut first = it.next().unwrap();\n        if let Some(other)\
    \ = it.next() {\n            let mut other_first = other.next().unwrap();\n  \
    \          if let Some(other_other) = it.next() {\n                let mut other_second_first\
    \ = other_other.next().unwrap();\n                match other_second_first {\n\
    \                    Some('\\0') => {\n                        s = s.chars().rev().collect();\n\
    \                    }\n                    _ => (),\n                };\n   \
    \             match other_first {\n                    Some('\\0') => {\n    \
    \                    s = s.chars().rev().collect();\n                    }\n \
    \                   _ => (),\n                };\n                match other_second\
    \ {\n                    Some('\\0') => {\n                        s = s.chars().rev().collect();\n\
    \                    }\n                    _ => (),\n                };\n   \
    \             match other {\n                    Some('\\0') => {\n          \
    \              s = s.chars().rev().collect();\n                    }\n       \
    \             _ => (),\n                };\n                match first {\n  \
    \                  Some('\\0') => {\n                        s = s.chars().rev().collect();\n\
    \                    }\n                    _ => (),\n                };\n   \
    \         } else {\n                match first {\n                    Some('\\\
    0') => {\n                        s = s.chars().rev().collect();\n           \
    \         }\n                    _ => (),\n                };\n              \
    \  match other_first {\n                    Some('\\0') => {\n               \
    \         s = s.chars().rev().collect();\n                    }\n            \
    \        _ => (),\n                };\n            }\n        } else {\n     \
    \       match first {\n                Some('\\0') => {\n                    s\
    \ = s.chars().rev().collect();\n                }\n                _ => (),\n\
    \            }\n        }\n    }\n    s", "    let mut s = String::from(s);\n\
    \    let mut result = String::from(s);\n    s.chars().for_each(|c| {\n       \
    \ let mut ch = c;\n        if *ch >= 'A' && *ch <= 'Z' {\n            *ch = *ch\
    \ - 'A' + 'a';\n        } else if *ch >= 'a' && *ch <= 'z' {\n            *ch\
    \ = *ch - 'a' + 'A';\n        } else {\n            *ch = *ch;\n        }\n  \
    \      result += *ch;\n    });\n    result", "    // use regex to find all words\
    \ in s\n    let mut matches: Vec<String> = regex::Regex::new(r\"[a-z]+\").unwrap().find_iter(&s).collect();\n\
    \n    // rev the words\n    for &str in matches {\n        let mut reverse = str;\n\
    \        reverse.chars().for_each(|c| match c {\n            c if c.is_alphanumeric()\
    \ => {\n                c.to_ascii_lowercase().swap()\n            }\n       \
    \     _ => (),\n        })\n    }\n\n    // concat all matches\n    matches.into_iter().filter(|&s|\
    \ !s.is_empty()).collect().join()", "    let mut str = s.to_string();\n    let\
    \ mut len = str.len();\n    while len > 0 {\n        let mut len = len;\n    \
    \    while len > 0 {\n            let c = str[len - 1];\n            if c.is_alpha()\
    \ {\n                str[len - 1] = c.to_uppercase();\n                break;\n\
    \            } else if c.is_digit() {\n                str[len - 1] = c.to_digit().unwrap();\n\
    \                break;\n            }\n            len -= 1;\n        }\n   \
    \ }\n    str", "    let mut s: String = s.to_string();\n    for ch in s.chars()\
    \ {\n        let c = if ch.is_lowercase() {\n            ch.to_uppercase()\n \
    \       } else {\n            ch.to_lowercase()\n        };\n        s = s.replace(c,\
    \ \"#\").to_string();\n    }\n    s.to_string()", "    let mut res = String::from(\"\
    \");\n    for &c in s.chars() {\n        if c.is_ascii_uppercase() {\n       \
    \     res.push_str(&c.to_ascii_lowercase());\n        } else {\n            res.push_str(&c.to_ascii_uppercase());\n\
    \        }\n    }\n    if res.is_empty() {\n        res = s;\n    }\n    res",
  "    let mut result = s.clone();\n    if result.is_empty() {\n        result = \"\
    #\";\n    }\n    let mut counter = 0;\n    let mut i = 0;\n    let mut length\
    \ = result.len();\n    let mut letters = false;\n    loop {\n        if i == length\
    \ {\n            break;\n        }\n        if let Some(letter) = result.chars().nth(i).unwrap()\
    \ {\n            counter += 1;\n            if counter == 2 {\n              \
    \  result.push_str(&(letter.to_ascii_lowercase()));\n            } else {\n  \
    \              result.push_str(&(letter.to_ascii_uppercase()));\n            }\n\
    \            i += 1;\n            length = result.len();\n        } else {\n \
    \           i += 1;\n            length = result.len();\n        }\n    }\n  \
    \  result", "    if s.chars().any(|c| c.is_ascii()) {\n        solve(s.to_ascii_lowercase())\n\
    \    } else {\n        solve(s.to_ascii_uppercase())\n    }", "    let mut new_s\
    \ = String::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let c: Char = s[i];\n        if c.is_letter() {\n            if s.len()\
    \ > i {\n                if s[i] == s[i+1] {\n                    new_s.push_str(&s[i..i]);\n\
    \                } else {\n                    new_s.push_str(&s[i..i+1]);\n \
    \               }\n            }\n            i += 1;\n        } else {\n    \
    \        new_s.push_str(&s[i]);\n            i += 1;\n        }\n    }\n    new_s.push_str(&s[..i]);\n\
    \    new_s", "    let mut s = s.chars();\n    s.reverse();\n    s.filter(|&c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').map(|c| c.to_ascii_lowercase().to_string())\n\
    \        .collect::<String>().iter()\n        .join(\"\").to_string()", "    s.chars().for_each(|c|\
    \ {\n        if c.is_alpha() {\n            c.to_ascii_lowercase().to_ascii_uppercase();\n\
    \        } else {\n            c\n        }\n    })", "    let mut res = String::from(s);\n\
    \    if res.chars().any(|c| *c < 'a' || *c > 'z') {\n        res.chars().rev().collect();\n\
    \    } else {\n        res.chars().collect();\n    }\n    res", "    if s.is_empty()\
    \ {\n        String::from(\"AaBbCcDd\")\n    } else {\n        let mut res = String::from(\"\
    \");\n        for &c in s.chars() {\n            match c {\n                'a'\
    \ | 'b' | 'c' => {\n                    res += String::from(\"CcDdEeFfGgHh\");\n\
    \                },\n                'd' | 'e' | 'f' => {\n                  \
    \  res += String::from(\"EeFfGgHhIiJj\");\n                },\n              \
    \  'g' | 'h' | 'i' => {\n                    res += String::from(\"HhIiJjKkLl\"\
    );\n                },\n                'j' | 'k' | 'l' => {\n               \
    \     res += String::from(\"IiJjKkLlMm\");\n                },\n             \
    \   'm' | 'l' | 'n' => {\n                    res += String::from(\"LlMmNnOoPpQq\"\
    );\n                },\n                'o' | 'p' | 'q' => {\n               \
    \     res += String::from(\"PpQqRrSsTt\");\n                },\n             \
    \   'r' | 's' | 't' => {\n                    res += String::from(\"RsTtUuVvWwXxYy\"\
    );\n                },\n                'u' | 'v' | 'w' => {\n               \
    \     res += String::from(\"VvWwXxYyZz\");\n                },\n             \
    \   'w' | 'x' | 'y' => {\n                    res += String::from(\"WxYyZz\");\n\
    \                },\n                'y' | 'z' | _ => {\n                    res\
    \ += String::from(\"Zz\");\n                }\n            };\n        }\n   \
    \     res += String::from(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"\
    );\n        res.chars().rev().collect::<Vec<_>>()\n    }", "    let mut result\
    \ = String::new();\n    let mut prev_letter = false;\n    for i in s.chars() {\n\
    \        if i.is_lowercase() {\n            prev_letter = false;\n           \
    \ if prev_letter == false {\n                result.push_str(\"A\");\n       \
    \     }\n            prev_letter = true;\n            result.push_str(i.get_lowercase());\n\
    \        } else {\n            prev_letter = false;\n            if prev_letter\
    \ == false {\n                result.push_str(\"a\");\n            }\n       \
    \     prev_letter = true;\n            result.push_str(i.get_uppercase());\n \
    \       }\n    }\n    result", "    let mut s = s;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if !is_letter(&s[i]) {\n            swap(i, i+1);\n \
    \       }\n        i += 1;\n    }\n    s.clone()", "    s.chars().filter(|&c|\
    \ c == 'a' || c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C').for_each(|&c|\
    \ {\n        if (c == 'a' || c == 'A') c = 'A';\n        if (c == 'b' || c ==\
    \ 'B') c = 'B';\n        if (c == 'c' || c == 'C') c = 'C';\n    })", "    let\
    \ mut s = s;\n    let mut s = s;\n    while let Some(c) = s.chars().next() {\n\
    \        let c = c as char;\n        if c.is_ascii_lowercase() {\n           \
    \ s = s.into_lowercase();\n        } else if c.is_ascii_uppercase() {\n      \
    \      s = s.into_uppercase();\n        } else {\n            s = c;\n       \
    \ }\n    }\n    s", "    let mut s = s;\n    let mut len = s.len();\n    while\
    \ len > 0 {\n        if s.is_ascii_lowercase(0) {\n            s = s.into_lowercase();\n\
    \        } else if s.is_ascii_uppercase(0) {\n            s = s.into_uppercase();\n\
    \        } else {\n            break;\n        }\n        len -= 1;\n    }\n \
    \   s", "    s.chars().map(|c| match c {\n        c @ _ => c,\n        '#' | '$'\
    \ => {\n            if s.len() == 0 {\n                c\n            } else {\n\
    \                if c.to_string().is_lowercase() {\n                    s.chars().map(|c|\
    \ match c {\n                        'a' => {\n                            c\n\
    \                        }\n                        'A' => {\n               \
    \             c\n                        }\n                        '#' | '$'\
    \ => {\n                            if s.len() == 0 {\n                      \
    \          c\n                            } else {\n                         \
    \       if c.to_string().is_lowercase() {\n                                  \
    \  s.chars().map(|c| match c {\n                                        'a' =>\
    \ {\n                                            c\n                         \
    \               }\n                                        'A' => {\n        \
    \                                    c\n                                     \
    \   }\n                                        _ => c,\n                     \
    \               }).collect()\n                                } else {\n     \
    \                               s.chars().map(|c| match c {\n                \
    \                        'a' => {\n                                          \
    \  c\n                                        }\n                            \
    \            'A' => {\n                                            c\n       \
    \                                 }\n                                        _\
    \ => c,\n                                    }).collect()\n                  \
    \              }\n                            }\n                        }\n \
    \                       _ => c,\n                    }).collect()\n          \
    \      } else {\n                    s.chars().map(|c| match c {\n           \
    \             'a' => {\n                            c\n                      \
    \  }\n                        'A' => {\n                            c\n      \
    \                  }\n                        '#' | '$' => {\n               \
    \             if s.len() == 0 {\n                                c\n         \
    \                   } else {\n                                if c.to_string().is_lowercase()\
    \ {\n                                    s.chars().map(|c| match c {\n       \
    \                                 'a' => {\n                                 \
    \           c\n                                        }\n                   \
    \                     'A' => {\n                                            c\n\
    \                                        }\n                                 \
    \       _ => c,\n                                    }).collect()\n          \
    \                      } else {\n                                    s.chars().map(|c|\
    \ match c {\n                                        'a' => {\n              \
    \                              c\n                                        }\n\
    \                                        'A' => {\n                          \
    \                  c\n                                        }\n            \
    \                            _ => c,\n                                    }).collect()\n\
    \                                }\n                            }\n          \
    \              }\n                        _ => c,\n                    }).collect()\n\
    \                }\n            }\n        }\n        _ => c,\n    }).collect()",
  "    let mut newString = \"\";\n    for ch in s {\n        if let Some(letter) =\
    \ match ch {\n            Some(c) => c,\n            None => return newString,\n\
    \            _ => return newString,\n        }\n        if let Some(lowerLetter)\
    \ = letter.to() {\n            let newLowerLetter = if lowerLetter == 'A' { 'B'\
    \ } else { lowerLetter };\n            newString = newString.to_string() + newLowerLetter\
    \ + newString;\n        } else {\n            newString = newString.to_string()\
    \ + letter + newString;\n        }\n    }\n    newString", "    let mut new_s\
    \ = s;\n    \n    for x in s.chars() {\n        let char = x.to_ascii_lowercase();\n\
    \        if char.len() != 1 || char.chars().first() != 'a' || char.chars().last().unwrap()\
    \ != 'a' {\n            new_s = new_s.to_string();\n        }\n    }\n    new_s",
  "    let mut s1 = s.to_lowercase();\n    let mut s2 = s.to_lowercase();\n\n    for\
    \ i in s.chars().enumerate() {\n        if s1.contains(i.0) {\n            s2.insert(i.0,\
    \ i.1);\n        } else {\n            s2.insert(i.0, i.0);\n        }\n    }\n\
    \n    s2.into()", "    let mut s = s;\n    s.chars().cloned().for_each(|c|\n \
    \       if c.is_ascii() {\n            if c >= 'a' && c <= 'z' {\n           \
    \     c.to_ascii_lowercase();\n            } else if c >= 'A' && c <= 'Z' {\n\
    \                c.to_ascii_uppercase();\n            } else {\n             \
    \   c = c.to_ascii_lowercase();\n            }\n        } else {\n           \
    \ c = c.to_ascii_lowercase();\n        }\n    );\n    String::from(s)", "    let\
    \ mut reversed = s.clone();\n    let mut result = String::new();\n    for i in\
    \ s.chars() {\n        if i.is_ascii_lowercase() {\n            reversed.to_lowercase();\n\
    \        } else if i.is_ascii_uppercase() {\n            reversed.to_uppercase();\n\
    \        } else {\n            result = result.push_str(&i);\n        }\n    }\n\
    \    result.reverse();\n    result", "    s.chars().map(|c| match c {\n      \
    \  'a' | 'A' => c as char,\n        'b' | 'B' => c as char,\n        'c' | 'C'\
    \ => c as char,\n        _ => c,\n    }).collect::<String>().reverse().into_iter().collect::<String>()",
  "    if s.is_empty() {\n        s\n    } else {\n        let mut new_s = s;\n  \
    \      new_s.reverse();\n        if new_s.is_lowercase() {\n            new_s.to_ascii_lowercase().reverse();\n\
    \        } else if new_s.is_uppercase() {\n            new_s.to_ascii_uppercase().reverse();\n\
    \        } else {\n            new_s\n        }\n    }", "    let mut s = s.to_string();\n\
    \    if s.chars().any(|c| !c.is_letter()) {\n        std::str::from_utf8(&s).unwrap().to_uppercase();\n\
    \    } else {\n        std::str::from_utf8(&s).unwrap().to_lowercase();\n    }",
  "    let mut res = String::from(s);\n\n    for c in s.chars() {\n        match c\
    \ {\n            'a' => {\n                res = res.chars().chain(Some(b => b.to_ascii_lowercase())).chain(Some(b\
    \ => b.to_ascii_uppercase()))\n                    .chain(Some(b => b.to_ascii_lowercase())).collect();\n\
    \            }\n            'A' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_uppercase())).chain(Some(b => b.to_ascii_lowercase()))\n     \
    \               .chain(Some(b => b.to_ascii_uppercase())).collect();\n       \
    \     }\n            'b' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_lowercase())).chain(Some(b => b.to_ascii_uppercase()))\n     \
    \               .chain(Some(b => b.to_ascii_lowercase())).collect();\n       \
    \     }\n            'B' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_uppercase())).chain(Some(b => b.to_ascii_lowercase()))\n     \
    \               .chain(Some(b => b.to_ascii_uppercase())).collect();\n       \
    \     }\n            '#' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_lowercase())).chain(Some(b => b.to_ascii_uppercase()))\n     \
    \               .chain(Some(b => b.to_ascii_lowercase())).collect();\n       \
    \     }\n            '@' => {\n                res = res.chars().chain(Some(b\
    \ => b.to_ascii_uppercase())).chain(Some(b => b.to_ascii_lowercase()))\n     \
    \               .chain(Some(b => b.to_ascii_uppercase())).collect();\n       \
    \     }\n            _ => (),\n        }\n    }\n    res", "    if s.chars().count()\
    \ > 0 {\n        Solution::iter(s)\n    } else {\n        Solution::reverse_iter(s)\n\
    \    }", "    if s.chars().any(|x| !x.is_ascii()) {\n        solve_reverse(s);\n\
    \    } else {\n        solve_reverse(s.to_ascii_lowercase());\n    }", "    let\
    \ mut s: Vec<_> = s.chars().collect();\n    s.reverse();\n    let mut new_s =\
    \ String::new();\n    for c in s {\n        if c.is_lowercase() {\n          \
    \  new_s.push_str(c.to_string().to_uppercase());\n        } else {\n         \
    \   new_s.push_str(c.to_string().to_lowercase());\n        }\n    }\n    new_s",
  "    if s.is_empty() { return String::new(); }\n\n    let mut s: String = s;\n \
    \   for c in s.chars() {\n        if let Some(upper) = c.to_ascii_uppercase()\
    \ {\n            s.replace(c.to_ascii_lowercase(), upper);\n        }\n      \
    \  if let Some(low) = c.to_ascii_lowercase() {\n            s.replace(c.to_ascii_uppercase(),\
    \ low);\n        }\n    }\n\n    s", "    if s.is_empty() {\n        \"\".to_string();\n\
    \    } else {\n        let mut s = s;\n        let mut i = 0;\n        while !s.is_empty()\
    \ {\n            let mut c = s[i];\n            if c == 'A' {\n              \
    \  if i == 0 {\n                    s = String::from(\"cA\");\n              \
    \      break;\n                }\n                c += 'a' - 'A';\n          \
    \  } else if c == 'a' {\n                if i == 0 {\n                    s =\
    \ String::from(\"Ca\");\n                    break;\n                }\n     \
    \           c += 'A' - 'a';\n            }\n            s[i] = c;\n          \
    \  i += 1;\n        }\n        s + &s[i..].to_string()\n    }", "    let mut result\
    \ = String::new();\n    for ch in s.chars() {\n        if ch.is_ascii_letter()\
    \ {\n            result.push((ch as u8).to_ascii_uppercase().to_string());\n \
    \       } else {\n            result.push(ch);\n        }\n    }\n    result",
  "    let mut s = s.to_lowercase();\n    if s.chars().any(|c| !c.is_ascii_lowercase())\
    \ {\n        s = s.to_uppercase();\n    }\n    s", '    solve_internal(s).to_string()',
  "    if s.is_empty() {\n        return s;\n    }\n    \n    let mut s = s;\n   \
    \ \n    // step 1: loop through each character, try to reverse it\n    for c in\
    \ s.chars() {\n        \n        // step 2: if the char not letter move to the\
    \ next one\n        if !c.is_letter() {\n            \n            // step 3:\
    \ if we are at the end, return the empty string\n            if s.len() == 0 {\n\
    \                return String::new();\n            }\n            \n        \
    \    // step 4: move to the next char\n            s = &s[1..];\n            \n\
    \            // step 5: move to the next char\n            c = &s[1..];\n    \
    \    }\n        \n        // step 6: reverse the char\n        s = s.chars().filter(|c|\
    \ c.is_letter()).map(|c| c.to_ascii_lowercase()).collect::<String>() + s;\n  \
    \      \n        // step 7: move to the next char\n        c = &s[1..];\n    }\n\
    \    \n    // step 8: return the resulted string\n    s", "    s.chars().map(|c|\
    \ {\n        match c {\n            c if c.is_letter() => c.to_uppercase(),\n\
    \            c if c.is_digit() => c.to_lowercase(),\n            _ => c,\n   \
    \     }\n    }).collect::<String>() + s.chars().filter(|c| !c.is_letter()).collect::<String>()\
    \ + s.chars().filter(|c| !c.is_digit()).collect::<String>() + s", "    let mut\
    \ res = String::from(\"a\");\n    let mut lower = String::from(\"z\");\n    let\
    \ mut upper = String::from(\"A\");\n\n    for i in s.chars() {\n        match\
    \ i {\n            'A' | 'a' => { res += &upper; upper = String::from(\"A\");},\n\
    \            'B' | 'b' => { res += &lower; lower = String::from(\"B\"); },\n \
    \           'C' | 'c' => { res += &upper; upper = String::from(\"C\");},\n   \
    \         'D' | 'd' => { res += &lower; lower = String::from(\"D\"); },\n    \
    \        'E' | 'e' => { res += &upper; upper = String::from(\"E\");},\n      \
    \      'F' | 'f' => { res += &lower; lower = String::from(\"F\"); },\n       \
    \     'G' | 'g' => { res += &upper; upper = String::from(\"G\");},\n         \
    \   'H' | 'h' => { res += &lower; lower = String::from(\"H\"); },\n          \
    \  'I' | 'i' => { res += &upper; upper = String::from(\"I\");},\n            'J'\
    \ | 'j' => { res += &lower; lower = String::from(\"J\"); },\n            'K' |\
    \ 'k' => { res += &upper; upper = String::from(\"K\");},\n            'L' | 'l'\
    \ => { res += &lower; lower = String::from(\"L\"); },\n            'M' | 'm' =>\
    \ { res += &upper; upper = String::from(\"M\");},\n            'N' | 'n' => {\
    \ res += &lower; lower = String::from(\"N\"); },\n            'O' | 'o' => { res\
    \ += &upper; upper = String::from(\"O\");},\n            'P' | 'p' => { res +=\
    \ &lower; lower = String::from(\"P\"); },\n            'Q' | 'q' => { res += &upper;\
    \ upper = String::from(\"Q\");},\n            'R' | 'r' => { res += &lower; lower\
    \ = String::from(\"R\"); },\n            'S' | 's' => { res += &upper; upper =\
    \ String::from(\"S\");},\n            'T' | 't' => { res += &lower; lower = String::from(\"\
    T\"); },\n            'U' | 'u' => { res += &upper; upper = String::from(\"U\"\
    );},\n            'V' | 'v' => { res += &lower; lower = String::from(\"V\"); },\n\
    \            'W' | 'w' => ", "    let mut s = s.replace(s.chars().filter_map(|c|\
    \ {\n        let is_letter = c.is_letter();\n        if is_letter {\n        \
    \    if c.is_lowercase() {\n                Some(c.to_uppercase().to_string())\n\
    \            } else {\n                Some(c.to_lowercase().to_string())\n  \
    \          }\n        } else {\n            None\n        }\n    }).collect::<Vec<String>>()).to_string();\n\
    \    \n    if s.is_empty() {\n        String::new()\n    } else {\n        s\n\
    \    }", '    s.chars().map(|c| if is_alpha_lower(c) then c.to_string().to_lowercase()
    else c.to_string()).collect::<String>().to_owned()', "    s.chars().fold(\"1234\"\
    .to_string(), |mut c, x| {\n        if c.is_empty() {\n            c = x.to_string();\n\
    \        } else {\n            c = c.chars().fold(x.to_string(), |mut d, y| {\n\
    \                if d.is_empty() {\n                    d = y.to_string();\n \
    \               } else {\n                    if let Some(c) = d.chars().next()\
    \ {\n                        d += c.to_ascii_lowercase().to_string();\n      \
    \              } else {\n                        d += y.to_string();\n       \
    \             }\n                }\n                d\n            });\n     \
    \   }\n        c\n    })", "    s.chars()\n        .filter(|c| is_letter(c))\n\
    \        .fold(\n            |s, c| {\n                let mut s = c.to_lowercase();\n\
    \                if *s != c {\n                    s = c.to_uppercase();\n   \
    \             }\n                s\n            },\n            &s.to_string(),\n\
    \        )", "    s.chars().map(|c| if c < 'a' || (c > 'z' && c < 'A') || (c >\
    \ 'Z') || (c < '0' && c > '9') {\n        String::from(c).to_string().to_uppercase()\n\
    \    } else {\n        String::from(c).to_string().to_lowercase()\n    }).collect::<String>()\
    \ + s", "    let mut res = s.clone();\n    let mut counter = String::new();\n\
    \    for (i, c) in s.chars().enumerate() {\n        counter.push_str(&(c.to_lowercase()));\n\
    \        if i != 0 {\n            res.push_str(&(c.to_uppercase()));\n       \
    \ }\n    }\n    res.push_str(&counter);\n    res", "    let mut s = s.to_lowercase();\n\
    \    let mut res = s.clone();\n\n    if res.len() == 0 {\n        String::from(\"\
    nothing\")\n    } else if res.chars().any(|c| match c {\n        'a' => true,\n\
    \        'z' => true,\n        'A' => true,\n        'Z' => true,\n        _ =>\
    \ false,\n    }) {\n        let mut res_copy = res.clone();\n        res_copy.reverse();\n\
    \        res = String::from(res_copy);\n    }\n    return res", "    if let Ok(mut\
    \ s) = s.chars() {\n        while let Some(mut c) = s.next() {\n            if\
    \ c.is_ascii_lowercase() {\n                c.to_ascii_uppercase();\n        \
    \    } else {\n                c.to_ascii_lowercase();\n            }\n      \
    \  }\n    }\n    String::from(s)", "    \n    match s {\n        s => s.to_string()\n\
    \            .chars()\n            .filter_map(|x| if x.is_a< char> { x.to_string()\
    \ + x.to_string().to_lowercase() } else { x })\n            .collect::<Vec<_>>()\n\
    \            .iter()\n            .fold(\"\".to_string(), |mut acc, char| match\
    \ char {\n                c if c.is_a< char> => {\n                    let mut\
    \ res = acc;\n                    res.push_str(&mut c.to_lowercase());\n     \
    \               res\n                },\n                c => {\n            \
    \        let mut res = acc;\n                    res.push_str(&mut c);\n     \
    \               res\n                }\n            })\n            .to_string(),\n\
    \        None => s.to_string()\n            .chars()\n            .map(|x| if\
    \ x.is_a< char> { x.to_string() + x.to_string().to_lowercase() } else { x })\n\
    \            .collect::<Vec<_>>()\n            .iter()\n            .fold(\"\"\
    .to_string(), |mut acc, char| match char {\n                c if c.is_a< char>\
    \ => {\n                    let mut res = acc;\n                    res.push_str(&mut\
    \ c.to_lowercase());\n                    res\n                },\n          \
    \      c => {\n                    let mut res = acc;\n                    res.push_str(&mut\
    \ c);\n                    res\n                }\n            })\n          \
    \  .to_string(),\n    }", "    let mut chars = s.chars();\n    chars.next().unwrap();\n\
    \    if chars.next() != Some('a'){\n        chars.next().unwrap();\n    }\n  \
    \  let mut result = String::new();\n    let mut cur = chars.next().unwrap();\n\
    \    loop {\n        if cur == Some('a') {\n            if chars.next() == Some('z')\
    \ {\n                cur = chars.next().unwrap();\n            }\n           \
    \ else\n                cur = chars.next().unwrap();\n        }\n        else\
    \ if cur == Some('z') {\n            if chars.next() == Some('a') { \n       \
    \         cur = chars.next().unwrap();\n            }\n            else\n    \
    \            cur = chars.next().unwrap();\n        }\n        else \n        \
    \    result.push(*cur);\n        cur = chars.next().unwrap();\n    }\n    result",
  "    if s.is_empty() { return String::new(); }\n    let mut str = String::new();\n\
    \    for ch in s {\n        let cap = match ch {\n            'a' => false,\n\
    \            'A' => false,\n            '#' => true,\n            _ => false,\n\
    \        };\n        if cap {\n            str = str.chars().filter_map(|c| if\
    \ c == 'A' { 'a' } else { c }).collect();\n        } else {\n            str =\
    \ str.chars().filter_map(|c| if c == 'a' { 'A' } else { c }).collect();\n    \
    \    }\n    }\n    str", "    match s.chars() {\n        // reverse the case of\
    \ the letter if there is one\n        char::is_letter => (s.to_string().chars().enumerate().filter_map(|(i,\
    \ _)| {\n            Some((\n                match i {\n                    //\
    \ reverse the case of the letter if there is one\n                    0 => Some(s.chars().nth(i).unwrap().to_ascii_lowercase()),\n\
    \                    n => Some(s.chars().nth(i).unwrap().to_ascii_uppercase()),\n\
    \                    _ => None,\n                }\n            ))\n        }).collect()).join(\"\
    \"),\n\n        _ => s,\n    }", "    let mut s = String::from(s);\n    let mut\
    \ chars = s.chars();\n    chars.reverse();\n    s = chars.collect();\n    String::from(s)",
  "    // Fn returns String\n    let mut new_s = s;\n\n    let mut i = 0;\n\n    while\
    \ i < new_s.len() {\n        if new_s[i..].chars().any(|&x| x >= 'A' && x <= 'Z')\
    \ {\n            new_s = new_s.to_string().to_lowercase();\n            i += 1;\n\
    \            continue;\n        }\n        if new_s[i..].chars().any(|&x| x >=\
    \ 'a' && x <= 'z') {\n            new_s = new_s.to_string().to_uppercase();\n\
    \            i += 1;\n            continue;\n        }\n        i += 1;\n    }\n\
    \n    new_s", "    if !s.is_empty() && s.chars().all(|c| c.is_letter()) {\n  \
    \      let mut reversed_s = s.chars().enumerate().rev().map(|(i, char)| {\n  \
    \          if i % 2 == 0 {\n                char.to_upper().to_string()\n    \
    \        } else {\n                char.to_lowercase().to_string()\n         \
    \   }\n        }).collect();\n        reversed_s.insert(0, s.chars().collect());\n\
    \        reversed_s.insert(0, s.chars().count());\n        return String::from(reversed_s);\n\
    \    } else {\n        return s.chars().collect();\n    }", "    s.chars().fold(String::new(),\
    \ |result, c| match c {\n        Some('a'..='z') => result.push_str(c.to_string()),\n\
    \        Some('A'..='Z') => result.push_str(c.to_string() + c.to_string()),\n\
    \        Some(_) => result.push_str(c.to_string()),\n        None => result.push_str(c.to_string()),\n\
    \    })", "    match s.chars().count(|c| is_letter(c.to_ascii_lowercase()) ||\
    \ is_letter(c.to_ascii_uppercase())) {\n        0 => s,\n        _ => reverse(s),\n\
    \    }", '    solve(s0, s.chars()).to_owned()', "    if s.is_empty() {\n     \
    \   String::new()\n    } else {\n        let mut s = String::from(*s);\n     \
    \   for i in 0..s.len() {\n            if s[i].is_ascii_letter() {\n         \
    \       if s.starts_with(s.chars().skip(i).rev().collect::<String>()) {\n    \
    \                s = s.replace(i+1, i+1, s[i].to_ascii_lowercase());\n       \
    \         } else {\n                    s = s.replace(i+1, i+1, s[i].to_ascii_uppercase());\n\
    \                }\n            } else {\n                s = s.replace(i+1, i+1,\
    \ s[i]);\n            }\n        }\n        \n        s\n    }", "    // return\
    \ s if s is empty\n    if s.is_empty() {\n        return s;\n    }\n\n    // count\
    \ how many letters in s\n    let mut letter_count: usize = 0;\n    for c in s.chars()\
    \ {\n        if c.is_ascii() {\n            letter_count += 1;\n        }\n  \
    \  }\n\n    // create string with new length\n    let mut result = String::with_capacity(s.len()\
    \ * letter_count + s.len());\n\n    // copy the s\n    result.extend(s.chars());\n\
    \n    // reverse every letters\n    for c in result.chars() {\n        if c.is_ascii()\
    \ {\n            let mut s = c.to_ascii_lowercase();\n            if s.is_ascii()\
    \ {\n                s = s.to_ascii_uppercase();\n            }\n            c.replace(s);\n\
    \        }\n    }\n\n    result", "    s.chars().filter(|c| c.is_ascii_lowercase()).map(|c|\
    \ c.to_ascii_lowercase()).collect()\n        .join().chars().filter(|c| c.is_ascii_uppercase()).map(|c|\
    \ c.to_ascii_uppercase()).collect()", "    \n    s.chars().enumerate().fold(String::from(\"\
    ?\"), |mut acc, (idx, ch)| {\n        let (mut x, mut y) = (acc, \"?\");\n   \
    \     let char = s.chars().nth(idx);\n        if let Some(is_letter) = char.ascii_lowercase()\
    \ {\n            x =  &mut ch.to_ascii_uppercase();\n        }\n        if let\
    \ Some(is_letter) = char.ascii_uppercase() {\n            y = &mut ch.to_ascii_lowercase();\n\
    \        }\n        acc\n    });\n    ", "    if s.len() == 0 {\n        String::from(\"\
    \")\n    } else {\n        let mut rev = s.chars().collect::<Vec<char>>();\n \
    \       rev.rev();\n        rev.join(\"\").to_string()\n    }", "    let mut res\
    \ = String::new();\n    let len = s.len();\n    for i in 0..len {\n        let\
    \ char = s[i]; // char here is String, not char.char()\n        if char.is_ascii_lowercase()\
    \ {\n            res.push_str(&s[len - i - 1].to_ascii_lowercase());\n       \
    \ } else {\n            res.push_str(&s[len - i - 1].to_ascii_uppercase());\n\
    \        }\n    }\n    res", "    let mut s = s;\n    while !s.is_empty() {\n\
    \        if s.is_alphanumeric() {\n            s = s.to_lowercase().to_uppercase();\n\
    \        }\n        else{\n            s = s.to_lowercase();\n        }\n    }\n\
    \    s", "    if s.is_empty() {\n        return String::from(\"1\");\n    }\n\
    \    let mut result = String::new();\n    for i in 0..s.len() {\n        match\
    \ s[i].to_ascii_lowercase() {\n            Some('a') => result.append(&'A' - 'a'),\n\
    \            Some('z') => result.append(&'Z' - 'z'),\n            Some(c) => result.append(&c\
    \ - 'a'),\n            None => result.append(&s[i] - 'a'),\n        }\n    }\n\
    \    result", "    let mut s = s;\n    let mut i = 0;\n    loop {\n        if\
    \ s[i].is_ascii() {\n            let j = (i + 1) % (s.len() - 1);\n          \
    \  s[i] = s[s.len() - j];\n            s[i] = s[i].to_upper();\n            i\
    \ += 1;\n        } else {\n            i += 1;\n        }\n        if i >= s.len()\
    \ {\n            break;\n        }\n    }\n    s", "    \n    let mut res = String::new();\n\
    \    for e in s.chars() {\n        let ch = match e.to_lowercase() {\n       \
    \     \"a\" => e.to_uppercase(),\n            \"b\" => e.to_lowercase(),\n   \
    \         \"c\" => e.to_uppercase(),\n            \"d\" => e.to_lowercase(),\n\
    \            _ => e,\n        };\n        res.push_str(&ch);\n    }\n    res",
  "    let mut s = s;\n    loop {\n        if s.is_empty() {\n            return s;\n\
    \        }\n        if s.chars().any(|c| c != 'a' && c != 'A' && c != '#' && c\
    \ != '$') {\n            return s;\n        }\n        let len = s.len();\n  \
    \      s.chars().cloned()\n            .enumerate()\n            .for_each(|(i,\
    \ c)| {\n                if *c.is_uppercase() {\n                    s.swap(i,\
    \ len - i - 1);\n                }\n            });\n    }", "    if s.len() ==\
    \ 0 {\n        return s;\n    }\n    let mut result = String::new();\n    for\
    \ i in s.chars() {\n        if i.is_ascii_lowercase() {\n            result.push_str(i.to_uppercase());\n\
    \        } else {\n            result.push_str(i.to_lowercase());\n        }\n\
    \    }\n    result", "    if !s.is_ascii() {\n        String::from_utf8(s.to_utf8()).unwrap().into()\n\
    \    } else {\n        let mut s = String::new();\n        iterate_string_by_char_case(s,\
    \ |c| {\n            match c {\n                'A' | 'a' => return 'B',\n   \
    \             'B' | 'b' => return 'A',\n                'C' | 'c' => return 'a',\n\
    \                'a' | 'A' => return 'b',\n                'b' | 'B' => return\
    \ 'C',\n                'C' | 'c' => return 'A',\n                'd' | 'D' =>\
    \ return 'D',\n                'D' | 'd' => return 'd',\n                'e' |\
    \ 'E' => return 'E',\n                'E' | 'e' => return 'e',\n             \
    \   'f' | 'F' => return 'F',\n                'F' | 'f' => return 'f',\n     \
    \           'G' | 'g' => return 'G',\n                'G' | 'g' => return 'g',\n\
    \                'h' | 'H' => return 'H',\n                'H' | 'h' => return\
    \ 'h',\n                'i' | 'I' => return 'I',\n                'I' | 'i' =>\
    \ return 'i',\n                'j' | 'J' => return 'J',\n                'J' |\
    \ 'j' => return 'j',\n                'k' | 'K' => return 'K',\n             \
    \   'K' | 'k' => return 'k',\n                'l' | 'L' => return 'L',\n     \
    \           'L' | 'l' => return 'l',\n                'm' | 'M' => return 'M',\n\
    \                'M' | 'm' => return 'm',\n                'n' | 'N' => return\
    \ 'N',\n                'N' | 'n' => return 'n',\n                'o' | 'O' =>\
    \ return 'O',\n                'O' | 'o' => return 'o',\n                'p' |\
    \ 'P' => return 'P',\n                'P' | 'p' => return 'p',\n             \
    \   'q' | 'Q' => return 'Q',\n                'Q' | 'q' => return 'q',\n     \
    \           'r' | 'R' => return 'R',\n                'R' | 'r' => return 'r',\n\
    \                's' | 'S' => return 'S',\n                'S' | 's' => return\
    \ 's',\n                't' | 'T' => return 'T',\n                'T' | 't' =>\
    \ return 't',\n                'u' | 'U' => return 'U',\n                'U' |\
    \ 'u' => return 'u',\n                'v' | 'V' => return 'V',\n             \
    \   'V' | 'v' => return 'v',\n                'w' | 'W' => return 'W',\n     \
    \           'W' | 'w' => return 'w',\n                'x' | 'X' => return 'X',\n\
    \                'X' | 'x' => return 'x',\n", "    s.chars()\n        .map(|c|\
    \ if c.is_letter() {\n            (c.to_lowercase(), c.to_uppercase())\n     \
    \   } else {\n            (c, c)\n        })\n        .fold(String::new(), |mut\
    \ s, (c, u)| {\n            if let (Some(c), Some(u)) = (c, u) {\n           \
    \     let mut s = String::from(s);\n                let mut i = s.len();\n   \
    \             s.insert((i >> 1).saturating_add(i), c);\n                s.insert((i\
    \ >> 1).saturating_add(i + 1), u);\n                s\n            } else {\n\
    \                s\n            }\n        });", "    let mut res = String::from(\"\
    0\");\n    let mut t = s.chars();\n    for c in t {\n        if c.is_lowercase()\
    \ {\n            res.push_str(c.to_uppercase());\n        } else if c.is_uppercase()\
    \ {\n            res.push_str(c.to_lowercase());\n        } else {\n         \
    \   res.push(c);\n        }\n    }\n    res.trim_left_until(1);\n    return res",
  "    s.chars()\n        .filter(|c| c != b'@')\n        .map(|c| if c == b'A' {\n\
    \            b'Z'\n        } else {\n            b'a'\n        })\n        .collect()\n\
    \        .to_string()", "    s.chars().map(|c| if c.is_alphanumeric() {\n    \
    \    c.to_ascii_lowercase()\n    } else {\n        c.to_ascii_uppercase()\n  \
    \  }).chain(s.chars()).collect::<Vec<_>>().map(|s| s.to_string()).collect()",
  "    if let Some(iter) = s.chars().filter_map(|c| {\n        match c {\n       \
    \     c if c >= 'a' && c <= 'z' => Some((c - 'a' + 10).to_string()),\n       \
    \     c if c >= 'A' && c <= 'Z' => Some((c - 'A' + 10).to_string()),\n       \
    \     _ => None,\n        }\n    }) {\n        s.reverse();\n        iter\n  \
    \  } else {\n        s.reverse();\n        String::from(\"\")\n    }", "    let\
    \ mut s = s;\n    \n    for c in s.chars().filter(|c| c.is_ascii()) {\n      \
    \  match c.to_ascii_lowercase() {\n            Some(c) => s.insert(c, s.len()\
    \ - c.len() as i32),\n            None => ()\n        }\n    }\n\n    if s.chars().count()\
    \ != 0 {\n        s\n    } else {\n        String::from(s.to_ascii_lowercase().unwrap())\n\
    \    }", "    let mut s = s;\n\n    for i in 0..s.len() {\n        let char =\
    \ s.chars().nth(i).unwrap();\n\n        if char.is_ascii_lowercase() {\n     \
    \       if i >= s.len() - 1 {\n                return s;\n            }\n\n  \
    \          let next = s.chars().nth(i + 1).unwrap();\n\n            if next.is_ascii_uppercase()\
    \ {\n                s = s.chars().collect();\n            }\n\n            let\
    \ next = s.chars().nth(i + 2).unwrap();\n\n            if next.is_ascii_lowercase()\
    \ {\n                s = s.chars().collect();\n            }\n        }\n\n  \
    \      let c = s.chars().nth(i).unwrap();\n\n        if c.is_ascii_uppercase()\
    \ {\n            if i >= s.len() - 2 {\n                return s;\n          \
    \  }\n\n            let next = s.chars().nth(i + 1).unwrap();\n\n            if\
    \ next.is_ascii_lowercase() {\n                s = s.chars().collect();\n    \
    \        }\n\n            let next = s.chars().nth(i + 2).unwrap();\n\n      \
    \      if next.is_ascii_uppercase() {\n                s = s.chars().collect();\n\
    \            }\n        }\n    }\n\n    s.into_owned()", "    s.chars().filter(|c|\
    \ c.is_ascii_lowercase()).fold(String::new(), |mut result, c| {\n        match\
    \ c {\n            'a' => {\n                result.push_str(&c.to_ascii_lowercase());\n\
    \                result.push_str(&c.to_ascii_uppercase());\n            },\n \
    \           'A' => {\n                result.push_str(&c.to_ascii_uppercase());\n\
    \                result.push_str(&c.to_ascii_lowercase());\n            },\n \
    \           _ => result.push_str(&c),\n        }\n        result\n    }).to_string()",
  '    solve(s.chars(), s.len())', "    solve1(s, s.chars().chain(s.chars().enumerate().filter(|(_,\
    \ c)| c != '#'))).to_string()", "    s.chars().filter_map(move |c|{\n        match\
    \ *c {\n            'A'..='Z' => Some(c.to_string().to_upper()),\n           \
    \ 'a'..='z' => Some(c.to_string().to_lower()),\n            _ => None,\n     \
    \   }\n    }).collect()", "    let mut res = s.clone();\n    let mut c = s.chars();\n\
    \    c.sort();\n\n    if c.is_empty() {\n        return res;\n    }\n\n    let\
    \ mut start = Some(c.next().unwrap());\n    let mut end = Some(c.next().unwrap());\n\
    \    while !start.is_none() && !end.is_none() {\n        let c = start.unwrap();\n\
    \        let e = end.unwrap();\n\n        let mut new_s = \"\";\n\n        if\
    \ c.is_uppercase() {\n            new_s.append(&c.to_lowercase());\n        }\
    \ else {\n            new_s.append(&c.to_uppercase());\n        }\n\n        if\
    \ e.is_uppercase() {\n            new_s.append(&e.to_lowercase());\n        }\
    \ else {\n            new_s.append(&e.to_uppercase());\n        }\n\n        res\
    \ = new_s + res;\n        start = Some(c.next().unwrap());\n        end = Some(c.next().unwrap());\n\
    \    }\n\n    res.to_string()", '    solve2(s, String::new())', "    if s.is_empty()\
    \ {\n        return s.to_owned();\n    }\n\n    let mut s = String::from(s);\n\
    \n    for letter in s.chars() {\n        if let Some(c) = match letter {\n   \
    \         c if c.is_lowercase() || c.is_uppercase() => c.to_uppercase(),\n   \
    \         c if c.is_uppercase() || c.is_lowercase() => c.to_lowercase(),\n   \
    \         _ => letter,\n        };\n        s = s.replace(&letter, \"\");\n  \
    \  }\n\n    return s.to_owned();", "    if s.chars().any(|c| c.is_lowercase())\
    \ {\n        s.chars()\n            .map(|c| if c.is_lowercase() {\n         \
    \       c\n            } else {\n                c.to_uppercase().to_string()\n\
    \            })\n            .collect()\n    } else {\n        s.chars()\n   \
    \         .map(|c| if c.is_lowercase() {\n                c\n            } else\
    \ {\n                c\n            })\n            .collect()\n    }", "    let\
    \ mut s = s;\n    for c in s.chars() {\n        if c.is_uppercase() {\n      \
    \      s = s.to_string().to_lowercase().chars().collect::<String>().join(\"\"\
    ) + c;\n        } else {\n            s = s.to_string().to_uppercase().chars().collect::<String>().join(\"\
    \") + c;\n        }\n    }\n    s", "    if s.len() == 0 {\n        return String::from(s);\n\
    \    }\n    if s.chars().all(|c| c.is_letter()) {\n        String::from(s.chars().map(|c|\
    \ if c.is_lower() { c.to_upper() } else { c.to_lower() }).collect::<String>())\n\
    \    } else {\n        String::from(s.chars().map(|c| c.to_ascii_lowercase()).collect::<String>())\n\
    \    }", "    check(s.chars().filter(|c| isalpha(c)).fold(s, |acc, c| {\n    \
    \    if c.is_uppercase() {\n            acc.to_string() + c.to_string() + acc.to_string()\n\
    \        } else {\n            acc + c.to_string() + acc\n        }\n    }))",
  "    let mut reversed = 0;\n    for i in s.chars() {\n        match i {\n      \
    \      'a' => reversed = !reversed,\n            'A' => reversed = !reversed,\n\
    \            'b' => reversed = !reversed,\n            'B' => reversed = !reversed,\n\
    \            'c' => reversed = !reversed,\n            'C' => reversed = !reversed,\n\
    \            _ => (),\n        }\n    }\n    if reversed == 0 {\n        s\n \
    \   } else {\n        s.chars().cloned()\n            .map(|c| {\n           \
    \     match c {\n                    'a' | 'A' => c as u32,\n                \
    \    'b' | 'B' => c as u32,\n                    'c' | 'C' => c as u32,\n    \
    \                _ => c,\n                }\n            })\n            .collect()\n\
    \            .cloned()\n            .join(\"\")\n    }", "    if s.is_empty()\
    \ {\n        String::new()\n    } else if is_letter(s) {\n        s.reverse();\n\
    \    } else if s.chars().all(|&c| !is_letter(c)) {\n        s.reverse();\n   \
    \ }\n    s"]
stop_tokens:
- "\n}"
