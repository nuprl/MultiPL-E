name: HumanEval_23_strlen
language: rs
prompt: "/// Return length of given string\n/// >>> strlen(String::from(\"\"))\n///\
  \ 0\n/// >>> strlen(String::from(\"abc\"))\n/// 3\nfn strlen(string: String) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = strlen;\n    assert_eq!(candidate(String::from(\"\
  \")), 0);\n    assert_eq!(candidate(String::from(\"x\")), 1);\n    assert_eq!(candidate(String::from(\"\
  asdasnakj\")), 9);\n}\n"
completions: ['    string.len()', '    string.len()', '    string.len()', '    string.len()',
  '    string.len()', '    string.len()', '    string.len()', '    string.len()',
  '    string.chars().count();', '    string.len()', '    string.chars().count() +
    0', '    string.len()', '    string.len()', '    string.len()', '    string.bytes().len()',
  '    string.len()', '    string.len()', '    string.chars().count() as isize', '    string.len()',
  '    string.len() as isize', "    if string.is_empty() {\n        return 0\n   \
    \ }\n    string.chars().count(|c| *c == 0)", '    string.chars().count() + 1',
  '    string.len() as isize', "    if string.is_empty() {\n        return 0;\n  \
    \  }\n    let mut len = 0;\n    for c in string.chars() {\n        len += 1;\n\
    \        if len > MAX_LEN {\n            return MAX_LEN;\n        }\n    }\n \
    \   len", '    string.chars().filter(|c| c.is_ascii()).count()', '    string.len()',
  '    string.len() as isize', "    if string.is_empty() {\n        return 0\n   \
    \ }\n    if string.len() <= 0 {\n        return 1\n    }\n    string.len() - 1",
  '    string.as_ref().len_utf8()', '    string.len()', "    if string.is_empty()\
    \ {\n        return 0;\n    }\n    let mut len: isize = 0;\n    for c in string.as_bytes()\
    \ {\n        len += 1;\n    }\n    len", "    if string.len() != 0 {\n       \
    \ string.len()\n    } else {\n        0\n    }", '    string.len()', '    string.len()
    as isize', '    string.length()', '    string.len()', '    string.chars().count().unwrap_or(0)',
  "    let mut len = 0;\n    for c in string.chars() {\n        len += 1;\n    }\n\
    \    len", '    string.len()', '    string.len() as isize', "    if string.chars().count()\
    \ == 0 {\n        return 0;\n    }\n    string.chars().count();", '    string.len()',
  '    string.len()', '    string.chars().count().unwrap_or(0)', '    string.len()',
  "    let len = string.len();\n    if len == 0 {\n        0\n    } else {\n     \
    \   len\n    }", '    string.len()', '    string.len()', '    string.length()',
  '    string.chars().count() + 1', '    string.len()', '    string.len()', '    string.chars().count()
    as isize', '    string.len()', '    string.rev().len()', '    string.len()', '    string.len()',
  '    string.len() as isize', '    string.as_bytes().len()', '    string.len()',
  '    string.len() as isize', '    string.chars().count() as isize', '    string.chars().count().unwrap()',
  "    let mut len = string.len();\n    unsafe {\n        assert!(len == string.as_ptr().add(rand::random::<usize>()\
    \ % len));\n    }\n    len", '    string.as_bytes().len()', '    string.chars().count();',
  '    string.len()', "    if string.is_empty() {\n        return 0\n    }\n\n   \
    \ string.as_bytes().len()", "    string.as_bytes()\n        .iter()\n        .map(|c|\
    \ c.to_ascii_lowercase().len())\n        .sum()", '    string.len()', '    string.len()',
  '    string.len()', '    string.chars().count();', '    string.len()', '    string.len()',
  '    string.len()', '    string.len()', '    string.len()', '    string.len() as
    isize', "    let mut len = 0;\n    for c in string.bytes() {\n        if *c <\
    \ b'A' || *c > b'z' {\n            return -1;\n        }\n        len += 1;\n\
    \    }\n    len", '    string.chars().count();', '    string.as_bytes().len()',
  "    if string.is_empty() {\n        return 0;\n    }\n\n    let mut pos = 0;\n\
    \    let mut len = string.len();\n\n    while pos < len {\n        let c = &string[pos];\n\
    \        if !c.is_ascii() {\n            break;\n        }\n\n        pos += 1;\n\
    \        len -= 1;\n    }\n\n    len", "    let mut len = string.len();\n    len\
    \ -= 1;\n    len", '    string.len()', '    string.as_str().len()', '    string.len()',
  '    string.len()', '    string.chars().count()', '    string.chars().count() +
    1;', '    string.length()', '    string.len() as isize', '    string.length()',
  "    let size = string.len() as isize;\n    if size == 0 {\n        0\n    } else\
    \ {\n        size\n    }", '    string.len()', '    string.chars().count().unwrap()',
  '    string.len() as isize', '    string.chars().count()', '    string.len()', " \
    \   if string.len() == 0 {\n        return 0;\n    }\n\n    let len = string.len();\n\
    \n    if len == 0 {\n        -1\n    } else {\n        len\n    }", '    string.len()',
  "    let mut s = string.as_str();\n    s.chars().count();", '    string.len()',
  '    string.as_bytes().len()', '    string.len()', "    if string.is_empty() {\n\
    \        return 0;\n    }\n\n    let mut len = 0;\n    for c in string.chars()\
    \ {\n        len = len + 1;\n    }\n\n    len", "    let len = string.len();\n\
    \    if len > MAX_LEN {\n        MAX_LEN\n    } else {\n        len\n    }", '    string.len()
    as isize', '    string.len()', '    string.len()', "    let mut len = 0;\n   \
    \ for c in string.as_bytes() {\n        if *c > 0xFF {\n            return -1;\n\
    \        }\n        len += 1;\n    }\n    len", '    string.len()', '    string.len()
    as isize', "    let len = string.len();\n    if len == 0 {\n        0\n    } else\
    \ {\n        len\n    }", "    string.as_bytes()\n        .iter()\n        .position(|c|\
    \ c == b'\\x00')\n        .unwrap_or(0)", '    string.chars().count();', "   \
    \ let mut len = 0;\n    for c in string.chars() {\n        len += 1;\n    }\n\
    \    len", '    string.len()', '    string.len()', '    string.len()', "    let\
    \ mut len = string.len();\n    len -= 1;\n    while string.chars().skip(len).count()\
    \ == 0 {\n        len -= 1;\n    }\n    len", "    let mut len = 0;\n    for ch\
    \ in string.chars() {\n        len += 1;\n    }\n    len", "    let mut pos =\
    \ 0;\n    let len = string.len();\n    for _ in 0..len {\n        pos += 1;\n\
    \    }\n    pos", '    string.len()', '    string.len()', '    string.len()',
  "    let mut buf = [0u8; 128];\n    let mut len = String::with_capacity(128);\n\
    \    string.chars().for_each(|c| {\n        if c > 127 {\n            len = String::from(\"\
    \");\n            return;\n        }\n        buf.truncate(0);\n        let ret\
    \ = buf.write_bytes(&[c as u8]);\n        if ret == buf.len() {\n            len\
    \ = String::from(&buf[..]);\n            return;\n        }\n    });\n    len.into_raw_size()",
  "    let mut len = string.len();\n    unsafe {\n        len.checked_add(i8::min_value()).unwrap()\n\
    \    }", '    string.len() as isize', '    string.len() as isize', '    string.chars().count();',
  '    string.chars().count() as isize', '    string.len()', '    string.as_str().len()',
  '    string.len()', '    string.len()', "    let len = string.len();\n    if len\
    \ < 0 {\n        0\n    } else {\n        len\n    }", '    string.as_bytes().len()',
  "    if string.is_empty() {\n        0\n    } else {\n        let mut len = 0;\n\
    \        for c in string.as_ref() {\n            len += c.len_utf8();\n      \
    \  }\n        len\n    }", '    string.len()', '    string.len()', '    string.chars().count()
    as isize', "    string.chars().count(|x| *x != '\\0')", '    string.chars().count();',
  '    string.len() as isize', '    string.chars().count()', '    string.chars().count().unwrap_or(0)',
  '    string.chars().count()', '    string.len()', '    string.len()', '    string.bytes().len()',
  '    string.len()', '    string.as_bytes().len()', '    string.len() as isize',
  '    string.len()', "    if string.is_empty() {\n        return 0\n    }\n\n   \
    \ let len = string.len();\n    if len > MAX_LEN {\n        MAX_LEN\n    } else\
    \ {\n        len\n    }", '    string.length()', '    string.len()', '    string.len()',
  '    string.len()', "    if string.is_empty() {\n        return 0\n    }\n    let\
    \ mut char_iter: CharIter = string.chars();\n    let mut counter: usize = 0;\n\
    \    while let Some(byte) = char_iter.next() {\n        if byte == 0 || byte ==\
    \ 255 {\n            return counter;\n        }\n        counter += 1;\n    }\n\
    \    counter as isize", '    string.len()', '    string.len()', '    string.len()',
  '    string.chars().count() + 0', '    string.len() as isize', '    string.len()',
  '    string.len()', '    string.as_bytes().len()', '    string.len()', '    string.len()',
  "    let mut len = string.len();\n    for &b in string.chars() {\n        len +=\
    \ 1;\n    }\n    len", '    string.chars().count();', '    string.len()', "  \
    \  string\n        .into_bytes()\n        .iter()\n        .map(|&b| b as usize)\n\
    \        .sum()", '    string.len()', '    string.len()', '    string.as_str().len()',
  '    string.len()', "    if string.is_empty() {\n        0\n    } else {\n     \
    \   string.as_ref().len()\n    }", '    string.len()', '    string.chars().count();',
  '    string.len()', '    string.len()', "    string\n        .as_bytes()\n     \
    \   .iter()\n        .map(|&b| b as u8)\n        .count();", "    let mut len\
    \ = string.len();\n    len.clamp_min(0);\n    len", '    string.len()', '    string.len()',
  "    let mut len_str = 0;\n    for (index, ch) in string.chars().enumerate() {\n\
    \        if index == 0 {\n            len_str += 1;\n        } else if ch == 0\
    \ {\n            len_str += 2;\n        } else {\n            len_str += 1;\n\
    \        }\n    }\n    len_str", '    string.len()', '    string.len() as isize',
  '    string.len()', '    string.len() as isize', '    string.len()', '    string.len()',
  "    if string.len() <= 0 {\n        return 0;\n    }\n    string.as_bytes().len()\
    \ as isize", '    string.len()', '    string.length()', '    string.len()', " \
    \   if string.len() == 0 {\n        0\n    } else {\n        string.len()\n  \
    \  }"]
stop_tokens:
- "\n}"
