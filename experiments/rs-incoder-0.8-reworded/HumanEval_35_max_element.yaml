name: HumanEval_35_max_element
language: rs
prompt: "/// Return maximum element in the vector.\n/// >>> max_element(vec![1, 2,\
  \ 3])\n/// 3\n/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
  /// 123\nfn max_element(l: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = max_element;\n    assert_eq!(candidate(vec![1,\
  \ 2, 3]), 3);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),\
  \ 124);\n}\n"
completions: ['    l.iter().max_unstable()', '    l.iter().max().unwrap_or(l.len())',
  '    l.iter().max().unwrap()', "    let mut max = l[0];\n    for e in l.iter_mut()\
    \ {\n        if e > max {\n            max = e;\n        }\n    }\n    max", " \
    \   if l.len() == 1 {\n        l[0]\n    } else {\n        let mut m = l[0];\n\
    \        for &n in &l[1..] {\n            if n < m {\n                m = &n;\n\
    \            }\n        }\n        m\n    }", '    l.iter().max_unstable().unwrap_or(0)',
  "    let mut max = l[0];\n    for i in l.iter().skip(1) {\n        if *i > max {\n\
    \            max = *i;\n        }\n    }\n    max", '    l.iter().max().unwrap_or(0)',
  "    let mut max_value = l[0];\n    for i in l.iter().rev() {\n        if i > &max_value\
    \ {\n            max_value = i;\n        }\n    }\n    max_value", '    l.iter().max().unwrap_or(l.len())',
  '    l.iter().max_by(|a, b| a.cmp(b)).unwrap_or(l.len())', '    l.iter().max_by_key(|&x|
    x).unwrap()', '    l.iter().max().unwrap()', "    let mut max_elem = l[0];\n \
    \   let mut idx = 1;\n    for (i, &elt) in l.iter().enumerate() {\n        if\
    \ *elt > max_elem {\n            max_elem = *elt;\n            idx = i;\n    \
    \    }\n    }\n    idx", "    let mut max = l.iter().cloned().max();\n    loop\
    \ {\n        if max.is_none() {\n            break;\n        }\n        match\
    \ l {\n            l if *l.is_none() == false => return *l.unwrap(),\n       \
    \     l if *l.is_some() == true => max = Some(*l.unwrap()),\n            _ =>\
    \ {}\n        }\n    }\n    max", "    let mut max: isize = 0;\n    for i in l.iter().rev()\
    \ {\n        if *i > max {\n            max = *i;\n        }\n    }\n    max",
  "    let mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n    let mut\
    \ max = l[0];\n    for v in l.iter().rev() {\n        if v > max {\n         \
    \   max = v;\n        }\n        if v < min {\n            min = v;\n        }\n\
    \    }\n    max", "    let mut it = l.iter().max_by_key(|&x| x).unwrap();\n  \
    \  it.next().unwrap()", "    if l.len() == 0 {\n        std::i32::MAX as isize\n\
    \    } else {\n        let mut max_element = l[0];\n        for ele in &l[1..]\
    \ {\n            if ele > max_element {\n                max_element = ele;\n\
    \            }\n        }\n        max_element\n    }", "    let mut max = l[0];\n\
    \    for i in 1 .. l.len() {\n        if l[i] > max {\n            max = l[i];\n\
    \        }\n    }\n    max", "    let mut max = l.iter().max().unwrap();\n   \
    \ for i in l {\n        if i < max {\n            max = i;\n        }\n    }\n\
    \    max", '    l.iter().max().unwrap()', "    let mut max = l.iter().max().unwrap();\n\
    \    for i in l.iter().rev() {\n        if i > max {\n            max = i;\n \
    \       }\n    }\n    max", "    let len = l.len();\n    l.iter().rev().fold(0,\
    \ |a, b| if *b > a { a } else { b })", "    let mut max_elt = 0;\n    for elt\
    \ in l.iter().cloned() {\n        if elt > max_elt {\n            max_elt = elt;\n\
    \        }\n    }\n    max_elt", '    l.iter().max().unwrap_or(0)', "    let mut\
    \ max = l[0];\n    for i in l.iter_mut() {\n        if *i > max {\n          \
    \  max = *i;\n        }\n    }\n    max", '    l.iter().max_unwrap_or_else(||
    l.len())', '    l.iter().max().unwrap_or(0)', "    let mut min_val = l[0];\n \
    \   let mut max_val = l[0];\n    for i in l.iter().rev() {\n        min_val =\
    \ if i < min_val { i } else { min_val };\n        max_val = if i > max_val { i\
    \ } else { max_val };\n    }\n    if min_val >= max_val {\n        return min_val;\n\
    \    }\n    return max_val;", '    l.iter().max().unwrap_or(l[0].clone())', " \
    \   if l.len() <= 1 {\n        l.into_iter().max()\n    } else {\n        let\
    \ mut iter = l.iter().rev();\n        let mut max = iter.peek();\n        iter.for_each(|&e|\
    \ if *e > max { *e = max });\n        max\n    }", "    let mut max = l[0];\n\
    \    for el in &l {\n        if *el > max {\n            max = *el;\n        }\n\
    \    }\n    max", "    let mut max = l.iter().max_by_key(|&x| x).unwrap();\n \
    \   if *l < max {\n        *l = max;\n    }\n    max", "    let mut min_val =\
    \ l.iter().min();\n    l.iter().for_each(|x| {\n        if x < min_val {\n   \
    \         min_val = x;\n        }\n    });\n    min_val", '    l.iter().max().unwrap()',
  "    let mut max = l[0];\n    for &e in l.iter().rev() {\n        if e > max {\n\
    \            max = e;\n        }\n    }\n    max", '    l.iter().max().unwrap_or(l.len())',
  "    let mut max = l.iter().max().unwrap();\n    for i in l.iter_mut().skip(1) {\n\
    \        *i =\n            if *i == max {\n                *i\n            } else\
    \ {\n                *i\n                    as isize\n                    - max\
    \ as isize + 1\n            };\n    }\n    max", "    let mut max_value = l.iter().max().unwrap();\n\
    \    let mut it = l.iter();\n    let mut found = false;\n    for elt in it.reversed()\
    \ {\n        if elt > max_value {\n            found = true;\n            max_value\
    \ = elt;\n        }\n    }\n    if !found {\n        max_value\n    } else {\n\
    \        max_value\n    }", '    l.iter().max().unwrap_or(0)', "    let mut max_el\
    \ = l.iter().max().unwrap();\n    loop {\n        match max_el {\n           \
    \ None => return max_el,\n            Some(el) => {\n                if el < 0\
    \ {\n                    max_el = l.iter().skip(1).take(1).last().unwrap();\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n        }\n    }", '    l.iter().max().unwrap_or(0)', "    let mut\
    \ max = l.iter().max().unwrap();\n    for i in &l {\n        if *i > max {\n \
    \           max = *i;\n        }\n    }\n    max", '    l.iter().max().unwrap_or(l.len()
    - 1)', '    l.iter().fold(std::i32::MIN as isize, |max_elem| *max_elem as isize)',
  '    l.iter().max().unwrap_or(0)', "    let mut max_value = l.iter().max().unwrap();\n\
    \    for ele in l {\n        if ele > max_value {\n            max_value = ele;\n\
    \        }\n    }\n    max_value", '    l.iter().max_unwrap_or(0)', "    let len\
    \ = l.len();\n    let mut max = l[0];\n    for i in 1..len {\n        if l[i]\
    \ > max {\n            max = l[i];\n        }\n    }\n    max", '    l.iter().max_unwrap_or(0)',
  '    l.iter().rev().max().unwrap_or(l.iter().max().unwrap_or(0))', '    l.iter().max_by(|a,
    b| a.cmp(b)).unwrap()', '    l.iter().max_by_key(|x| *x).unwrap_or(l.len())',
  "    if l.len() == 0 {\n        panic!(\"The vector is empty.\")\n    }\n    let\
    \ mut max = l[0];\n    for i in 1..l.len() {\n        if max < l[i] {\n      \
    \      max = l[i];\n        }\n    }\n    max", '    l.iter().max_by_key(|x| *x).unwrap()',
  '    l.iter().max().unwrap_or(0)', '    l.iter().max_unwrap_or(0)', "    let mut\
    \ i = l.iter().min_by_key(|x| x);\n    l.iter().rev().nth(i).unwrap()", "    let\
    \ mut max = l[0];\n    let mut max_idx = 0;\n    for &el in l {\n        if el\
    \ > max {\n            max = el;\n            max_idx = 1;\n        } else if\
    \ el == max {\n            max_idx += 1;\n        }\n    }\n    max_idx", '    l.iter().max().unwrap_or(0)',
  "    let mut max = l.iter().max().unwrap();\n    l.iter().any(|&x| x >= max).cloned()\
    \ ? max : l.iter().max().unwrap()", "    let mut max = l[0];\n    let mut i =\
    \ 0;\n    while i < l.len() {\n        if max < l[i] {\n            max = l[i];\n\
    \        }\n        i += 1;\n    }\n    max", "    if l.len() < 1 {\n        panic!(\"\
    max_element: no elements in vector\");\n    }\n\n    let mut max: isize = 0;\n\
    \    let mut cur = l.len();\n\n    loop {\n        let next = cur - 1;\n\n   \
    \     // loop breaks on max\n        if l[next] > max {\n            break;\n\
    \        }\n\n        // set max and cur\n        max = l[next];\n        cur\
    \ = next;\n    }\n\n    max", "    if l.len() == 1 {\n        return l[0];\n \
    \   }\n    let mut largest = l[0];\n    for i in l.iter().rev() {\n        if\
    \ i > largest {\n            largest = i;\n        }\n    }\n    largest", " \
    \   let mut it = l.iter().max_by(|a, b| a.partial_cmp(b).unwrap());\n    match\
    \ it.next() {\n        None => isize::MAX,\n        Some(val) => val,\n    }",
  "    let mut max: isize = 0;\n    for &i in l {\n        if max < i {\n        \
    \    max = i;\n        }\n    }\n    max", '    l.iter().max().unwrap_or(l[0].clone())',
  "    if l.len() == 0 {\n        l.len()\n    } else {\n        let mut max = l[0];\n\
    \        for i in 1 .. l.len() {\n            if l[i] > max {\n              \
    \  max = l[i];\n            }\n        }\n        max\n    }", '    l.iter().max_unwrap_or(0)',
  '    l.iter().max().unwrap_or(0)', '    l.iter().max().unwrap_or(l.len())', '    l.iter().max().unwrap()',
  "    let mut max_elem = l.iter().max();\n    max_elem = *max_elem;\n    max_elem",
  '    l.iter().rev().max().unwrap_or(l.len())', "    let mut min_el = l.iter().min_by_key(|&a|\
    \ a);\n    l.iter().max_by_key(|&a| {\n        if a < min_el {\n            min_el\
    \ = a;\n        }\n    });\n    min_el", "    let mut max = 0;\n    for i in l.iter()\
    \ {\n        if i > max {\n            max = i;\n        }\n    }\n    max", '    l.iter().max().unwrap_or(l[0].clone())',
  '    l.iter().max().unwrap()', '    l.iter().max().unwrap()', '    l.iter().max().unwrap_or(0)',
  '    l.iter().max().unwrap_or(l.len())', '    l.iter().max().unwrap()', '    l.iter().max().unwrap_or(l.len())',
  "    let mut max_value = l[0];\n\n    for &i in l {\n        if *i > max_value {\n\
    \            max_value = *i;\n        }\n    }\n\n    max_value", "    let mut\
    \ max = l[0];\n    for i in 1..l.len() {\n        if max < l[i] {\n          \
    \  max = l[i];\n        }\n    }\n    max", '    l.iter().max().unwrap_or(l.len())',
  '    l.iter().max_unwrap_or(l.len())', '    l.iter().max().unwrap_or(0)', "    let\
    \ mut max = l[0];\n    for i in l.iter().rev() {\n        if *i > max {\n    \
    \        max = *i;\n        }\n    }\n    max", "    l.iter().fold(0, |max_so_far,\
    \ val| match val {\n        Some(val) => cmp::max(max_so_far, val),\n        None\
    \ => max_so_far,\n    })", '    l.iter().max_by_key(|x| x).unwrap()', '    l.iter().max_by_key(|&a|
    a).unwrap()', '    l.iter().max().unwrap_or(0)', "    // Binary search\n    let\
    \ mut left = 0;\n    let mut right = l.len() - 1;\n    while left <= right {\n\
    \        let middle = left + (right - left) / 2;\n        if l[middle] > l[middle+1]\
    \ {\n            right = middle - 1;\n        } else {\n            left = middle\
    \ + 1;\n        }\n    }\n    l[left]", '    l.iter().max().unwrap_or(0)', '    l.iter().max().unwrap()',
  "    let mut res = vec![0];\n    let mut max_val = l[0];\n\n    for i in l.iter()\
    \ {\n        if *i > *max_val {\n            max_val = i;\n        }\n    }\n\
    \    res[0] = max_val;\n    res[1]", "    let mut max_elem = l[0];\n    for i\
    \ in &l[l.len() - 1] {\n        if i > max_elem {\n            max_elem = i;\n\
    \        }\n    }\n    max_elem", "    let mut max = l.iter().max().unwrap();\n\
    \    l.iter().for_each(|x| *x = -*x);\n    max", '    l.iter().max_by_key(|&x|
    x).unwrap()', '    l.iter().max_by_key(|&x| x).unwrap()', '    l.iter().max_by_key(|x|
    x).unwrap()', "    let mut min = l[0];\n    for &e in l {\n        if e > min\
    \ {\n            min = e;\n        }\n    }\n    min", '    l.iter().max().unwrap()',
  "    let mut max = l[0];\n    for i in 1 .. l.len() {\n        if max < l[i] {\n\
    \            max = l[i];\n        }\n    }\n    max", '    l.iter().max().unwrap_or(l.iter().next().unwrap_or(0))',
  '    l.iter().max().unwrap_or(-1)', '    l.iter().max().unwrap()', '    l.iter().max_unwrap_or(l.len())',
  "    let mut max = l[0];\n    for &e in &l {\n        if e > max {\n           \
    \ max = e;\n        }\n    }\n    max", "    let mut max = l[0];\n    for &x in\
    \ &l {\n        if x > max {\n            max = x;\n        }\n    }\n    max",
  "    let mut max_val = l[0];\n    let mut max_idx = 0;\n\n    for idx in 1..l.len()\
    \ {\n        if l[idx] > max_val {\n            max_val = l[idx];\n          \
    \  max_idx = idx;\n        }\n    }\n\n    max_idx", "    let mut max_elem = std::i32::MAX;\n\
    \    for elem in l {\n        if elem > max_elem {\n            max_elem = elem;\n\
    \        }\n    }\n    max_elem", '    l.iter().max().unwrap_or(0)', '    l.iter().max_by_key(|x|
    x).unwrap()', "    let mut it = l.iter().max_by_key(|&x| x);\n    it.unwrap()",
  "    let mut max = l.iter().fold(isize::MIN, isize::MAX);\n    max = l.iter().fold(max,\
    \ |a, b| a.partial_cmp(&b).unwrap());\n    max", "    let mut max = l[0];\n  \
    \  for e in l {\n        if e > max {\n            max = e;\n        }\n    }\n\
    \    max", '    l.iter().max().unwrap()', '    l.iter().rev().max().unwrap()',
  '    l.iter().max().unwrap()', '    l.iter().max().unwrap()', "    if l.is_empty()\
    \ {\n        l.push(isize::max_value());\n    }\n    let mut m = l[0];\n    for\
    \ i in 1..l.len() {\n        if l[i] > m {\n            m = l[i];\n        }\n\
    \    }\n    m", '    l.iter().max().unwrap_or(0)', "    let mut max_elem: isize\
    \ = 0;\n    let mut max_index: isize = 0;\n\n    for i in l {\n        if max_elem\
    \ < i {\n            max_elem = i;\n            max_index = i;\n        }\n  \
    \  }\n\n    max_index", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l[0]", '    l.iter().max_by_key(|x| x).unwrap()',
  "    let mut max_value = l[0];\n    for i in l.iter() {\n        if i > max_value\
    \ {\n            max_value = i;\n        }\n    }\n    max_value", "    if l.len()\
    \ == 1 {\n        return l[0];\n    }\n\n    let mut max = l[0];\n    for i in\
    \ l.iter().rev() {\n        if i > max {\n            max = i;\n        }\n  \
    \  }\n    max", '    l.rev().max()', "    let mut max_val = l[0];\n    for i in\
    \ l.iter() {\n        if i > max_val {\n            max_val = i;\n        }\n\
    \    }\n    max_val", "    let mut max_element = l.iter().max();\n    max_element.unwrap()",
  "    let mut max_val = l[0];\n    for i in 1..l.len() {\n        let val = l[i];\n\
    \        if val > max_val {\n            max_val = val;\n        }\n    }\n  \
    \  max_val", '    l.iter().max_by(|a, b| a.cmp(b)).unwrap_or(l.len())', "    let\
    \ mut cmp = l[0];\n    for ele in l.iter().rev() {\n        cmp = cmp.max(ele);\n\
    \    }\n    cmp", '    l.iter().max_by_key(|x| x).unwrap()', '    l.iter().max_by(|a,
    b| a.partial_cmp(b).unwrap_or(a > b)).unwrap()', "    l.iter().fold(l.iter().max().unwrap(),\
    \ |a, b| {\n        b.cmp(a).unwrap()\n    })", '    l.iter().max_unstable().unwrap()',
  '    l.iter().max().unwrap()', '    l.iter().max_by_key(|x| x).unwrap()', "    if\
    \ l.len() == 0 {\n        l.iter().max().unwrap()\n    } else {\n        l.iter().max().unwrap().clone()\n\
    \    }", '    l.iter().max().unwrap_or(l.len())', "    if l.is_empty() {\n   \
    \     isize::MAX\n    } else {\n        let mut i = 0;\n        let mut max =\
    \ l[0];\n        for &v in &l {\n            if *v > max {\n                max\
    \ = v;\n            }\n            i += 1;\n        }\n        max\n    }", '    l.iter().max().unwrap_or(l.len())',
  "    let mut max_val = l[0];\n    for i in 1..l.len() {\n        if l[i] > max_val\
    \ {\n            max_val = l[i];\n        }\n    }\n    max_val", '    l.iter().max().unwrap_or(l.len()
    - 1)', "    let mut res = l.iter().max().unwrap();\n    loop {\n        match\
    \ l.iter().skip(1).find(|&x| x > res) {\n            Some(Ok(pos)) => {\n    \
    \            res = pos;\n            }\n            Some(Ok(i)) => {\n       \
    \         return i;\n            }\n            None => return res,\n        }\n\
    \    }", "    if l.len() == 0 {\n        panic!(\"max_element called on empty\
    \ vector\");\n    }\n    let mut max = l[0];\n    for i in 1..l.len() {\n    \
    \    if l[i] > max {\n            max = l[i];\n        }\n    }\n    max", '    l.iter().max().unwrap()',
  "    let mut max = l[0];\n    for &elt in l.iter().rev() {\n        if elt > max\
    \ {\n            max = elt;\n        }\n    }\n    max", "    let mut max = l[0];\n\
    \    for &x in l {\n        if x > max {\n            max = x;\n        }\n  \
    \  }\n    max", '    l.iter().max_unwrap_or(std::i32::MAX as isize)', '    l.iter().max().unwrap_or(l.len())',
  "    let mut max_elem = l;\n    let mut max_ele_idx = l.len();\n    for i in 0..l.len()\
    \ {\n        if l[i] > max_elem[0] {\n            max_elem = &l[..i];\n      \
    \      max_ele_idx = i;\n        }\n    }\n    max_ele_idx", "    let mut max\
    \ = l.iter().max().unwrap();\n    for i in l {\n        if i < max {\n       \
    \     max = i;\n        }\n    }\n    max", "    let mut max_elem = *l;\n    loop\
    \ {\n        let index = l.iter().position(|&x| x > &max_elem).unwrap();\n   \
    \     max_elem = index > 0 ? l[index] : max_elem;\n    }", '    l.iter().max_by(|a,
    b| a.partial_cmp(b).unwrap()).unwrap()', '    l.iter().fold(std::i32::MAX, (std::i32::MAX
    as isize).cmp)', "    let mut max_value = l.iter().max().unwrap();\n    for i\
    \ in l.iter().rev() {\n        if i > max_value {\n            max_value = i;\n\
    \        }\n    }\n    max_value", "    let mut max_elem = 0;\n    let mut max_elem\
    \ = l.iter().enumerate().max_by(|(a, b), (c, d) in {\n        if *c > *d {\n \
    \           1\n        } else {\n            0\n        }\n    })?.1;\n    max_elem",
  '    l.iter().max_unwrap_or(l[l.len() - 1])', '    l.iter().max_by_key(|&i| i).unwrap()',
  "    let mut max_ele = l.iter().max_unwrap_or(0);\n    for i in &l {\n        if\
    \ i < max_ele {\n            max_ele = i;\n        }\n    }\n    max_ele", '    l.iter().max().unwrap_or(0)',
  '    l.iter().max().unwrap_or(0)', '    l.iter().max_unwrap_or(l.len())', "    let\
    \ mut v = l;\n    v.sort();\n    v.last_mut().unwrap()", "    let mut max_elem\
    \ = l.iter().max().unwrap();\n    for elt in l.iter().rev() {\n        if elt\
    \ > max_elem {\n            max_elem = elt;\n        }\n    }\n    max_elem",
  '    l.iter().max().unwrap_or(0)', '    l.iter().max_by_key(|x| x).unwrap()', '    l.iter().max().unwrap_or(-1)',
  '    l.iter().max().unwrap_or(0)', "    // We need an unstable sorting algorithm,\
    \ so let's take advantage of unstable sorting\n    // for now.\n    let mut max\
    \ = l.iter().rev().peek().unwrap();\n    let mut max_index = 0;\n    for i in\
    \ l.iter().rev().skip(1) {\n        if *i >= max {\n            max = *i;\n  \
    \          max_index = i;\n        }\n    }\n    max_index", '    l.iter().max().unwrap_or(l.len())',
  '    l.iter().max().unwrap()', '    l.iter().max().unwrap()', '    l.iter().max().unwrap_or(l.len())',
  "    let mut max_elem = l.iter().max().unwrap();\n    for v in l {\n        if v\
    \ > max_elem {\n            max_elem = v;\n        }\n    }\n    max_elem", " \
    \   let mut largest = l[0];\n    let mut largest_idx = l.iter().position(|&x|\
    \ x > &largest);\n    let mut smaller_idx = 0;\n    while largest_idx < l.len()\
    \ && l[largest_idx] < l[smaller_idx] {\n        largest = l[largest_idx];\n  \
    \      largest_idx = (largest_idx + 1) % l.len();\n    }\n\n    if largest_idx\
    \ >= l.len() {\n        return l[0];\n    }\n    l[largest_idx]", '    l.iter().max().unwrap_or(-1)',
  '    l.iter().max()', "    let mut max = l[0];\n    for &x in l {\n        if x\
    \ >= max {\n            max = x;\n        }\n    }\n    max", '    l.iter().max().unwrap_or(l.len())',
  '    l.iter().max_by(|a, b| a.cmp(&b)).unwrap()', "    if l.len() == 0 {\n     \
    \   return 0;\n    }\n\n    let mut max = 0;\n    for i in l.iter() {\n      \
    \  if i > max {\n            max = i;\n        }\n    }\n    max", '    l.iter().max_by_key(|&x|
    *x).unwrap()', '    l.iter().max()', '    l.iter().max().unwrap()', "    let mut\
    \ max_val: isize = 0;\n    let mut min_val: isize = 0;\n\n    for el in l {\n\
    \        if el > max_val {\n            max_val = el;\n        }\n        if el\
    \ < min_val {\n            min_val = el;\n        }\n    }\n    if max_val ==\
    \ min_val {\n        return min_val;\n    }\n\n    return max_val", "    let mut\
    \ max = l[0];\n    for i in l.iter().rev() {\n        if i > max {\n         \
    \   max = i;\n        }\n    }\n    max", "    let mut max = l.iter().max().unwrap();\n\
    \    l.iter().for_each(|e| if e > max { max = e; });\n    max", "    // Return\
    \ maximum element index\n    let mut max_elem_index = 0;\n    // Get max element\
    \ from the vector\n    let mut max_elem = l[0];\n    for i in l {\n        if\
    \ *i > *max_elem {\n            max_elem = i;\n            max_elem_index = i;\n\
    \        }\n    }\n    return max_elem_index;", '    l.iter().max().unwrap()',
  '    l.iter().max().unwrap_or(l.iter().last().unwrap_or(0))', '    l.iter().max().unwrap_or(0)',
  "    let mut max: isize = l[0];\n    for el in l.iter().rev() {\n        if el >\
    \ max {\n            max = el;\n        }\n    }\n    max", '    l.iter().max_by_key(|&x|
    x).unwrap()', "    let mut min = l[0];\n    for v in l.iter().skip(1) {\n    \
    \    if v < min {\n            min = v;\n        }\n    }\n    min"]
stop_tokens:
- "\n}"
