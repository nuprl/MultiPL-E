language: rs
name: HumanEval_48_is_palindrome
results:
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    (text as &str).chars()\n\
    \        .zip(text.chars().skip(1))\n        .any(|(a, b)| a == b)\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0605]: non-primitive cast: `String` as `&str`\n  --> /tmp/tmpqq_pv_34.rs:11:5\n\
    \   |\n11 |     (text as &str).chars()\n   |     ^^^^^^^^^^^^^^ invalid cast\n\
    \   |\nhelp: consider borrowing the value\n   |\n11 |     (&text as &str).chars()\n\
    \   |      +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0605`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    (text.to_lowercase()\n\
    \        .chars()\n        .enumerate()\n        .filter_map(|(i, char)| {\n \
    \           if char != char::from_u32(text.len() - 1 - i) {\n                Some(String::new())\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .all(|s| s.is_some())\n    )\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmp_1j2a0qi.rs:11:5\n\
    \   |\n11 |       (text.to_lowercase()\n   |       ^\n...\n21 |           .all(|s|\
    \ s.is_some())\n   |  ______________________________^\n22 | |     )\n   | |_____^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n11 ~     text.to_lowercase()\n12 |         .chars()\n13 |         .enumerate()\n\
    14 |         .filter_map(|(i, char)| {\n15 |             if char != char::from_u32(text.len()\
    \ - 1 - i) {\n16 |                 Some(String::new())\n ...\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_1j2a0qi.rs:15:39\n   |\n15 |             if\
    \ char != char::from_u32(text.len() - 1 - i) {\n   |                         \
    \              ^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n\
    \   |\n15 |             if char != char::from_u32((text.len() - 1 - i).try_into().unwrap())\
    \ {\n   |                                       +                  +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_1j2a0qi.rs:15:24\n   |\n15 |\
    \             if char != char::from_u32(text.len() - 1 - i) {\n   |          \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0599]: no method named `is_some` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp_1j2a0qi.rs:21:20\n   |\n21 |         .all(|s| s.is_some())\n\
    \   |                    ^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().fold(false,\
    \ |mut b, b1| b == b1.rev()).unwrap_or(true)\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmp437tz9l6.rs:11:50\n\
    \   |\n11 |     text.chars().fold(false, |mut b, b1| b == b1.rev()).unwrap_or(true)\n\
    \   |                                                  ^^^ `char` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for type `bool` in the current scope\n  -->\
    \ /tmp/tmp437tz9l6.rs:11:57\n   |\n11 |     text.chars().fold(false, |mut b, b1|\
    \ b == b1.rev()).unwrap_or(true)\n   |                                       \
    \                  ^^^^^^^^^ method not found in `bool`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len <= 1 {\n        return true;\n    }\n\n    let middle = len / 2;\n\
    \n    if text.chars().take(middle).collect::<Vec<char>>() != text\n        .chars()\n\
    \        .skip(middle + 1)\n        .take(middle - 1)\n        .collect::<Vec<char>>()\n\
    \    {\n        return false;\n    }\n\n    is_palindrome(text.to_string())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjvct6iuw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Create reverse\
    \ string first\n    let text = text.to_owned();\n    let mut text = String::from(text);\n\
    \    let len = text.len();\n    for i in 0..len / 2 {\n        // Move all characters\
    \ to the left\n        text[i] = text[(len-1) - i];\n    }\n\n    // Compare with\
    \ original string\n    text == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgn9vo3_l.rs:17:9\n\
    \   |\n17 |         text[i] = text[(len-1) - i];\n   |         ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgn9vo3_l.rs:17:19\n   |\n17 |         text[i] = text[(len-1) -\
    \ i];\n   |                   ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text:\
    \ String = text;\n    loop {\n        let last = text.chars().nth(text.length()\
    \ - 1).unwrap();\n        let current = text.chars().nth(text.len() - 1).unwrap();\n\
    \        if last != current {\n            return false;\n        }\n        text\
    \ = text.chars().skip_while(|&b| b != last).collect();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpqj5jhqre.rs:13:42\n   |\n13 |         let last\
    \ = text.chars().nth(text.length() - 1).unwrap();\n   |                      \
    \                    ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .zip(text.chars().skip(1))\n        .all(|(&x, &y)| x == y)\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_hc0negq.rs:13:16\n   |\n\
    13 |         .all(|(&x, &y)| x == y)\n   |                ^^    - expected due\
    \ to this\n   |                |\n   |                expected `char`, found reference\n\
    \   |                help: you can probably remove the explicit borrow: `x`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_hc0negq.rs:13:20\n   |\n13 |  \
    \       .all(|(&x, &y)| x == y)\n   |                    ^^- expected due to this\n\
    \   |                    |\n   |                    expected `char`, found reference\n\
    \   |                    help: you can probably remove the explicit borrow: `y`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    let mut rev: Vec<usize> = vec![];\n    for (i, c) in text.chars().enumerate()\
    \ {\n        rev.push(i);\n        if rev[len-i-1] == c {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5u3l_a1p.rs:15:28\n   |\n\
    15 |         if rev[len-i-1] == c {\n   |                            ^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut len\
    \ = text.len();\n    let mut i = len / 2;\n    let mut j = len / 2;\n    while\
    \ i >= 0 {\n        if text[i] != text[j] {\n            return false;\n     \
    \   }\n        i -= 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1nt9j9_n.rs:15:12\n\
    \   |\n15 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1nt9j9_n.rs:15:23\n   |\n15 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let mut first = true;\n\n    for\
    \ i in 1..text.len() - 1 {\n        let c = text[i];\n\n        if first {\n \
    \           first = false;\n        } else {\n            if c != text[text.len()\
    \ - i - 1] {\n                return false;\n            }\n        }\n    }\n\
    \n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv7a34ijm.rs:18:17\n\
    \   |\n18 |         let c = text[i];\n   |                 ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv7a34ijm.rs:23:21\n   |\n23 |             if c != text[text.len()\
    \ - i - 1] {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.chars();\n    let mut text_reversed = text.clone(); // need to clone\
    \ since reversing consumes it\n    let mut is_palindrome = true;\n    if text.len()\
    \ > 1 {\n        text_reversed.reverse();\n        while text_reversed == text\
    \ {\n            text.next();\n            text_reversed.next();\n        }\n\
    \    }\n    is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpaxb_eu6b.rs:14:13\n   |\n14 |     if text.len() > 1 {\n\
    \   |             ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `Chars` in the current scope\n  --> /tmp/tmpaxb_eu6b.rs:15:23\n\
    \   |\n15 |         text_reversed.reverse();\n   |                       ^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0369]: binary operation `==` cannot\
    \ be applied to type `Chars<'_>`\n  --> /tmp/tmpaxb_eu6b.rs:16:29\n   |\n16 |\
    \         while text_reversed == text {\n   |               ------------- ^^ ----\
    \ Chars<'_>\n   |               |\n   |               Chars<'_>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // remove white\
    \ spaces\n    let text = text.to_lowercase();\n    let mut text = text.replace(\"\
    _\", \"\");\n\n    // reverse the string\n    let mut reversed_text = text.chars().fold(String::new(),\
    \ |mut reverse_text, char| {\n        reverse_text.push((char as usize) - 32);\n\
    \        reverse_text.push('\\0');\n        reverse_text\n    });\n\n    // compare\
    \ them\n    text.chars().fold(false, |result, char| {\n        result == reversed_text.chars().fold(false,\
    \ |result, char_| {\n            result && (char as usize) == (char_ as usize)\n\
    \        })\n    })\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphsz9tzta.rs:17:27\n   |\n\
    17 |         reverse_text.push((char as usize) - 32);\n   |                  \
    \         ^^^^^^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut str\
    \ = [0; text.len()];\n    text.get_utf8_str()\n        .into_iter()\n        .zip(str.iter_mut())\n\
    \        .for_each(|&(str, mut i)| {\n            *i = str;\n        });\n   \
    \ str.rev()\n        == text\n        .get_utf8_str()\n        .into_iter()\n\
    \        .zip(str.iter())\n        .for_each(|&(str, i)| {\n            *i = str;\n\
    \        });\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpsmg_x05p.rs:11:23\n   |\n10 | fn is_palindrome(text: String) -> bool\
    \ {\n   |                  ---- this would need to be a `const`\n11 |     let\
    \ mut str = [0; text.len()];\n   |                       ^^^^\n\nerror[E0599]:\
    \ no method named `get_utf8_str` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpsmg_x05p.rs:12:10\n   |\n12 |     text.get_utf8_str()\n   |   \
    \       ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `get_utf8_str` found for struct `String` in the current scope\n  --> /tmp/tmpsmg_x05p.rs:20:10\n\
    \   |\n20 |         .get_utf8_str()\n   |          ^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0435, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0435`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut iter:\
    \ Box<Iterator<Item = String>> = text.chars().take(text.len() / 2).collect();\n\
    \    let mut is_palindrome = true;\n    while let Some(first) = iter.next() {\n\
    \        if iter.is_none() {\n            is_palindrome = false;\n           \
    \ break;\n        }\n        if first != iter.next().unwrap() {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n    iter\n        .next()\n\
    \        .unwrap()\n        == String::from(text.chars().take(text.len() / 2).collect())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: trait objects without an explicit `dyn` are deprecated\n  -->\
    \ /tmp/tmpg84j7iwi.rs:11:23\n   |\n11 |     let mut iter: Box<Iterator<Item =\
    \ String>> = text.chars().take(text.len() / 2).collect();\n   |              \
    \         ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(bare_trait_objects)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n11 -     let mut iter: Box<Iterator<Item = String>> = text.chars().take(text.len()\
    \ / 2).collect();\n11 +     let mut iter: Box<dyn Iterator<Item = String>> = text.chars().take(text.len()\
    \ / 2).collect();\n   | \n\nerror[E0277]: a value of type `Box<dyn Iterator<Item\
    \ = String>>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpg84j7iwi.rs:11:84\n     |\n11   |     let mut iter: Box<Iterator<Item\
    \ = String>> = text.chars().take(text.len() / 2).collect();\n     |          \
    \                                                                          ^^^^^^^\
    \ value of type `Box<dyn Iterator<Item = String>>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Box<dyn\
    \ Iterator<Item = String>>`\n     = help: the trait `FromIterator<I>` is implemented\
    \ for `Box<[I]>`\nnote: required by a bound in `collect`\n\nerror[E0599]: no method\
    \ named `is_none` found for struct `Box<dyn Iterator<Item = String>>` in the current\
    \ scope\n  --> /tmp/tmpg84j7iwi.rs:14:17\n   |\n14 |         if iter.is_none()\
    \ {\n   |                 ^^^^^^^ method not found in `Box<dyn Iterator<Item =\
    \ String>>`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ String::from(text);\n\n    s.reverse();\n\n    s == String::from(text)\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpsk65c0og.rs:13:7\n   |\n13 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut iter\
    \ = text.chars().enumerate();\n    let mut last_idx = iter.last().unwrap().0;\n\
    \    while let Some((idx, ch)) = iter.next() {\n        if *ch != *iter.get_mut(last_idx\
    \ - 1).unwrap().0 || *ch != *iter.get_mut(last_idx + 1).unwrap().0 {\n       \
    \     return false;\n        }\n        last_idx = idx;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp11nkf_3c.rs:14:12\n\
    \   |\n14 |         if *ch != *iter.get_mut(last_idx - 1).unwrap().0 || *ch !=\
    \ *iter.get_mut(last_idx + 1).unwrap().0 {\n   |            ^^^\n\nerror[E0599]:\
    \ no method named `get_mut` found for struct `Enumerate` in the current scope\n\
    \   --> /tmp/tmp11nkf_3c.rs:14:25\n    |\n14  |         if *ch != *iter.get_mut(last_idx\
    \ - 1).unwrap().0 || *ch != *iter.get_mut(last_idx + 1).unwrap().0 {\n    |  \
    \                       ^^^^^^^ method not found in `Enumerate<Chars<'_>>`\n \
    \   |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n14  |         if *ch != *Pin::new(&mut iter).get_mut(last_idx - 1).unwrap().0\
    \ || *ch != *iter.get_mut(last_idx + 1).unwrap().0 {\n    |                  \
    \  +++++++++++++     +\n\nerror[E0614]: type `char` cannot be dereferenced\n \
    \ --> /tmp/tmp11nkf_3c.rs:14:61\n   |\n14 |         if *ch != *iter.get_mut(last_idx\
    \ - 1).unwrap().0 || *ch != *iter.get_mut(last_idx + 1).unwrap().0 {\n   |   \
    \                                                          ^^^\n\nerror[E0599]:\
    \ no method named `get_mut` found for struct `Enumerate` in the current scope\n\
    \   --> /tmp/tmp11nkf_3c.rs:14:74\n    |\n14  |         if *ch != *iter.get_mut(last_idx\
    \ - 1).unwrap().0 || *ch != *iter.get_mut(last_idx + 1).unwrap().0 {\n    |  \
    \                                                                        ^^^^^^^\
    \ method not found in `Enumerate<Chars<'_>>`\n    |\nhelp: consider wrapping the\
    \ receiver expression with the appropriate type\n    |\n14  |         if *ch !=\
    \ *iter.get_mut(last_idx - 1).unwrap().0 || *ch != *Pin::new(&mut iter).get_mut(last_idx\
    \ + 1).unwrap().0 {\n    |                                                   \
    \                  +++++++++++++     +\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_lowercase();\n    let mut is_palindrome = true;\n\n    for &c in text.chars()\
    \ {\n        if c != text.chars().rposition(|&c| c == c) {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n\n    is_palindrome\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv26wj8v3.rs:14:9\n   |\n\
    14 |     for &c in text.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpv26wj8v3.rs:15:30\n     |\n15   |         if c != text.chars().rposition(|&c|\
    \ c == c) {\n     |                              ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv26wj8v3.rs:15:41\n   |\n15 |         if c != text.chars().rposition(|&c|\
    \ c == c) {\n   |                                         ^--\n   |          \
    \                               ||\n   |                                     \
    \    |expected due to this\n   |                                         expected\
    \ `char`, found reference\n   |                                         help:\
    \ did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n       \
    \    found reference `&_`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len < 2 {\n        return true;\n    }\n    let mut left = text.as_bytes();\n\
    \    let mut right = left.clone();\n    loop {\n        if left[0] == right[-1]\
    \ {\n            break;\n        }\n        left.pop();\n        right.pop();\n\
    \    }\n    left.len() == text.len() && left.is_empty() == right.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: negative integers cannot be used to index on a `[u8]`\n  --> /tmp/tmpnkdh1g3r.rs:18:29\n\
    \   |\n18 |         if left[0] == right[-1] {\n   |                          \
    \   ^^ cannot use a negative integer for indexing on `[u8]`\n   |\nhelp: to access\
    \ an element starting from the end of the `[u8]`, compute the index\n   |\n18\
    \ |         if left[0] == right[right.len() -1] {\n   |                      \
    \       +++++++++++\n\nerror[E0599]: no method named `pop` found for reference\
    \ `&[u8]` in the current scope\n  --> /tmp/tmpnkdh1g3r.rs:21:14\n   |\n21 |  \
    \       left.pop();\n   |              ^^^ method not found in `&[u8]`\n\nerror[E0599]:\
    \ no method named `pop` found for reference `&[u8]` in the current scope\n  -->\
    \ /tmp/tmpnkdh1g3r.rs:22:15\n   |\n22 |         right.pop();\n   |           \
    \    ^^^ method not found in `&[u8]`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.to_lowercase()\n\
    \        .reverse()\n        .eq(&text.to_lowercase())\n}\n\nfn main() {\n   \
    \ let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp1p17n40y.rs:12:10\n   |\n12 |         .reverse()\n\
    \   |          ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().fold(false,\
    \ (|acc, &c| acc && c.chars().collect::<Vec<_>>() == c.chars().collect::<Vec<_>>().rev()))\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpouu0qn77.rs:11:30\n\
    \   |\n11 |     text.chars().fold(false, (|acc, &c| acc && c.chars().collect::<Vec<_>>()\
    \ == c.chars().collect::<Vec<_>>().rev()))\n   |                             \
    \ ^                                                                          \
    \           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n11 -     text.chars().fold(false, (|acc, &c|\
    \ acc && c.chars().collect::<Vec<_>>() == c.chars().collect::<Vec<_>>().rev()))\n\
    11 +     text.chars().fold(false, |acc, &c| acc && c.chars().collect::<Vec<_>>()\
    \ == c.chars().collect::<Vec<_>>().rev())\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpouu0qn77.rs:11:37\n   |\n11 |     text.chars().fold(false, (|acc,\
    \ &c| acc && c.chars().collect::<Vec<_>>() == c.chars().collect::<Vec<_>>().rev()))\n\
    \   |                                     ^--\n   |                          \
    \           ||\n   |                                     |expected due to this\n\
    \   |                                     expected `char`, found reference\n \
    \  |                                     help: did you mean `c`: `&char`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars()).all(|(a,\
    \ b)| (a == b) && (a != ' '))\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpejahl8ac.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().chunks(2).all().is_ok()\
    \ && is_palindrome_recursive(&text.chars().chunks(2).collect::<Vec<_>>())\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome_recursive` in this scope\n\
    \  --> /tmp/tmpt4k1gejk.rs:11:45\n   |\n11 |     text.chars().chunks(2).all().is_ok()\
    \ && is_palindrome_recursive(&text.chars().chunks(2).collect::<Vec<_>>())\n  \
    \ |                                             ^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `chunks` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpt4k1gejk.rs:11:18\n   |\n11 |     text.chars().chunks(2).all().is_ok()\
    \ && is_palindrome_recursive(&text.chars().chunks(2).collect::<Vec<_>>())\n  \
    \ |                  ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no\
    \ method named `chunks` found for struct `Chars` in the current scope\n  --> /tmp/tmpt4k1gejk.rs:11:83\n\
    \   |\n11 |     text.chars().chunks(2).all().is_ok() && is_palindrome_recursive(&text.chars().chunks(2).collect::<Vec<_>>())\n\
    \   |                                                                        \
    \           ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len < 2 {\n        return true;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i <= j {\n        if text[i] != text[j] {\n        \
    \    return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpomq99esq.rs:18:12\n\
    \   |\n18 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpomq99esq.rs:18:23\n   |\n18 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 0 {\n        return true;\n    }\n    if text.length() == 1 {\n        return\
    \ text == String::from(&text[..]);\n    }\n    let mut left = 0;\n    let mut\
    \ right = text.length() - 1;\n\n    loop {\n        if right < left {\n      \
    \      return false;\n        }\n        if text[left] != text[right] {\n    \
    \        return false;\n        }\n        left += 1;\n        right -= 1;\n \
    \   }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpca_69q1x.rs:14:13\n   |\n14 |     if text.length()\
    \ == 1 {\n   |             ^^^^^^ help: there is an associated function with a\
    \ similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpca_69q1x.rs:18:26\n   |\n18 | \
    \    let mut right = text.length() - 1;\n   |                          ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpca_69q1x.rs:24:12\n\
    \   |\n24 |         if text[left] != text[right] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ % 2 == 1 {\n        // Odd length, no palindrome\n        return false;\n  \
    \  }\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut len = text.len();\n\
    \n    // Find middle of string\n    while i < len {\n        if text[i] != text[j]\
    \ {\n            break;\n        }\n        i += 1;\n        j += 1;\n    }\n\n\
    \    if i != len - j {\n        return false;\n    }\n\n    let mut left = 0;\n\
    \    let mut right = len - 1;\n\n    while left < right {\n        if text[left]\
    \ != text[right] {\n            break;\n        }\n        left += 1;\n      \
    \  right -= 1;\n    }\n\n    j = 0;\n    for i in 0..right {\n        if i !=\
    \ j {\n            return false;\n        }\n        j += 1;\n    }\n\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpftfm77ks.rs:22:12\n\
    \   |\n22 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpftfm77ks.rs:22:23\n   |\n22 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpftfm77ks.rs:37:12\n   |\n37 |         if text[left] != text[right]\
    \ {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed\
    \ = text.chars().filter_map(|c| c.to_digit(10).unwrap()).collect::<Vec<u8>>();\n\
    \    reversed.sort_unstable();\n    text == &reversed\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ngfm33i.rs:11:52\n   |\n\
    11 |     let mut reversed = text.chars().filter_map(|c| c.to_digit(10).unwrap()).collect::<Vec<u8>>();\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `u32`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `u32`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n11 |     let mut reversed = text.chars().filter_map(|c| Some(c.to_digit(10).unwrap())).collect::<Vec<u8>>();\n\
    \   |                                                    +++++               \
    \        +\n\nerror[E0277]: can't compare `String` with `&Vec<u8>`\n  --> /tmp/tmp5ngfm33i.rs:13:10\n\
    \   |\n13 |     text == &reversed\n   |          ^^ no implementation for `String\
    \ == &Vec<u8>`\n   |\n   = help: the trait `PartialEq<&Vec<u8>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // remove all\
    \ '\\0' from the string and compare with the string reversed\n    // to remove\
    \ leading '\\0' from the string.\n    text\n        .chars()\n        .filter(|c|\
    \ !c.is_ascii_letter())\n        .filter(|c| !c.is_ascii_digit())\n        .filter_map(|c|\
    \ c)\n        .fold(String::new(), |mut s, c| {\n            s.push_str(&c.to_string());\n\
    \            s.push_str(\"-\");\n            s.push_str(&c.to_string());\n   \
    \         s.push_str(\"\\0\");\n            s\n        })\n        .chars()\n\
    \        .filter_map(|c| c)\n        .rev()\n        .all(|c| c == text[0..length()\
    \ - 1])\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `length` in this scope\n  --> /tmp/tmpgk0qj3hf.rs:28:31\n\
    \   |\n28 |         .all(|c| c == text[0..length() - 1])\n   |               \
    \                ^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `is_ascii_letter` found for reference `&char` in the current scope\n  --> /tmp/tmpgk0qj3hf.rs:15:24\n\
    \   |\n15 |         .filter(|c| !c.is_ascii_letter())\n   |                  \
    \      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgk0qj3hf.rs:17:25\n\
    \   |\n17 |         .filter_map(|c| c)\n   |                         ^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |         .filter_map(|c| Some(c))\n   |                         +++++\
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgk0qj3hf.rs:26:25\n   |\n\
    26 |         .filter_map(|c| c)\n   |                         ^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `char`\nhelp: try wrapping the expression in `Some`\n   |\n\
    26 |         .filter_map(|c| Some(c))\n   |                         +++++ +\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_lowercase();\n    if let Some(last_word) = get_last_word(&mut text)\
    \ {\n        let mut last_word = last_word.to_lowercase();\n        let mut reversed_text\
    \ = &mut text;\n        reversed_text.reverse();\n        if last_word == reversed_text\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_last_word` in this scope\n  -->\
    \ /tmp/tmp9xts7hrb.rs:12:30\n   |\n12 |     if let Some(last_word) = get_last_word(&mut\
    \ text) {\n   |                              ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `reverse` found for mutable reference `&mut String`\
    \ in the current scope\n  --> /tmp/tmp9xts7hrb.rs:15:23\n   |\n15 |         reversed_text.reverse();\n\
    \   |                       ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text;\n    s.reverse();\n    s == text\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnoe3t75j.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut buffer\
    \ = String::new();\n    let mut pos = 0;\n    while pos < text.len() {\n     \
    \   let c = text.get(&pos);\n        if c != ' ' {\n            buffer.push(c);\n\
    \        }\n        pos += 1;\n    }\n    buffer == text.rev()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `&usize`\n   --> /tmp/tmp13pwqsw1.rs:14:26\n\
    \    |\n14  |         let c = text.get(&pos);\n    |                      ---\
    \ ^^^^ string indices are ranges of `usize`\n    |                      |\n  \
    \  |                      required by a bound introduced by this call\n    |\n\
    \    = help: the trait `SliceIndex<str>` is not implemented for `&usize`\n   \
    \ = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp13pwqsw1.rs:15:17\n   |\n15 |         if c != ' ' {\n   |     \
    \            ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<&_>`\n              found type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp13pwqsw1.rs:16:25\n   |\n16 |             buffer.push(c);\n\
    \   |                         ^ expected `char`, found enum `Option`\n   |\n \
    \  = note: expected type `char`\n              found enum `Option<&_>`\n\nerror[E0599]:\
    \ `String` is not an iterator\n   --> /tmp/tmp13pwqsw1.rs:20:20\n    |\n20  |\
    \       buffer == text.rev()\n    |                      ^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .rev()\n        .eq(&text.chars())\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpu1jz0beg.rs:13:13\n\
    \   |\n13 |         .eq(&text.chars())\n   |          -- ^^^^^^^^^^^^^ `&Chars<'_>`\
    \ is not an iterator\n   |          |\n   |          required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Chars<'_>`\nhelp: consider dereferencing here\n   |\n13 |         .eq(*&text.chars())\n\
    \   |             +\nhelp: consider removing the leading `&`-reference\n   |\n\
    13 -         .eq(&text.chars())\n13 +         .eq(text.chars())\n   | \nhelp:\
    \ consider changing this borrow's mutability\n   |\n13 |         .eq(&mut text.chars())\n\
    \   |             ~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text\n    \
    \    .chars()\n        .filter(|c| *c != ' ')\n        .fold(true, |acc, _| !acc)\n\
    \        && text\n            .chars()\n            .map(|c| *c as u32)\n    \
    \        .rev()\n            .fold(false, |acc, _| !acc)\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpvsp84b52.rs:17:22\n\
    \   |\n17 |             .map(|c| *c as u32)\n   |                      ^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // check for\
    \ empty strings\n    if text.len() == 0 || text.is_empty() {\n        return true;\n\
    \    }\n\n    let mut i = 0;\n    let mut j = text.len() - 1;\n\n    while i <=\
    \ j {\n        if text[i] != text[j] {\n            return false;\n        }\n\
    \        i += 1;\n        j -= 1;\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kmbso7u.rs:20:12\n\
    \   |\n20 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8kmbso7u.rs:20:23\n   |\n20 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text;\n    let mut i = 0;\n    let mut j = 0;\n    loop {\n        if i == s.len()\
    \ - 1 {\n            return j == i;\n        }\n\n        if i == j {\n      \
    \      return false;\n        }\n\n        let c = s[i].chars().next().unwrap();\n\
    \        let uc = s[j].chars().next().unwrap();\n\n        if c != uc {\n    \
    \        return false;\n        }\n\n        i += 1;\n        j += 1;\n    }\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw84pp9b7.rs:23:17\n\
    \   |\n23 |         let c = s[i].chars().next().unwrap();\n   |              \
    \   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpw84pp9b7.rs:24:18\n   |\n24 |         let uc = s[j].chars().next().unwrap();\n\
    \   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .enumerate()\n        .map(|(i, c)| {\n            assert!(\n       \
    \         i / 2 == text.length() - c.len(),\n                \"Character {} doesn't\
    \ match length of string {}\",\n                c,\n                text\n   \
    \         );\n            c\n        })\n        .reduce(|a, &b| a == b)\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbaxl40uj.rs:15:31\n   |\n15 |                 i\
    \ / 2 == text.length() - c.len(),\n   |                               ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmpbaxl40uj.rs:15:44\n\
    \   |\n15 |                 i / 2 == text.length() - c.len(),\n   |          \
    \                                  ^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbaxl40uj.rs:22:21\n   |\n22 |         .reduce(|a,\
    \ &b| a == b)\n   |                     ^--\n   |                     ||\n   |\
    \                     |expected due to this\n   |                     expected\
    \ `char`, found reference\n   |                     help: did you mean `b`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbaxl40uj.rs:22:25\n   |\n22 |  \
    \       .reduce(|a, &b| a == b)\n   |                         ^^^^^^ expected\
    \ `char`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbaxl40uj.rs:11:5\n\
    \   |\n10 |   fn is_palindrome(text: String) -> bool {\n   |                 \
    \                    ---- expected `bool` because of return type\n11 | /     text.chars()\n\
    12 | |         .enumerate()\n13 | |         .map(|(i, c)| {\n14 | |          \
    \   assert!(\n...  |\n21 | |         })\n22 | |         .reduce(|a, &b| a == b)\n\
    \   | |_______________________________^ expected `bool`, found enum `Option`\n\
    \   |\n   = note: expected type `bool`\n              found enum `Option<char>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut str\
    \ = text;\n    str.reverse();\n    str == text\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpl8j80aq2.rs:12:9\n   |\n12 |     str.reverse();\n\
    \   |         ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut first\
    \ = String::new();\n    let mut last = String::new();\n\n    for &c in text.chars()\
    \ {\n        match c {\n            c if !c.is_alphanumeric() =>\n           \
    \     panic!(\"is_palindrome: invalid character in string: {}\", c),\n\n     \
    \       c if c == ' ' => {\n                first = c;\n                last =\
    \ c;\n            }\n\n            c => {\n                let new_first = first.chars().next().unwrap().to_string();\n\
    \                let new_last = last.chars().next().unwrap().to_string();\n\n\
    \                if new_first != c && new_last != c {\n                    return\
    \ false;\n                }\n\n                first = c;\n                last\
    \ = c;\n            }\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxvfdewpj.rs:14:9\n   |\n\
    14 |     for &c in text.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // TODO: optimize\
    \ this to reduce memory allocation\n    let mut left = 0 as usize;\n    let mut\
    \ right = (text.len() - 1) as usize;\n    while left < right {\n        if text[left]\
    \ != text[right] {\n            return false;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy_7ewg0x.rs:15:12\n\
    \   |\n15 |         if text[left] != text[right] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy_7ewg0x.rs:15:26\n   |\n15 |         if text[left] != text[right]\
    \ {\n   |                          ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut input\
    \ = text.clone();\n    input.reverse();\n    input == text\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpd_70117s.rs:12:11\n   |\n12 |     input.reverse();\n\
    \   |           ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut buffer\
    \ = text.chars();\n    buffer.reverse();\n    buffer.next().unwrap().eq(text)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpt2yl57o7.rs:12:12\n   |\n12 |     buffer.reverse();\n\
    \   |            ^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt2yl57o7.rs:13:31\n   |\n13 |     buffer.next().unwrap().eq(text)\n\
    \   |                               ^^^^ expected `&char`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut rev:\
    \ Vec<String> = text.chars().collect();\n    rev.extend_from_slice(&rev[..rev.reverse().len()]);\n\
    \    rev == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp1mz1i8jn.rs:11:45\n     |\n11\
    \   |     let mut rev: Vec<String> = text.chars().collect();\n     |         \
    \                                    ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0599]: no method named `len` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmp1mz1i8jn.rs:12:48\n   |\n12 |     rev.extend_from_slice(&rev[..rev.reverse().len()]);\n\
    \   |                                                ^^^ method not found in `()`\n\
    \nerror[E0277]: can't compare `Vec<String>` with `String`\n  --> /tmp/tmp1mz1i8jn.rs:13:9\n\
    \   |\n13 |     rev == text\n   |         ^^ no implementation for `Vec<String>\
    \ == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `Vec<String>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text;\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    let mut reverse\
    \ = 0;\n    let mut c = false;\n    while i < j {\n        let c = s.chars().next().unwrap();\n\
    \        reverse += c.as_bytes().wrapping_mul(255).last().unwrap();\n        if\
    \ c != s.chars().next().unwrap() {\n            i += 1;\n        } else {\n  \
    \          c += 1;\n            i += 1;\n        }\n        j -= 1;\n        if\
    \ c != s.chars().next().unwrap() {\n            i += 1;\n        } else {\n  \
    \          c += 1;\n            i += 1;\n        }\n        if i > (s.len() -\
    \ 1) / 2 {\n            return reverse.to_string() == s;\n        }\n    }\n \
    \   return reverse.to_string() == s;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3o9lk5lm.rs:18:22\n   |\n18 |         reverse += c.as_bytes().wrapping_mul(255).last().unwrap();\n\
    \   |                      ^^^^^^^^ method not found in `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmp3o9lk5lm.rs:22:13\n\
    \   |\n22 |             c += 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmp3o9lk5lm.rs:29:13\n\
    \   |\n29 |             c += 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut left\
    \ = 0;\n    let mut right = text.len();\n    let mut found = false;\n    let mut\
    \ i = 0;\n    loop {\n        if i > text.len() / 2 {\n            left = 0;\n\
    \            right = text.len() - 1;\n            i = 1;\n        }\n        //\
    \ If left >= right, then we have found the palidrome string.\n        // Break\
    \ out of loop as we do not need to search other characters.\n        if left >=\
    \ right {\n            break;\n        }\n        // If we are looking for the\
    \ first character, then increase left\n        // by 1 and decrease right by 1\n\
    \        if i == 0 {\n            left += 1;\n            right -= 1;\n      \
    \  }\n        // If we are looking for the last character, then decrease left\n\
    \        // by 1 and increase right by 1\n        if i == text.len() - 1 {\n \
    \           left -= 1;\n            right += 1;\n        }\n        // If current\
    \ character in text is same as current character\n        // in reverse of text,\
    \ then we have found the palidrome string.\n        if text[i] == text[text.len()\
    \ - 1 - i] {\n            found = true;\n            break;\n        }\n     \
    \   i += 1;\n    }\n    found\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq0ydogya.rs:40:12\n\
    \   |\n40 |         if text[i] == text[text.len() - 1 - i] {\n   |           \
    \ ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq0ydogya.rs:40:23\n   |\n40 |         if text[i] == text[text.len()\
    \ - 1 - i] {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len < 2 || len % 2 != 1 {\n        return false;\n    }\n\n    let (first,\
    \ last) = text.split_at_mut(len - 1);\n    first.reverse() == last\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmpv469bka_.rs:17:11\n   |\n17 |     first.reverse()\
    \ == last\n   |           ^^^^^^^ method not found in `&mut str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut a =\
    \ text.chars();\n    let mut b = a.clone();\n    loop {\n        if *b == 0 {\
    \ return true; }\n        if *a != *b {\n            return false;\n        }\n\
    \        a.next();\n        b.next();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Chars<'_>` cannot be dereferenced\n  --> /tmp/tmpbw6czvxe.rs:14:12\n\
    \   |\n14 |         if *b == 0 { return true; }\n   |            ^^\n\nerror[E0614]:\
    \ type `Chars<'_>` cannot be dereferenced\n  --> /tmp/tmpbw6czvxe.rs:15:12\n \
    \  |\n15 |         if *a != *b {\n   |            ^^\n\nerror[E0614]: type `Chars<'_>`\
    \ cannot be dereferenced\n  --> /tmp/tmpbw6czvxe.rs:15:18\n   |\n15 |        \
    \ if *a != *b {\n   |                  ^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_string();\n    text.rev()\n        .chars()\n        .rev()\n    \
    \    .filter(|&c| c != ' ')\n        .is_ok()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpo8kee4yj.rs:12:10\n\
    \    |\n12  |       text.rev()\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Get a mutable\
    \ reference to the String\n    let mut s = text;\n\n    // Iterate through the\
    \ string and reverse\n    for let mut i = s.len() - 1; s.len() > 0; i -= 1 {\n\
    \        if s[i] < s[i as usize] {\n            // Shift the characters\n    \
    \        s.swap(i, i + 1);\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `let`\n  --> /tmp/tmprs3kg526.rs:15:9\n\
    \   |\n15 |     for let mut i = s.len() - 1; s.len() > 0; i -= 1 {\n   |     \
    \    ^^^ expected identifier, found keyword\n\nerror: missing `in` in `for` loop\n\
    \  --> /tmp/tmprs3kg526.rs:15:12\n   |\n15 |     for let mut i = s.len() - 1;\
    \ s.len() > 0; i -= 1 {\n   |            ^ help: try adding `in` here\n\nerror:\
    \ expected expression, found keyword `mut`\n  --> /tmp/tmprs3kg526.rs:15:13\n\
    \   |\n15 |     for let mut i = s.len() - 1; s.len() > 0; i -= 1 {\n   |     \
    \        ^^^ expected expression\n\nerror: aborting due to 3 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().collect::<Vec<char>>().eq(&text.chars().rev().collect::<Vec<char>>())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut l =\
    \ text.len();\n    let mut i = 0;\n    while l > 1 && i <= l {\n        if text[i]\
    \ != text[text.len() - 1 - i] {\n            return false;\n        }\n      \
    \  i += 1;\n        l -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppizh2bru.rs:14:12\n\
    \   |\n14 |         if text[i] != text[text.len() - 1 - i] {\n   |           \
    \ ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppizh2bru.rs:14:23\n   |\n14 |         if text[i] != text[text.len()\
    \ - 1 - i] {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text;\n    let mut j = s.len() - 1;\n    while s.chars().nth(j).unwrap() ==\
    \ s.chars().nth(s.len() - j).unwrap() {\n        j -= 1;\n    }\n    j == 0 ||\
    \ s.chars().nth(j).unwrap() == s.chars().nth(s.len() - j).unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp73g6fmjp.rs:12:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text;\n    let len = s.len();\n\n    while len > 0 {\n        if s[len / 2]\
    \ != s[len - 1] {\n            return false;\n        }\n\n        len -= 1;\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3vg638m9.rs:15:12\n\
    \   |\n15 |         if s[len / 2] != s[len - 1] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3vg638m9.rs:15:26\n   |\n15 |         if s[len / 2] != s[len -\
    \ 1] {\n   |                          ^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text:\
    \ String = text;\n    text.rev()\n        .chars()\n        .take(text.len() /\
    \ 2)\n        .enumerate()\n        .filter(|&(_, c)| c != 0)\n        .all(|&(i,\
    \ _)| text == text.as_bytes()[text.len() - i - 1 as usize])\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp81f99_ql.rs:12:10\n\
    \    |\n12  |       text.rev()\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len < 2 {\n        return true;\n    }\n\n    let mut first = 0;\n   \
    \ let mut last = len - 1;\n\n    while first < last {\n        if text[first]\
    \ != text[last] {\n            return false;\n        }\n\n        first += 1;\n\
    \        last -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx_0irl14.rs:20:12\n\
    \   |\n20 |         if text[first] != text[last] {\n   |            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx_0irl14.rs:20:27\n   |\n20 |         if text[first] != text[last]\
    \ {\n   |                           ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    (text.chars().len()\
    \ % 2) == 0 && is_palindrome_rec(&text[..text.len() / 2])\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome_rec` in this scope\n\
    \  --> /tmp/tmpiiqwi1rd.rs:11:38\n   |\n11 |     (text.chars().len() % 2) == 0\
    \ && is_palindrome_rec(&text[..text.len() / 2])\n   |                        \
    \              ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpiiqwi1rd.rs:11:19\n\
    \   |\n11 |     (text.chars().len() % 2) == 0 && is_palindrome_rec(&text[..text.len()\
    \ / 2])\n   |                   ^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().collect::<Vec<char>>().reverse().eq(&text)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3mxkctp9.rs:11:54\n   |\n\
    11 |     text.chars().collect::<Vec<char>>().reverse().eq(&text)\n   |       \
    \                                               ^^^^^ expected `()`, found struct\
    \ `String`\n   |\n   = note: expected reference `&()`\n              found reference\
    \ `&String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Calculate\
    \ the length of the text\n    let mut len = text.len();\n\n    // Reverse the\
    \ text\n    text.rev();\n\n    // Check if the text is equal to its reverse\n\
    \    text.eq(&text)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpxnny4l41.rs:15:10\n\
    \    |\n15  |       text.rev();\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .skip_while(|&x| x == x)\n        .rev()\n        .eq(text.chars().skip_while(|&x|\
    \ x == x))\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `SkipWhile<Chars<'_>, [closure@/tmp/tmpm367dc40.rs:12:21:\
    \ 12:32]>: DoubleEndedIterator` is not satisfied\n    --> /tmp/tmpm367dc40.rs:13:10\n\
    \     |\n13   |         .rev()\n     |          ^^^ the trait `DoubleEndedIterator`\
    \ is not implemented for `SkipWhile<Chars<'_>, [closure@/tmp/tmpm367dc40.rs:12:21:\
    \ 12:32]>`\n     |\nnote: required by a bound in `rev`\n\nerror[E0599]: the method\
    \ `eq` exists for struct `Rev<SkipWhile<Chars<'_>, [closure@/tmp/tmpm367dc40.rs:12:21:\
    \ 12:32]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpm367dc40.rs:14:10\n\
    \   |\n14 |            .eq(text.chars().skip_while(|&x| x == x))\n   |       \
    \      ^^ method cannot be called on `Rev<SkipWhile<Chars<'_>, [closure@/tmp/tmpm367dc40.rs:12:21:\
    \ 12:32]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `SkipWhile<Chars<'_>, [closure@/tmp/tmpm367dc40.rs:12:21:\
    \ 12:32]>: DoubleEndedIterator`\n           which is required by `Rev<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpm367dc40.rs:12:21: 12:32]>>: Iterator`\n           `Rev<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpm367dc40.rs:12:21: 12:32]>>: Iterator`\n           which is\
    \ required by `&mut Rev<SkipWhile<Chars<'_>, [closure@/tmp/tmpm367dc40.rs:12:21:\
    \ 12:32]>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 0 {\n        return true;\n    }\n    let mut index = 0;\n    let mut size\
    \ = text.len();\n    let mut last_index = 0;\n    let mut last_size = size;\n\
    \    let mut last_char = text.chars().nth(0);\n    let mut char = last_char;\n\
    \n    while index < size {\n        if char <= ' ' {\n            break;\n   \
    \     }\n        if char != text[size - index - 1] {\n            break;\n   \
    \     }\n        last_char = char;\n        last_size = size;\n        index +=\
    \ 1;\n    }\n    if index == last_size {\n        return true;\n    }\n\n    while\
    \ index < size {\n        if char <= ' ' {\n            break;\n        }\n  \
    \      if char != text[size - index - 1] {\n            break;\n        }\n  \
    \      last_char = char;\n        last_size = size;\n        index += 1;\n   \
    \ }\n\n    char == text[size - index - 1]\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_k6baeu.rs:22:20\n   |\n\
    22 |         if char <= ' ' {\n   |                    ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n22 |       \
    \  if char <= Some(' ') {\n   |                    +++++   +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2_k6baeu.rs:25:20\n\
    \   |\n25 |         if char != text[size - index - 1] {\n   |                \
    \    ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2_k6baeu.rs:37:20\n   |\n37 |         if char\
    \ <= ' ' {\n   |                    ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n37 |         if char <= Some('\
    \ ') {\n   |                    +++++   +\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp2_k6baeu.rs:40:20\n   |\n40 |         if\
    \ char != text[size - index - 1] {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \ "
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // reverse\
    \ the text and compare it to original\n    // if original is equal to reversed\n\
    \    // then text is palindrome\n    let reversed_text = text.rev().clone();\n\
    \    let original = text;\n    reversed_text == original\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpgdant5n5.rs:14:30\n\
    \    |\n14  |       let reversed_text = text.rev().clone();\n    |           \
    \                     ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true\n    }\n    text.chars().rposition(|x| x == x).is_some()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpmnoe0ikj.rs:14:18\n     |\n14   |     text.chars().rposition(|x|\
    \ x == x).is_some()\n     |                  ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut len\
    \ = text.len();\n    let mut i = 0;\n    while i < len {\n        if text[i] !=\
    \ text[len - i - 1] {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkev10yq6.rs:14:12\n\
    \   |\n14 |         if text[i] != text[len - i - 1] {\n   |            ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkev10yq6.rs:14:23\n   |\n14 |         if text[i] != text[len -\
    \ i - 1] {\n   |                       ^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.chars();\n    let mut i = 0;\n    while i < text.len() {\n        if\
    \ *text != text.get_mut(i).unwrap() {\n            return false;\n        }\n\
    \        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpf12s81z4.rs:13:20\n   |\n13 |     while i < text.len()\
    \ {\n   |                    ^^^ method not found in `Chars<'_>`\n\nerror[E0614]:\
    \ type `Chars<'_>` cannot be dereferenced\n  --> /tmp/tmpf12s81z4.rs:14:12\n \
    \  |\n14 |         if *text != text.get_mut(i).unwrap() {\n   |            ^^^^^\n\
    \nerror[E0599]: no method named `get_mut` found for struct `Chars` in the current\
    \ scope\n   --> /tmp/tmpf12s81z4.rs:14:26\n    |\n14  |         if *text != text.get_mut(i).unwrap()\
    \ {\n    |                          ^^^^^^^ method not found in `Chars<'_>`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n14  |         if *text != Pin::new(&mut text).get_mut(i).unwrap() {\n\
    \    |                     +++++++++++++     +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut texts\
    \ = text.chars();\n    let mut it = texts.rev().take(texts.len());\n    let mut\
    \ reversed = String::new();\n    for text in it {\n        reversed.push_str(text);\n\
    \    }\n    text == reversed\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp03phdmd5.rs:12:41\n   |\n12 |     let mut it = texts.rev().take(texts.len());\n\
    \   |                                         ^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp03phdmd5.rs:15:27\n   |\n15 |\
    \         reversed.push_str(text);\n   |                           ^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_string();\n    let mut i = 0;\n    while i < text.len() {\n      \
    \  let j = text.len() - i - 1;\n        if text[j] != text[j + i] {\n        \
    \    return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfrxkdq_d.rs:15:12\n\
    \   |\n15 |         if text[j] != text[j + i] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfrxkdq_d.rs:15:23\n   |\n15 |         if text[j] != text[j + i]\
    \ {\n   |                       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text_rev\
    \ = text.rev().to_string();\n    text_rev.chars().all(|c| c != text_rev.chars().nth(text.len()).unwrap())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpl6ge9e3x.rs:11:29\n\
    \    |\n11  |       let mut text_rev = text.rev().to_string();\n    |        \
    \                       ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ String::from(text);\n    s[s.len() - 1] = '\\0';\n    s == String::from(text.rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpph6__8b4.rs:12:5\n\
    \   |\n12 |     s[s.len() - 1] = '\\0';\n   |     ^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpph6__8b4.rs:13:28\n\
    \    |\n13  |       s == String::from(text.rev())\n    |                     \
    \         ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_string();\n    text.rev();\n    text == text\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp840tldyt.rs:12:10\n\
    \    |\n12  |       text.rev();\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut iter\
    \ = text.char_indices().rev().take(text.length());\n    let mut start = iter.next();\n\
    \    let mut end = iter.next();\n    loop {\n        // skip characters while\
    \ they aren't equal\n        if start.index() != end.index() {\n            if\
    \ start.index() < end.index() {\n                if text.get(start.index()) !=\
    \ text.get(end.index()) {\n                    start = end;\n                \
    \    end = iter.next();\n                } else {\n                    return\
    \ false;\n                }\n            } else {\n                if text.get(start.index())\
    \ != text.get(end.index()) {\n                    start = iter.next();\n     \
    \           } else {\n                    return true;\n                }\n  \
    \          }\n        }\n        if start.index() == end.index() {\n         \
    \   break;\n        }\n    }\n    start.index() == text.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpf2nhk8ef.rs:11:56\n   |\n11 |     let mut iter\
    \ = text.char_indices().rev().take(text.length());\n   |                     \
    \                                   ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `index` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmpf2nhk8ef.rs:16:18\n   |\n\
    16 |         if start.index() != end.index() {\n   |                  ^^^^^ method\
    \ not found in `Option<(usize, char)>`\n\nerror[E0599]: no method named `index`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpf2nhk8ef.rs:16:33\n\
    \   |\n16 |         if start.index() != end.index() {\n   |                  \
    \               ^^^^^ method not found in `Option<(usize, char)>`\n\nerror[E0599]:\
    \ no method named `index` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpf2nhk8ef.rs:17:22\n   |\n17 |             if start.index() < end.index()\
    \ {\n   |                      ^^^^^ method not found in `Option<(usize, char)>`\n\
    \nerror[E0599]: no method named `index` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpf2nhk8ef.rs:17:36\n   |\n17 |             if start.index()\
    \ < end.index() {\n   |                                    ^^^^^ method not found\
    \ in `Option<(usize, char)>`\n\nerror[E0599]: no method named `index` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmpf2nhk8ef.rs:18:35\n   |\n\
    18 |                 if text.get(start.index()) != text.get(end.index()) {\n \
    \  |                                   ^^^^^ method not found in `Option<(usize,\
    \ char)>`\n\nerror[E0599]: no method named `index` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpf2nhk8ef.rs:18:60\n   |\n18 |             \
    \    if text.get(start.index()) != text.get(end.index()) {\n   |             \
    \                                               ^^^^^ method not found in `Option<(usize,\
    \ char)>`\n\nerror[E0599]: no method named `index` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpf2nhk8ef.rs:25:35\n   |\n25 "
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Compare\
    \ from end to start, stop when encountering the middle value\n    let mut start\
    \ = text.len() - 1;\n    let mut middle = start as usize;\n    while start >=\
    \ 0 && middle < text.len() {\n        if text.chars().nth(start) != text.chars().nth(middle\
    \ + 1) {\n            return false;\n        }\n        start -= 1;\n        middle\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpk10pg_t9.rs:12:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ String::from(text);\n\n    s.chars().enumerate().filter_map(|(_, char)| {\n\
    \        let char_inverted = s.chars().skip_while(|c| c != char).next().unwrap();\n\
    \        s.insert(s.chars().skip_while(|c| c != char_inverted).next().unwrap(),\
    \ char);\n        Some(char)\n    }).all(|c| c == String::from(&s[..]))\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1xmfu02m.rs:14:56\n\
    \   |\n14 |         let char_inverted = s.chars().skip_while(|c| c != char).next().unwrap();\n\
    \   |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1xmfu02m.rs:15:45\n\
    \   |\n15 |         s.insert(s.chars().skip_while(|c| c != char_inverted).next().unwrap(),\
    \ char);\n   |                                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1xmfu02m.rs:15:18\n   |\n15 |  \
    \       s.insert(s.chars().skip_while(|c| c != char_inverted).next().unwrap(),\
    \ char);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xmfu02m.rs:17:21\n\
    \   |\n17 |     }).all(|c| c == String::from(&s[..]))\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == String::from(text)\n\
    \        .rev()\n        .chars()\n        .all(|c| *c == *c as u32)\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmplgvwlupr.rs:12:10\n\
    \    |\n12  |           .rev()\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == reverse(text)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpxnlpu45k.rs:11:13\n\
    \   |\n11 |     text == reverse(text)\n   |             ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.chars().len()\
    \ == 1 {\n        return true;\n    }\n\n    if text.len() % 2 == 1 {\n      \
    \  return false;\n    }\n\n    let mut s = text;\n    let mut i = 0;\n    let\
    \ mut j = text.len() - 1;\n    while i < j {\n        if s[i] == s[j] {\n    \
    \        i += 1;\n            j -= 1;\n        } else {\n            if i != j\
    \ {\n                return false;\n            }\n            i += 1;\n     \
    \       j -= 1;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmph2zi7max.rs:11:21\n   |\n11 |     if text.chars().len()\
    \ == 1 {\n   |                     ^^^ method not found in `Chars<'_>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph2zi7max.rs:23:12\n\
    \   |\n23 |         if s[i] == s[j] {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph2zi7max.rs:23:20\n   |\n23 |         if s[i] == s[j] {\n   | \
    \                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text.to_string();\n    debug_assert!(s.len() > 0);\n    s.resize(0, s.len());\n\
    \    let mut j = s.len();\n    let mut i = 0;\n    for _ in s.chars() {\n    \
    \    if i > j {\n            break;\n        }\n        let char = s[i as usize];\n\
    \        debug_assert!(char.chars().next().is_some());\n        if char != char.chars().next().unwrap()\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `resize` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9jq1lzx_.rs:13:7\n   |\n13 |     s.resize(0, s.len());\n\
    \   |       ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp9jq1lzx_.rs:20:20\n   |\n20 |  \
    \       let char = s[i as usize];\n   |                    ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text\n    \
    \    .chars()\n        .filter_map(|c| match c {\n            c => Some(c),\n\
    \            _ => None,\n        })\n        .take(text.len() / 2)\n        .is_sorted()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmpj2js4s76.rs:18:10\n   |\n18 |         .is_sorted()\n   |          ^^^^^^^^^\n\
    \   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut index\
    \ = 0;\n    let mut end = text.len();\n    let mut is_palindrome = true;\n\n \
    \   while index != end {\n        let mut reversed_text = text[index..=end].to_lowercase();\n\
    \n        if reversed_text == text {\n            is_palindrome = true;\n    \
    \    } else {\n            is_palindrome = false;\n        }\n\n        index\
    \ += 1;\n        end -= 1;\n    }\n\n    is_palindrome\n}\n\nfn main() {\n   \
    \ let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `aba`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    let mut i = 0;\n    let mut j = len - 1;\n    while i < j {\n        if text[i]\
    \ != text[j] {\n            return false;\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb_kktvhm.rs:15:12\n\
    \   |\n15 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb_kktvhm.rs:15:23\n   |\n15 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text.to_lowercase();\n    s.reverse();\n    s == text\n}\n\nfn main() {\n  \
    \  let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp1qe2c8iz.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut low\
    \ = text.chars().skip(1);\n    let mut high = low.cloned().rev();\n    loop {\n\
    \        if high == low {\n            break;\n        }\n        if text.get().unwrap()\
    \ != high.get().unwrap() {\n            break;\n        }\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Skip<Chars<'_>> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp9zyxlgi5.rs:12:24\n     |\n12   |     let mut high =\
    \ low.cloned().rev();\n     |                        ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `rev` exists for struct `Cloned<Skip<Chars<'_>>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp9zyxlgi5.rs:12:33\n   |\n12 |     \
    \   let mut high = low.cloned().rev();\n   |                                 \
    \   ^^^ method cannot be called on `Cloned<Skip<Chars<'_>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Skip<Chars<'_>> as Iterator>::Item = &_`\n           which is required\
    \ by `Cloned<Skip<Chars<'_>>>: Iterator`\n           `Cloned<Skip<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Skip<Chars<'_>>>: Iterator`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp9zyxlgi5.rs:17:17\n    |\n17  |         if text.get().unwrap()\
    \ != high.get().unwrap() {\n    |                 ^^^- supplied 0 arguments\n\
    \    |                 |\n    |                 expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut len\
    \ = text.len();\n    let mut i = text.len() - 1;\n    while i > 0 {\n        if\
    \ text.chars().nth(i) != text.chars().nth(text.len() - i - 1) {\n            return\
    \ false;\n        }\n        i -= 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp00yw6c7q.rs:12:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .enumerate()\n        .take(text.len() / 2)\n        .all(|(idx, val)|\
    \ val == text[(text.len() - 1) - idx])\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb4ecwz33.rs:14:34\n\
    \   |\n14 |         .all(|(idx, val)| val == text[(text.len() - 1) - idx])\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text_iter\
    \ = text.chars();\n    let mut reversed = false;\n\n    let mut last_char: char;\n\
    \    let mut next_char: char;\n    while text_iter.has_next() {\n        last_char\
    \ = text_iter.next()?;\n        next_char = text_iter.next()?;\n        if last_char\
    \ == next_char {\n            reversed = false;\n        } else {\n          \
    \  reversed = true;\n            break;\n        }\n    }\n    reversed\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `has_next` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpgvqij1t_.rs:16:21\n   |\n16 |     while text_iter.has_next()\
    \ {\n   |                     ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpgvqij1t_.rs:17:37\n\
    \   |\n10 | / fn is_palindrome(text: String) -> bool {\n11 | |     let mut text_iter\
    \ = text.chars();\n12 | |     let mut reversed = false;\n13 | |\n...  |\n17 |\
    \ |         last_char = text_iter.next()?;\n   | |                           \
    \          ^ cannot use the `?` operator in a function that returns `bool`\n...\
    \  |\n26 | |     reversed\n27 | | }\n   | |_- this function should return `Result`\
    \ or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>`\
    \ is not implemented for `bool`\n\nerror[E0277]: the `?` operator can only be\
    \ used in a function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmpgvqij1t_.rs:18:37\n   |\n10 | / fn is_palindrome(text:\
    \ String) -> bool {\n11 | |     let mut text_iter = text.chars();\n12 | |    \
    \ let mut reversed = false;\n13 | |\n...  |\n18 | |         next_char = text_iter.next()?;\n\
    \   | |                                     ^ cannot use the `?` operator in a\
    \ function that returns `bool`\n...  |\n26 | |     reversed\n27 | | }\n   | |_-\
    \ this function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<Option<Infallible>>` is not implemented for `bool`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text:\
    \ String = text;\n    text.rrev();\n    text == text\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rrev` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpahynwzbc.rs:12:10\n   |\n12 |     text.rrev();\n   |  \
    \        ^^^^ method not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.to_lowercase()\n\
    \        .chars()\n        .collect()\n        == text.chars().collect()\n   \
    \     .reverse()\n        .collect()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmph1wlmqbd.rs:14:25\n\
    \   |\n14 |         == text.chars().collect()\n   |                         ^^^^^^^\
    \ cannot infer type for type parameter `B` declared on the associated function\
    \ `collect`\n   |\n   = note: type must be known at this point\nhelp: consider\
    \ specifying the type argument in the method call\n   |\n14 |         == text.chars().collect::<B>()\n\
    \   |                                +++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().clone().rev().eq(&text.chars())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpmxdlx0m_.rs:11:35\n\
    \   |\n11 |     text.chars().clone().rev().eq(&text.chars())\n   |           \
    \                     -- ^^^^^^^^^^^^^ `&Chars<'_>` is not an iterator\n   | \
    \                               |\n   |                                required\
    \ by a bound introduced by this call\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `&Chars<'_>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&Chars<'_>`\nhelp: consider dereferencing\
    \ here\n   |\n11 |     text.chars().clone().rev().eq(*&text.chars())\n   |   \
    \                                +\nhelp: consider removing the leading `&`-reference\n\
    \   |\n11 -     text.chars().clone().rev().eq(&text.chars())\n11 +     text.chars().clone().rev().eq(text.chars())\n\
    \   | \nhelp: consider changing this borrow's mutability\n   |\n11 |     text.chars().clone().rev().eq(&mut\
    \ text.chars())\n   |                                   ~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Use a stack\
    \ to reverse string and check palindrome\n    let mut s = String::from(\"\");\n\
    \    for (i, c) in text.chars().enumerate() {\n        s.push_str(&c.to_string());\n\
    \        if i >= text.len() / 2 {\n            if s.cmp(text[(text.len() - 1 -\
    \ i) as usize..]) == 0 {\n                return true;\n            }\n      \
    \  }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpti8e_m0j.rs:16:22\n   |\n\
    16 |             if s.cmp(text[(text.len() - 1 - i) as usize..]) == 0 {\n   |\
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&String`,\
    \ found `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpti8e_m0j.rs:16:64\n\
    \   |\n16 |             if s.cmp(text[(text.len() - 1 - i) as usize..]) == 0 {\n\
    \   |                                                                ^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .chain(text.chars().windows(2).map(|&b| if b == b.rev() { return b; }\
    \ else { return b.rev(); }))\n        .collect::<String>()\n        == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpn_qrlidz.rs:12:29\n   |\n12 |         .chain(text.chars().windows(2).map(|&b|\
    \ if b == b.rev() { return b; } else { return b.rev(); }))\n   |             \
    \                ^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut it\
    \ = text.chars().enumerate();\n    let mut mid = 0;\n    let mut end = text.len()\
    \ - 1;\n    while mid < end {\n        match it.next() {\n            Some((index,\
    \ c)) => {\n                if c != text[mid] {\n                    return false;\n\
    \                }\n                mid += 1;\n            },\n            None\
    \ => return true,\n        }\n        end -= 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyf51t_pg.rs:17:25\n\
    \   |\n17 |                 if c != text[mid] {\n   |                        \
    \ ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut len\
    \ = text.len();\n    let mut left = 0;\n    let mut right = len - 1;\n\n    while\
    \ left < right {\n        if text[left].to_lowercase() != text[right].to_lowercase()\
    \ {\n            return false;\n        }\n\n        left += 1;\n        right\
    \ -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2x2bztnq.rs:16:12\n\
    \   |\n16 |         if text[left].to_lowercase() != text[right].to_lowercase()\
    \ {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2x2bztnq.rs:16:41\n\
    \   |\n16 |         if text[left].to_lowercase() != text[right].to_lowercase()\
    \ {\n   |                                         ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut iter\
    \ = text.chars().nth(text.len() / 2);\n    iter.rev().eq(&iter[..])\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<char>` is not an iterator\n   --> /tmp/tmpqwex4ktb.rs:12:10\n\
    \    |\n12  |       iter.rev().eq(&iter[..])\n    |            ^^^ `Option<char>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: Iterator`\n            which is required by `&mut\
    \ Option<char>: Iterator`\n\nerror[E0608]: cannot index into a value of type `Option<char>`\n\
    \  --> /tmp/tmpqwex4ktb.rs:12:20\n   |\n12 |     iter.rev().eq(&iter[..])\n  \
    \ |                    ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().enumerate().any(|(i,\
    \ c)| {\n        // If character is not in lower case or upper case - it's not\
    \ a palindrome\n        !(c == c.to_lowercase() + 'a' || c == c.to_uppercase()\
    \ + 'A')\n    })\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `ToLowercase`\n  --> /tmp/tmpiym3maon.rs:13:33\n\
    \   |\n13 |         !(c == c.to_lowercase() + 'a' || c == c.to_uppercase() + 'A')\n\
    \   |                ---------------- ^ --- char\n   |                |\n   |\
    \                ToLowercase\n\nerror[E0369]: cannot add `char` to `ToUppercase`\n\
    \  --> /tmp/tmpiym3maon.rs:13:64\n   |\n13 |         !(c == c.to_lowercase() +\
    \ 'a' || c == c.to_uppercase() + 'A')\n   |                                  \
    \             ---------------- ^ --- char\n   |                              \
    \                 |\n   |                                               ToUppercase\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \n    for i in 0..len / 2 {\n        if text.charAt(i) != text.charAt(len - 1\
    \ - i) {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `charAt` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpagi5c5rs.rs:14:17\n   |\n14 |         if text.charAt(i)\
    \ != text.charAt(len - 1 - i) {\n   |                 ^^^^^^ help: there is an\
    \ associated function with a similar name: `chars`\n\nerror[E0599]: no method\
    \ named `charAt` found for struct `String` in the current scope\n  --> /tmp/tmpagi5c5rs.rs:14:35\n\
    \   |\n14 |         if text.charAt(i) != text.charAt(len - 1 - i) {\n   |    \
    \                               ^^^^^^ help: there is an associated function with\
    \ a similar name: `chars`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut it\
    \ = text.char_indices();\n    let mut j = it.next().unwrap().1;\n\n    let mut\
    \ is_palindrome = true;\n    while j != it.next().unwrap().1 {\n        if text[j]\
    \ != text[j + it.next().unwrap().1 - 1] {\n            is_palindrome = false;\n\
    \            break;\n        }\n        j += it.next().unwrap().1;\n    }\n  \
    \  is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpb_hltbqr.rs:16:12\n\
    \   |\n16 |         if text[j] != text[j + it.next().unwrap().1 - 1] {\n   | \
    \           ^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the\
    \ trait `Index<char>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpb_hltbqr.rs:16:30\n\
    \   |\n16 |         if text[j] != text[j + it.next().unwrap().1 - 1] {\n   | \
    \                           - ^ -------------------- char\n   |              \
    \              |\n   |                            char\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpb_hltbqr.rs:20:9\n\
    \   |\n20 |         j += it.next().unwrap().1;\n   |         -^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0368,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    !text.iter().rev().all(|&c|\
    \ !c.is_alphanumeric())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp9arncntc.rs:11:11\n   |\n11 |     !text.iter().rev().all(|&c|\
    \ !c.is_alphanumeric())\n   |           ^^^^ method not found in `String`\n  \
    \ |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n11 |     !text.chars().rev().all(|&c|\
    \ !c.is_alphanumeric())\n   |           ~~~~~\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    let mut it = text.chars();\n    let mut found = false;\n\
    \    let mut current_char = it.next();\n    let mut prev_char = it.next();\n\n\
    \    for _ in 0..text.len() / 2 {\n        if prev_char == current_char {\n  \
    \          found = true;\n            break;\n        } else {\n            prev_char\
    \ = current_char;\n            current_char = it.next();\n        }\n    }\n\n\
    \    found\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqo_166d_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars()).all(|(x,\
    \ y)| x == y)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppkgdc9gq.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text;\n    s.reverse();\n    s == text\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnoe3t75j.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976111
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ String::from(text);\n    s.reverse();\n    s == text\n}\n\nfn main() {\n   \
    \ let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpvvmcpifj.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reverse_text\
    \ = text.chars().rev();\n    let reversed_string = reverse_text\n        .collect::<Vec<char>>()\n\
    \        .join(\"\");\n    reverse_text == text.chars().collect()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `join` exists for struct `Vec<char>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpxncku92q.rs:14:10\n   |\n14 |\
    \         .join(\"\");\n   |          ^^^^ method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[char]: Join<_>`\n\nerror[E0369]: binary operation\
    \ `==` cannot be applied to type `Rev<Chars<'_>>`\n  --> /tmp/tmpxncku92q.rs:15:18\n\
    \   |\n15 |     reverse_text == text.chars().collect()\n   |     ------------\
    \ ^^ ---------------------- _\n   |     |\n   |     Rev<Chars<'_>>\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // TODO: optimize\
    \ algorithm without creating new string.\n    let len = text.len();\n    if len\
    \ <= 1 {\n        return true;\n    }\n    let mid = len / 2;\n    let left =\
    \ text.as_bytes()[0..mid];\n    let right = text.as_bytes()[mid..len];\n    if\
    \ left == right {\n        return true;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[u8]` cannot be known at compilation\
    \ time\n  --> /tmp/tmphmybqtgp.rs:17:9\n   |\n17 |     let left = text.as_bytes()[0..mid];\n\
    \   |         ^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[u8]`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\nhelp: consider borrowing here\n   |\n17 |     let left = &text.as_bytes()[0..mid];\n\
    \   |                +\n\nerror[E0277]: the size for values of type `[u8]` cannot\
    \ be known at compilation time\n  --> /tmp/tmphmybqtgp.rs:18:9\n   |\n18 |   \
    \  let right = text.as_bytes()[mid..len];\n   |         ^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[u8]`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n18 |     let right = &text.as_bytes()[mid..len];\n   |         \
    \        +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // convert\
    \ string into chars\n    let mut chars = text.as_bytes();\n    let mut chars_\
    \ = chars.clone();\n    // reverse the string\n    let mut result = String::from(\"\
    \");\n    for i in 0..chars_.len() / 2 {\n        result.append(&chars_[i..i +\
    \ 1]);\n    }\n    // if the original and reverse string are same then palindrome\n\
    \    result == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6lp0g3y9.rs:17:16\n   |\n17 |         result.append(&chars_[i..i\
    \ + 1]);\n   |                ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reverse_text\
    \ = text.clone();\n    reverse_text.rev();\n    text == reverse_text\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpb148cona.rs:12:18\n\
    \    |\n12  |       reverse_text.rev();\n    |                    ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.as_bytes();\n    if text.len() <= 1 {\n        return true;\n    }\n  \
    \  let last = &text[text.len() - 1];\n    let mut i = 0;\n    while i < text.len()\
    \ {\n        if *text[i] != *last{\n            return false;\n        }\n   \
    \     i += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpsq5_50g5.rs:18:12\n\
    \   |\n18 |         if *text[i] != *last{\n   |            ^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut input\
    \ = text.as_bytes().to_vec();\n    let mut buffer = Vec::new();\n    let mut reversed\
    \ = String::new();\n    reversed.clear();\n    for x in input {\n        buffer.push(x);\n\
    \        if buffer.len() > 1 {\n            reversed.push(b'a' - buffer[buffer.len()\
    \ - 1]);\n            buffer.pop();\n        }\n    }\n    reversed.into_boxed_str()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcxq6djoc.rs:18:27\n   |\n\
    18 |             reversed.push(b'a' - buffer[buffer.len() - 1]);\n   |       \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcxq6djoc.rs:22:34\n   |\n22 |\
    \     reversed.into_boxed_str() == text\n   |                                \
    \  ^^^^ expected struct `Box`, found struct `String`\n   |\n   = note: expected\
    \ struct `Box<str>`\n              found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().enumerate().all(|(_,\
    \ x)| x == text.chars().skip_while(|&c| c <= 'z' || c <= 'Z'))\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpppaazc86.rs:11:48\n   |\n\
    11 |     text.chars().enumerate().all(|(_, x)| x == text.chars().skip_while(|&c|\
    \ c <= 'z' || c <= 'Z'))\n   |                                               \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `SkipWhile`\n   |\n   = note: expected type `char`\n            found struct\
    \ `SkipWhile<Chars<'_>, [closure@/tmp/tmpppaazc86.rs:11:72: 11:97]>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.to_lowercase().chars()\n\
    \        .collect::<Vec<_>>()\n        .reverse()\n        .iter()\n        .zip(text.chars().collect::<Vec<_>>().iter())\n\
    \        .all(|(a, b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmp9yeiikre.rs:14:10\n   |\n14 |         .iter()\n   |   \
    \       ^^^^ method not found in `()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // O(1) runtime\n\
    \    text.chars()\n        .chunks_exact(text.len())\n        .filter(|chunk|\
    \ chunk.to_chars().collect::<Vec<_>>() == chunk.to_chars().collect::<Vec<_>>().rev())\n\
    \        .count() == text.len()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chunks_exact` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpm1_19h1m.rs:13:10\n   |\n13 |         .chunks_exact(text.len())\n\
    \   |          ^^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    (text.chars().rbegin()\
    \ == text.chars().rend() && is_palindrome_impl(text.chars().to_vec())) ||\n  \
    \      is_palindrome_impl(text.chars().to_owned())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome_impl` in this scope\n\
    \  --> /tmp/tmpa6ruoovh.rs:11:54\n   |\n11 |     (text.chars().rbegin() == text.chars().rend()\
    \ && is_palindrome_impl(text.chars().to_vec())) ||\n   |                     \
    \                                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_palindrome_impl` in this scope\n  -->\
    \ /tmp/tmpa6ruoovh.rs:12:9\n   |\n12 |         is_palindrome_impl(text.chars().to_owned())\n\
    \   |         ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `rbegin` found for struct `Chars` in the current scope\n  --> /tmp/tmpa6ruoovh.rs:11:19\n\
    \   |\n11 |     (text.chars().rbegin() == text.chars().rend() && is_palindrome_impl(text.chars().to_vec()))\
    \ ||\n   |                   ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `rend` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpa6ruoovh.rs:11:44\n   |\n11 |     (text.chars().rbegin() == text.chars().rend()\
    \ && is_palindrome_impl(text.chars().to_vec())) ||\n   |                     \
    \                       ^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `to_vec` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpa6ruoovh.rs:11:86\n   |\n11 |     (text.chars().rbegin() == text.chars().rend()\
    \ && is_palindrome_impl(text.chars().to_vec())) ||\n   |                     \
    \                                                                 ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_lowercase();\n    let mut i = text.len() - 1;\n    while i >= 0 {\n\
    \        if text[i] != text[i + text.len() / 2] {\n            return false;\n\
    \        }\n        i -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa0r_uw7h.rs:14:12\n\
    \   |\n14 |         if text[i] != text[i + text.len() / 2] {\n   |           \
    \ ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa0r_uw7h.rs:14:23\n   |\n14 |         if text[i] != text[i + text.len()\
    \ / 2] {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let mut text = text.to_string();\n\
    \    let mut left = 0;\n    let mut right = text.len() - 1;\n\n    while left\
    \ < right {\n        if text.get(left) != text.get(right) {\n            return\
    \ false;\n        }\n\n        left += 1;\n        right -= 1;\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n   --> /tmp/tmpbxc5gdyw.rs:20:21\n\
    \    |\n20  |         if text.get(left) != text.get(right) {\n    |          \
    \       --- ^^^^ string indices are ranges of `usize`\n    |                 |\n\
    \    |                 required by a bound introduced by this call\n    |\n  \
    \  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n    = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a\
    \ bound in `core::str::<impl str>::get`\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `usize`\n   --> /tmp/tmpbxc5gdyw.rs:20:39\n    |\n20  |      \
    \   if text.get(left) != text.get(right) {\n    |                            \
    \       --- ^^^^^ string indices are ranges of `usize`\n    |                \
    \                   |\n    |                                   required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not\
    \ implemented for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len <= 1 { return true; }\n    let mut current = String::from(\"\");\n\
    \    let mut last = String::from(\"\");\n    for i in 0..len {\n        if text[i]\
    \ != current {\n            return false;\n        }\n        current = String::from(text[i]);\n\
    \    }\n    if current != last { return false; }\n    for i in 0..len {\n    \
    \    if text[i] != last {\n            return false;\n        }\n        last\
    \ = String::from(text[i]);\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnmlkwa45.rs:16:12\n\
    \   |\n16 |         if text[i] != current {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnmlkwa45.rs:19:32\n   |\n19 |         current = String::from(text[i]);\n\
    \   |                                ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnmlkwa45.rs:23:12\n   |\n23 |         if text[i] != last {\n  \
    \ |            ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror["
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed\
    \ = text;\n    let mut first = true;\n    for &c in text.chars() {\n        let\
    \ mut cur = c;\n        if first {\n            first = false;\n        } else\
    \ {\n            reversed.swap(&mut cur);\n        }\n    }\n    reversed == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpppxyz6cy.rs:13:9\n   |\n\
    13 |     for &c in text.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpppxyz6cy.rs:18:22\n   |\n18 |             reversed.swap(&mut\
    \ cur);\n   |                      ^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true\n    }\n    text.chars().zip(text.chars().skip(1))\n\
    \        .rev()\n        .zip(text.chars().skip(1))\n        .rev()\n        .fold(true,\
    \ |a, b| a && b && (a == b));\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpf8left3n.rs:15:10\n     |\n15   |         .rev()\n     |    \
    \      ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Zip<Chars<'_>, Skip<Chars<'_>>>`\n\
    note: required by a bound in `rev`\n\nerror[E0599]: the method `zip` exists for\
    \ struct `Rev<Zip<Chars<'_>, Skip<Chars<'_>>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpf8left3n.rs:16:10\n   |\n16 |            .zip(text.chars().skip(1))\n\
    \   |             ^^^ method cannot be called on `Rev<Zip<Chars<'_>, Skip<Chars<'_>>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Zip<Chars<'_>, Skip<Chars<'_>>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<Zip<Chars<'_>, Skip<Chars<'_>>>>: Iterator`\n\
    \           `Rev<Zip<Chars<'_>, Skip<Chars<'_>>>>: Iterator`\n           which\
    \ is required by `&mut Rev<Zip<Chars<'_>, Skip<Chars<'_>>>>: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8left3n.rs:10:35\n   |\n10 | fn is_palindrome(text:\
    \ String) -> bool {\n   |    -------------                  ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n    let mut s = String::from(text);\n  \
    \  s.reverse();\n    s == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp_46yxscr.rs:15:7\n   |\n15 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed_text\
    \ = text;\n    let mut reversed_text_len = text.len();\n    reversed_text.reverse();\n\
    \    for ch in text.chars() {\n        if ch != reversed_text[reversed_text_len\
    \ - 1] {\n            return false;\n        }\n        reversed_text_len -= 1;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp8hsakuhz.rs:13:19\n   |\n13 |     reversed_text.reverse();\n\
    \   |                   ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8hsakuhz.rs:15:18\n   |\n15 |         if ch != reversed_text[reversed_text_len\
    \ - 1] {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(0..text.len()).all(|(a,b)|\
    \ a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdi_j_opi.rs:11:54\n   |\n\
    11 |     text.chars().zip(0..text.len()).all(|(a,b)| a == b)\n   |           \
    \                                           ^ expected `char`, found `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text ==\
    \ String::from(text).rev() {\n        return true;\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpa73vzl6a.rs:11:35\n\
    \    |\n11  |       if text == String::from(text).rev() {\n    |             \
    \                        ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reverse\
    \ = text\n        .split_whitespace()\n        .reverse()\n        .collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < reverse.len() {\n        if reverse[i] == text[i]\
    \ {\n            i += 1;\n        } else {\n            break;\n        }\n  \
    \  }\n    i == reverse.len()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpub8d7wyi.rs:13:10\n   |\n13 |         .reverse()\n\
    \   |          ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpub8d7wyi.rs:17:26\n\
    \   |\n17 |         if reverse[i] == text[i] {\n   |                         \
    \ ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait\
    \ `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Rev<Chars<'_>>`\n\
    \  --> /tmp/tmpn_4ocx6z.rs:11:24\n   |\n11 |     text.chars().rev() == text\n\
    \   |     ------------------ ^^ ---- String\n   |     |\n   |     Rev<Chars<'_>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut result\
    \ = false;\n\n    let text = text.to_string();\n    let text = &text[..text.len()\
    \ / 2];\n\n    for &c in text.chars() {\n        let mut index = text.rfind(&c).unwrap();\n\
    \        if index > 0 {\n            index = text.rfind(&c, index).unwrap();\n\
    \        }\n        result |= index == text.len();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5p758yvq.rs:16:9\n   |\n\
    16 |     for &c in text.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmp5p758yvq.rs:19:26\n     |\n19   |             index = text.rfind(&c,\
    \ index).unwrap();\n     |                          ^^^^^ --  ----- supplied 2\
    \ arguments\n     |                          |\n     |                       \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text.to_string();\n    s.reverse();\n    s == text\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgn234phm.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_string();\n    text.rev();\n    text.eq(text)\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp_40ly4jf.rs:12:10\n\
    \    |\n12  |       text.rev();\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_40ly4jf.rs:13:13\n   |\n13 |     text.eq(text)\n   |         \
    \    ^^^^\n   |             |\n   |             expected reference, found struct\
    \ `String`\n   |             help: consider borrowing here: `&text`\n   |\n  \
    \ = note: expected reference `&_`\n                 found struct `String`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.is_empty()\
    \ {\n        return true;\n    }\n    let mut str1 = text.chars();\n    str1.next();\n\
    \    let mut str2 = str1.clone();\n    str2.next();\n    while let Some(first)\
    \ = str1.next() {\n        if let Some(second) = str2.next() {\n            if\
    \ first != second {\n                return false;\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv38ppr4o.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Reverse\
    \ the string\n    let rev_text = text.chars().fold(String::new(), |mut acc, &c|\
    \ {\n        acc.push_str(&c.to_string() + 'a');\n        acc\n    });\n\n   \
    \ // Check equality\n    let mut len = 0;\n    while rev_text[len..].chars().any(|c|\
    \ c != c[0]) {\n        len += 1;\n    }\n\n    rev_text[..len].chars().all(|c|\
    \ c == c[0])\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpusn_daw6.rs:12:63\n   |\n\
    12 |     let rev_text = text.chars().fold(String::new(), |mut acc, &c| {\n   |\
    \                                                               ^--\n   |    \
    \                                                           ||\n   |         \
    \                                                      |expected due to this\n\
    \   |                                                               expected `char`,\
    \ found reference\n   |                                                      \
    \         help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0608]: cannot index into a value of\
    \ type `char`\n  --> /tmp/tmpusn_daw6.rs:19:48\n   |\n19 |     while rev_text[len..].chars().any(|c|\
    \ c != c[0]) {\n   |                                                ^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpusn_daw6.rs:23:42\n\
    \   |\n23 |     rev_text[..len].chars().all(|c| c == c[0])\n   |             \
    \                             ^^^^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ String::new();\n    s.push_str(text);\n    let len = s.len();\n    let mut i\
    \ = 0;\n    let mut j = len - 1;\n    while i < j {\n        if s[(i + j) as usize]\
    \ != s[i + j as usize] {\n            return false;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaoys86pc.rs:12:16\n   |\n\
    12 |     s.push_str(text);\n   |                ^^^^\n   |                |\n\
    \   |                expected `&str`, found struct `String`\n   |            \
    \    help: consider borrowing here: `&text`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpaoys86pc.rs:17:12\n   |\n17 |  \
    \       if s[(i + j) as usize] != s[i + j as usize] {\n   |            ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpaoys86pc.rs:17:35\n   |\n17 |         if s[(i + j) as usize] !=\
    \ s[i + j as usize] {\n   |                                   ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.to_string();\n    text.rev().is_eq(text)\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpoppvpix6.rs:12:10\n\
    \    |\n12  |       text.rev().is_eq(text)\n    |            ^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().enumerate().rev().map(|(i,\
    \ c)| {\n        if i >= text.len() || c != text[i..(i + 1)].chars().nth(0).unwrap()\
    \ {\n            false\n        } else {\n            true\n        }\n    }).unwrap_or(true)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpg0850dqt.rs:11:30\n     |\n11   |     text.chars().enumerate().rev().map(|(i,\
    \ c)| {\n     |                              ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]:\
    \ the method `map` exists for struct `Rev<Enumerate<Chars<'_>>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpg0850dqt.rs:11:36\n   |\n11 |     \
    \  text.chars().enumerate().rev().map(|(i, c)| {\n   |                       \
    \               ^^^ method cannot be called on `Rev<Enumerate<Chars<'_>>>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `Enumerate<Chars<'_>>: DoubleEndedIterator`\n   \
    \        which is required by `Rev<Enumerate<Chars<'_>>>: Iterator`\n        \
    \   `Rev<Enumerate<Chars<'_>>>: Iterator`\n           which is required by `&mut\
    \ Rev<Enumerate<Chars<'_>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < text.len() && j < text.len() {\n     \
    \   if text[i] != text[j] {\n            break;\n        }\n        i += 1;\n\
    \        j += 1;\n    }\n    i == text.len() || j == text.len() || text[i] !=\
    \ text[j]\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppqydftm4.rs:14:12\n\
    \   |\n14 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppqydftm4.rs:14:23\n   |\n14 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppqydftm4.rs:20:43\n   |\n20 |     i == text.len() || j == text.len()\
    \ || text[i] != text[j]\n   |                                           ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<us"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 1 {\n        return text == text.chars().next().unwrap();\n    }\n\n    let\
    \ (start, end) = text.chars().windows(2).collect::<Vec<_>>();\n    let mut left\
    \ = start;\n    let mut right = end;\n    let mut rev = Vec::new();\n\n    loop\
    \ {\n        match text[left] {\n            None => return true,\n          \
    \  Some(c) => rev.append(c),\n        }\n        match text[right] {\n       \
    \     None => return true,\n            Some(c) => rev.append(c),\n        }\n\
    \        rev.swap(left, right);\n        left += 1;\n        right -= 1;\n   \
    \ }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpa1vuv0kq.rs:12:21\n\
    \   |\n12 |         return text == text.chars().next().unwrap();\n   |       \
    \              ^^ no implementation for `String == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0599]: no method named `windows` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpa1vuv0kq.rs:15:37\n   |\n15 |  \
    \   let (start, end) = text.chars().windows(2).collect::<Vec<_>>();\n   |    \
    \                                 ^^^^^^^ method not found in `Chars<'_>`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa1vuv0kq.rs:21:15\n\
    \   |\n21 |         match text[left] {\n   |               ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa1vuv0kq.rs:25:15\n   |\n25 |         match text[right] {\n   |\
    \               ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .rev()\n        .eq(&text.chars())\n        .unwrap_or(false)\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpj_rfqij8.rs:13:13\n\
    \   |\n13 |         .eq(&text.chars())\n   |          -- ^^^^^^^^^^^^^ `&Chars<'_>`\
    \ is not an iterator\n   |          |\n   |          required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Chars<'_>`\nhelp: consider dereferencing here\n   |\n13 |         .eq(*&text.chars())\n\
    \   |             +\nhelp: consider removing the leading `&`-reference\n   |\n\
    13 -         .eq(&text.chars())\n13 +         .eq(text.chars())\n   | \nhelp:\
    \ consider changing this borrow's mutability\n   |\n13 |         .eq(&mut text.chars())\n\
    \   |             ~~~~\n\nerror[E0599]: no method named `unwrap_or` found for\
    \ type `bool` in the current scope\n  --> /tmp/tmpj_rfqij8.rs:14:10\n   |\n14\
    \ |         .unwrap_or(false)\n   |          ^^^^^^^^^ method not found in `bool`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .enumerate()\n        .all(|(pos, c)| {\n            c.cmp(text.chars().nth(pos).unwrap())\
    \ == 0\n        })\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgztiz0f.rs:14:19\n   |\n\
    14 |             c.cmp(text.chars().nth(pos).unwrap()) == 0\n   |            \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                   |\n   |       \
    \            expected `&char`, found `char`\n   |                   help: consider\
    \ borrowing here: `&text.chars().nth(pos).unwrap()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprgztiz0f.rs:14:54\n   |\n14 |             c.cmp(text.chars().nth(pos).unwrap())\
    \ == 0\n   |                                                      ^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reverse\
    \ = String::from(text);\n    reverse.chars()\n        .rev()\n        .for_each(|c|\
    \ {\n            if c == c.to_char() {\n                let _ = reverse.push(c).unwrap();\n\
    \            }\n        });\n    reverse.eq(&text)\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_char` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpr_ciwdrf.rs:15:23\n   |\n15 |             if c == c.to_char()\
    \ {\n   |                       ^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpr_ciwdrf.rs:16:41\n   |\n16 |                 let _ = reverse.push(c).unwrap();\n\
    \   |                                         ^^^^^^ method not found in `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut iter\
    \ = text.chars();\n\n    let mut index = 0;\n\n    while let Some(next_char) =\
    \ (iter.next() as? char) {\n        if index != iter.index() - 1 {\n         \
    \   return false;\n        }\n        index = index + 1;\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: `?Trait` is not permitted in trait object types\n  --> /tmp/tmpgx5c05lc.rs:15:48\n\
    \   |\n15 |     while let Some(next_char) = (iter.next() as? char) {\n   |   \
    \                                             ^^^^^^\n\nerror[E0404]: expected\
    \ trait, found builtin type `char`\n  --> /tmp/tmpgx5c05lc.rs:15:50\n   |\n15\
    \ |     while let Some(next_char) = (iter.next() as? char) {\n   |           \
    \                                       ^^^^ not a trait\n\nwarning: unnecessary\
    \ parentheses around `let` scrutinee expression\n  --> /tmp/tmpgx5c05lc.rs:15:33\n\
    \   |\n15 |     while let Some(next_char) = (iter.next() as? char) {\n   |   \
    \                              ^                    ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n15 -     while let Some(next_char)\
    \ = (iter.next() as? char) {\n15 +     while let Some(next_char) = iter.next()\
    \ as? char {\n   | \n\nerror[E0224]: at least one trait is required for an object\
    \ type\n  --> /tmp/tmpgx5c05lc.rs:15:48\n   |\n15 |     while let Some(next_char)\
    \ = (iter.next() as? char) {\n   |                                           \
    \     ^^^^^^\n\nerror[E0599]: no method named `index` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpgx5c05lc.rs:16:26\n   |\n16 |         if\
    \ index != iter.index() - 1 {\n   |                          ^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to 4 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0224, E0404, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0224`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut a =\
    \ text.to_bytes();\n    let mut b = a.reverse();\n    a.iter().zip(b.iter()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_bytes` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3_sxltig.rs:11:22\n   |\n11 |     let mut a = text.to_bytes();\n\
    \   |                      ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `bytes`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().clone().rev().cloned().is_sub(&text)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Rev<Chars<'_>> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpafvnn5vn.rs:11:32\n     |\n11   |     text.chars().clone().rev().cloned().is_sub(&text)\n\
    \     |                                ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: no method named\
    \ `is_sub` found for struct `Cloned` in the current scope\n  --> /tmp/tmpafvnn5vn.rs:11:41\n\
    \   |\n11 |     text.chars().clone().rev().cloned().is_sub(&text)\n   |      \
    \                                   ^^^^^^ method not found in `Cloned<Rev<Chars<'_>>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 0 {\n        return true;\n    }\n    if text.len() == 1 {\n        return\
    \ text == text.reverse();\n    }\n    let mut it1 = text.char_indices().rev();\n\
    \    let mut it2 = text.char_indices().rev();\n    let mut last = String::new();\n\
    \    let mut i = 0;\n    while i < text.len() - 1 {\n        if *it1[i] == *it2[i]\
    \ {\n            last.push(*it1[i]);\n            i += 1;\n        } else {\n\
    \            if *it1[i] != *it2[i] {\n                break;\n            }\n\
    \            last.push(*it1[i]);\n            i += 1;\n        }\n    }\n    if\
    \ last.len() == 0 {\n        return true;\n    }\n    if last.len() == 1 {\n \
    \       return text == text.reverse();\n    }\n    return is_palindrome(text.reverse());\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpofktx69p.rs:15:29\n   |\n15 |         return text\
    \ == text.reverse();\n   |                             ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror[E0608]: cannot\
    \ index into a value of type `Rev<CharIndices<'_>>`\n  --> /tmp/tmpofktx69p.rs:22:13\n\
    \   |\n22 |         if *it1[i] == *it2[i] {\n   |             ^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Rev<CharIndices<'_>>`\n  --> /tmp/tmpofktx69p.rs:22:24\n\
    \   |\n22 |         if *it1[i] == *it2[i] {\n   |                        ^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Rev<CharIndices<'_>>`\n  -->\
    \ /tmp/tmpofktx69p.rs:23:24\n   |\n23 |             last.push(*it1[i]);\n   |\
    \                        ^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `Rev<CharIndices<'_>>`\n  --> /tmp/tmpofktx69p.rs:26:17\n   |\n26 |   \
    \          if *it1[i] != *it2[i] {\n   |                 ^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Rev<CharIndices<'_>>`\n  --> /tmp/tmpofktx69p.rs:26:28\n\
    \   |\n26 |             if *it1[i] != *it2[i] {\n   |                        \
    \    ^^^^^^\n\nerror[E0608]: cannot index into a value of type `Rev<CharIndices<'_>>`\n\
    \  --> /tmp/tmpofktx69p.rs:29:24\n   |\n29 |             last.push(*it1[i]);\n\
    \   |                        ^^^^^^\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpofktx69p.rs:37:29\n\
    \   |\n37 |         return text == text.reverse();\n   |                     \
    \        ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpofktx69p.rs:39:31\n   |\n39 |     return is_palindrome(text.reverse());\n\
    \   |                               ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 9 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an "
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Special\
    \ case for empty string\n    if text.len() == 0 {\n        return true;\n    }\n\
    \n    let (left, right) = text.chars().span(|c| c == text.chars().last().unwrap());\n\
    \n    left == right\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `span` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmprhzfxxql.rs:16:38\n   |\n16 |     let (left, right) = text.chars().span(|c|\
    \ c == text.chars().last().unwrap());\n   |                                  \
    \    ^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().enumerate().map(|(_,\
    \ index)| {\n        let slice = text.chars().skip(index).take(text.len() - index).collect::<String>();\n\
    \        if slice != slice.rev() {\n            false\n        } else {\n    \
    \        true\n        }\n    }).all(|bool| bool)\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5y13o5mv.rs:12:39\n   |\n\
    12 |         let slice = text.chars().skip(index).take(text.len() - index).collect::<String>();\n\
    \   |                                       ^^^^^ expected `usize`, found `char`\n\
    \nerror[E0277]: cannot subtract `char` from `usize`\n  --> /tmp/tmp5y13o5mv.rs:12:62\n\
    \   |\n12 |         let slice = text.chars().skip(index).take(text.len() - index).collect::<String>();\n\
    \   |                                                              ^ no implementation\
    \ for `usize - char`\n   |\n   = help: the trait `Sub<char>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmp5y13o5mv.rs:13:27\n\
    \    |\n13  |           if slice != slice.rev() {\n    |                     \
    \        ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut s =\
    \ text;\n    s.reverse();\n\n    let mut i = 0;\n    let mut j = s.size();\n\n\
    \    while i < j {\n        if s[i] != s[j] {\n            return false;\n   \
    \     }\n\n        i += 1;\n        j -= 1;\n    }\n\n    return true;\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp60qgh8mh.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0599]: no method named `size` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp60qgh8mh.rs:15:19\n   |\n15 |     let mut\
    \ j = s.size();\n   |                   ^^^^ method not found in `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp60qgh8mh.rs:18:12\n\
    \   |\n18 |         if s[i] != s[j] {\n   |            ^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .filter_map(|c| char::from_digit(c.to_digit()))\n        .windows(2)\n\
    \        .fold(1, |acc, &(window1, window2)| {\n            let mut acc1 = acc;\n\
    \            let mut acc2 = acc;\n\n            acc1 += window1.1;\n         \
    \   acc2 += window2.1;\n\n            if acc1 > acc2 {\n                acc1\n\
    \            } else {\n                acc2\n            }\n        })\n     \
    \   == 1\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpsjjr4zxf.rs:12:44\n    |\n12  |         .filter_map(|c| char::from_digit(c.to_digit()))\n\
    \    |                                            ^^^^^^^^- supplied 0 arguments\n\
    \    |                                            |\n    |                   \
    \                         expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 2 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpsjjr4zxf.rs:12:25\n    |\n12  |         .filter_map(|c|\
    \ char::from_digit(c.to_digit()))\n    |                         ^^^^^^^^^^^^^^^^\
    \ ------------ supplied 1 argument\n    |                         |\n    |   \
    \                      expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `windows` found for struct `FilterMap`\
    \ in the current scope\n  --> /tmp/tmpsjjr4zxf.rs:13:10\n   |\n13 |         .windows(2)\n\
    \   |          ^^^^^^^ method not found in `FilterMap<Chars<'_>, [closure@/tmp/tmpsjjr4zxf.rs:12:21:\
    \ 12:55]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut rev1\
    \ = text.chars().fold(String::new(), |rev, rev| {\n        rev.chars().fold(rev,\
    \ |rev_, rev_| rev_.push(rev_));\n        rev\n    });\n    let mut rev2 = rev1.chars().fold(rev1,\
    \ |rev, rev| {\n        rev.chars().fold(rev, |rev_, rev_| rev_.push(rev_));\n\
    \        rev\n    });\n    let rev3 = rev2.chars().fold(rev2, |rev, rev| {\n \
    \       rev.chars().fold(rev, |rev_, rev_| rev_.push(rev_));\n        rev\n  \
    \  });\n    rev3 == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `rev` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmp433sel4i.rs:11:59\n   |\n11 |     let mut rev1 = text.chars().fold(String::new(),\
    \ |rev, rev| {\n   |                                                         \
    \  ^^^ used as parameter more than once\n\nerror[E0415]: identifier `rev_` is\
    \ bound more than once in this parameter list\n  --> /tmp/tmp433sel4i.rs:12:38\n\
    \   |\n12 |         rev.chars().fold(rev, |rev_, rev_| rev_.push(rev_));\n   |\
    \                                      ^^^^ used as parameter more than once\n\
    \nerror[E0415]: identifier `rev` is bound more than once in this parameter list\n\
    \  --> /tmp/tmp433sel4i.rs:15:50\n   |\n15 |     let mut rev2 = rev1.chars().fold(rev1,\
    \ |rev, rev| {\n   |                                                  ^^^ used\
    \ as parameter more than once\n\nerror[E0415]: identifier `rev_` is bound more\
    \ than once in this parameter list\n  --> /tmp/tmp433sel4i.rs:16:38\n   |\n16\
    \ |         rev.chars().fold(rev, |rev_, rev_| rev_.push(rev_));\n   |       \
    \                               ^^^^ used as parameter more than once\n\nerror[E0415]:\
    \ identifier `rev` is bound more than once in this parameter list\n  --> /tmp/tmp433sel4i.rs:19:46\n\
    \   |\n19 |     let rev3 = rev2.chars().fold(rev2, |rev, rev| {\n   |        \
    \                                      ^^^ used as parameter more than once\n\n\
    error[E0415]: identifier `rev_` is bound more than once in this parameter list\n\
    \  --> /tmp/tmp433sel4i.rs:20:38\n   |\n20 |         rev.chars().fold(rev, |rev_,\
    \ rev_| rev_.push(rev_));\n   |                                      ^^^^ used\
    \ as parameter more than once\n\nerror[E0599]: no method named `chars` found for\
    \ type `char` in the current scope\n  --> /tmp/tmp433sel4i.rs:12:13\n   |\n12\
    \ |         rev.chars().fold(rev, |rev_, rev_| rev_.push(rev_));\n   |       \
    \      ^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp433sel4i.rs:13:9\n   |\n13 |         rev\n   |         ^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |         |\n   |         expected\
    \ struct `String`, fo"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed_text\
    \ = text.clone();\n\n    loop {\n        if reversed_text == text {\n        \
    \    return true;\n        }\n\n        if text.len() <= 1 {\n            break;\n\
    \        }\n\n        // reverse the text character by character and add to reversed\
    \ text\n        let mut reversed_text_char_iter = reversed_text.chars().nth(1).rev();\n\
    \        let mut text_char_iter = text.chars().nth(1).rev();\n\n        let mut\
    \ char_iter = reversed_text.chars();\n\n        while char_iter.next() == text_char_iter.next()\
    \ {\n            // reverse the two chars being compared\n            char_iter.next();\n\
    \            text_char_iter.next();\n        }\n\n        reversed_text = &reversed_text[0..char_iter.next()];\n\
    \        text = &text[char_iter.next()..];\n    }\n\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<char>` is not an iterator\n   --> /tmp/tmp0w_a5hwp.rs:23:72\n\
    \    |\n23  |           let mut reversed_text_char_iter = reversed_text.chars().nth(1).rev();\n\
    \    |                                                                       \
    \   ^^^ `Option<char>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Option<char>: Iterator`\n         \
    \   which is required by `&mut Option<char>: Iterator`\n\nerror[E0599]: `Option<char>`\
    \ is not an iterator\n   --> /tmp/tmp0w_a5hwp.rs:24:54\n    |\n24  |         \
    \  let mut text_char_iter = text.chars().nth(1).rev();\n    |                \
    \                                        ^^^ `Option<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<char>: Iterator`\n            which is required by `&mut Option<char>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0w_a5hwp.rs:34:43\n\
    \   |\n34 |         reversed_text = &reversed_text[0..char_iter.next()];\n   |\
    \                                           ^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0w_a5hwp.rs:34:25\n\
    \   |\n11 |     let mut reversed_text = text.clone();\n   |                  \
    \           ------------ expected due to this value\n...\n34 |         reversed_text\
    \ = &reversed_text[0..char_iter.next()];\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n34 |         reversed_text = (&reversed_text[0..char_iter.next()]).to_string();\n\
    \   |                         +                                   +++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<char>>`\n\
    \  --> /tmp/tmp0w_a5hwp.rs:35:17\n   |\n35 |         text = &text[char_iter.next()..];\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<char>>`\n\
    \   |\n   = help: the "
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text\n    \
    \    .chars()\n        .collect()\n        .windows(2)\n        .filter(|&(a,\
    \ b)| a == b)\n        .count() == text.chars().count() / 2\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4horuqf7.rs:13:10\n\
    \   |\n13 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n13 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.is_empty()\
    \ {\n        return true;\n    }\n    if text.len() <= 1 {\n        return true;\n\
    \    }\n    let mut i = 0;\n    let mut j = text.len() - 1;\n    while i < j {\n\
    \        if text[i] != text[j] {\n            return false;\n        }\n     \
    \   i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw0mh6dz0.rs:20:12\n\
    \   |\n20 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpw0mh6dz0.rs:20:23\n   |\n20 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut iter:\
    \ Iterator<&str> = text.chars().collect();\n    iter.take(text.len() / 2).all(|&c|\
    \ c == iter.unwrap().rev().unwrap())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "warning: trait objects without an explicit `dyn` are deprecated\n  -->\
    \ /tmp/tmpj4i52_l0.rs:11:19\n   |\n11 |     let mut iter: Iterator<&str> = text.chars().collect();\n\
    \   |                   ^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(bare_trait_objects)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n11 -     let mut iter: Iterator<&str> = text.chars().collect();\n\
    11 +     let mut iter: dyn Iterator<&str> = text.chars().collect();\n   | \n\n\
    error[E0107]: this trait takes 0 generic arguments but 1 generic argument was\
    \ supplied\n  --> /tmp/tmpj4i52_l0.rs:11:19\n   |\n11 |     let mut iter: Iterator<&str>\
    \ = text.chars().collect();\n   |                   ^^^^^^^^ ---- help: replace\
    \ the generic bound with the associated type: `Item = &str`\n   |            \
    \       |\n   |                   expected 0 generic arguments\n\nerror[E0191]:\
    \ the value of the associated type `Item` (from trait `Iterator`) must be specified\n\
    \  --> /tmp/tmpj4i52_l0.rs:11:19\n   |\n11 |     let mut iter: Iterator<&str>\
    \ = text.chars().collect();\n   |                   ^^^^^^^^^^^^^^ associated\
    \ type `Item` must be specified\n\nerror: the `take` method cannot be invoked\
    \ on a trait object\n    --> /tmp/tmpj4i52_l0.rs:12:10\n     |\n12   |     iter.take(text.len()\
    \ / 2).all(|&c| c == iter.unwrap().rev().unwrap())\n     |          ^^^^\n\nerror[E0277]:\
    \ the size for values of type `dyn Iterator` cannot be known at compilation time\n\
    \  --> /tmp/tmpj4i52_l0.rs:11:9\n   |\n11 |     let mut iter: Iterator<&str> =\
    \ text.chars().collect();\n   |         ^^^^^^^^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `dyn\
    \ Iterator`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: a\
    \ value of type `dyn Iterator` cannot be built from an iterator over el"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .zip(text.chars().skip_back().rev())\n        .all(|(a, b)| a == b)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `skip_back` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp31988iq0.rs:12:27\n   |\n12 |         .zip(text.chars().skip_back().rev())\n\
    \   |                           ^^^^^^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text;\n    let len = text.len();\n    if len <= 1 {\n        return true;\n\
    \    }\n    let mut index = 1;\n    while index != len - 1 {\n        if text[index]\
    \ != text[len - index] {\n            return false;\n        }\n        index\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgn8lje7b.rs:18:12\n\
    \   |\n18 |         if text[index] != text[len - index] {\n   |            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgn8lje7b.rs:18:27\n   |\n18 |         if text[index] != text[len\
    \ - index] {\n   |                           ^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut left\
    \ = text.len();\n    let mut right = text.len();\n    let mut mid = 0;\n\n   \
    \ while left != right {\n        if text[mid] != text[left - 1] {\n          \
    \  return false;\n        }\n\n        mid += 1;\n        left -= 1;\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmps5_s7o22.rs:16:12\n   |\n16 |         if text[mid] != text[left - 1]\
    \ {\n   |            ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps5_s7o22.rs:16:25\n   |\n16 |         if text[mid] != text[left\
    \ - 1] {\n   |                         ^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text;\n    text.shrink_to_fit();\n    let (left, right) = text.split_at_mut(text.len());\n\
    \    for (a, b) in (left.chars(), right.chars()) {\n        let c = *a;\n    \
    \    if c != *b {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `(Chars<'_>, Chars<'_>)` is not an iterator\n  --> /tmp/tmpm8o5ugqj.rs:14:19\n\
    \   |\n14 |     for (a, b) in (left.chars(), right.chars()) {\n   |          \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(Chars<'_>, Chars<'_>)` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `(Chars<'_>, Chars<'_>)`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `(Chars<'_>, Chars<'_>)`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().fold(true,\
    \ |b, c| b && c == text.chars().last().unwrap())\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5p7vr63d.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut input\
    \ = text.to_owned();\n    let mut output = text.to_owned();\n\n    input = input.chars().skip(1).collect::<String>();\n\
    \    output = output.chars().skip(1).collect::<String>();\n\n    output == input\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_usjqo67.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .rev()\n        .take(text.len() / 2)\n        .rev()\n        .eq(text)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpn456tyfi.rs:14:10\n     |\n14   |         .rev()\n     |    \
    \      ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `ExactSizeIterator` for `Rev<Chars<'_>>`\n     = note: required\
    \ because of the requirements on the impl of `DoubleEndedIterator` for `std::iter::Take<Rev<Chars<'_>>>`\n\
    note: required by a bound in `rev`\n\nerror[E0599]: the method `eq` exists for\
    \ struct `Rev<std::iter::Take<Rev<Chars<'_>>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpn456tyfi.rs:15:10\n   |\n15 |            .eq(text)\n\
    \   |             ^^ method cannot be called on `Rev<std::iter::Take<Rev<Chars<'_>>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `std::iter::Take<Rev<Chars<'_>>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n\
    \           `Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n           which\
    \ is required by `&mut Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().fold(false,\
    \ |acc, c| {\n        acc && c == text.chars().last().unwrap()\n    })\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfz77olh0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .enumerate()\n        .map(|(i, &c)| {\n            c.to_ascii_lowercase()\n\
    \                .chars()\n                .enumerate()\n                .map(|(j,\
    \ &d)| {\n                    if i == j {\n                        d\n       \
    \             } else {\n                        false\n                    }\n\
    \                })\n                .any(|d| d)\n        })\n        .any(|d|\
    \ d)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7yo7lv80.rs:13:19\n   |\n\
    13 |         .map(|(i, &c)| {\n   |                   ^^- expected due to this\n\
    \   |                   |\n   |                   expected `char`, found reference\n\
    \   |                   help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Special\
    \ cases\n    if text == String::from(\"a\") {\n        return true;\n    }\n\n\
    \    let len = text.len();\n    if len == 0 {\n        return true;\n    }\n\n\
    \    let mid = len / 2;\n\n    for i in 0..mid {\n        let c = text.chars().nth(i).unwrap();\n\
    \        let c2 = text.chars().nth(len - i - 1).unwrap();\n\n        if c == c2\
    \ {\n            continue;\n        }\n\n        return false;\n    }\n\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n    let mut left = text.chars().skip(1).peekable();\n\
    \    let mut right = text.chars().skip(1).peekable();\n    let mut current = left;\n\
    \    while current.peek() != None {\n        let chars = current.take();\n   \
    \     if chars.len() > 0 {\n            if chars[0] != chars[chars.len() - 1]\
    \ {\n                return false;\n            }\n        }\n        current\
    \ = right;\n        right = left.clone();\n        left = right.clone();\n   \
    \ }\n    return true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpiukiqp6_.rs:18:29\n     |\n18   |         let chars = current.take();\n\
    \     |                             ^^^^- supplied 0 arguments\n     |       \
    \                      |\n     |                             expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0599]: the method `len`\
    \ exists for struct `std::iter::Take<Peekable<Skip<Chars<'_>>>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpiukiqp6_.rs:19:18\n   |\n19 |     \
    \       if chars.len() > 0 {\n   |                     ^^^ method cannot be called\
    \ on `std::iter::Take<Peekable<Skip<Chars<'_>>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `Peekable<Skip<Chars<'_>>>:\
    \ ExactSizeIterator`\n           which is required by `std::iter::Take<Peekable<Skip<Chars<'_>>>>:\
    \ ExactSizeIterator`\n\nerror[E0608]: cannot index into a value of type `std::iter::Take<Peekable<Skip<Chars<'_>>>>`\n\
    \  --> /tmp/tmpiukiqp6_.rs:20:16\n   |\n20 |             if chars[0] != chars[chars.len()\
    \ - 1] {\n   |                ^^^^^^^^\n\nerror[E0599]: the method `len` exists\
    \ for struct `std::iter::Take<Peekable<Skip<Chars<'_>>>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpiukiqp6_.rs:20:40\n   |\n20 |            \
    \    if chars[0] != chars[chars.len() - 1] {\n   |                           \
    \                ^^^ method cannot be called on `std::iter::Take<Peekable<Skip<Chars<'_>>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Peekable<Skip<Chars<'_>>>: ExactSizeIterator`\n\
    \           which is required by `std::iter::Take<Peekable<Skip<Chars<'_>>>>:\
    \ ExactSizeIterator`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.is_empty()\
    \ {\n        true\n    } else {\n        let mut low = text[0].unwrap();\n   \
    \     let mut high = text[len(text) - 1].unwrap();\n\n        let mut i = 0;\n\
    \        while i < text.len() - 1 {\n            if low != high {\n          \
    \      let c = text[i];\n                text[i] = text[i + 1];\n            \
    \    text[i + 1] = c;\n            }\n\n            i += 1;\n            low +=\
    \ 1;\n            high -= 1;\n        }\n\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp23vlli7e.rs:15:29\n\
    \   |\n15 |         let mut high = text[len(text) - 1].unwrap();\n   |       \
    \                      ^^^ not found in this scope\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp23vlli7e.rs:14:23\n   |\n14\
    \ |         let mut low = text[0].unwrap();\n   |                       ^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23vlli7e.rs:20:25\n   |\n20 |                 let c = text[i];\n\
    \   |                         ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23vlli7e.rs:21:17\n   |\n21 |                 text[i] = text[i\
    \ + 1];\n   |                 ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \       "
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Step 1:\
    \ Make text to lower case\n    let mut text_lowercase = text.to_lowercase();\n\
    \n    // Step 2: Remove spaces from text\n    text_lowercase.remove_indices('\
    \ ', 0, text.len());\n\n    // Step 3: Loop through characters in text\n    for\
    \ i in 0..text_lowercase.len() {\n        let mut left_char_pos = i;\n       \
    \ let mut right_char_pos = i;\n\n        // Step 4: Check characters one by one\n\
    \        while left_char_pos > 0 && right_char_pos < text.len() && text_lowercase[left_char_pos].is_ascii_alphanumeric()\
    \ {\n            if text_lowercase[left_char_pos].is_ascii_alphanumeric() && (text_lowercase[right_char_pos].is_ascii_alphanumeric()\
    \ || text_lowercase[right_char_pos].is_ascii_lowercase()) {\n                left_char_pos\
    \ -= 1;\n                right_char_pos += 1;\n            } else {\n        \
    \        break;\n            }\n        }\n\n        if left_char_pos > 0 && (left_char_pos\
    \ == right_char_pos || text_lowercase[left_char_pos].is_ascii_alphanumeric() ||\
    \ text_lowercase[left_char_pos].is_ascii_lowercase()) {\n            // If both\
    \ character have same ASCII value\n            // or both character are alphanumeric\
    \ then it is not a palindrome\n            return false;\n        }\n    }\n\n\
    \    // If all characters are alphanumeric or all characters are lowercase then\
    \ it is not a palindrome\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_indices` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0kry3k0g.rs:15:20\n   |\n15 |     text_lowercase.remove_indices('\
    \ ', 0, text.len());\n   |                    ^^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0kry3k0g.rs:23:67\n   |\n23 |         while left_char_pos > 0 &&\
    \ right_char_pos < text.len() && text_lowercase[left_char_pos].is_ascii_alphanumeric()\
    \ {\n   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0kry3k0g.rs:24:16\n   |\n24 | ...   if text_lowercase[left_char_pos].is_ascii_alphanumeric()\
    \ && (text_lowercase[right_char_pos].is_ascii_alphanumeric() || text_lowerca...\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0kry3k0g.rs:24:74\n   |\n24 | ...pos].is_ascii_alphanumeric() &&\
    \ (text_lowe"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text;\n    text.reverse();\n    text == text\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpit8nt_rj.rs:12:10\n   |\n12 |     text.reverse();\n\
    \   |          ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len < 2 {\n        return true;\n    }\n    let mut first = true;\n  \
    \  for &c in text.as_bytes() {\n        if first {\n            first = false;\n\
    \        } else {\n            if *c != *text.rposition(|c| c == a) {\n      \
    \          return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmpj1_3qvwo.rs:20:47\n\
    \   |\n20 |             if *c != *text.rposition(|c| c == a) {\n   |         \
    \                                      ^ help: a local variable with a similar\
    \ name exists: `c`\n\nerror[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpj1_3qvwo.rs:20:16\n\
    \   |\n20 |             if *c != *text.rposition(|c| c == a) {\n   |         \
    \       ^^\n\nerror[E0599]: no method named `rposition` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpj1_3qvwo.rs:20:28\n   |\n20 |          \
    \   if *c != *text.rposition(|c| c == a) {\n   |                            ^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut text\
    \ = text.chars();\n    let mut first = String::new();\n    let mut last = String::new();\n\
    \    loop {\n        let c = text.next().unwrap();\n        if c != ' ' {\n  \
    \          first.append(&c);\n        }\n        if c == ' ' {\n            break;\n\
    \        }\n        last.append(&c);\n    }\n    first == last\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpphzfqeqg.rs:17:19\n   |\n17 |             first.append(&c);\n\
    \   |                   ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpphzfqeqg.rs:22:14\n   |\n22 |         last.append(&c);\n   |       \
    \       ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .enumerate()\n        .filter(|&(i, _)| {\n            if i < text.len()\
    \ - 1 {\n                if text[i] != text[i+1] {\n                    false\n\
    \                } else {\n                    true\n                }\n     \
    \       } else {\n                true\n            }\n        })\n        .is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcj427gf7.rs:15:20\n\
    \   |\n15 |                 if text[i] != text[i+1] {\n   |                  \
    \  ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcj427gf7.rs:15:31\n   |\n15 |                 if text[i] != text[i+1]\
    \ {\n   |                               ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `is_empty` found for struct `Filter`\
    \ in the current scope\n  --> /tmp/tmpcj427gf7.rs:24:10\n   |\n24 |         .is_empty()\n\
    \   |          ^^^^^^^^ method not found in `Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmpcj427gf7.rs:13:17:\
    \ 23:10]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .zip(text.chars().skip(1))\n        .all(|(a, b)| a == b)\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4bmw_ujf.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .zip(text.chars().skip_while(|&a| !a.is_ascii_lowercase()))\n       \
    \ .all(|&(l, r)| l == r)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrxalj92.rs:13:15\n   |\n\
    13 |         .all(|&(l, r)| l == r)\n   |               ^^^^^^-\n   |        \
    \       |     |\n   |               |     expected due to this\n   |         \
    \      expected tuple, found reference\n   |\n   = note:  expected tuple `(char,\
    \ char)`\n           found reference `&_`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // https://stackoverflow.com/a/34853969\n\
    \    let mut text = text.to_owned();\n    if text.len() == 0 {\n        return\
    \ true;\n    }\n\n    let first = text[0];\n    let last = text[text.len() - 1];\n\
    \n    if first != last {\n        return false;\n    }\n\n    is_palindrome(&text[1..(text.len()\
    \ - 1)])\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmppa_t2sg9.rs:17:17\n   |\n17 |     let first = text[0];\n   |       \
    \          ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppa_t2sg9.rs:18:16\n\
    \   |\n18 |     let last = text[text.len() - 1];\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppa_t2sg9.rs:24:19\n\
    \   |\n24 |     is_palindrome(&text[1..(text.len() - 1)])\n   |              \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n24 |     is_palindrome((&text[1..(text.len()\
    \ - 1)]).to_string())\n   |                   +                          +++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut i =\
    \ 0;\n    let mut j = text.len() - 1;\n\n    while i <= j {\n        if text[i]\
    \ != text[j] {\n            return false;\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy56u3yka.rs:15:12\n\
    \   |\n15 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy56u3yka.rs:15:23\n   |\n15 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed\
    \ = text.chars().rev().collect::<String>();\n    reversed.chars()\n        .by_ref()\n\
    \        .eq(&text.chars())\n        .unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpdid6_n5q.rs:14:13\n\
    \   |\n14 |         .eq(&text.chars())\n   |          -- ^^^^^^^^^^^^^ `&Chars<'_>`\
    \ is not an iterator\n   |          |\n   |          required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Chars<'_>`\nhelp: consider dereferencing here\n   |\n14 |         .eq(*&text.chars())\n\
    \   |             +\nhelp: consider removing the leading `&`-reference\n   |\n\
    14 -         .eq(&text.chars())\n14 +         .eq(text.chars())\n   | \nhelp:\
    \ consider changing this borrow's mutability\n   |\n14 |         .eq(&mut text.chars())\n\
    \   |             ~~~~\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `bool` in the current scope\n  --> /tmp/tmpdid6_n5q.rs:15:10\n   |\n15 |   \
    \      .unwrap()\n   |          ^^^^^^ method not found in `bool`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let mut char_iter = text.chars();\n\
    \    let mut rev_iter = char_iter.rchars();\n\n    let (left, right) = char_iter.next();\n\
    \    let (left_rev, rev_right) = rev_iter.next();\n\n    while left != right {\n\
    \        if *left != *left_rev {\n            return false;\n        }\n\n   \
    \     (left, right) = char_iter.next();\n        (left_rev, rev_right) = rev_iter.next();\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rchars` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpmlbywh6r.rs:16:34\n   |\n16 |     let mut rev_iter\
    \ = char_iter.rchars();\n   |                                  ^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmlbywh6r.rs:18:9\n\
    \   |\n18 |     let (left, right) = char_iter.next();\n   |         ^^^^^^^^^^^^^\
    \   ---------------- this expression has type `Option<char>`\n   |         |\n\
    \   |         expected enum `Option`, found tuple\n   |\n   = note: expected enum\
    \ `Option<char>`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmlbywh6r.rs:26:9\n   |\n26 |         (left, right) = char_iter.next();\n\
    \   |         ^^^^^^^^^^^^^   ---------------- this expression has type `Option<char>`\n\
    \   |         |\n   |         expected enum `Option`, found tuple\n   |\n   =\
    \ note: expected enum `Option<char>`\n             found tuple `(_, _)`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .enumerate()\n        .any(|(pos, char)| char == text.get(pos).unwrap())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n   --> /tmp/tmp9v6fu2jl.rs:13:45\n\
    \    |\n13  |         .any(|(pos, char)| char == text.get(pos).unwrap())\n   \
    \ |                                         --- ^^^ string indices are ranges\
    \ of `usize`\n    |                                         |\n    |         \
    \                                required by a bound introduced by this call\n\
    \    |\n    = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9v6fu2jl.rs:13:36\n   |\n13 |         .any(|(pos, char)| char ==\
    \ text.get(pos).unwrap())\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\nhelp: consider dereferencing the borrow\n  \
    \ |\n13 |         .any(|(pos, char)| char == *text.get(pos).unwrap())\n   |  \
    \                                  +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed\
    \ = text.chars().collect::<String>();\n    reversed.reverse();\n\n    text ==\
    \ reversed\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgsjhfr3m.rs:12:14\n   |\n12 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed\
    \ = text.clone().rev();\n    match (reversed.clone(), reversed) {\n        (text,\
    \ rev) => rev == text,\n        _ => false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpkp7n7ykb.rs:11:37\n\
    \    |\n11  |       let mut reversed = text.clone().rev();\n    |            \
    \                           ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text ==\
    \ text.reverse() {\n        return true;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdpgutdxt.rs:11:21\n   |\n11 |     if text == text.reverse()\
    \ {\n   |                     ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .cloned()\n        .enumerate()\n        .fold(false, (i, &(c1, c2))\
    \ => {\n            if c1 != c2 {\n                return true;\n            }\n\
    \            i += 1;\n            false\n        })\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmp7_jns6i4.rs:14:37\n   |\n14 |         .fold(false, (i, &(c1, c2))\
    \ => {\n   |                                     ^^ expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut iter\
    \ = text.chars();\n    let mut it = iter.reverse();\n    let mut char = char;\n\
    \    while let Some(c) = it.next() {\n        if text != String::from(&*char)\
    \ {\n            return false;\n        }\n        char = c;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `char`\n  --> /tmp/tmpletph4u7.rs:13:20\n\
    \   |\n13 |     let mut char = char;\n   |                    ^^^^ not a value\n\
    \nerror[E0599]: no method named `reverse` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpletph4u7.rs:12:23\n   |\n12 |     let mut it = iter.reverse();\n\
    \   |                       ^^^^^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .zip(text.chars().skip(1))\n        .all(|(a, b)| a == b)\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4bmw_ujf.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().enumerate().filter(|&(c,\
    \ i)| {\n        i != text.len() - i - 1\n    }).all(|(_, i)| c == text[i])\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpc3xcz105.rs:13:21\n\
    \   |\n13 |     }).all(|(_, i)| c == text[i])\n   |                     ^ help:\
    \ a local variable with a similar name exists: `i`\n\nerror[E0277]: cannot subtract\
    \ `char` from `usize`\n  --> /tmp/tmpc3xcz105.rs:12:25\n   |\n12 |         i !=\
    \ text.len() - i - 1\n   |                         ^ no implementation for `usize\
    \ - char`\n   |\n   = help: the trait `Sub<char>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `char`\n  --> /tmp/tmpc3xcz105.rs:13:26\n\
    \   |\n13 |     }).all(|(_, i)| c == text[i])\n   |                          ^^^^^^^\
    \ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip2(text.chars().skip_back(),\
    \ |a, b| a == b).all(|(a, b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `zip2` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpb3nv1c26.rs:11:18\n   |\n11 |     text.chars().zip2(text.chars().skip_back(),\
    \ |a, b| a == b).all(|(a, b)| a == b)\n   |                  ^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `skip_back` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpb3nv1c26.rs:11:36\n   |\n11 |  \
    \   text.chars().zip2(text.chars().skip_back(), |a, b| a == b).all(|(a, b)| a\
    \ == b)\n   |                                    ^^^^^^^^^ method not found in\
    \ `Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut len\
    \ = 0;\n    let mut start = 0;\n    for ch in text.chars() {\n        if *ch <\
    \ 128 {\n            return true;\n        }\n        if *ch == 0 {\n        \
    \    len = ch;\n            start = text.len() - 1;\n        } else {\n      \
    \      if len != ch {\n                return false;\n            }\n        }\n\
    \    }\n    if len < start {\n        return false;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut p = 0;\n    let mut q = 0;\n    while i != q\
    \ {\n        p += 1;\n        q += 1;\n        if i < q {\n            if text[i]\
    \ != text[j] {\n                return false;\n            }\n        }\n    \
    \    i += 1;\n        j += 1;\n    }\n    if i == q && j == p {\n        return\
    \ true;\n    }\n    if i != q {\n        return false;\n    }\n    if j != p {\n\
    \        return false;\n    }\n    for _ in 0..text.len() {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpfyh9vncd.rs:14:12\n\
    \   |\n14 |         if *ch < 128 {\n   |            ^^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpfyh9vncd.rs:17:12\n   |\n17 | \
    \        if *ch == 0 {\n   |            ^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfyh9vncd.rs:18:19\n   |\n11 |     let mut len = 0;\n   |      \
    \             - expected due to this value\n...\n18 |             len = ch;\n\
    \   |                   ^^ expected integer, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfyh9vncd.rs:21:23\n   |\n21 |             if len != ch\
    \ {\n   |                       ^^ expected integer, found `char`\n\nerror[E0277]:\
    \ can't compare `{integer}` with `char`\n  --> /tmp/tmpfyh9vncd.rs:21:20\n   |\n\
    21 |             if len != ch {\n   |                    ^^ no implementation\
    \ for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmpfyh9vncd.rs:37:16\n   |\n37 |     \
    \        if text[i] != text[j] {\n   |                ^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpfyh9vncd.rs:37:27\n   |\n37 |             if text[i] != text[j]\
    \ {\n   |                           ^^^^^^^ `Stri"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut it\
    \ = text.char_indices();\n\n    for i in 0..text.len() {\n        if i >= it.len()\
    \ || it[it.len() - i - 1] != it.last() {\n            return false;\n        }\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmp9h2jc6yx.rs:14:20\n   |\n14 |         if i >= it.len()\
    \ || it[it.len() - i - 1] != it.last() {\n   |                    ^^^ method not\
    \ found in `CharIndices<'_>`\n\nerror[E0599]: no method named `len` found for\
    \ struct `CharIndices` in the current scope\n  --> /tmp/tmp9h2jc6yx.rs:14:35\n\
    \   |\n14 |         if i >= it.len() || it[it.len() - i - 1] != it.last() {\n\
    \   |                                   ^^^ method not found in `CharIndices<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Check for\
    \ empty string\n    if text.len() == 0 {\n        return true;\n    }\n\n    //\
    \ If the first letter of the string is equal to last letter\n    // then it is\
    \ a palindrome\n    if text[0] == text[text.len() - 1] {\n        true\n    }\
    \ else {\n        // Check if the middle of the string is equal to last letter\n\
    \        // If not then check if the middle of the string is equal to first letter\n\
    \        // If not then it is a palindrome\n        if text[0] != text[(text.len()\
    \ / 2) - 1] {\n            if text[(text.len() / 2)] != text[0] {\n          \
    \      true\n            } else {\n                false\n            }\n    \
    \    } else {\n            false\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp80ln42hw.rs:18:8\n   |\n18 |     if text[0] == text[text.len() - 1]\
    \ {\n   |        ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   =\
    \ help: the trait `Index<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp80ln42hw.rs:18:19\n\
    \   |\n18 |     if text[0] == text[text.len() - 1] {\n   |                   ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp80ln42hw.rs:24:12\n   |\n24 |         if text[0] != text[(text.len()\
    \ / 2) - 1] {\n   |            ^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Ran"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .map(|&c| if c < 'a' || c > 'z' { return false })\n        .rev()\n \
    \       .eq(text)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpky6o7eka.rs:12:15\n   |\n\
    12 |         .map(|&c| if c < 'a' || c > 'z' { return false })\n   |         \
    \      ^--\n   |               ||\n   |               |expected due to this\n\
    \   |               expected `char`, found reference\n   |               help:\
    \ did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpky6o7eka.rs:12:19\n\
    \   |\n10 | fn is_palindrome(text: String) -> bool {\n   |                   \
    \                ---- expected `_` because of return type\n11 |     text.chars()\n\
    12 |         .map(|&c| if c < 'a' || c > 'z' { return false })\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n\
    \   |\nnote: return type inferred to be `bool` here\n  --> /tmp/tmpky6o7eka.rs:12:50\n\
    \   |\n12 |         .map(|&c| if c < 'a' || c > 'z' { return false })\n   |  \
    \                                                ^^^^^\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpky6o7eka.rs:14:13\n   |\n14 |         .eq(text)\n\
    \   |          -- ^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |          |\n   |          required by a bound introduced by\
    \ this call\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.is_empty()\
    \ {\n        return true;\n    }\n\n    let mut s = text;\n    let mut i = s.len()\
    \ - 1;\n    while i >= 0 {\n        if s[i] != s[i as usize] {\n            return\
    \ false;\n        }\n        --i;\n    }\n\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptc8tg9ea.rs:18:12\n\
    \   |\n18 |         if s[i] != s[i as usize] {\n   |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptc8tg9ea.rs:18:20\n   |\n18 |         if s[i] != s[i as usize]\
    \ {\n   |                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmptc8tg9ea.rs:21:10\n   |\n21 |         --i;\n   |          ^^ cannot\
    \ apply unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmptc8tg9ea.rs:21:9\n\
    \   |\n21 |         --i;\n   |         ^^^ cannot apply unary operator `-`\n \
    \  |\nhelp: parentheses are required to parse this as an expression\n   |\n18\
    \ ~         (if s[i] != s[i as usize] {\n19 |             return false;\n20 ~\
    \         })\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0600.\nFor more information about an error,\
    \ try `r"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    !text.chars().all_bytes().boxed().cloned().rev().eq(&text.chars().all_bytes().boxed().cloned())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `all_bytes` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmprd0sr86h.rs:11:19\n   |\n11 |     !text.chars().all_bytes().boxed().cloned().rev().eq(&text.chars().all_bytes().boxed().cloned())\n\
    \   |                   ^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `all_bytes` found for struct `Chars` in the current scope\n\
    \  --> /tmp/tmprd0sr86h.rs:11:71\n   |\n11 |     !text.chars().all_bytes().boxed().cloned().rev().eq(&text.chars().all_bytes().boxed().cloned())\n\
    \   |                                                                       ^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().enumerate().all(|(index,\
    \ char)| {\n        let sliced = String::from_utf8(text.chars().skip(index).take(1)).unwrap();\n\
    \        sliced == sliced.chars().last().unwrap()\n    })\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqaeozdih.rs:12:40\n   |\n\
    12 |         let sliced = String::from_utf8(text.chars().skip(index).take(1)).unwrap();\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `std::iter::Take`\n   |\n   = note: expected\
    \ struct `Vec<u8>`\n              found struct `std::iter::Take<Skip<Chars<'_>>>`\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpqaeozdih.rs:13:16\n\
    \   |\n13 |         sliced == sliced.chars().last().unwrap()\n   |           \
    \     ^^ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.is_empty()\
    \ {\n        return true;\n    }\n\n    if text[0] != text.get(text.len() - 1)\
    \ {\n        return false;\n    }\n\n    let mut s = text.clone();\n    let mut\
    \ reverse: String = String::from(\"\");\n\n    while let Some(i) = s.find(|c|\
    \ *c != c) {\n        reverse.push(*s);\n        s = s.clone();\n    }\n\n   \
    \ s == reverse\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp7c3wpkn1.rs:15:8\n   |\n15 |     if text[0] != text.get(text.len() -\
    \ 1) {\n   |        ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n   -->\
    \ /tmp/tmp7c3wpkn1.rs:15:28\n    |\n15  |     if text[0] != text.get(text.len()\
    \ - 1) {\n    |                        --- ^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n    |                        |\n    |                        required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7c3wpkn1.rs:23:22\n   |\n23 |         reverse.push(*s);\n\
    \   |                      ^^ expected `char`, found `str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed\
    \ = String::new();\n    let mut it = text.chars();\n    while let Some(c) = it.next()\
    \ {\n        reversed.push_str(&c.to_string());\n    }\n\n    it == reversed.chars()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Chars<'_>`\n\
    \  --> /tmp/tmpz1wl853u.rs:17:8\n   |\n17 |     it == reversed.chars()\n   | \
    \    -- ^^ ---------------- Chars<'_>\n   |     |\n   |     Chars<'_>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reverse\
    \ = text.get_chars().rev();\n    match reverse.next() {\n        Some('z') =>\
    \ false,\n        Some('Z') => false,\n        Some('z') => false,\n        Some('Z')\
    \ => false,\n        Some(x) => true,\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_chars` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpoivnjp9j.rs:11:28\n   |\n11 |     let mut reverse\
    \ = text.get_chars().rev();\n   |                            ^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `chars`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len <= 1 {\n        return true;\n    }\n    let mut half = len / 2;\n\
    \    let mut left = String::new();\n    let mut right = String::new();\n    let\
    \ mut cursor = half;\n    while cursor > 0 {\n        left.push((text[cursor -\
    \ 1] as char).to_string());\n        right.push((text[cursor] as char).to_string());\n\
    \        cursor = cursor / 2;\n    }\n    left == right\n}\n\nfn main() {\n  \
    \  let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkp65_k2t.rs:20:20\n\
    \   |\n20 |         left.push((text[cursor - 1] as char).to_string());\n   | \
    \                   ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkp65_k2t.rs:20:19\n\
    \   |\n20 |         left.push((text[cursor - 1] as char).to_string());\n   | \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkp65_k2t.rs:21:21\n   |\n21 |         right.push((text[cursor]\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkp65_k2t.rs:21:20\n\
    \   |\n21 |         right.push((text[cursor] as char).to_string());\n   |    \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .chain(text.chars().cloned())\n        .rev()\n        .eq(&text.chars().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp_b1kbif4.rs:12:29\n     |\n12   |         .chain(text.chars().cloned())\n\
    \     |                             ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &char`\n   --> /tmp/tmp_b1kbif4.rs:12:16\n\
    \    |\n12  |         .chain(text.chars().cloned())\n    |          ----- ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&char`, found `char`\n    |          |\n    |          required by\
    \ a bound introduced by this call\n    |\n    = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\nnote: required\
    \ by a bound in `std::iter::Iterator::chain`\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmp_b1kbif4.rs:12:16\n   |\n\
    12 |         .chain(text.chars().cloned())\n   |          ----- ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |          |\n   |          required by\
    \ a bound introduced by this call\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0599]: the method `rev` exists for struct `std::iter::Chain<Chars<'_>,\
    \ Cloned<Chars<'_>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp_b1kbif4.rs:13:10\n\
    \   |\n13 |           .rev()\n   |            ^^^ method cannot be called on `std::iter::Chain<Chars<'_>,\
    \ Cloned<Chars<'_>>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `<Cloned<Chars<'_>> as Iterator>::Item\
    \ = char`\n           which is required by `std::iter::Chain<Chars<'_>, Cloned<Chars<'_>>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `std::iter::Chain<Chars<'"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reverse\
    \ = String::from(\"\");\n    reverse.rev();\n    text.chars()\n        .skip_while(|&c|\
    \ c == ' ' || c == '\\t' || c == '\\n')\n        .take_while(|&c| c != ' ')\n\
    \        .filter(|c| c != '\\t' && c != '\\n')\n        .for_each(|c| {\n    \
    \        reverse.push(c);\n        });\n    reverse == text\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpcgmu7qj_.rs:12:13\n\
    \    |\n12  |       reverse.rev();\n    |               ^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpcgmu7qj_.rs:16:23\n   |\n16 |   \
    \      .filter(|c| c != '\\t' && c != '\\n')\n   |                       ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcgmu7qj_.rs:16:36\n\
    \   |\n16 |         .filter(|c| c != '\\t' && c != '\\n')\n   |              \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text\n    \
    \    .chars()\n        .filter(|c| c.is_alphanumeric())\n        .filter(|c| !c.is_whitespace())\n\
    \        .filter_map(|c| c.to_ascii_lowercase())\n        .rev()\n        .eq(&text.to_ascii_lowercase())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyonm_axl.rs:15:25\n   |\n\
    15 |         .filter_map(|c| c.to_ascii_lowercase())\n   |                   \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `char`\n   |\n   =\
    \ note: expected enum `Option<_>`\n              found type `char`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n15 |         .filter_map(|c| Some(c.to_ascii_lowercase()))\n\
    \   |                         +++++                      +\n\nerror[E0277]: `&String`\
    \ is not an iterator\n  --> /tmp/tmpyonm_axl.rs:17:13\n   |\n17 |         .eq(&text.to_ascii_lowercase())\n\
    \   |          -- ^^^^^^^^^^^^^^^^^^^^^^^^^^ `&String` is not an iterator\n  \
    \ |          |\n   |          required by a bound introduced by this call\n  \
    \ |\n   = help: the trait `Iterator` is not implemented for `&String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text\n    \
    \    .chars()\n        .rev()\n        .map(|c| c.to_string())\n        .eq(&text.chars().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpdc7acqhf.rs:15:13\n\
    \   |\n15 |         .eq(&text.chars().collect::<String>())\n   |          -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `&String` is not an iterator\n   |          |\n   |          required by a bound\
    \ introduced by this call\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars()\n\
    \        .zip(text.chars().skip(1))\n        .all(|(a, b)| a == b)\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4bmw_ujf.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut buffer\
    \ = text.as_ref();\n    buffer[0] = '\\0';\n    let mut is_palindrome = true;\n\
    \    let mut i = 0;\n    for &c in &buffer {\n        if *c != buffer[i as usize]\
    \ {\n            is_palindrome = false;\n            break;\n        }\n     \
    \   i += 1;\n    }\n    is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmptay1d1cx.rs:11:27\n\
    \   |\n11 |     let mut buffer = text.as_ref();\n   |         ----------     \
    \   ^^^^^^ cannot infer type for type parameter `T` declared on the trait `AsRef`\n\
    \   |         |\n   |         consider giving `buffer` the explicit type `&T`,\
    \ where the type parameter `T` is specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Find the\
    \ length of the string\n    let mut len = text.len();\n    // Move the beginning\
    \ of string to index 0\n    text.as_bytes()[0..len/2].to_vec()\n        == text.as_bytes()[len/2..len].to_vec()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp22v068q2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut buffer\
    \ = String::from(text);\n    let len = (text.len() - 1) as usize;\n    let mut\
    \ i = 0;\n    while i <= len {\n        if buffer[i as usize] != buffer[(i + len\
    \ - 1) as usize] {\n            return false;\n        }\n        i += 1;\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1i09mgub.rs:15:12\n\
    \   |\n15 |         if buffer[i as usize] != buffer[(i + len - 1) as usize] {\n\
    \   |            ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1i09mgub.rs:15:34\n   |\n15 |         if buffer[i as usize] !=\
    \ buffer[(i + len - 1) as usize] {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut input\
    \ = text.chars();\n    input.next(); // skip first element\n    let mut reversed\
    \ = String::new();\n    input.next(); // skip first element\n    while !input.is_empty()\
    \ {\n        reversed.push(input.next());\n    }\n\n    let mut input = reversed.chars();\n\
    \    input.next(); // skip first element\n    let mut output = String::new();\n\
    \    while !input.is_empty() {\n        output.push(input.next());\n    }\n  \
    \  reversed.cmp(&output) == 0\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp_x6y5lv7.rs:15:18\n   |\n15 |     while !input.is_empty()\
    \ {\n   |                  ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_x6y5lv7.rs:16:23\n   |\n16 |         reversed.push(input.next());\n\
    \   |                       ^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0599]: no method named `is_empty` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp_x6y5lv7.rs:22:18\n   |\n22 |     while !input.is_empty()\
    \ {\n   |                  ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_x6y5lv7.rs:23:21\n   |\n23 |         output.push(input.next());\n\
    \   |                     ^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_x6y5lv7.rs:25:30\n   |\n25 |\
    \     reversed.cmp(&output) == 0\n   |                              ^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.is_empty()\
    \ {\n        return true;\n    }\n\n    let mut i = 0;\n    let mut j = text.len()\
    \ - 1;\n\n    while i >= 0 && j >= 0 {\n        if text[i] != text[j] {\n    \
    \        return false;\n        }\n\n        i += 1;\n        j -= 1;\n    }\n\
    \n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpwhdtpgoq.rs:19:12\n   |\n19 |         if text[i] != text[j] {\n   |\
    \            ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwhdtpgoq.rs:19:23\n\
    \   |\n19 |         if text[i] != text[j] {\n   |                       ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Iterate\
    \ over all characters from last to first\n    for pos in text.chars().rev().enumerate()\
    \ {\n        // If position is odd, then it is palindrome\n        if pos.1 %\
    \ 2 != 0 {\n            return text.get(pos.0 - 1) != text.get(pos.0);\n     \
    \   }\n    }\n    // If we reach here, then we have no odd characters\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpmtfy6q4k.rs:14:18\n\
    \   |\n14 |         if pos.1 % 2 != 0 {\n   |            ----- ^ - {integer}\n\
    \   |            |\n   |            char\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `usize`\n   --> /tmp/tmpmtfy6q4k.rs:15:29\n    |\n15  |      \
    \       return text.get(pos.0 - 1) != text.get(pos.0);\n    |                \
    \         --- ^^^^^^^^^ string indices are ranges of `usize`\n    |          \
    \               |\n    |                         required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    note: required by a bound in `core::str::<impl str>::get`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n   --> /tmp/tmpmtfy6q4k.rs:15:52\n\
    \    |\n15  |             return text.get(pos.0 - 1) != text.get(pos.0);\n   \
    \ |                                                --- ^^^^^ string indices are\
    \ ranges of `usize`\n    |                                                |\n\
    \    |                                                required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    note: required by a bound in `core::str::<impl str>::get`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976112
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    (text.chars().rev()\
    \ == text.chars())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmpojh09tan.rs:11:5\n\
    \   |\n11 |     (text.chars().rev() == text.chars())\n   |     ^             \
    \                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n11 -     (text.chars().rev() == text.chars())\n\
    11 +     text.chars().rev() == text.chars()\n   | \n\nerror[E0369]: binary operation\
    \ `==` cannot be applied to type `Rev<Chars<'_>>`\n  --> /tmp/tmpojh09tan.rs:11:25\n\
    \   |\n11 |     (text.chars().rev() == text.chars())\n   |      ------------------\
    \ ^^ ------------ Chars<'_>\n   |      |\n   |      Rev<Chars<'_>>\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976112
