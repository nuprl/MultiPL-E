language: rs
name: HumanEval_58_common
results:
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut i\
    \ = Vec::new();\n\n    while l1.len() != 0 || l2.len() != 0 {\n        while l1.len()\
    \ != 0 && l2.len() != 0 && l1[0] == l2[0] {\n            result.push(l1[0]);\n\
    \            l1.pop();\n            l2.pop();\n        }\n        if l1.len()\
    \ != 0 {\n            result.push(l1[0]);\n            l1.pop();\n        }\n\
    \        if l2.len() != 0 {\n            result.push(l2[0]);\n            l2.pop();\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmpq7imt9gt.rs:8:17\n\
    \  |\n8 |     let mut i = Vec::new();\n  |         -----   ^^^^^^^^ cannot infer\
    \ type for type parameter `T`\n  |         |\n  |         consider giving `i`\
    \ the explicit type `Vec<T>`, where the type parameter `T` is specified\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|&(_, x)|\
    \ x == 1).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n --> /tmp/tmp9xkxiiu8.rs:7:49\n\
    \  |\n7 |     l1.iter().zip(l2.iter()).filter(|&(_, x)| x == 1).collect::<Vec<_>>()\n\
    \  |                                                 ^^ no implementation for\
    \ `&isize == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>` is not\
    \ implemented for `&isize`\n  = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n    \
    \        i16\n            i32\n            i64\n            i8\n            isize\n\
    \          and 6 others\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9xkxiiu8.rs:7:5\n\
    \  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n7 |     l1.iter().zip(l2.iter()).filter(|&(_, x)| x == 1).collect::<Vec<_>>()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n\
    \             found struct `Vec<(&isize, &isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 1;\n    let mut j = l1.len();\n\
    \    while i <= j {\n        match l1[i] & l2[j] {\n            0 => i = i + 1,\n\
    \            x | x & x0 => j = j - 1,\n        }\n    }\n    while i <= j {\n\
    \        l1[i ..]\n    }\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `&`\n  --> /tmp/tmplvzi3d4c.rs:12:19\n\
    \   |\n12 |             x | x & x0 => j = j - 1,\n   |                   ^ expected\
    \ one of `=>`, `@`, `if`, or `|`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvzi3d4c.rs:16:9\n\
    \   |\n15 | /     while i <= j {\n16 | |         l1[i ..]\n   | |         ^^^^^^^^\
    \ expected `()`, found slice `[isize]`\n17 | |     }\n   | |_____- expected this\
    \ to be `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvzi3d4c.rs:15:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n15 | /     while i <= j {\n16 | |         l1[i\
    \ ..]\n17 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    use std::cmp::Ordering;\n    let mut l1\
    \ = l1.to_vec();\n    let mut l2 = l2.to_vec();\n    l1.sort_unstable_by(|a, b|\
    \ {\n        Ordering::Less if a < b else Ordering::Greater\n    });\n    l2.sort_unstable_by(|a,\
    \ b| {\n        Ordering::Less if a < b else Ordering::Greater\n    });\n    l1.iter().cloned().chain(l2.iter()).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmp5mh3bkhd.rs:11:24\n   |\n11 |         Ordering::Less\
    \ if a < b else Ordering::Greater\n   |                        ^^ expected one\
    \ of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`,\
    \ `}`, or an operator, found keyword `if`\n  --> /tmp/tmp5mh3bkhd.rs:14:24\n \
    \  |\n14 |         Ordering::Less if a < b else Ordering::Greater\n   |      \
    \                  ^^ expected one of 8 possible tokens\n\nwarning: unused import:\
    \ `std::cmp::Ordering`\n --> /tmp/tmp5mh3bkhd.rs:7:9\n  |\n7 |     use std::cmp::Ordering;\n\
    \  |         ^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by\
    \ default\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize>\
    \ as IntoIterator>::Item == isize`\n   --> /tmp/tmp5mh3bkhd.rs:16:24\n    |\n\
    16  |     l1.iter().cloned().chain(l2.iter()).cloned().collect()\n    |      \
    \                  ^^^^^ expected `isize`, found `&isize`\n    |\nnote: required\
    \ by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]: the method `cloned`\
    \ exists for struct `std::iter::Chain<Cloned<std::slice::Iter<'_, isize>>, std::slice::Iter<'_,\
    \ isize>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp5mh3bkhd.rs:16:41\n\
    \   |\n16 |       l1.iter().cloned().chain(l2.iter()).cloned().collect()\n   |\
    \                                           ^^^^^^ method cannot be called on\
    \ `std::iter::Chain<Cloned<std::slice::Iter<'_, isize>>, std::slice::Iter<'_,\
    \ isize>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ isize>>, std::slice::Iter<'_, isize>>: Iterator`\n           which is required\
    \ by `&mut std::iter::Chain<Cloned<std::slice::Iter<'_, isize>>, std::slice::Iter<'_,\
    \ isize>>: Iterator`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut cs = vec![0; l1.len()];\n    for\
    \ i in 0..l1.len() {\n        cs.push(l1[i] & l2[i]);\n    }\n    cs.sort_unstable();\n\
    \    cs\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 9]`,\n right: `[1, 5, 653]`', /tmp/tmpybra7yhq.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)|\
    \ a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmptubvgxpv.rs:7:54\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).collect()\n\
    \     |                                                      ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() {\n        panic!(\"\
    len(l1) != len(l2)\");\n    }\n\n    let mut ret = vec![];\n\n    let mut l1 =\
    \ l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n     \
    \       l2.pop();\n        } else {\n            l1.pop();\n        }\n\n    \
    \    if l2.len() == 0 {\n            l1.pop();\n        } else {\n           \
    \ l2.pop();\n        }\n\n        if l1.len() == 0 || l2.len() == 0 {\n      \
    \      break;\n        }\n\n        let mut i = 0;\n        let mut j = 0;\n\n\
    \        while l1[i += 1] == l2[j += 1] {\n            continue;\n        }\n\n\
    \        ret.push(l1[i / 1]);\n    }\n\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `()`\n  --> /tmp/tmpf2iyck7s.rs:36:15\n\
    \   |\n36 |         while l1[i += 1] == l2[j += 1] {\n   |               ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `()`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `(Bound<usize>, Bound<usize>)`\n   = note:\
    \ required because of the requirements on the impl of `Index<()>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `()`\n  --> /tmp/tmpf2iyck7s.rs:36:29\n\
    \   |\n36 |         while l1[i += 1] == l2[j += 1] {\n   |                   \
    \          ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `()`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `(Bound<usize>, Bound<usize>)`\n\
    \   = note: required because of the requirements on the impl of `Index<()>` for\
    \ `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ index1 = 0..l1.len();\n    let mut index2 = 0..l2.len();\n    let mut swap =\
    \ true;\n    let mut found = false;\n    let mut index = 0;\n    loop {\n    \
    \    while index1 == index2 {\n            index1 += 1;\n            index2 +=\
    \ 1;\n        }\n        if index1 > index2 {\n            while !found && index1\
    \ < index2 {\n                index += 1;\n                if l1.get(index) ==\
    \ l2.get(index) {\n                    found = true;\n                }\n    \
    \            index1 += 1;\n            }\n            if found {\n           \
    \     result.push(l1.get(index));\n            } else {\n                while\
    \ !found && index2 < index1 {\n                    index2 += 1;\n            \
    \        if l1.get(index) == l2.get(index) {\n                        found =\
    \ true;\n                    }\n                }\n                if found {\n\
    \                    result.push(l2.get(index));\n                }\n        \
    \    }\n        } else {\n            while !found && index1 > index2 {\n    \
    \            index += 1;\n                if l1.get(index) == l2.get(index) {\n\
    \                    found = true;\n                }\n                index2\
    \ += 1;\n            }\n            if found {\n                result.push(l1.get(index));\n\
    \            } else {\n                while !found && index2 < index1 {\n   \
    \                 index2 += 1;\n                    if l1.get(index) == l2.get(index)\
    \ {\n                        found = true;\n                    }\n          \
    \      }\n                if found {\n                    result.push(l2.get(index));\n\
    \                }\n            }\n        }\n        if index1 == index2 {\n\
    \            break;\n        }\n        swap = !swap;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `std::ops::Range<usize>`\n  --> /tmp/tmpo5q334tw.rs:15:13\n   |\n15 |      \
    \       index1 += 1;\n   |             ------^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `std::ops::Range<usize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmpo5q334tw.rs:16:13\n   |\n16 |             index2 += 1;\n   |  \
    \           ------^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `std::ops::Range<usize>`\n\nerror[E0369]: binary operation `>` cannot\
    \ be applied to type `std::ops::Range<usize>`\n  --> /tmp/tmpo5q334tw.rs:18:19\n\
    \   |\n18 |         if index1 > index2 {\n   |            ------ ^ ------ std::ops::Range<usize>\n\
    \   |            |\n   |            std::ops::Range<usize>\n\nerror[E0369]: binary\
    \ operation `<` cannot be applied to type `std::ops::Range<usize>`\n  --> /tmp/tmpo5q334tw.rs:19:36\n\
    \   |\n19 |             while !found && index1 < index2 {\n   |              \
    \               ------ ^ ------ std::ops::Range<usize>\n   |                 \
    \            |\n   |                             std::ops::Range<usize>\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmpo5q334tw.rs:24:17\n   |\n24 |                 index1 += 1;\n  \
    \ |                 ------^^^^^\n   |                 |\n   |                \
    \ cannot use `+=` on type `std::ops::Range<usize>`\n\nerror[E0369]: binary operation\
    \ `<` cannot be applied to type `std::ops::Range<usize>`\n  --> /tmp/tmpo5q334tw.rs:29:40\n\
    \   |\n29 |                 while !found && index2 < index1 {\n   |          \
    \                       ------ ^ ------ std::ops::Range<usize>\n   |         \
    \                        |\n   |                                 std::ops::Range<usize>\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmpo5q334tw.rs:30:21\n   |\n30 |                     index2 += 1;\n\
    \   |                     ------^^^^^\n   |                "
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut iter1\
    \ = l1.iter().cloned();\n    let mut iter2 = l2.iter().cloned();\n    let mut\
    \ cur_common: Option<usize> = None;\n    loop {\n        // find next common item\n\
    \        let cur_item = iter1.next()\n            .ok_or_else(|| format!(\"common\
    \ item {} is empty\", l1))\n            .unwrap();\n        let next_item = iter2.next()\n\
    \            .ok_or_else(|| format!(\"common item {} is empty\", l2))\n      \
    \      .unwrap();\n        if cur_item == next_item {\n            continue;\n\
    \        }\n        if cur_common.is_some() {\n            iter1.next_back()\n\
    \                .ok_or_else(|| format!(\"common item {} is empty\", l1))\n  \
    \              .unwrap();\n            iter2.next_back()\n                .ok_or_else(||\
    \ format!(\"common item {} is empty\", l2))\n                .unwrap();\n    \
    \        if cur_common.unwrap() == next_item {\n                continue;\n  \
    \          }\n        }\n        cur_common = Some(next_item);\n        result.push(cur_item);\n\
    \        if cur_item.is_none() {\n            break;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `Vec<isize>` doesn't implement `std::fmt::Display`\n  -->\
    \ /tmp/tmp0ojp3jk3.rs:14:63\n   |\n14 |             .ok_or_else(|| format!(\"\
    common item {} is empty\", l1))\n   |                                        \
    \                       ^^ `Vec<isize>` cannot be formatted with the default formatter\n\
    \   |\n   = help: the trait `std::fmt::Display` is not implemented for `Vec<isize>`\n\
    \   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ `Vec<isize>` doesn't implement `std::fmt::Display`\n  --> /tmp/tmp0ojp3jk3.rs:17:63\n\
    \   |\n17 |             .ok_or_else(|| format!(\"common item {} is empty\", l2))\n\
    \   |                                                               ^^ `Vec<isize>`\
    \ cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `Vec<isize>`\n   = note: in format strings you may be\
    \ able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error\
    \ originates in the macro `$crate::__export::format_args` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0277]: `Vec<isize>` doesn't\
    \ implement `std::fmt::Display`\n  --> /tmp/tmp0ojp3jk3.rs:24:67\n   |\n24 | \
    \                .ok_or_else(|| format!(\"common item {} is empty\", l1))\n  \
    \ |                                                                   ^^ `Vec<isize>`\
    \ cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `Vec<isize>`\n   = note: in format strings you may be\
    \ able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error\
    \ originates in the macro `$crate::__export::format_args` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0277]: `Vec<isize>` doesn't\
    \ implement `std::fmt::Display`\n  --> /tmp/tmp0ojp3jk3.rs:27:67\n   |\n27 | \
    \                .ok_or_else(|| format!(\"common item {} is empty\""
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    (l1..=l2).filter(|&x| l1.iter().any(|y|\
    \ y == x)).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `filter` exists for struct `RangeInclusive<Vec<isize>>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpmclxuj9f.rs:7:15\n \
    \   |\n7   |       (l1..=l2).filter(|&x| l1.iter().any(|y| y == x)).collect()\n\
    \    |                 ^^^^^^ method cannot be called on `RangeInclusive<Vec<isize>>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Step`\n            which is required\
    \ by `RangeInclusive<Vec<isize>>: Iterator`\n            `RangeInclusive<Vec<isize>>:\
    \ Iterator`\n            which is required by `&mut RangeInclusive<Vec<isize>>:\
    \ Iterator`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c = 0;\n    let mut l = l1.len();\n\
    \    let mut m = l2.len();\n\n    let mut result = l1.clone();\n\n    while l\
    \ > 0 && m > 0 {\n        if l[l - 1] > m[m - 1] {\n            c += 1;\n    \
    \        l -= 1;\n        } else {\n            m -= 1;\n        }\n    }\n\n\
    \    while l > 0 {\n        c += 1;\n        l -= 1;\n        result.push(l1[l\
    \ - 1]);\n    }\n\n    while m > 0 {\n        m -= 1;\n        result.push(l2[m\
    \ - 1]);\n    }\n\n    if c > result.len() {\n        result.extend_from_slice(&[0;\
    \ c]);\n    }\n    if m > result.len() {\n        result.extend_from_slice(&[0;\
    \ m]);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpx_chn2ps.rs:34:39\n   |\n7  |     let mut c = 0;\n   |     ---------\
    \ help: consider using `const` instead of `let`: `const c`\n...\n34 |        \
    \ result.extend_from_slice(&[0; c]);\n   |                                   \
    \    ^ non-constant value\n\nerror[E0435]: attempt to use a non-constant value\
    \ in a constant\n  --> /tmp/tmpx_chn2ps.rs:37:39\n   |\n9  |     let mut m = l2.len();\n\
    \   |     --------- help: consider using `const` instead of `let`: `const m`\n\
    ...\n37 |         result.extend_from_slice(&[0; m]);\n   |                   \
    \                    ^ non-constant value\n\nerror[E0608]: cannot index into a\
    \ value of type `usize`\n  --> /tmp/tmpx_chn2ps.rs:14:12\n   |\n14 |         if\
    \ l[l - 1] > m[m - 1] {\n   |            ^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `usize`\n  --> /tmp/tmpx_chn2ps.rs:14:23\n   |\n14 |  \
    \       if l[l - 1] > m[m - 1] {\n   |                       ^^^^^^^^\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0435, E0608.\nFor more information about an error, try `rustc --explain E0435`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    loop {\n        if l1.len() == l2.len()\
    \ {\n            if l1.len() == 0 {\n                return l2;\n            }\n\
    \            if l2.len() == 0 {\n                return l1;\n            }\n \
    \       }\n\n        if l1.len() == 0 {\n            return l2;\n        }\n\n\
    \        if l2.len() == 0 {\n            return l1;\n        }\n\n        let\
    \ mut l3 = l1.clone();\n        l3.remove(&l2[0]);\n        if l3 == l1 {\n  \
    \          return l1;\n        }\n\n        if l3 == l2 {\n            return\
    \ l2;\n        }\n\n        let mut l4 = l2.clone();\n        l4.remove(&l1[0]);\n\
    \        if l4 == l1 {\n            return l1;\n        }\n\n        if l4 ==\
    \ l2 {\n            return l2;\n        }\n\n        let mut l5 = l1.clone();\n\
    \        l5.remove(&l2[0]);\n        l5.remove(&l1[0]);\n        if l5 == l1 {\n\
    \            return l1;\n        }\n\n        if l5 == l2 {\n            return\
    \ l2;\n        }\n\n        let mut l6 = l2.clone();\n        l6.remove(&l1[0]);\n\
    \        l6.remove(&l2[0]);\n        if l6 == l1 {\n            return l1;\n \
    \       }\n\n        if l6 == l2 {\n            return l2;\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaeau2rkm.rs:26:19\n   |\n\
    26 |         l3.remove(&l2[0]);\n   |                   ^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaeau2rkm.rs:36:19\n\
    \   |\n36 |         l4.remove(&l1[0]);\n   |                   ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaeau2rkm.rs:46:19\n\
    \   |\n46 |         l5.remove(&l2[0]);\n   |                   ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaeau2rkm.rs:47:19\n\
    \   |\n47 |         l5.remove(&l1[0]);\n   |                   ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaeau2rkm.rs:57:19\n\
    \   |\n57 |         l6.remove(&l1[0]);\n   |                   ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaeau2rkm.rs:58:19\n\
    \   |\n58 |         l6.remove(&l2[0]);\n   |                   ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror: aborting due to 6 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i1 = l1.iter();\n    let mut i2\
    \ = l2.iter();\n\n    let mut common = vec![0; l1.len()];\n    let mut j = 0;\n\
    \    while i1.next() && i2.next() {\n        if i1.next().unwrap() == i2.next().unwrap()\
    \ {\n            common[j] = i1.next().unwrap();\n            j += 1;\n      \
    \  }\n    }\n    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjh8rv1z.rs:12:11\n   |\n\
    12 |     while i1.next() && i2.next() {\n   |           ^^^^^^^^^ expected `bool`,\
    \ found enum `Option`\n   |\n   = note: expected type `bool`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqjh8rv1z.rs:12:24\n\
    \   |\n12 |     while i1.next() && i2.next() {\n   |                        ^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqjh8rv1z.rs:14:25\n   |\n14 |             common[j] = i1.next().unwrap();\n\
    \   |             ---------   ^^^^^^^^^^^^^^^^^^ expected integer, found `&isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             common[j]\
    \ = *i1.next().unwrap();\n   |                         +\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.iter();\n    l.sort();\n\
    \    let mut l2 = l2.iter();\n    l2.sort();\n    l == l2 ? l1 : l2\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `l1`\n\
    \  --> /tmp/tmpy8_0broa.rs:11:15\n   |\n11 |     l == l2 ? l1 : l2\n   |     \
    \          ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0599]:\
    \ no method named `sort` found for struct `std::slice::Iter` in the current scope\n\
    \ --> /tmp/tmpy8_0broa.rs:8:7\n  |\n8 |     l.sort();\n  |       ^^^^ method not\
    \ found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named `sort`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpy8_0broa.rs:10:8\n\
    \   |\n10 |     l2.sort();\n   |        ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut counts\
    \ = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else {\n            if l1[i]\
    \ < l2[j] {\n                counts[k] =\n                    counts[k] + 1;\n\
    \                k += 1;\n            } else {\n                counts[k] =\n\
    \                    counts[k] - 1;\n                k -= 1;\n            }\n\
    \        }\n    }\n    for i in 0..(res.len() - 1) {\n        if counts[i] >=\
    \ 2 {\n            res.swap(i, i + 1);\n        }\n    }\n    res.sort_unstable();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmpw2jbhe6l.rs:8:22\n\
    \  |\n8 |     let mut counts = vec![];\n  |         ----------   ^^^^^^ cannot\
    \ infer type for type parameter `T`\n  |         |\n  |         consider giving\
    \ `counts` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    \  |\n  = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    debug_assert!(l1.len() >= l2.len());\n\
    \    let mut result = vec![];\n    for i in 0..l1.len() {\n        if l1.len()\
    \ == 0 || l2.len() == 0 {\n            return vec![];\n        }\n\n        if\
    \ l1[l1[i] - 1] < l2[l2[i] - 1] {\n            result.push(l1[i]);\n        }\
    \ else {\n            result.push(l2[i]);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpvsihdicb.rs:14:12\n\
    \   |\n14 |         if l1[l1[i] - 1] < l2[l2[i] - 1] {\n   |            ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpvsihdicb.rs:14:28\n\
    \   |\n14 |         if l1[l1[i] - 1] < l2[l2[i] - 1] {\n   |                 \
    \           ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    use std::cmp::Ordering::*;\n\n    l1.iter().cloned().filter(|&x|\
    \ l2.iter().any(|&y| x == y)).cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering::*`\n --> /tmp/tmpc44tjmai.rs:7:9\n\
    \  |\n7 |     use std::cmp::Ordering::*;\n  |         ^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0271]: type\
    \ mismatch resolving `<std::slice::Iter<'_, isize> as Iterator>::Item == &&_`\n\
    \ --> /tmp/tmpc44tjmai.rs:9:64\n  |\n9 |     l1.iter().cloned().filter(|&x| l2.iter().any(|&y|\
    \ x == y)).cloned().collect()\n  |                                           \
    \                     ^^^^^^ expected reference, found `isize`\n  |\n  = note:\
    \ expected reference `&&_`\n             found reference `&isize`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  = note: 1 redundant requirement hidden\n  = note: required because\
    \ of the requirements on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpc44tjmai.rs:9:31: 9:62]>`\n\nerror[E0631]: type mismatch\
    \ in closure arguments\n --> /tmp/tmpc44tjmai.rs:9:64\n  |\n9 |     l1.iter().cloned().filter(|&x|\
    \ l2.iter().any(|&y| x == y)).cloned().collect()\n  |                        \
    \       -------------------------------  ^^^^^^ expected signature of `for<'r>\
    \ fn(&'r &_) -> _`\n  |                               |\n  |                 \
    \              found signature of `for<'r> fn(&'r isize) -> _`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpc44tjmai.rs:9:31: 9:62]>`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<Filter<Cloned<std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpc44tjmai.rs:9:31: 9:62]>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpc44tjmai.rs:9:73\n   |\n9  |        l1.iter().cloned().filter(|&x|\
    \ l2.iter().any(|&y| x == y)).cloned().collect()\n   |                       \
    \                                                     ^^^^^^^ method cannot be\
    \ called on `Cloned<Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpc44tjmai.rs:9:31:\
    \ 9:62]>>` due to unsatisf"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut d = l1.len() as isize;\n    for\
    \ i in l2.iter().cloned() {\n        if d > l1.len() {\n            return l2;\n\
    \        }\n        let i = i as usize;\n        if l1[d - i] != l2[d - i] {\n\
    \            d = l1.len();\n        }\n    }\n    if d != l1.len() {\n       \
    \ l1.drain(..d);\n    }\n    l1\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpe61u_m02.rs:9:16\n  |\n9 |\
    \         if d > l1.len() {\n  |                ^^^^^^^^ expected `isize`, found\
    \ `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n  |\n9 |         if d > l1.len().try_into().unwrap()\
    \ {\n  |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe61u_m02.rs:13:19\n   |\n13 |         if l1[d - i] != l2[d\
    \ - i] {\n   |                   ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmpe61u_m02.rs:13:17\n   |\n\
    13 |         if l1[d - i] != l2[d - i] {\n   |                 ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpe61u_m02.rs:13:12\n   |\n13 |         if l1[d - i] != l2[d - i]\
    \ {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe61u_m02.rs:13:32\n\
    \   |\n13 |         if l1[d - i] != l2[d - i] {\n   |                        \
    \        ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize`\
    \ from `isize`\n  --> /tmp/tmpe61u_m02.rs:13:30\n   |\n13 |         if l1[d -\
    \ i] != l2[d - i] {\n   |                              ^ no implementation for\
    \ `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not im"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() < l2.len() {\n        l2.iter().cloned().chain(l1.iter().cloned()).filter(|&x|\
    \ l2.iter().any(|&y| *x == *y)).cloned().collect()\n    } else {\n        l1.iter().cloned().chain(l2.iter().cloned()).filter(|&x|\
    \ l1.iter().any(|&y| *x == *y)).cloned().collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmppxgm1va2.rs:8:85\n\
    \  |\n8 |         l2.iter().cloned().chain(l1.iter().cloned()).filter(|&x| l2.iter().any(|&y|\
    \ *x == *y)).cloned().collect()\n  |                                         \
    \                                            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n --> /tmp/tmppxgm1va2.rs:8:91\n  |\n8 |         l2.iter().cloned().chain(l1.iter().cloned()).filter(|&x|\
    \ l2.iter().any(|&y| *x == *y)).cloned().collect()\n  |                      \
    \                                                                     ^^\n\nerror[E0271]:\
    \ type mismatch resolving `<std::slice::Iter<'_, isize> as Iterator>::Item ==\
    \ &&_`\n --> /tmp/tmppxgm1va2.rs:8:96\n  |\n8 |         l2.iter().cloned().chain(l1.iter().cloned()).filter(|&x|\
    \ l2.iter().any(|&y| *x == *y)).cloned().collect()\n  |                      \
    \                                                                          ^^^^^^\
    \ expected reference, found `isize`\n  |\n  = note: expected reference `&&_`\n\
    \             found reference `&isize`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, isize>>`\n  = note:\
    \ 2 redundant requirements hidden\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Filter<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ isize>>, Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmppxgm1va2.rs:8:61:\
    \ 8:94]>`\n\nerror[E0631]: type mismatch in closure arguments\n --> /tmp/tmppxgm1va2.rs:8:96\n\
    \  |\n8 |         l2.iter().cloned().chain(l1.iter().cloned()).filter(|&x| l2.iter().any(|&y|\
    \ *x == *y)).cloned().collect()\n  |                                         \
    \                    ---------------------------------  ^^^^^^ expected signature\
    \ of `for<'r> fn(&'r &_) -> _`\n  |                                          \
    \                   |\n  |                                                   \
    \          found signature of `for<'r> fn(&'r isize) -> _`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Iterator` fo"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return vec![];\n    }\n\n    let mut j = 0;\n\n    let mut l = l1;\n \
    \   let mut h = l2;\n    while j < l1.len() {\n        if h[j] == l {\n      \
    \      l += 1;\n            j += 1;\n        }\n        if h[j] == h[l] {\n  \
    \          h +=1;\n            j += 1;\n            l += 1;\n        }\n    }\n\
    \    return vec![l];\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4cu_pder.rs:16:20\n   |\n\
    16 |         if h[j] == l {\n   |                    ^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct\
    \ `Vec<isize>`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Vec<isize>`\n  --> /tmp/tmp4cu_pder.rs:17:13\n   |\n17 |          \
    \   l += 1;\n   |             -^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `Vec<isize>`\n  --> /tmp/tmp4cu_pder.rs:20:20\n   |\n20 |       \
    \  if h[j] == h[l] {\n   |                    ^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `Vec<isize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Vec<isize>>` for `Vec<isize>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmp4cu_pder.rs:21:13\n\
    \   |\n21 |             h +=1;\n   |             -^^^^\n   |             |\n \
    \  |             cannot use `+=` on type `Vec<isize>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmp4cu_pder.rs:23:13\n\
    \   |\n23 |             l += 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4cu_pder.rs:26:17\n   |\n26 |     return vec![l];\n   |\
    \                 ^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = Vec::with_capacity(l1.len());\n\
    \    let mut i1 = Vec::with_capacity(l1.len());\n    let mut i2 = Vec::with_capacity(l2.len());\n\
    \    let mut c = 0;\n    for i in l1 {\n        if l1.contains(&i) {\n       \
    \     i1.push(i as isize);\n        } else {\n            c += 1;\n        }\n\
    \    }\n    for i in l2 {\n        if l2.contains(&i) {\n            i2.push(i\
    \ as isize);\n        } else {\n            c += 1;\n        }\n    }\n    for\
    \ i in i1 {\n        if l1.contains(&i) {\n            s.push(i);\n        }\n\
    \    }\n    for i in i2 {\n        if l2.contains(&i) {\n            s.push(i);\n\
    \        }\n    }\n    for i in 0..c {\n        s.push(i);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l1`\n   --> /tmp/tmpnrxwmmbx.rs:12:12\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \           -- move occurs because `l1` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n11  |     for i in l1 {\n    |            \
    \  -- `l1` moved due to this implicit call to `.into_iter()`\n12  |         if\
    \ l1.contains(&i) {\n    |            ^^^^^^^^^^^^^^^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `l1`\n    = note: borrow occurs due to deref coercion to `[isize]`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n11  |     for i in &l1 {\n    |              +\n\
    \nerror[E0382]: borrow of moved value: `l2`\n  --> /tmp/tmpnrxwmmbx.rs:19:12\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                         -- move occurs because `l2` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n18 |     for i in l2 {\n   |     \
    \         -- `l2` moved due to this implicit call to `.into_iter()`\n19 |    \
    \     if l2.contains(&i) {\n   |            ^^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n   |\n   = note: borrow occurs due to deref coercion to `[isize]`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n   |\n18 |     for i in &l2 {\n   |              +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize> = Vec::new();\n\
    \    let mut i: usize = 0;\n    for x in l1 {\n        while l1.get(i) == x {\n\
    \            i += 1;\n            if i > l1.len() {\n                break\n \
    \           }\n        }\n        ret.push(x);\n    }\n    for x in l2 {\n   \
    \     while l2.get(i) == x {\n            i += 1;\n            if i > l2.len()\
    \ {\n                break\n            }\n        }\n        ret.push(x);\n \
    \   }\n    ret\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwczjzdn8.rs:10:28\n   |\n\
    10 |         while l1.get(i) == x {\n   |                            ^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwczjzdn8.rs:19:28\n\
    \   |\n19 |         while l2.get(i) == x {\n   |                            ^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut len\
    \ = l1.len();\n    let mut i = 1;\n\n    while i < len {\n        if l1[i] < l2[i]\
    \ {\n            i += 1;\n        } else {\n            if l1[i] == l2[i] {\n\
    \                res.push(l1[i]);\n            }\n\n            i += 1;\n    \
    \    }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp7vuqjey5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize> = Vec::new();\n\
    \    for &x in l1.iter() {\n        if l2.iter().any(|&y| x == y) {\n        \
    \    ret.push(x);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp5w1mp2ck.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(_, c1)|\
    \ c1 == c1).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpwxll2iiw.rs:7:37: 7:55]>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpwxll2iiw.rs:7:57\n     |\n7    |\
    \     l1.iter().zip(l2.iter()).filter(|(_, c1)| c1 == c1).cloned().collect()\n\
    \     |                                                         ^^^^^^ expected\
    \ reference, found tuple\n     |\n     = note: expected reference `&_`\n     \
    \               found tuple `(&isize, &isize)`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpwxll2iiw.rs:7:37: 7:55]>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpwxll2iiw.rs:7:66\n  \
    \ |\n7  |        l1.iter().zip(l2.iter()).filter(|(_, c1)| c1 == c1).cloned().collect()\n\
    \   |                                                                     ^^^^^^^\
    \ method cannot be called on `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpwxll2iiw.rs:7:37: 7:55]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpwxll2iiw.rs:7:37: 7:55]> as Iterator>::Item = &_`\n       \
    \    which is required by `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpwxll2iiw.rs:7:37: 7:55]>>: Iterator`\n           `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpwxll2iiw.rs:7:37: 7:55]>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpwxll2iiw.rs:7:37: 7:55]>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1_len = l1.len();\n    let mut\
    \ l2_len = l2.len();\n    while l1_len > 0 && l2_len > 0 {\n        let l1 = l1[0];\n\
    \        let l2 = l2[0];\n        if l1 < l2 {\n            l1 = l1 - l2;\n  \
    \          l1_len -= 1;\n        } else {\n            l2 = l2 - l1;\n       \
    \     l2_len -= 1;\n        }\n    }\n    l1.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `l1` is never read\n  --> /tmp/tmp1uhvcl5_.rs:13:13\n\
    \   |\n13 |             l1 = l1 - l2;\n   |             ^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `l2` is never read\n  --> /tmp/tmp1uhvcl5_.rs:16:13\n   |\n\
    16 |             l2 = l2 - l1;\n   |             ^^\n   |\n   = help: maybe it\
    \ is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `l1`\n  --> /tmp/tmp1uhvcl5_.rs:13:13\n   |\n10 |         let l1 =\
    \ l1[0];\n   |             --\n   |             |\n   |             first assignment\
    \ to `l1`\n   |             help: consider making this binding mutable: `mut l1`\n\
    ...\n13 |             l1 = l1 - l2;\n   |             ^^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `l2`\n  --> /tmp/tmp1uhvcl5_.rs:16:13\n   |\n11 |         let l2 =\
    \ l2[0];\n   |             --\n   |             |\n   |             first assignment\
    \ to `l2`\n   |             help: consider making this binding mutable: `mut l2`\n\
    ...\n16 |             l2 = l2 - l1;\n   |             ^^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror: aborting due to 2 previous errors; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  let mut l: Vec<isize> = l1.clone();\n    let mut m: Vec<isize> = l2.clone();\n\
    \    let mut res = vec![l.len()];\n\n    loop {\n        match (&l[i], &m[j])\
    \ {\n            (_, 0) | _ => break,\n            (&x, &y) if x == y => res.push(x\
    \ + 1),\n            (&x, &y) if x > y => {\n                if i < *res.len()\
    \ {\n                    res.push(l[i])\n                }\n                i\
    \ += 1;\n                j += 1;\n            },\n            _ => {\n       \
    \         if j < m[j].len() {\n                    res.push(m[j])\n          \
    \      }\n                j += 1;\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw3fn7phu.rs:16:44\n   |\n\
    16 |             (&x, &y) if x == y => res.push(x + 1),\n   |                \
    \                            ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n16 |             (&x, &y) if x == y => res.push((x + 1).try_into().unwrap()),\n\
    \   |                                            +     +++++++++++++++++++++\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpw3fn7phu.rs:18:24\n\
    \   |\n18 |                 if i < *res.len() {\n   |                        ^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw3fn7phu.rs:19:30\n   |\n19 |\
    \                     res.push(l[i])\n   |                              ^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |                   \
    \  res.push(l[i].try_into().unwrap())\n   |                                  ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpw3fn7phu.rs:25:29\n   |\n25 |                 if j < m[j].len()\
    \ {\n   |                             ^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw3fn7phu.rs:26:30\n   |\n26 |              \
    \       res.push(m[j])\n   |                              ^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n26 |                     res.push(m[j].try_into().unwrap())\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw3fn7phu.rs:32:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n32 |  \
    \   res\n   |     ^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1: Vec<isize> = l1.into_iter().cloned().collect();\n\
    \    let mut l2: Vec<isize> = l2.into_iter().cloned().collect();\n    l1.sort();\n\
    \    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().zip(l2.iter()).filter(|&(x,\
    \ &y)| *x != *y).collect()\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpfepgbppu.rs:7:45\n     |\n7    |     let mut l1: Vec<isize>\
    \ = l1.into_iter().cloned().collect();\n     |                               \
    \              ^^^^^^ expected reference, found `isize`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `isize`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpfepgbppu.rs:7:54\n   |\n7  |       let mut l1: Vec<isize> = l1.into_iter().cloned().collect();\n\
    \   |                                                        ^^^^^^^ method cannot\
    \ be called on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpfepgbppu.rs:8:45\n     |\n8    |     let mut l2: Vec<isize>\
    \ = l2.into_iter().cloned().collect();\n     |                               \
    \              ^^^^^^ expected reference, found `isize`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `isize`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpfepgbppu.rs:8:54\n   |\n8  |       let mut l2: Vec<isize> = l2.into_iter().cloned().collect();\n\
    \   |                                                        ^^^^^^^ method cannot\
    \ be called on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n   "
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return vec![];\n    }\n\n    let mut l1 = l1.iter().cloned().collect();\n\
    \    let mut l2 = l2.iter().cloned().collect();\n\n    let mut res = vec![];\n\
    \n    while l1.len() != 0 || l2.len() != 0 {\n        let len = (l1.len() + l2.len())\
    \ / 2;\n        if l1.len() < l2.len() {\n            l1 = &l1[0..len];\n    \
    \    } else if l2.len() < l1.len() {\n            l2 = &l2[0..len];\n        }\
    \ else {\n            if l1.len() == l2.len() {\n                while l1.len()\
    \ != 0 {\n                    let e1 = l1.remove(0)\n                        .cloned()\n\
    \                        .collect();\n                    if !l2.contains(&e1)\
    \ {\n                        res.push(e1);\n                    }\n          \
    \      }\n                while l2.len() != 0 {\n                    let e2 =\
    \ l2.remove(0)\n                        .cloned()\n                        .collect();\n\
    \                    if !l1.contains(&e2) {\n                        res.push(e2);\n\
    \                    }\n                }\n            } else {\n            \
    \    while l1.len() != 0 {\n                    let e1 = l1.remove(0)\n      \
    \                  .cloned()\n                        .collect();\n          \
    \          if !l2.contains(&e1) {\n                        res.push(e1);\n   \
    \                 }\n                }\n                while l2.len() != 0 {\n\
    \                    let e2 = l2.remove(0)\n                        .cloned()\n\
    \                        .collect();\n                    if !l1.contains(&e2)\
    \ {\n                        res.push(e2);\n                    }\n          \
    \      }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpx157bd6a.rs:16:11\n\
    \   |\n11 |     let mut l1 = l1.iter().cloned().collect();\n   |         ------\
    \ consider giving `l1` a type\n...\n16 |     while l1.len() != 0 || l2.len() !=\
    \ 0 {\n   |           ^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = vec![];\n    let mut j = 0;\n\
    \    while j < l1.len() && j < l2.len() {\n        if l1[j] == l2[j] {\n     \
    \       s.pushl1[j];\n            j += 1;\n        } else {\n            s.pushl2[j];\n\
    \            j += 1;\n        }\n    }\n    vec!s\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `s`\n  --> /tmp/tmpd6wnsk8o.rs:18:9\n\
    \   |\n18 |     vec!s\n   |         ^ expected one of `(`, `[`, or `{`\n\nerror[E0609]:\
    \ no field `pushl1` on type `Vec<_>`\n  --> /tmp/tmpd6wnsk8o.rs:11:15\n   |\n\
    11 |             s.pushl1[j];\n   |               ^^^^^^ unknown field\n\nerror[E0609]:\
    \ no field `pushl2` on type `Vec<_>`\n  --> /tmp/tmpd6wnsk8o.rs:14:15\n   |\n\
    14 |             s.pushl2[j];\n   |               ^^^^^^ unknown field\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    loop {\n      \
    \  let mut i = 0;\n        let mut j = 0;\n        for (i, j) in l1.iter().zip(l2.iter())\
    \ {\n            if i >= j {\n                l1.swap(i, j);\n               \
    \ break;\n            }\n        }\n        for (i, j) in l2.iter().zip(l1.iter())\
    \ {\n            if i >= j {\n                l2.swap(i, j);\n               \
    \ break;\n            }\n        }\n        if i == 0 {\n            break;\n\
    \        }\n    }\n    l1.to_owned()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplp2soue9.rs:14:25\n   |\n\
    14 |                 l1.swap(i, j);\n   |                         ^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp2soue9.rs:14:28\n\
    \   |\n14 |                 l1.swap(i, j);\n   |                            ^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp2soue9.rs:20:25\n\
    \   |\n20 |                 l2.swap(i, j);\n   |                         ^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp2soue9.rs:20:28\n\
    \   |\n20 |                 l2.swap(i, j);\n   |                            ^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common = Vec::new();\n    let mut\
    \ i = 1;\n    let mut j = 1;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] < l2[j] {\n            common.push(*i);\n            i += 1;\n  \
    \      } else {\n            common.push(*j);\n            i += 1;\n         \
    \   j += 1;\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpzdw0fjwa.rs:12:25\n\
    \   |\n12 |             common.push(*i);\n   |                         ^^\n\n\
    error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpzdw0fjwa.rs:15:25\n\
    \   |\n15 |             common.push(*j);\n   |                         ^^\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(_, l2)|\
    \ l2 != 0).map(|(_, l1)| l1).collect()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&isize` with `{integer}`\n --> /tmp/tmpxwal2rjd.rs:7:50\n\
    \  |\n7 |     l1.iter().zip(l2.iter()).filter(|(_, l2)| l2 != 0).map(|(_, l1)|\
    \ l1).collect()\n  |                                                  ^^ no implementation\
    \ for `&&isize == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&isize`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmpxwal2rjd.rs:7:74\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|(_, l2)| l2 != 0).map(|(_,\
    \ l1)| l1).collect()\n     |                                                 \
    \                         ^^^^^^^ value of type `Vec<isize>` cannot be built from\
    \ `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1.iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut v2 = l2.iter().cloned().collect::<Vec<isize>>();\n    while v1.len()\
    \ > 0 && v2.len() > 0 {\n        if v1[0] < v2[0] {\n            v1.pop();\n \
    \       } else {\n            v2.pop();\n        }\n    }\n    v1.extend(v2).cloned()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpbmzchbgv.rs:16:19\n\
    \   |\n16 |     v1.extend(v2).cloned()\n   |                   ^^^^^^ `()` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    result.extend_from_slice(l1.iter().cloned().collect::<Vec<_>>());\n\
    \    result.extend_from_slice(l2.iter().cloned().collect::<Vec<_>>());\n    result.sort();\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnf0t5319.rs:8:30\n  |\n8 |\
    \     result.extend_from_slice(l1.iter().cloned().collect::<Vec<_>>());\n  | \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |    \
    \                          |\n  |                              expected `&[_]`,\
    \ found struct `Vec`\n  |                              help: consider borrowing\
    \ here: `&l1.iter().cloned().collect::<Vec<_>>()`\n  |\n  = note: expected reference\
    \ `&[_]`\n                found struct `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpnf0t5319.rs:9:30\n  |\n9 |     result.extend_from_slice(l2.iter().cloned().collect::<Vec<_>>());\n\
    \  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\
    \                              |\n  |                              expected `&[_]`,\
    \ found struct `Vec`\n  |                              help: consider borrowing\
    \ here: `&l2.iter().cloned().collect::<Vec<_>>()`\n  |\n  = note: expected reference\
    \ `&[_]`\n                found struct `Vec<isize>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut iter1: iter::Peekable<Vec<isize>>\
    \ = l1.iter();\n    let mut iter2: iter::Peekable<Vec<isize>> = l2.iter();\n \
    \   let mut iter1_next = iter1.peekable();\n    let mut iter2_next = iter2.peekable();\n\
    \    let mut res: Vec<isize>;\n    loop {\n        let mut res: Vec<isize>;\n\
    \        let mut l1 = iter1_next.peekable();\n        let mut l2 = iter2_next.peekable();\n\
    \        if l1.is_none() && l2.is_none() {\n            break;\n        }\n  \
    \      if l1.is_none() {\n            iter1_next = iter1.next();\n           \
    \ l1 = iter1_next.peekable();\n            if l1.is_none() {\n               \
    \ break;\n            }\n        }\n        if l2.is_none() {\n            iter2_next\
    \ = iter2.next();\n            l2 = iter2_next.peekable();\n            if l2.is_none()\
    \ {\n                break;\n            }\n        }\n        let l1 = l1.as_ref().unwrap();\n\
    \        let l2 = l2.as_ref().unwrap();\n        let mut common_elems = iter1\n\
    \            .next()\n            .unwrap()\n            .iter()\n           \
    \ .zip(iter2.next().unwrap().iter())\n            .filter(|&(x, &y)| x == y)\n\
    \            .collect();\n        res.extend(common_elems.clone());\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `iter`\n\
    \ --> /tmp/tmpjlyu_iun.rs:7:20\n  |\n7 |     let mut iter1: iter::Peekable<Vec<isize>>\
    \ = l1.iter();\n  |                    ^^^^ use of undeclared crate or module\
    \ `iter`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `iter`\n --> /tmp/tmpjlyu_iun.rs:8:20\n  |\n8 |     let mut iter2: iter::Peekable<Vec<isize>>\
    \ = l2.iter();\n  |                    ^^^^ use of undeclared crate or module\
    \ `iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    loop {\n        let mut it1 = l1.iter().cloned().peekable();\n\
    \        let mut it2 = l2.iter().cloned().peekable();\n        assert!(it1.peek()\
    \ != it2.peek());\n        if it1.peek() == it2.peek() {\n            it1.next();\n\
    \            it2.next();\n        }\n\n        if it1.peek().is_none() || it2.peek().is_none()\
    \ {\n            return vec![];\n        }\n\n        if it1.peek().unwrap() ==\
    \ it2.peek().unwrap() {\n            l1.remove();\n            l2.remove();\n\
    \        }\n        else {\n            return vec![];\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp33jx_8sn.rs:21:16\n     |\n21   |             l1.remove();\n\
    \     |                ^^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmp33jx_8sn.rs:22:16\n     |\n22   |           \
    \  l2.remove();\n     |                ^^^^^^- supplied 0 arguments\n     |  \
    \              |\n     |                expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1;\n    let mut it =\
    \ l2.iter();\n\n    while let Some(item) = it.next() {\n        if result.contains(item)\
    \ {\n            result.remove(item);\n        } else {\n            result +=\
    \ &[item];\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8c9k0o7a.rs:12:27\n   |\n\
    12 |             result.remove(item);\n   |                           ^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `Vec<isize>`\n  --> /tmp/tmp8c9k0o7a.rs:14:13\n   |\n14 |\
    \             result += &[item];\n   |             ------^^^^^^^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = l1.iter().cloned();\n    i.sort_unstable();\n\
    \    let mut j = l2.iter().cloned();\n    j.sort_unstable();\n    let mut uv =\
    \ Vec::new();\n    while i != j {\n        match i.next().cmp(&j.next().unwrap())\
    \ {\n            Less    => continue,\n            Equal   => uv.push(i.pop()),\n\
    \            Greater => j.pop(),\n        }\n    }\n    uv\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_unstable` found for struct `Cloned`\
    \ in the current scope\n --> /tmp/tmpqdwb5lu1.rs:8:7\n  |\n8 |     i.sort_unstable();\n\
    \  |       ^^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0599]: no method named `sort_unstable` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpqdwb5lu1.rs:10:7\n   |\n10 |     j.sort_unstable();\n\
    \   |       ^^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0369]: binary operation `!=` cannot be applied to type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmpqdwb5lu1.rs:12:13\n   |\n12 |     while i != j {\n \
    \  |           - ^^ - Cloned<std::slice::Iter<'_, isize>>\n   |           |\n\
    \   |           Cloned<std::slice::Iter<'_, isize>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqdwb5lu1.rs:13:28\n   |\n13 |         match i.next().cmp(&j.next().unwrap())\
    \ {\n   |                            ^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected reference `&Option<isize>`\n      \
    \        found reference `&isize`\n\nerror[E0599]: no method named `pop` found\
    \ for struct `Cloned` in the current scope\n  --> /tmp/tmpqdwb5lu1.rs:15:34\n\
    \   |\n15 |             Equal   => uv.push(i.pop()),\n   |                   \
    \               ^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0599]: no method named `pop` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpqdwb5lu1.rs:16:26\n   |\n16 |             Greater => j.pop(),\n\
    \   |                          ^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().collect::<Vec<_>>();\n    l1.sort_unstable();\n  \
    \  l2.sort_unstable();\n    let mut i = 0;\n    let mut j = l1.len();\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            i +=\
    \ 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    l2.truncate(j);\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpga9cclhf.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     l1\n   |     ^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut lcs = Vec::new();\n    let mut\
    \ len1 = l1.len();\n    let mut len2 = l2.len();\n\n    let mut i = 0;\n    let\
    \ mut j = 0;\n\n    while i < len1 && j < len2 {\n        if l1[i] == l2[j] {\n\
    \            lcs.push(l1[i]);\n            i += 1;\n            i += 1;\n    \
    \        j += 1;\n        } else {\n            if l1[i] < l2[j] {\n         \
    \       i += 1;\n            } else {\n                j += 1;\n            }\n\
    \        }\n    }\n\n    match i < len1 {\n        true => {\n            lcs.extend(l1[..i]);\n\
    \            lcs.extend(l2[..j]);\n            lcs\n        }\n        false =>\
    \ lcs.extend(l1[..len1]),\n    }\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n   --> /tmp/tmpn5er3pm2.rs:31:24\n    |\n31  |           \
    \  lcs.extend(l1[..i]);\n    |                 ------ ^^^^^^^ doesn't have a size\
    \ known at compile-time\n    |                 |\n    |                 required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `[isize]`\nnote: required by a bound in `extend`\n\nerror[E0277]:\
    \ `[isize]` is not an iterator\n   --> /tmp/tmpn5er3pm2.rs:31:24\n    |\n31  |\
    \             lcs.extend(l1[..i]);\n    |                 ------ ^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n    |                 |\n    |     \
    \            required by a bound introduced by this call\n    |\n    = note: the\
    \ trait bound `[isize]: IntoIterator` is not satisfied\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `[isize]`\nnote: required\
    \ by a bound in `extend`\nhelp: consider borrowing here\n    |\n31  |        \
    \     lcs.extend(&l1[..i]);\n    |                        +\n31  |           \
    \  lcs.extend(&mut l1[..i]);\n    |                        ++++\n\nerror[E0277]:\
    \ the size for values of type `[isize]` cannot be known at compilation time\n\
    \   --> /tmp/tmpn5er3pm2.rs:32:24\n    |\n32  |             lcs.extend(l2[..j]);\n\
    \    |                 ------ ^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                 |\n    |                 required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `[isize]`\n\
    note: required by a bound in `extend`\n\nerror[E0277]: `[isize]` is not an iterator\n\
    \   --> /tmp/tmpn5er3pm2.rs:32:24\n    |\n32  |             lcs.extend(l2[..j]);\n\
    \    |                 ------ ^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \    |                 |\n    |                 required by a bound introduced\
    \ by this call\n    |\n    = note: the trait bound `[isize]: IntoIterator` is\
    \ not satisfied\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `[isize]`\nnote: requ"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = vec![0; l1.len()];\n    let\
    \ mut i = Vec::new();\n    for &x in l1 {\n        if !s2.contains(&x) {\n   \
    \         s.push(x);\n            i.push(i);\n        }\n    }\n    let mut j\
    \ = Vec::new();\n    for &x in l2 {\n        if !s1.contains(&x) {\n         \
    \   j.push(x);\n        }\n    }\n    let mut result = Vec::new();\n    for i\
    \ in i {\n        for j in j {\n            if s.iter().zip(j.iter()).all(|(a,b)|\
    \ a == b) {\n                result.push(*i);\n                break;\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `s2` in this scope\n  --> /tmp/tmp04wrrajh.rs:10:13\n\
    \   |\n10 |         if !s2.contains(&x) {\n   |             ^^ help: a local variable\
    \ with a similar name exists: `l2`\n\nerror[E0425]: cannot find value `s1` in\
    \ this scope\n  --> /tmp/tmp04wrrajh.rs:17:13\n   |\n17 |         if !s1.contains(&x)\
    \ {\n   |             ^^ help: a local variable with a similar name exists: `l1`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp04wrrajh.rs:9:9\n  |\n9 |     for\
    \ &x in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `x`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp04wrrajh.rs:12:20\n   |\n12 |             i.push(i);\n   |    \
    \                ^- help: try using a conversion method: `.to_vec()`\n   |   \
    \                 |\n   |                    cyclic type of infinite size\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp04wrrajh.rs:16:9\n   |\n16 |   \
    \  for &x in l2 {\n   |         ^^    -- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1_hash_set = HashSet::new();\n\
    \    for elt in l1.iter() {\n        l1_hash_set.insert(elt);\n    }\n    let\
    \ mut l2_hash_set = HashSet::new();\n    for elt in l2.iter() {\n        l2_hash_set.insert(elt);\n\
    \    }\n    l2.iter().filter(|&elt| !l1_hash_set.contains(elt)).collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpab6auwe_.rs:7:27\n  |\n7 |     let mut l1_hash_set = HashSet::new();\n\
    \  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpab6auwe_.rs:11:27\n\
    \   |\n11 |     let mut l2_hash_set = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmpab6auwe_.rs:15:57\n     |\n15   |     l2.iter().filter(|&elt|\
    \ !l1_hash_set.contains(elt)).collect()\n     |                              \
    \                           ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip2(l2.iter(), |&i, &j| i +\
    \ j).filter(|&(i, _)| i != 0).collect()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `zip2` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmppakrgfyx.rs:7:15\n  |\n7 |     l1.iter().zip2(l2.iter(),\
    \ |&i, &j| i + j).filter(|&(i, _)| i != 0).collect()\n  |               ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in\
    \ 0..(l1.len()) {\n        let mut found = false;\n        for j in 0..(l2.len())\
    \ {\n            if l1[i] == l2[j] {\n                found = true;\n        \
    \        break;\n            }\n        }\n        if !found {\n            result.push(l1[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpf86htom8.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter()\n        .zip(l2.iter())\n  \
    \      .filter(|(&a, &b)| a != b)\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmp9eollw_j.rs:10:10\n\
    \     |\n10   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n     |\n\
    \     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut uset = HashSet::new();\n    let\
    \ mut iset1 = HashSet::new();\n    let mut iset2 = HashSet::new();\n    let mut\
    \ iset3 = HashSet::new();\n    let mut iset4 = HashSet::new();\n\n    for e in\
    \ l1 {\n        uset.insert(e);\n        if !iset1.insert(e).unwrap() {\n    \
    \        iset1.remove(e);\n        }\n    }\n    for e in l2 {\n        uset.insert(e);\n\
    \        if !iset2.insert(e).unwrap() {\n            iset2.remove(e);\n      \
    \  }\n    }\n    for e in iset1 & iset2 {\n        uset.insert(e);\n    }\n  \
    \  for e in iset1 & iset3 {\n        uset.insert(e);\n    }\n    for e in iset3\
    \ & iset4 {\n        uset.insert(e);\n    }\n    if !iset3.is_empty() && !iset4.is_empty()\
    \ {\n        for i in iset1 & iset2 {\n            if !uset.contains(&i) {\n \
    \               uset.insert(i);\n            }\n        }\n        for i in iset1\
    \ & iset4 {\n            if !uset.contains(&i) {\n                uset.insert(i);\n\
    \            }\n        }\n        for i in iset3 & iset4 {\n            if !uset.contains(&i)\
    \ {\n                uset.insert(i);\n            }\n        }\n    }\n    uset.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpe1vxro5g.rs:7:20\n  |\n7 |     let mut uset = HashSet::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpe1vxro5g.rs:8:21\n\
    \  |\n8 |     let mut iset1 = HashSet::new();\n  |                     ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmpe1vxro5g.rs:9:21\n  |\n9 |     let\
    \ mut iset2 = HashSet::new();\n  |                     ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpe1vxro5g.rs:10:21\n   |\n10 |     let mut iset3 = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpe1vxro5g.rs:11:21\n\
    \   |\n11 |     let mut iset4 = HashSet::new();\n   |                     ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = Vec::new();\n    for i in l1.iter()\
    \ {\n        if l2.iter().any(|&j| i == j) {\n            s.push(i);\n       \
    \ }\n    }\n    s\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmp7f6yzjaw.rs:9:33\n\
    \  |\n9 |         if l2.iter().any(|&j| i == j) {\n  |                       \
    \          ^^ no implementation for `&isize == isize`\n  |\n  = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n  = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n            f32\n           \
    \ f64\n            i128\n            i16\n            i32\n            i64\n \
    \           i8\n            isize\n          and 6 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7f6yzjaw.rs:13:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n13 |  \
    \   s\n   |     ^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set = l1.clone();\n    set.sort();\n\
    \    let mut ret = l2.clone();\n    let mut i = 0;\n    while i < set.len() {\n\
    \        if ret[i] == set[i] {\n            i += 1;\n        } else {\n      \
    \      let j = i;\n            while j > 0 && !ret[j-1] == set[j] {\n        \
    \        j -= 1;\n            }\n            ret = ret[j..];\n            i +=\
    \ 1;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppegqcm_d.rs:19:19\n   |\n\
    9  |     let mut ret = l2.clone();\n   |                   ---------- expected\
    \ due to this value\n...\n19 |             ret = ret[j..];\n   |             \
    \      ^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |      \
    \             |\n   |                   expected struct `Vec`, found slice `[isize]`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    loop {\n\
    \        let idx = l3.iter().position(|x| *x == l2[0]).unwrap();\n        if idx\
    \ < l3.len() {\n            l3.remove(idx);\n            l3.push(l2[0]);\n   \
    \         return l3;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        l3.push(l2[0]);\n        l2.pop();\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l2` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmplumk2rxk.rs:19:9\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                           -- help: consider changing this\
    \ to be mutable: `mut l2`\n...\n19 |         l2.pop();\n   |         ^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut iter = l1.iter();\n    let mut\
    \ it = l2.iter();\n    let mut common = Vec::new();\n    if iter.is_empty() {\n\
    \        common.extend(l2.iter());\n    } else {\n        common.extend(iter.next().unwrap());\n\
    \    }\n\n    let mut next = it.next();\n    while !next.is_none() {\n       \
    \ common.extend(next.unwrap());\n        next = it.next();\n    }\n    common\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'exact_size_is_empty'\n \
    \ --> /tmp/tmpqky5k066.rs:10:13\n   |\n10 |     if iter.is_empty() {\n   |   \
    \          ^^^^^^^^\n   |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror[E0277]: `&isize` is not an iterator\n   --> /tmp/tmpqky5k066.rs:13:23\n\
    \    |\n13  |         common.extend(iter.next().unwrap());\n    |            \
    \    ------ ^^^^^^^^^^^^^^^^^^^^ `&isize` is not an iterator\n    |          \
    \      |\n    |                required by a bound introduced by this call\n \
    \   |\n    = help: the trait `Iterator` is not implemented for `&isize`\n    =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&isize`\nnote: required by a bound in `extend`\n\nerror[E0277]: `&isize` is\
    \ not an iterator\n   --> /tmp/tmpqky5k066.rs:18:23\n    |\n18  |         common.extend(next.unwrap());\n\
    \    |                ------ ^^^^^^^^^^^^^ `&isize` is not an iterator\n    |\
    \                |\n    |                required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `Iterator` is not implemented for `&isize`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&isize`\nnote: required by a bound in `extend`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0658.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut sorted_l1 = l1.iter().cloned().sorted();\n\
    \    let mut sorted_l2 = l2.iter().cloned().sorted();\n\n    loop {\n        if\
    \ sorted_l1.next().unwrap() < sorted_l2.next().unwrap() {\n            break\n\
    \        }\n        if sorted_l1.next().unwrap() > sorted_l2.next().unwrap() {\n\
    \            sorted_l1.next();\n            sorted_l2.next();\n        }\n   \
    \ }\n    sorted_l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmpsmm5xvb4.rs:7:44\n  |\n7 |     let mut sorted_l1\
    \ = l1.iter().cloned().sorted();\n  |                                        \
    \    ^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Cloned` in the current scope\n -->\
    \ /tmp/tmpsmm5xvb4.rs:8:44\n  |\n8 |     let mut sorted_l2 = l2.iter().cloned().sorted();\n\
    \  |                                            ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    (l1, l2).sort_by_key(|&a| a.clone()).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for tuple `(Vec<isize>,\
    \ Vec<isize>)` in the current scope\n --> /tmp/tmp6sxx7pgh.rs:7:14\n  |\n7 | \
    \    (l1, l2).sort_by_key(|&a| a.clone()).collect()\n  |              ^^^^^^^^^^^\
    \ method not found in `(Vec<isize>, Vec<isize>)`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = Vec::new();\n    let mut k\
    \ = l1.len();\n    while k != 0 {\n        let mut i = 0;\n        while i < k\
    \ {\n            if l1[i] == l2[i] {\n                i += 1;\n              \
    \  continue;\n            }\n            if l1[i] < l2[i] {\n                break;\n\
    \            }\n            s.push(l1[i]);\n            i += 1;\n        }\n \
    \       k /= 2;\n    }\n    s[..]\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8xk9mh7p.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     s[..]\n   |     ^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |     |\n   |     expected struct `Vec`, found slice\
    \ `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n               found\
    \ slice `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() < l2.len() {\n        let mut\
    \ r = l2;\n        r.extend(l1.iter().filter(|&x| l1.contains(&x)));\n       \
    \ r\n    } else {\n        let mut r = l1;\n        r.extend(l2.iter().filter(|&x|\
    \ l2.contains(&x)));\n        r\n    }\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 5, 7, 1, 5, 9, 653, 121]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpox4fz0ju.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() {\n        vec![]\n\
    \    }\n    let mut result = vec![];\n    for &x in l1.iter() {\n        if l2.iter().any(|&y|\
    \ x == y) {\n            result.push(x);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5ytg4l79.rs:8:9\n  |\n7 |\
    \ /     if l1.len() != l2.len() {\n8 | |         vec![]\n  | |         ^^^^^^\
    \ expected `()`, found struct `Vec`\n9 | |     }\n  | |_____- expected this to\
    \ be `()`\n  |\n  = note: expected unit type `()`\n                found struct\
    \ `Vec<_>`\n  = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\nhelp: consider using a semicolon\
    \ here\n  |\n9 |     };\n  |      +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    use std::cmp::Ordering;\n    let mut common:\
    \ Vec<isize> = l1.clone();\n    let mut l1: Vec<isize> = l1.to_vec();\n    let\
    \ mut l2: Vec<isize> = l2.to_vec();\n    let mut len1 = l1.len();\n    let mut\
    \ len2 = l2.len();\n    let mut last: usize = 0;\n    while len1 != 0 || len2\
    \ != 0 {\n        if len1 == 0 || len2 == 0 {\n            break;\n        }\n\
    \        let cmp = l1[last]\n            .cmp(&l2[last])\n            .unwrap_or_else(Ordering::Less);\n\
    \        if cmp == Ordering::Less {\n            last = last + 1;\n          \
    \  if last == len1 {\n                common = common.to_vec();\n            \
    \    len1 = len1 - 1;\n            }\n        } else {\n            last = last\
    \ + 1;\n            if last == len2 {\n                common = common.to_vec();\n\
    \                len2 = len2 - 1;\n            }\n        }\n    }\n    common\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or_else` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmp843cenjn.rs:20:14\n   |\n20 |          \
    \   .unwrap_or_else(Ordering::Less);\n   |              ^^^^^^^^^^^^^^ method\
    \ not found in `std::cmp::Ordering`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut lc = vec![];\n    for &x in l1\
    \ {\n        if l2.iter().any(|&y| x == y) {\n            lc.push(x);\n      \
    \  }\n    }\n    lc\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7wcat_2s.rs:8:9\n  |\n8 |\
    \     for &x in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `x`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    vec!(l1.iter().cloned().filter(|x| l2.iter().any(|y|\
    \ x == y)).cloned().collect())\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n --> /tmp/tmps_7_ijqt.rs:7:67\n  |\n7 |     vec!(l1.iter().cloned().filter(|x|\
    \ l2.iter().any(|y| x == y)).cloned().collect())\n  |                        \
    \                                           ^^^^^^ expected reference, found `isize`\n\
    \  |\n  = note: expected reference `&&_`\n             found reference `&isize`\n\
    \  = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\n  = note: 1 redundant requirement hidden\n\
    \  = note: required because of the requirements on the impl of `Iterator` for\
    \ `Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmps_7_ijqt.rs:7:36:\
    \ 7:65]>`\n\nerror[E0631]: type mismatch in closure arguments\n --> /tmp/tmps_7_ijqt.rs:7:67\n\
    \  |\n7 |     vec!(l1.iter().cloned().filter(|x| l2.iter().any(|y| x == y)).cloned().collect())\n\
    \  |                                    -----------------------------  ^^^^^^\
    \ expected signature of `for<'r> fn(&'r &_) -> _`\n  |                       \
    \             |\n  |                                    found signature of `for<'r>\
    \ fn(&'r isize) -> _`\n  |\n  = note: required because of the requirements on\
    \ the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmps_7_ijqt.rs:7:36:\
    \ 7:65]>`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmps_7_ijqt.rs:7:36: 7:65]>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmps_7_ijqt.rs:7:76\n   |\n7  |        vec!(l1.iter().cloned().filter(|x|\
    \ l2.iter().any(|y| x == y)).cloned().collect())\n   |                       \
    \                                                        ^^^^^^^ method cannot\
    \ be called on `Cloned<Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmps_7_ijqt.rs:7:36:\
    \ 7:65]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmps_7_ijqt.rs:7:36: 7:"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    while\
    \ l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            result.push(*l2);\n\
    \            l2.clear();\n        } else if l2.len() == 0 {\n            result.push(*l1);\n\
    \            l1.clear();\n        } else {\n            if *l1 == *l2 {\n    \
    \            l1.pop();\n                l2.pop();\n            } else if *l1 >\
    \ *l2 {\n                l1.pop();\n            } else {\n                l2.pop();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n   --> /tmp/tmp7b5k8np2.rs:10:25\n    |\n10  |           \
    \  result.push(*l2);\n    |                    ---- ^^^ doesn't have a size known\
    \ at compile-time\n    |                    |\n    |                    required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `[isize]`\nnote: required by a bound in `Vec::<T, A>::push`\n\
    \nerror[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n   --> /tmp/tmp7b5k8np2.rs:7:22\n    |\n7   |     let mut result = Vec::new();\n\
    \    |                      ^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `[isize]`\nnote:\
    \ required by a bound in `Vec::<T>::new`\n\nerror[E0277]: the size for values\
    \ of type `[isize]` cannot be known at compilation time\n   --> /tmp/tmp7b5k8np2.rs:7:22\n\
    \    |\n7   |     let mut result = Vec::new();\n    |                      ^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `[isize]`\nnote: required by a bound in `Vec`\n\nerror[E0599]:\
    \ the method `push` exists for struct `Vec<[isize]>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmp7b5k8np2.rs:13:20\n   |\n13 |             result.push(*l1);\n\
    \   |                    ^^^^ method cannot be called on `Vec<[isize]>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `[isize]: Sized`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7b5k8np2.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found slice `[isize]`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<[isize]>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more informat"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() {\n        return\
    \ vec![];\n    }\n    let mut res = Vec::with_capacity(l1.len());\n    let mut\
    \ u: usize = 0;\n    let mut v1: Vec<isize> = l1.iter().cloned().collect();\n\
    \    let mut v2: Vec<isize> = l2.iter().cloned().collect();\n    while u < v1.len()\
    \ && v2 < v2.len() {\n        if v1[u] == v2[u] {\n            u += 1;\n     \
    \       v2.remove(v2.iter().cloned().nth(u));\n        }\n        else {\n   \
    \         u += 1;\n            res.push(v1[u]);\n        }\n    }\n    res.extend(v1.drain(..));\n\
    \    res.extend(v2.drain(..));\n    res\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpktgyk0hm.rs:14:32\n   |\n\
    14 |     while u < v1.len() && v2 < v2.len() {\n   |                         \
    \       ^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpktgyk0hm.rs:17:23\n   |\n17 |             v2.remove(v2.iter().cloned().nth(u));\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in\
    \ l1.iter().cloned() {\n        if l2.iter().any(|&i| i == i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpqw4qvbje.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        let mut index = 0;\n    \
    \    if l1.len() != 0 {\n            index = l1.iter().position(|&x| x == l1[0]).unwrap();\n\
    \        }\n        if l2.len() != 0 {\n            index = l2.iter().position(|&x|\
    \ x == l2[0]).unwrap();\n        }\n        if index != 0 {\n            result.push(l1[index]);\n\
    \            result.push(l2[index]);\n            l1.remove(index).unwrap();\n\
    \            l2.remove(index).unwrap();\n        } else {\n            result.push(l1[0]);\n\
    \            result.push(l2[0]);\n            l1.remove(0);\n            l2.remove(0);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpdw5gudh8.rs:19:30\n   |\n19 |             l1.remove(index).unwrap();\n\
    \   |                              ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpdw5gudh8.rs:20:30\n   |\n20 |             l2.remove(index).unwrap();\n\
    \   |                              ^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n        \
    \    i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    l1[i\
    \ .. ].iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpb7m7io1f.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = Vec::with_capacity(l1.len());\n\
    \    s.extend_from_slice(l1);\n    s.extend_from_slice(l2);\n\n    vec![\n   \
    \     s.remove(&s[0]), // remove first element\n        s.remove(&s[1]),\n   \
    \ ]\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkus17aud.rs:8:25\n  |\n8 |\
    \     s.extend_from_slice(l1);\n  |                         ^^\n  |          \
    \               |\n  |                         expected `&[_]`, found struct `Vec`\n\
    \  |                         help: consider borrowing here: `&l1`\n  |\n  = note:\
    \ expected reference `&[_]`\n                found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpkus17aud.rs:9:25\n  |\n9 |     s.extend_from_slice(l2);\n\
    \  |                         ^^\n  |                         |\n  |          \
    \               expected `&[_]`, found struct `Vec`\n  |                     \
    \    help: consider borrowing here: `&l2`\n  |\n  = note: expected reference `&[_]`\n\
    \                found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkus17aud.rs:12:18\n   |\n12 |         s.remove(&s[0]), // remove\
    \ first element\n   |                  ^^^^^ expected `usize`, found reference\n\
    \   |\n   = note:   expected type `usize`\n           found reference `&_`\nhelp:\
    \ consider removing the borrow\n   |\n12 -         s.remove(&s[0]), // remove\
    \ first element\n12 +         s.remove(s[0]), // remove first element\n   | \n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkus17aud.rs:13:18\n   |\n13 |\
    \         s.remove(&s[1]),\n   |                  ^^^^^ expected `usize`, found\
    \ `&isize`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // The first vector will always be shorter\
    \ and the first two elements will be\n    // equal to each other.\n    let shorter\
    \ = l1.len() > l2.len();\n    let first = (shorter ? l1.clone() : l2).to_vec();\n\
    \    let second = (shorter ? l2.clone() : l1).to_vec();\n    let mut it = first.iter().cloned();\n\
    \    let mut last = second.iter().cloned();\n\n    let mut result = Vec::new();\n\
    \n    // If both vectors are of length 0 or 1, there's nothing left to do.\n \
    \   if shorter == false {\n        result.push(it.next().unwrap());\n        result.push(last.next().unwrap());\n\
    \        return result;\n    }\n\n    // Find common elements\n    while let Some(_)\
    \ = it.next() {\n        result.push(it.next().unwrap());\n        last.next();\n\
    \    }\n\n    // Find first common element\n    let mut last = second.iter().cloned();\n\
    \    while let Some(_) = last.next() {\n        result.push(last.next().unwrap());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `l1`\n\
    \  --> /tmp/tmpkbwyjbg9.rs:10:28\n   |\n10 |     let first = (shorter ? l1.clone()\
    \ : l2).to_vec();\n   |                           -^^ expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n   |                           |\n   |           \
    \                help: missing `,`\n\nerror: expected one of `)`, `,`, `.`, `?`,\
    \ or an operator, found `l2`\n  --> /tmp/tmpkbwyjbg9.rs:11:29\n   |\n11 |    \
    \ let second = (shorter ? l2.clone() : l1).to_vec();\n   |                   \
    \         -^^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |       \
    \                     |\n   |                            help: missing `,`\n\n\
    error[E0573]: expected type, found local variable `l2`\n  --> /tmp/tmpkbwyjbg9.rs:10:41\n\
    \   |\n10 |     let first = (shorter ? l1.clone() : l2).to_vec();\n   |      \
    \                                   ^^ expecting a type here because of type ascription\n\
    \nerror[E0573]: expected type, found local variable `l1`\n  --> /tmp/tmpkbwyjbg9.rs:11:42\n\
    \   |\n11 |     let second = (shorter ? l2.clone() : l1).to_vec();\n   |     \
    \                                     ^^ expecting a type here because of type\
    \ ascription\n\nerror[E0277]: the `?` operator can only be applied to values that\
    \ implement `Try`\n  --> /tmp/tmpkbwyjbg9.rs:10:18\n   |\n10 |     let first =\
    \ (shorter ? l1.clone() : l2).to_vec();\n   |                  ^^^^^^^^^ the `?`\
    \ operator cannot be applied to type `bool`\n   |\n   = help: the trait `Try`\
    \ is not implemented for `bool`\n\nerror[E0277]: the `?` operator can only be\
    \ used in a function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmpkbwyjbg9.rs:10:26\n   |\n6  | / fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n7  | |     // The first vector\
    \ will always be shorter and the first two elements will be\n8  | |     // equal\
    \ to each other.\n9  | |     let shorter = l1.len() > l2.len();\n10 | |     let\
    \ first = (shorter ? l1.clone() : l2).to_vec();\n   | |                      \
    \    ^ cannot use the `?` operator in a functi"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c: Vec<isize> = l1.clone();\n \
    \   c.sort_unstable();\n    let mut t: Vec<isize> = l2.clone();\n    t.sort_unstable();\n\
    \    c.dedup();\n    t.dedup();\n    let mut i: usize = 0;\n    while i < c.len()\
    \ && i < t.len() {\n        if l1[c[i]] < l2[t[i]] {\n            c.pop(i);\n\
    \        } else {\n            t.pop(i);\n        }\n        i += 1;\n    }\n\
    \    c + t\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpi7un8_2b.rs:15:12\n\
    \   |\n15 |         if l1[c[i]] < l2[t[i]] {\n   |            ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpi7un8_2b.rs:15:23\n   |\n15 |         if l1[c[i]]\
    \ < l2[t[i]] {\n   |                       ^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpi7un8_2b.rs:16:15\n     |\n16 \
    \  |             c.pop(i);\n     |               ^^^ - supplied 1 argument\n \
    \    |               |\n     |               expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpi7un8_2b.rs:18:15\n     |\n18 \
    \  |             t.pop(i);\n     |               ^^^ - supplied 1 argument\n \
    \    |               |\n     |               expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0369]: cannot add `Vec<isize>` to\
    \ `Vec<isize>`\n  --> /tmp/tmpi7un8_2b.rs:22:7\n   |\n22 |     c + t\n   |   \
    \  - ^ - Vec<isize>\n   |     |\n   |     Vec<isize>\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0369.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    itertools::common::<isize>()(l1, l2)\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `itertools`\n\
    \ --> /tmp/tmpbkb9nzdf.rs:7:5\n  |\n7 |     itertools::common::<isize>()(l1, l2)\n\
    \  |     ^^^^^^^^^ use of undeclared crate or module `itertools`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return Vec::new();\n    }\n\n    let mut common: Vec<isize> = Vec::new();\n\
    \    let mut last: usize = l1.len() - 1;\n\n    while last != 0 {\n        let\
    \ mut first = l1[0];\n\n        if l2[first] != first {\n            common.push(first);\n\
    \            last = last - 1;\n        }\n\n        first = l2[first];\n     \
    \   last--;\n    }\n\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp6_zrgx5g.rs:23:15\n\
    \   |\n23 |         last--;\n   |               ^ expected expression\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6_zrgx5g.rs:17:12\n\
    \   |\n17 |         if l2[first] != first {\n   |            ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6_zrgx5g.rs:22:17\n   |\n22 |         first\
    \ = l2[first];\n   |                 ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common:\
    \ Vec<isize> = l1.clone();\n    while l1.len() != 0 && l2.len() != 0 {\n     \
    \   let mut min: isize = (l1.len() > l2.len() ? l1.len() : l2.len());\n      \
    \  let mut min2: isize = (l1.len() > l2.len() ? l2.len() : l1.len());\n      \
    \  let mut l1_count: usize = 0;\n        let mut l2_count: usize = 0;\n      \
    \  for &x in l1 {\n            if x == l2.get(l2_count) {\n                l1_count\
    \ += 1;\n            } else {\n                break;\n            }\n       \
    \ }\n        for &x in l2 {\n            if x == l1.get(l1_count) {\n        \
    \        l2_count += 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        if l1_count == l2_count {\n            common.push(x);\n\
    \            l1.pop();\n            l2.pop();\n        } else {\n            min\
    \ = std::cmp::min(min2, min);\n        }\n    }\n    common\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpz1zzuhx8.rs:11:53\n\
    \   |\n11 |         let mut min: isize = (l1.len() > l2.len() ? l1.len() : l2.len());\n\
    \   |                                                     ^^^^^^^^-----\n   |\
    \                                                             |\n   |        \
    \                                                     help: remove the type ascription\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `l1`\n  -->\
    \ /tmp/tmpz1zzuhx8.rs:11:53\n   |\n11 |         let mut min: isize = (l1.len()\
    \ > l2.len() ? l1.len() : l2.len());\n   |                                   \
    \                 -^^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |\
    \                                                    |\n   |                 \
    \                                   help: missing `,`\n\nerror: casts cannot be\
    \ followed by a method call\n  --> /tmp/tmpz1zzuhx8.rs:12:54\n   |\n12 |     \
    \    let mut min2: isize = (l1.len() > l2.len() ? l2.len() : l1.len());\n   |\
    \                                                      ^^^^^^^^-----\n   |   \
    \                                                           |\n   |          \
    \                                                    help: remove the type ascription\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `l2`\n  -->\
    \ /tmp/tmpz1zzuhx8.rs:12:54\n   |\n12 |         let mut min2: isize = (l1.len()\
    \ > l2.len() ? l2.len() : l1.len());\n   |                                   \
    \                  -^^ expected one of `)`, `,`, `.`, `?`, or an operator\n  \
    \ |                                                     |\n   |              \
    \                                       help: missing `,`\n\nerror[E0573]: expected\
    \ type, found local variable `l2`\n  --> /tmp/tmpz1zzuhx8.rs:11:64\n   |\n11 |\
    \         let mut min: isize = (l1.len() > l2.len() ? l1.len() : l2.len());\n\
    \   |                                                                ^^ expecting\
    \ a type here because of type ascription\n\nerror[E0573]: expected type, found\
    \ local variable `l1`\n  --> /tmp/tmpz1zzuhx8.rs:12:"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut it = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    it.sort();\n    let mut it = l2.iter().cloned().collect::<Vec<_>>();\n  \
    \  it.sort();\n    let mut result = it.clone();\n    result.sort();\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 5, 7, 9, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpytz98evn.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(&x, &y)|\
    \ x != y).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpx1qeqopn.rs:7:56\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|(&x, &y)| x != y).collect()\n\
    \     |                                                        ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ tmp1 = l2.clone();\n    let mut tmp2 = l2.clone();\n\n    loop {\n        if\
    \ tmp1.iter().any(|&x| *x == *result.iter().any(|&x| *x == *tmp2.iter().first()))\
    \ {\n            result.push(*tmp2.iter().first());\n            tmp2.pop();\n\
    \        } else {\n            result.push(*tmp1.iter().first());\n          \
    \  tmp1.pop();\n        }\n\n        if tmp1.len() == 0 && tmp2.len() == 0 {\n\
    \            break;\n        }\n\n        tmp2 = tmp1.clone();\n        tmp1 =\
    \ result.clone();\n        result.clear();\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpuknf04na.rs:12:33\n\
    \   |\n12 |         if tmp1.iter().any(|&x| *x == *result.iter().any(|&x| *x ==\
    \ *tmp2.iter().first())) {\n   |                                 ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpuknf04na.rs:12:63\n   |\n\
    12 |         if tmp1.iter().any(|&x| *x == *result.iter().any(|&x| *x == *tmp2.iter().first()))\
    \ {\n   |                                                               ^^\n\n\
    error[E0599]: no method named `first` found for struct `std::slice::Iter` in the\
    \ current scope\n  --> /tmp/tmpuknf04na.rs:12:82\n   |\n12 |         if tmp1.iter().any(|&x|\
    \ *x == *result.iter().any(|&x| *x == *tmp2.iter().first())) {\n   |         \
    \                                                                         ^^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0614]: type `bool`\
    \ cannot be dereferenced\n  --> /tmp/tmpuknf04na.rs:12:39\n   |\n12 |        \
    \ if tmp1.iter().any(|&x| *x == *result.iter().any(|&x| *x == *tmp2.iter().first()))\
    \ {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `first` found for struct `std::slice::Iter` in\
    \ the current scope\n  --> /tmp/tmpuknf04na.rs:13:38\n   |\n13 |             result.push(*tmp2.iter().first());\n\
    \   |                                      ^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0599]: no method named `first` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpuknf04na.rs:16:38\n   |\n16 |          \
    \   result.push(*tmp1.iter().first());\n   |                                 \
    \     ^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c = 0;\n    let mut res = vec![];\n\
    \n    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len()\
    \ {\n        if l1[i1] == l2[i2] {\n            res.push(i1);\n            c +=\
    \ 1;\n            i1 += 1;\n            i2 += 1;\n        }\n        else if l1[i1]\
    \ < l2[i2] {\n            i1 += 1;\n        }\n        else {\n            i2\
    \ += 1;\n        }\n    }\n\n    if i1 == l1.len() {\n        res.push(i2);\n\
    \    }\n\n    if i2 == l2.len() {\n        res.push(i1);\n    }\n\n    if c >\
    \ 0 {\n        res.sort();\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1mhlhhzv.rs:39:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n39 |     res\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1;\n    l.sort();\n    l =\
    \ l2.iter().filter(|x| l.iter().filter(|y| x == y).count() == 1).collect();\n\
    \    l.sort()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpg3hwoap5.rs:9:72\n     |\n9\
    \    |     l = l2.iter().filter(|x| l.iter().filter(|y| x == y).count() == 1).collect();\n\
    \     |                                                                      \
    \  ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg3hwoap5.rs:10:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n10 |     l.sort()\n   | \
    \    ^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 1;\n    let mut j = 1;\n\n\
    \    while i <= l1.len() && j <= l2.len() {\n        if l1[i] < l2[j] {\n    \
    \        i += 1;\n        } else if l1[i] == l2[j] {\n            i += 1;\n  \
    \          j += 1;\n        } else {\n            j += 1;\n        }\n    }\n\n\
    \    while i <= l1.len() {\n        i += 1;\n    }\n\n    while j <= l2.len()\
    \ {\n        j += 1;\n    }\n\n    vec![l1[0], l2[j - 1]]\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 7 but the
    index is 7'', /tmp/tmp3sz38p2g.rs:11:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() {\n        return\
    \ vec![];\n    }\n    let mut seen = HashSet::new();\n    let mut result = vec![];\n\
    \    for el1 in l1 {\n        if seen.contains(&el1) {\n            continue;\n\
    \        }\n        seen.insert(el1);\n        for el2 in l2 {\n            if\
    \ el2 == el1 {\n                continue;\n            }\n            if seen.contains(&el2)\
    \ {\n                continue;\n            }\n            seen.insert(el2);\n\
    \            result.push(el1);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpgz8de06f.rs:10:20\n   |\n10 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = l1.len();\n\
    \    while i != j {\n        let k = (i + j) / 2;\n        if l1[..k].iter().zip(l2[..k].iter()).any(|&(u1,\
    \ u2)| u1 != u2) {\n            i = k;\n        } else {\n            j = k;\n\
    \        }\n    }\n    l1[..j].clone()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjya4t7xy.rs:11:52\n   |\n\
    11 |         if l1[..k].iter().zip(l2[..k].iter()).any(|&(u1, u2)| u1 != u2) {\n\
    \   |                                                    ^^^^^^^^-\n   |     \
    \                                               |       |\n   |              \
    \                                      |       expected due to this\n   |    \
    \                                                expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(&isize, &isize)`\n           found reference\
    \ `&_`\n\nerror[E0599]: no method named `clone` found for slice `[isize]` in the\
    \ current scope\n  --> /tmp/tmpjya4t7xy.rs:17:13\n   |\n17 |     l1[..j].clone()\n\
    \   |             ^^^^^ method not found in `[isize]`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter())\n        .filter(|&(_,\
    \ l)| l != l1)\n        .map(|(_, l1)| l1)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Vec<isize>`\n --> /tmp/tmp1r5xepnn.rs:8:29\n\
    \  |\n8 |         .filter(|&(_, l)| l != l1)\n  |                            \
    \ ^^ no implementation for `&isize == Vec<isize>`\n  |\n  = help: the trait `PartialEq<Vec<isize>>`\
    \ is not implemented for `&isize`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmp1r5xepnn.rs:10:10\n\
    \     |\n10   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: -1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut l3 = l1.clone();\n    loop {\n        if l1.len()\
    \ != l2.len() {\n            break;\n        }\n        if l1[l1.len() - 1] ==\
    \ l2[l2.len() - 1] {\n            l3.pop();\n            l1.pop();\n         \
    \   l2.pop();\n        }\n        if l1.len() == 0 {\n            l3.pop();\n\
    \        }\n        if l2.len() == 0 {\n            l3.pop();\n        }\n   \
    \ }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976136
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l2.iter().zip(l1.iter()).filter(|(a, b)|\
    \ a == b).map(|&(a, b)| *b).collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu4rsizpo.rs:7:59\n  |\n7 |\
    \     l2.iter().zip(l1.iter()).filter(|(a, b)| a == b).map(|&(a, b)| *b).collect()\n\
    \  |                                                           ^^^^^^-\n  |  \
    \                                                         |     |\n  |       \
    \                                                    |     expected due to this\n\
    \  |                                                           expected tuple,\
    \ found reference\n  |\n  = note:  expected tuple `(&isize, &isize)`\n       \
    \   found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return vec![];\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut l = l1.len();\n    let mut k = l2.len();\n    loop {\n        if i == l\
    \ {\n            k = l2.len();\n            j = 0;\n        }\n        if j ==\
    \ k {\n            l = l1.len();\n            i = 0;\n        }\n        if l1[i]\
    \ == l2[j] {\n            i += 1;\n            j += 1;\n            if i == l\
    \ {\n                return vec![l1[i]];\n            }\n        }\n        if\
    \ l1[i] > l2[j] {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 7 but the
    index is 7'', /tmp/tmpgvchxdrq.rs:23:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut a = l1.clone();\n    let mut b\
    \ = l2.clone();\n    a.sort_unstable();\n    b.sort_unstable();\n    if a.iter().all(|&i|\
    \ i == b[0]) {\n        return a;\n    }\n    b.iter().cloned().filter(|&i| i\
    \ !~ a[0]).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `~`\n  --> /tmp/tmpj_vjxc1r.rs:14:38\n\
    \   |\n14 |     b.iter().cloned().filter(|&i| i !~ a[0]).cloned().collect()\n\
    \   |                                      ^ expected one of `(`, `[`, or `{`\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(l1.len());\n\
    \    result.extend(l1.iter().filter(|&x| !l2.iter().any(|&y| x == y)));\n    result.extend(l2.iter().filter(|&x|\
    \ !l1.iter().any(|&y| x == y)));\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmpxuvqkywc.rs:8:63\n\
    \  |\n8 |     result.extend(l1.iter().filter(|&x| !l2.iter().any(|&y| x == y)));\n\
    \  |                                                               ^^ no implementation\
    \ for `&isize == isize`\n  |\n  = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmpxuvqkywc.rs:9:63\n\
    \  |\n9 |     result.extend(l2.iter().filter(|&x| !l1.iter().any(|&y| x == y)));\n\
    \  |                                                               ^^ no implementation\
    \ for `&isize == isize`\n  |\n  = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() > l2.len() {\n        l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(_,\
    \ &a)| a == 1).collect()\n    } else {\n        l2.iter().cloned().zip(l1.iter().cloned()).filter(|&(_,\
    \ &a)| a == 1).collect()\n    }\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyzcbvxob.rs:8:65\n  |\n8 |\
    \         l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(_, &a)| a == 1).collect()\n\
    \  |                                                                 ^^- expected\
    \ due to this\n  |                                                           \
    \      |\n  |                                                                \
    \ expected `isize`, found reference\n  |                                     \
    \                            help: you can probably remove the explicit borrow:\
    \ `a`\n  |\n  = note:   expected type `isize`\n          found reference `&_`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(isize, isize)`\n    --> /tmp/tmpyzcbvxob.rs:8:78\n \
    \    |\n8    |         l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(_,\
    \ &a)| a == 1).collect()\n     |                                             \
    \                                 ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=(isize, isize)>`\n     |\n     = help:\
    \ the trait `FromIterator<(isize, isize)>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyzcbvxob.rs:10:65\n\
    \   |\n10 |         l2.iter().cloned().zip(l1.iter().cloned()).filter(|&(_, &a)|\
    \ a == 1).collect()\n   |                                                    \
    \             ^^- expected due to this\n   |                                 \
    \                                |\n   |                                     \
    \                            expected `isize`, found reference\n   |         \
    \                                                        help: you can probably\
    \ remove the explicit borrow: `a`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `(isize, isize)`\n  \
    \  --> /tmp/tmpyzcbvxob.rs:10:78\n     |\n10   |         "
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = l1;\n    s.sort_unstable();\n\
    \    s.dedup();\n    s\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpowudc89v.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|&x| l2.iter().any(|&y|\
    \ x == y)).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmp0dxfyljl.rs:7:48\n\
    \  |\n7 |     l1.iter().filter(|&x| l2.iter().any(|&y| x == y)).collect()\n  |\
    \                                                ^^ no implementation for `&isize\
    \ == isize`\n  |\n  = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from an\
    \ iterator over elements of type `&isize`\n    --> /tmp/tmp0dxfyljl.rs:7:55\n\
    \     |\n7    |     l1.iter().filter(|&x| l2.iter().any(|&y| x == y)).collect()\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    (l1.iter().zip(l2.iter()).filter(|&(elt1,\
    \ elt2)| elt1 == elt2).map(|&elt| (elt1, elt2))).collect()\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `elt1` in this scope\n --> /tmp/tmpp9z5d85s.rs:7:80\n\
    \  |\n7 |     (l1.iter().zip(l2.iter()).filter(|&(elt1, elt2)| elt1 == elt2).map(|&elt|\
    \ (elt1, elt2))).collect()\n  |                                              \
    \                                  ^^^^ help: a local variable with a similar\
    \ name exists: `elt`\n\nerror[E0425]: cannot find value `elt2` in this scope\n\
    \ --> /tmp/tmpp9z5d85s.rs:7:86\n  |\n7 |     (l1.iter().zip(l2.iter()).filter(|&(elt1,\
    \ elt2)| elt1 == elt2).map(|&elt| (elt1, elt2))).collect()\n  |              \
    \                                                                        ^^^^\
    \ help: a local variable with a similar name exists: `elt`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpp9z5d85s.rs:7:73\n  |\n7 |     (l1.iter().zip(l2.iter()).filter(|&(elt1,\
    \ elt2)| elt1 == elt2).map(|&elt| (elt1, elt2))).collect()\n  |              \
    \                                                           ^----\n  |       \
    \                                                                  ||\n  |   \
    \                                                                      |expected\
    \ due to this\n  |                                                           \
    \              expected tuple, found reference\n  |                          \
    \                                               help: did you mean `elt`: `&(&isize,\
    \ &isize)`\n  |\n  = note:  expected tuple `(&isize, &isize)`\n          found\
    \ reference `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut len1 = l1.len();\n    let mut len2\
    \ = l2.len();\n\n    let mut i = 0;\n    while i < len1 && i < len2 {\n      \
    \  if l1[i] == l2[i] {\n            i += 1;\n        } else {\n            if\
    \ l1[i] > l2[i] {\n                len1 = len1 - 1;\n            } else {\n  \
    \              len2 = len2 - 1;\n            }\n        }\n    }\n\n    let mut\
    \ rs = Vec::new();\n    if len1 == len2 {\n        for _ in 0..len1 {\n      \
    \      rs.push(l1[i]);\n        }\n    }\n\n    while i < len1 {\n        rs.push(l1[i]);\n\
    \        i += 1;\n    }\n\n    while i < len2 {\n        rs.push(l2[i]);\n   \
    \     i += 1;\n    }\n\n    rs\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp4ri29wkx.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ hashmap = HashMap::new();\n    l1.sort_unstable();\n    l2.sort_unstable();\n\
    \    for &x in l1 {\n        if !hashmap.contains_key(&x) {\n            hashmap.insert(x,\
    \ 0);\n            result.push(x);\n        }\n    }\n    for &x in l2 {\n   \
    \     if !hashmap.contains_key(&x) {\n            hashmap.insert(x, 0);\n    \
    \        result.push(x);\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpvm4j2gw0.rs:8:23\n  |\n8 |     let mut hashmap = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvm4j2gw0.rs:11:9\n   |\n11 |     for &x in l1\
    \ {\n   |         ^^    -- this expression has type `Option<isize>`\n   |    \
    \     |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvm4j2gw0.rs:17:9\n   |\n17 |     for &x in l2 {\n   |         ^^\
    \    -- this expression has type `Option<isize>`\n   |         |\n   |       \
    \  expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = vec![];\n    let mut t = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        let mut l1 = l1;\n      \
    \  let mut l2 = l2;\n        let mut i = 0;\n        while l1.len() != 0 && l2.len()\
    \ != 0 {\n            if l1[0] != l2[0] {\n                break;\n          \
    \  }\n            i += 1;\n            l1.remove(0);\n            l2.remove(0);\n\
    \        }\n        if l1.len() == 0 || l2.len() == 0 {\n            s.push(i);\n\
    \            t.push(i);\n        } else {\n            s.push(i);\n        }\n\
    \    }\n    vec![t[0], t[1], t[2]]\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l1`\n  --> /tmp/tmp7vr40g0_.rs:9:11\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \         -- move occurs because `l1` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n9  |     while l1.len() != 0 || l2.len() != 0 {\n   |\
    \           ^^^^^^^^ value borrowed here after move\n10 |         let mut l1 =\
    \ l1;\n   |                      -- value moved here, in previous iteration of\
    \ loop\n\nerror[E0382]: borrow of moved value: `l2`\n  --> /tmp/tmp7vr40g0_.rs:9:28\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                         -- move occurs because `l2` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n9  |     while l1.len() != 0 || l2.len()\
    \ != 0 {\n   |                            ^^^^^^^^ value borrowed here after move\n\
    10 |         let mut l1 = l1;\n11 |         let mut l2 = l2;\n   |           \
    \           -- value moved here, in previous iteration of loop\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(_, v)|\
    \ v == 1).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&isize` with `{integer}`\n --> /tmp/tmppd79rjxf.rs:7:48\n\
    \  |\n7 |     l1.iter().zip(l2.iter()).filter(|(_, v)| v == 1).collect::<Vec<_>>()\n\
    \  |                                                ^^ no implementation for `&&isize\
    \ == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&&isize`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror[E0308]: mismatched types\n --> /tmp/tmppd79rjxf.rs:7:5\n  |\n\
    6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |           \
    \                                   ---------- expected `Vec<isize>` because of\
    \ return type\n7 |     l1.iter().zip(l2.iter()).filter(|(_, v)| v == 1).collect::<Vec<_>>()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n\
    \             found struct `Vec<(&isize, &isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() { return Vec::new();\
    \ }\n\n    let mut l: Vec<isize> = l1.iter().cloned().collect();\n\n    if l.len()\
    \ < 2 {\n        return l;\n    }\n\n    for i in 1..(l.len() - 1).max() {\n \
    \       let a = l[i];\n        let b = l[i - 1];\n\n        if a != b {\n    \
    \        l.swap(i - 1, i);\n        }\n    }\n    l\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpuidxm7jj.rs:15:31\n    |\n15  |     for i in 1..(l.len() - 1).max()\
    \ {\n    |                               ^^^- supplied 0 arguments\n    |    \
    \                           |\n    |                               expected 1\
    \ argument\n    |\nnote: associated function defined here\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)|\
    \ a == b).collect::<Vec<_>>().sorted()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Vec<(&isize, &isize)>`\
    \ in the current scope\n --> /tmp/tmpdfb8lcgy.rs:7:74\n  |\n7 |     l1.iter().zip(l2.iter()).filter(|(a,\
    \ b)| a == b).collect::<Vec<_>>().sorted()\n  |                              \
    \                                            ^^^^^^ help: there is an associated\
    \ function with a similar name: `is_sorted`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i: isize = 0;\n    let mut j: isize\
    \ = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n\
    \            i += 1;\n            j += 1;\n        } else {\n            if l1[i]\
    \ < l2[j] {\n                i += 1;\n            } else {\n                j\
    \ += 1;\n            }\n        }\n    }\n    vec![j..l2.len()]\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp83hf7221.rs:9:15\n  |\n9 |\
    \     while i < l1.len() && j < l2.len() {\n  |               ^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     while i < l1.len().try_into().unwrap()\
    \ && j < l2.len() {\n  |                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp83hf7221.rs:9:31\n  |\n9 |     while i < l1.len()\
    \ && j < l2.len() {\n  |                               ^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     while i < l1.len() && j < l2.len().try_into().unwrap()\
    \ {\n  |                                       ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp83hf7221.rs:10:12\n\
    \   |\n10 |         if l1[i] == l2[j] {\n   |            ^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp83hf7221.rs:10:21\n   |\n10 |         if l1[i]\
    \ == l2[j] {\n   |                     ^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp83hf7221.rs:14:16\n   |\n14 |            \
    \ if l1[i] < l2[j] {\n   |                ^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemen"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l2.iter().partition(|&a| l1.contains(&a))\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjkvok07f.rs:7:5\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n7 |     l2.iter().partition(|&a| l1.contains(&a))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n\
    \              found tuple `(_, _)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n\
    \n    // Iterate over elements and add unique elements.\n    for el1 in l1 {\n\
    \        for el2 in l2 {\n            if el1 == el2 {\n                continue;\n\
    \            }\n\n            if !result.contains(&el2) {\n                result.push(el2);\n\
    \            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l2`\n   --> /tmp/tmpebys_2_f.rs:11:20\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                           -- move occurs because `l2` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n11  |         for el2 in l2\
    \ {\n    |                    ^^ `l2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l2`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n11\
    \  |         for el2 in &l2 {\n    |                    +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().cloned().zip(l2.iter().cloned())\n\
    \        .filter(|(_, &b)| a == b)\n        .map(|(_, a)| a)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `a` in this scope\n --> /tmp/tmpx2u2dln0.rs:8:27\n\
    \  |\n8 |         .filter(|(_, &b)| a == b)\n  |                           ^ help:\
    \ a local variable with a similar name exists: `b`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpx2u2dln0.rs:8:22\n  |\n8 |         .filter(|(_, &b)| a ==\
    \ b)\n  |                      ^^- expected due to this\n  |                 \
    \     |\n  |                      expected `isize`, found reference\n  |     \
    \                 help: you can probably remove the explicit borrow: `b`\n  |\n\
    \  = note:   expected type `isize`\n          found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    while\
    \ l1.len() != l2.len() {\n        let mut found = false;\n        for i1 in l1.iter()\
    \ {\n            for i2 in l2.iter() {\n                if i1 == i2 {\n      \
    \              found = true;\n                    break;\n                }\n\
    \            }\n            if !found {\n                break;\n            }\n\
    \        }\n        if !found {\n            result.push(*l1.iter().min());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpsnsc7909.rs:22:25\n\
    \   |\n22 |             result.push(*l1.iter().min());\n   |                 \
    \        ^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n\n    l1.sort_unstable();\n    l2.sort_unstable();\n\n  \
    \  let mut ret: Vec<isize> = Vec::new();\n    while l1.len() != 0 || l2.len()\
    \ != 0 {\n        if l1.len() == 0 && l2.len() != 0 {\n            break;\n  \
    \      }\n        if l1.len() == 0 {\n            l2.pop();\n        } else if\
    \ l2.len() == 0 {\n            l1.pop();\n        } else {\n            let mut\
    \ l1_x = l1.pop().unwrap();\n            let mut l2_x = l2.pop().unwrap();\n \
    \           while l1_x == l2_x {\n                l2_x = l2.pop().unwrap();\n\
    \            }\n            ret.unpush(l1_x);\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unpush` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmph0uq9ini.rs:28:17\n   |\n28 |             ret.unpush(l1_x);\n\
    \   |                 ^^^^^^ help: there is an associated function with a similar\
    \ name: `push`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    for (i,\
    \ &e) in l2.iter().enumerate() {\n        if i != 0 && &result == &l1 {\n    \
    \        loop {\n                if e == &l1[i - 1] {\n                    result\
    \ = result.clone();\n                } else {\n                    break;\n  \
    \              }\n            }\n        }\n        result.push(e);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppaluhs_k.rs:11:25\n   |\n\
    11 |                 if e == &l1[i - 1] {\n   |                         ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n11 -                 if e == &l1[i - 1] {\n11 +                 if e ==\
    \ l1[i - 1] {\n   | \n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\n    for\
    \ e in l1 {\n        match l2.iter().position(|x| x == e) {\n            Some(pos)\
    \ => {\n                result = result.insert(pos, e);\n            }\n     \
    \       None => return vec![],\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpyj7_nk1q.rs:10:40\n\
    \   |\n10 |         match l2.iter().position(|x| x == e) {\n   |             \
    \                           ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyj7_nk1q.rs:12:26\n\
    \   |\n7  |     let mut result = Vec::new();\n   |                      ----------\
    \ expected due to this value\n...\n12 |                 result = result.insert(pos,\
    \ e);\n   |                          ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i\
    \ in 0..l1.len() {\n        if l1.iter().any(|e| e == l1[i]) {\n            result.push(l1[i]);\n\
    \        }\n    }\n    for i in 0..l2.len() {\n        if l2.iter().any(|e| e\
    \ == l2[i]) {\n            result.push(l2[i]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmp1o_3qnmc.rs:9:32\n\
    \  |\n9 |         if l1.iter().any(|e| e == l1[i]) {\n  |                    \
    \            ^^ no implementation for `&isize == isize`\n  |\n  = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n  = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n            f32\n           \
    \ f64\n            i128\n            i16\n            i32\n            i64\n \
    \           i8\n            isize\n          and 6 others\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmp1o_3qnmc.rs:14:32\n   |\n14 | \
    \        if l2.iter().any(|e| e == l2[i]) {\n   |                            \
    \    ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().cloned().zip(l2.iter().cloned())\n\
    \        .filter(|(a, b)| a != b)\n        .map(|(a, b)| a)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpzo4yq_me.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    while l1.len()\
    \ > 0 && l2.len() > 0 {\n        if l1[0] < l2[0] { l1.pop(); } else { l2.pop();\
    \ }\n        if l1.len() > 0 && l2.len() > 0 {\n            if l1[0] > l2[0] {\
    \ result.push(*l1); }\n            } else { result.push(*l2); }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp_e9fnpud.rs:16:1\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - this opening brace...\n\
    ...\n14 |     }\n   |     - ...matches this closing brace\n15 |     result\n16\
    \ | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter()\n        .zip(l2.iter())\n  \
    \      .filter(|(a, b)| a < b)\n        .map(|(a, b)| a)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmp3ixie1lk.rs:11:10\n     |\n\
    11   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = vec![];\n    for (i, elt) in\
    \ l1.iter().enumerate() {\n        if l2[i] == elt {\n            s.push(i);\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyepwb4eh.rs:9:21\n  |\n9 |\
    \         if l2[i] == elt {\n  |                     ^^^ expected `isize`, found\
    \ `&isize`\n  |\nhelp: consider dereferencing the borrow\n  |\n9 |         if\
    \ l2[i] == *elt {\n  |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyepwb4eh.rs:13:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n13 |     s\n   |     ^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut u: Vec<isize> = vec![];\n    let\
    \ mut t: Vec<isize> = vec![];\n\n    l1.sort_unstable();\n    l2.sort_unstable();\n\
    \n    for i in l1.iter().zip(l2.iter()) {\n        if i.0 != i.1 {\n         \
    \   t.push(i.0);\n            u.push(i.1);\n        }\n    }\n\n    if t.len()\
    \ == u.len() {\n        t\n    } else {\n        vec![t]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmimbtfaf.rs:15:20\n   |\n\
    15 |             t.push(i.0);\n   |                    ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |        \
    \     t.push(*i.0);\n   |                    +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmimbtfaf.rs:16:20\n   |\n16 |             u.push(i.1);\n   |  \
    \                  ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |             u.push(*i.1);\n   |       \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmimbtfaf.rs:23:14\n\
    \   |\n23 |         vec![t]\n   |              ^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut it = l1.iter().cloned().chain(l2.iter().cloned()).collect::<Vec<_>>();\n\
    \    let mut i1 = it.next().unwrap();\n    let mut i2 = it.next().unwrap();\n\n\
    \    while i1 != i2 {\n        if *i1 < *i2 {\n            i1 = it.next().unwrap();\n\
    \        } else {\n            i2 = it.next().unwrap();\n        }\n    }\n  \
    \  it.collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<isize>` in the\
    \ current scope\n --> /tmp/tmpwb6h3bjm.rs:8:21\n  |\n8 |     let mut i1 = it.next().unwrap();\n\
    \  |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<isize>` in the current scope\n\
    \ --> /tmp/tmpwb6h3bjm.rs:9:21\n  |\n9 |     let mut i2 = it.next().unwrap();\n\
    \  |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpwb6h3bjm.rs:13:21\n   |\n13 |             i1 = it.next().unwrap();\n\
    \   |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpwb6h3bjm.rs:15:21\n   |\n15 |             i2 = it.next().unwrap();\n\
    \   |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpwb6h3bjm.rs:18:8\n    |\n18\
    \  |       it.collect::<Vec<_>>()\n    |          ^^^^^^^ `Vec<isize>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    loop {\n        let mut l1 = l1.to_vec();\n\
    \        let mut l2 = l2.to_vec();\n        if l1.is_empty() {\n            return\
    \ l2.clone();\n        }\n        if l2.is_empty() {\n            return l1.clone();\n\
    \        }\n\n        if l1[0] == l2[0] {\n            l1.remove(0);\n       \
    \     l2.remove(0);\n        }\n        if l1.is_empty() {\n            return\
    \ l2.clone();\n        }\n        if l2.is_empty() {\n            return l1.clone();\n\
    \        }\n\n        if l1[0] == l2[0] {\n            return l1.clone().collect();\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpg4dub9f6.rs:29:31\n\
    \    |\n29  |               return l1.clone().collect();\n    |              \
    \                   ^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut u1: Vec<isize> = Vec::new();\n\
    \    let mut u2: Vec<isize> = Vec::new();\n    let mut c: Vec<isize> = Vec::new();\n\
    \    let mut i: isize = 0;\n    while i < l1.len() {\n        if l1.get(&i) ==\
    \ l2.get(&i) {\n            c.push(l1.get(&i));\n            u1.push(l1.get(&i));\n\
    \            i += 1;\n        } else {\n            if l1.get(&i) < l2.get(&i)\
    \ {\n                u1.push(l1.get(&i));\n            } else {\n            \
    \    u2.push(l2.get(&i));\n            }\n            i += 1;\n        }\n   \
    \ }\n    if u1.len() > u2.len() {\n        u1.extend(u2.drain(..).cloned());\n\
    \    } else if u2.len() > u1.len() {\n        u2.extend(u1.drain(..).cloned());\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkv8q526_.rs:11:15\n   |\n\
    11 |     while i < l1.len() {\n   |               ^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     while i < l1.len().try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `&isize`\n   --> /tmp/tmpkv8q526_.rs:12:19\n\
    \    |\n12  |         if l1.get(&i) == l2.get(&i) {\n    |               --- ^^\
    \ slice indices are of type `usize` or ranges of `usize`\n    |              \
    \ |\n    |               required by a bound introduced by this call\n    |\n\
    \    = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::get`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `&isize`\n   --> /tmp/tmpkv8q526_.rs:12:33\n    |\n12 \
    \ |         if l1.get(&i) == l2.get(&i) {\n    |                             ---\
    \ ^^ slice indices are of type `usize` or ranges of `usize`\n    |           \
    \                  |\n    |                             required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    note: required by a bound in `core::slice::<impl [T]>::get`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `&isize`\n   --> /tmp/tmpkv8q526_.rs:13:27\n\
    \    |\n13  |             c.push(l1.get(&i));\n    |                       ---\
    \ ^^ slice indices are of type `usize` or ranges of `usize`\n    |           \
    \            |\n    |                       required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    note: required by a bound in `core::slice::<impl [T]>::get`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkv8q526_.rs:1"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c = l1.clone();\n    c.sort_unstable();\n\
    \    c.dedup();\n    c.iter().zip(l2.iter()).map(|(_, c2)| c2)\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj2jrw8ne.rs:10:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n10 |     c.iter().zip(l2.iter()).map(|(_, c2)| c2)\n  \
    \ |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `Map`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Map<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpj2jrw8ne.rs:10:33:\
    \ 10:45]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i: usize = 0;\n    let mut j: usize\
    \ = 0;\n    let mut common: Vec<isize> = Vec::new();\n    while i < l1.len() &&\
    \ j < l2.len() {\n        if l1[i] < l2[j] {\n            common.push(*l1[i]);\n\
    \            i += 1;\n        } else {\n            common.push(*l2[j]);\n   \
    \         j += 1;\n        }\n    }\n\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpvhi_k1en.rs:12:25\n\
    \   |\n12 |             common.push(*l1[i]);\n   |                         ^^^^^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpvhi_k1en.rs:15:25\n\
    \   |\n15 |             common.push(*l2[j]);\n   |                         ^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)|\
    \ a < b).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppmsro98i.rs:7:5\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n7 |     l1.iter().zip(l2.iter()).filter(|(a, b)| a < b).collect::<Vec<_>>()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n        \
    \     found struct `Vec<(&isize, &isize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut u1 = HashSet::new();\n    let mut\
    \ u2 = HashSet::new();\n    l1.iter().for_each(|&x| {\n        u1.insert(x);\n\
    \    });\n    l2.iter().for_each(|&x| {\n        u2.insert(x);\n    });\n    u2.difference(&u1).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpji7mvsns.rs:7:18\n  |\n7 |     let mut u1 = HashSet::new();\n  |   \
    \               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpji7mvsns.rs:8:18\n\
    \  |\n8 |     let mut u2 = HashSet::new();\n  |                  ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut u1: HashMap<isize, usize>;\n  \
    \  u1 = HashMap::new();\n    let mut u2: HashMap<isize, usize>;\n    u2 = HashMap::new();\n\
    \    l1.iter().for_each(|&x| u1.insert(*x, usize::MAX));\n    l2.iter().for_each(|&x|\
    \ u2.insert(*x, usize::MAX));\n\n    for (x, y) in u1.iter().zip(u2.iter()) {\n\
    \        if *x == *y {\n            continue;\n        }\n\n        if u1.get(x)\
    \ < u2.get(y) {\n            u2.insert(x, usize::MAX);\n        } else {\n   \
    \         u1.insert(y, usize::MAX);\n        }\n    }\n\n    u1.iter().map(|&x|\
    \ x).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpefibcmmi.rs:7:17\n\
    \  |\n7 |     let mut u1: HashMap<isize, usize>;\n  |                 ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashMap;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n --> /tmp/tmpefibcmmi.rs:8:10\n  |\n8 |     u1\
    \ = HashMap::new();\n  |          ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\
    \nerror[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpefibcmmi.rs:9:17\n\
    \  |\n9 |     let mut u2: HashMap<isize, usize>;\n  |                 ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashMap;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmpefibcmmi.rs:10:10\n   |\n10 |  \
    \   u2 = HashMap::new();\n   |          ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpefibcmmi.rs:11:39\n\
    \   |\n11 |     l1.iter().for_each(|&x| u1.insert(*x, usize::MAX));\n   |    \
    \                                   ^^\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmpefibcmmi.rs:12:39\n   |\n12 |     l2.iter().for_each(|&x|\
    \ u2.insert(*x, usize::MAX));\n   |                                       ^^\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize> = l1;\n    let\
    \ mut len1: usize = l1.len();\n    let mut len2: usize = l2.len();\n    loop {\n\
    \        if len1 == len2 {\n            break;\n        }\n        if ret.is_empty()\
    \ {\n            break;\n        }\n        let mut x: isize = ret[0];\n     \
    \   if l2.contains(&x) {\n            let i: usize = ret[0];\n            while\
    \ l1.contains(&i) {\n                ret.push(ret.remove(i));\n              \
    \  len1--;\n            }\n        }\n        if l1.contains(&x) {\n         \
    \   let i: usize = ret[0];\n            while l2.contains(&i) {\n            \
    \    ret.push(ret.remove(i));\n                len2--;\n            }\n      \
    \  }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpwc9wqt77.rs:22:23\n\
    \   |\n22 |                 len1--;\n   |                       ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmpwc9wqt77.rs:29:23\n   |\n\
    29 |                 len2--;\n   |                       ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwc9wqt77.rs:19:28\n   |\n19 |\
    \             let i: usize = ret[0];\n   |                    -----   ^^^^^^ expected\
    \ `usize`, found `isize`\n   |                    |\n   |                    expected\
    \ due to this\n   |\nhelp: you can convert an `isize` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |             let i: usize = ret[0].try_into().unwrap();\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwc9wqt77.rs:20:31\n   |\n20 |             while l1.contains(&i)\
    \ {\n   |                               ^^ expected `isize`, found `usize`\n \
    \  |\n   = note: expected reference `&isize`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwc9wqt77.rs:26:28\n   |\n26 |\
    \             let i: usize = ret[0];\n   |                    -----   ^^^^^^ expected\
    \ `usize`, found `isize`\n   |                    |\n   |                    expected\
    \ due to this\n   |\nhelp: you can convert an `isize` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n26 |             let i: usize = ret[0].try_into().unwrap();\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwc9wqt77.rs:27:31\n   |\n27 |             while l2.contains(&i)\
    \ {\n   |                               ^^ expected `isize`, found `usize`\n \
    \  |\n   = note: expected reference `&isize`\n              found reference `&usize`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().sorted_by_key(|&a| l2.iter().sorted_by_key(|&b|\
    \ a < b)).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpfqjsykyp.rs:7:15\n  |\n7 |     l1.iter().sorted_by_key(|&a|\
    \ l2.iter().sorted_by_key(|&b| a < b)).collect()\n  |               ^^^^^^^^^^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method\
    \ named `sorted_by_key` found for struct `std::slice::Iter` in the current scope\n\
    \ --> /tmp/tmpfqjsykyp.rs:7:44\n  |\n7 |     l1.iter().sorted_by_key(|&a| l2.iter().sorted_by_key(|&b|\
    \ a < b)).collect()\n  |                                            ^^^^^^^^^^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter())\n        .filter(|(_,\
    \ c2)| c2 != 0)\n        .map(|(c, c)| c)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `c` is bound more than once in this parameter\
    \ list\n --> /tmp/tmp55qv9qlm.rs:9:19\n  |\n9 |         .map(|(c, c)| c)\n  |\
    \                   ^ used as parameter more than once\n\nerror[E0277]: can't\
    \ compare `&&isize` with `{integer}`\n --> /tmp/tmp55qv9qlm.rs:8:30\n  |\n8 |\
    \         .filter(|(_, c2)| c2 != 0)\n  |                              ^^ no implementation\
    \ for `&&isize == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&isize`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmp55qv9qlm.rs:10:10\n\
    \     |\n10   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0415.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    common2(l1, l2, false, false)\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `common2` in this scope\n --> /tmp/tmpwpag1pu3.rs:7:5\n\
    \  |\n7 |     common2(l1, l2, false, false)\n  |     ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() {\n        vec!()\n\
    \    } else {\n        let mut res = vec!();\n        let mut l1: HashSet<isize>\
    \ = HashSet::from_iter(l1.iter().cloned());\n        let mut l2: HashSet<isize>\
    \ = HashSet::from_iter(l2.iter().cloned());\n        while l1.len() > 0 || l2.len()\
    \ > 0 {\n            let mut x: Option<usize> = None;\n            if l1.len()\
    \ > 0 {\n                x = l1.pop().unwrap();\n            }\n            if\
    \ l2.len() > 0 {\n                if x.is_some() {\n                    res.push(*x);\n\
    \                } else {\n                    l2.pop().unwrap();\n          \
    \      }\n            }\n        }\n        res\n    }\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpe45u6bw0.rs:11:21\n\
    \   |\n11 |         let mut l1: HashSet<isize> = HashSet::from_iter(l1.iter().cloned());\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpe45u6bw0.rs:11:38\n\
    \   |\n11 |         let mut l1: HashSet<isize> = HashSet::from_iter(l1.iter().cloned());\n\
    \   |                                      ^^^^^^^ not found in this scope\n \
    \  |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpe45u6bw0.rs:12:21\n\
    \   |\n12 |         let mut l2: HashSet<isize> = HashSet::from_iter(l2.iter().cloned());\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpe45u6bw0.rs:12:38\n\
    \   |\n12 |         let mut l2: HashSet<isize> = HashSet::from_iter(l2.iter().cloned());\n\
    \   |                                      ^^^^^^^ not found in this scope\n \
    \  |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0614]: type `Option<usize>` cannot be dereferenced\n  --> /tmp/tmpe45u6bw0.rs:20:30\n\
    \   |\n20 |                     res.push(*x);\n   |                          \
    \    ^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut m = l1\n        .iter()\n     \
    \   .zip(l2)\n        .filter(|(a, b)| a.is_ok() && b.is_ok())\n        .collect::<Vec<_>>();\n\
    \    m\n        .iter()\n        .cloned()\n        .zip(m.iter().cloned())\n\
    \        .filter(|&(_, a), &(_, b)| a == b)\n        .collect::<Vec<_>>()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmpzqxd9j45.rs:10:28\n   |\n10 |         .filter(|(a,\
    \ b)| a.is_ok() && b.is_ok())\n   |                            ^^^^^ method not\
    \ found in `&&isize`\n\nerror[E0599]: no method named `is_ok` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpzqxd9j45.rs:10:41\n   |\n10 | \
    \        .filter(|(a, b)| a.is_ok() && b.is_ok())\n   |                      \
    \                   ^^^^^ method not found in `&isize`\n\nerror[E0593]: closure\
    \ is expected to take 1 argument, but it takes 2 arguments\n  --> /tmp/tmpzqxd9j45.rs:16:10\n\
    \   |\n16 |         .filter(|&(_, a), &(_, b)| a == b)\n   |          ^^^^^^ ------------------\
    \ takes 2 arguments\n   |          |\n   |          expected closure that takes\
    \ 1 argument\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzqxd9j45.rs:12:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n12 | /     m\n13 | |         .iter()\n14 | |  \
    \       .cloned()\n15 | |         .zip(m.iter().cloned())\n16 | |         .filter(|&(_,\
    \ a), &(_, b)| a == b)\n17 | |         .collect::<Vec<_>>()\n   | |____________________________^\
    \ expected `isize`, found tuple\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<((&isize, isize), (&isize, isize))>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0593, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut it1 = l1.iter().cloned().peekable();\n    let mut it2 = l2.iter().cloned().peekable();\n\
    \    let mut it2_next = it2.peek();\n    while let Some(val2) = it2 {\n      \
    \  if it1 == it2_next {\n            result.push(*it1);\n            it1.next();\n\
    \            it2_next.next();\n        } else if *it1 < *val2 {\n            result.push(*it1);\n\
    \            it1.next();\n        } else {\n            result.push(*val2);\n\
    \            it2_next.next();\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjsov2tyq.rs:11:15\n   |\n\
    11 |     while let Some(val2) = it2 {\n   |               ^^^^^^^^^^   --- this\
    \ expression has type `Peekable<Cloned<std::slice::Iter<'_, isize>>>`\n   |  \
    \             |\n   |               expected struct `Peekable`, found enum `Option`\n\
    \   |\n   = note: expected struct `Peekable<Cloned<std::slice::Iter<'_, isize>>>`\n\
    \                found enum `Option<_>`\nhelp: you might have meant to use field\
    \ `peeked` whose type is `Option<Option<<Cloned<std::slice::Iter<'_, isize>> as\
    \ Iterator>::Item>>`\n   |\n11 |     while let Some(val2) = it2.peeked {\n   |\
    \                            ~~~~~~~~~~\n\nerror[E0369]: binary operation `==`\
    \ cannot be applied to type `Peekable<Cloned<std::slice::Iter<'_, isize>>>`\n\
    \  --> /tmp/tmpjsov2tyq.rs:12:16\n   |\n12 |         if it1 == it2_next {\n  \
    \ |            --- ^^ -------- Option<&isize>\n   |            |\n   |       \
    \     Peekable<Cloned<std::slice::Iter<'_, isize>>>\n\nerror[E0614]: type `Peekable<Cloned<std::slice::Iter<'_,\
    \ isize>>>` cannot be dereferenced\n  --> /tmp/tmpjsov2tyq.rs:13:25\n   |\n13\
    \ |             result.push(*it1);\n   |                         ^^^^\n\nerror[E0599]:\
    \ no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpjsov2tyq.rs:15:22\n\
    \   |\n15 |             it2_next.next();\n   |                      ^^^^ method\
    \ not found in `Option<&isize>`\n\nerror[E0614]: type `Peekable<Cloned<std::slice::Iter<'_,\
    \ isize>>>` cannot be dereferenced\n  --> /tmp/tmpjsov2tyq.rs:16:19\n   |\n16\
    \ |         } else if *it1 < *val2 {\n   |                   ^^^^\n\nerror[E0614]:\
    \ type `Peekable<Cloned<std::slice::Iter<'_, isize>>>` cannot be dereferenced\n\
    \  --> /tmp/tmpjsov2tyq.rs:17:25\n   |\n17 |             result.push(*it1);\n\
    \   |                         ^^^^\n\nerror[E0599]: no method named `next` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpjsov2tyq.rs:21:22\n  \
    \ |\n21 |             it2_next.next();\n   |                      ^^^^ method\
    \ not found in `Option<&isize>`\n\nerror: aborting due to 7 previous errors\n\n\
    Some error"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut a = l1;\n    let mut b = l2;\n\
    \    loop {\n        if a.len() == b.len() {\n            a.sort();\n        \
    \    b.sort();\n        }\n        if a.len() < b.len() {\n            return\
    \ b;\n        }\n        b.swap(0, a.len());\n    }\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 7 but the
    index is 7'', /tmp/tmpmonyv1j4.rs:17:11

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in\
    \ l1.iter().zip(l2.iter()) {\n        if i.1 == i.2 {\n            result.push(i.0);\n\
    \        }\n    }\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `2` on type `(&isize, &isize)`\n --> /tmp/tmpdj6v1n7c.rs:9:21\n\
    \  |\n9 |         if i.1 == i.2 {\n  |                     ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdj6v1n7c.rs:14:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n14 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // We are lazy and only need to keep track\
    \ of the current first element seen\n    // to know where to insert the second\
    \ element.\n    let mut n = 0;\n    let mut i = 0;\n    let mut last: Option<isize>\
    \ = None;\n    let mut first: Option<isize> = None;\n    for &el in l1.iter()\
    \ {\n        if el == l2[n as usize] {\n            if n == 0 {\n            \
    \    // If this is the first element, then we keep the first seen and then\n \
    \               // insert the second element.\n                first = Some(i);\n\
    \            }\n            i += 1;\n        } else {\n            n = 1;\n  \
    \          first = Some(i);\n        }\n        if i == l2.len() {\n         \
    \   // The second element was already inserted. Store the location of the second\n\
    \            // element.\n            last = Some(i);\n        }\n    }\n    if\
    \ first == None {\n        last = Some(i);\n    }\n    if n == 0 {\n        //\
    \ If no elements were found, then just append the second element. This should\n\
    \        // only happen if the vectors are empty.\n        last = Some(l2.len());\n\
    \    }\n    // If both elements are found in the same position, then the elements\
    \ are equal.\n    // We return an empty vector to indicate this.\n    if let Some(i)\
    \ = first {\n        if let Some(i) = last {\n            if i == l2.len() {\n\
    \                return vec![];\n            }\n        }\n        return vec![i];\n\
    \    }\n    if let Some(i) = last {\n        if i == l1.len() {\n            return\
    \ vec![i];\n        }\n    }\n    // The two elements are not in the same positions.\
    \ We append them and sort them.\n    let mut ret = vec![l2[0]];\n    for i in\
    \ 0..l2.len() {\n        if i != 0 {\n            ret.push(l2[i]);\n        }\n\
    \    }\n    ret.sort();\n    ret\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvbo2anty.rs:25:17\n   |\n\
    25 |         if i == l2.len() {\n   |                 ^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if i == l2.len().try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvbo2anty.rs:37:21\n   |\n37 |         last = Some(l2.len());\n\
    \   |                     ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n37 |         last = Some(l2.len().try_into().unwrap());\n   |   \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvbo2anty.rs:43:21\n   |\n43 |             if i == l2.len() {\n\
    \   |                     ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n43 |             if i == l2.len().try_into().unwrap() {\n   |   \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvbo2anty.rs:50:17\n   |\n50 |         if i == l1.len() {\n   |\
    \                 ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n50 |         if i == l1.len().try_into().unwrap() {\n   |             \
    \            ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n   \
    \         result.push(*l2.pop());\n        } else if l2.len() == 0 {\n       \
    \     result.push(*l1.pop());\n        } else {\n            if l1.last() == l2.last()\
    \ {\n                result.push(*l1.pop());\n                l1.pop();\n    \
    \        } else {\n                result.push(*l1.pop());\n                l2.pop();\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2n0z7xxz.rs:13:25\n\
    \   |\n13 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp2n0z7xxz.rs:15:25\n   |\n15 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp2n0z7xxz.rs:18:29\n   |\n18 |        \
    \         result.push(*l1.pop());\n   |                             ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2n0z7xxz.rs:21:29\n\
    \   |\n21 |                 result.push(*l1.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // sort both vectors\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n\n    // iterate through l1, and find the element that\
    \ appears in l2, return the\n    // index of that element in l2\n    let mut idx\
    \ = 0;\n    let mut found = false;\n    while !found {\n        found = l2[l1.iter().position(|&x|\
    \ *x == *l2[idx])].is_some();\n        if found {\n            // increment the\
    \ index\n            idx += 1;\n        }\n    }\n    // return the result vector\n\
    \    l2.iter()\n        .take(l1.iter().position(|&x| *x == *l2[idx]))\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp4z0wzmym.rs:16:44\n\
    \   |\n16 |         found = l2[l1.iter().position(|&x| *x == *l2[idx])].is_some();\n\
    \   |                                            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp4z0wzmym.rs:16:50\n   |\n16 |        \
    \ found = l2[l1.iter().position(|&x| *x == *l2[idx])].is_some();\n   |       \
    \                                           ^^^^^^^^\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmp4z0wzmym.rs:16:17\n\
    \   |\n16 |         found = l2[l1.iter().position(|&x| *x == *l2[idx])].is_some();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<isize>`\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmp4z0wzmym.rs:24:39\n   |\n24 |\
    \         .take(l1.iter().position(|&x| *x == *l2[idx]))\n   |               \
    \                        ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp4z0wzmym.rs:24:45\n   |\n24 |         .take(l1.iter().position(|&x|\
    \ *x == *l2[idx]))\n   |                                             ^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4z0wzmym.rs:24:15\n   |\n24 |\
    \         .take(l1.iter().position(|&x| *x == *l2[idx]))\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmp4z0wzmym.rs:25:10\n\
    \     |\n25   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c: Vec<isize> = l1.iter().cloned().collect();\n\
    \    c.sort();\n    c = c.dedup();\n    c.extend(l2.iter().cloned().collect());\n\
    \    c\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpysc22c_f.rs:9:9\n  |\n7 |\
    \     let mut c: Vec<isize> = l1.iter().cloned().collect();\n  |             \
    \   ---------- expected due to this type\n8 |     c.sort();\n9 |     c = c.dedup();\n\
    \  |         ^^^^^^^^^ expected struct `Vec`, found `()`\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\nnote: method `dedup` modifies\
    \ its receiver in-place\n --> /tmp/tmpysc22c_f.rs:9:11\n  |\n9 |     c = c.dedup();\n\
    \  |         - ^^^^^ this call modifies `c` in-place\n  |         |\n  |     \
    \    you probably want to use this value after calling the method...\n  = note:\
    \ ...instead of the `()` output of method `dedup`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() {\n        panic!(\"\
    Vectors must be same length.\")\n    }\n    let mut l = l1.iter();\n    l.zip(l2.iter()).map(|(a,\
    \ b)| (*a).cmp(*b)).collect_vec()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp279b3pvp.rs:11:44\n   |\n\
    11 |     l.zip(l2.iter()).map(|(a, b)| (*a).cmp(*b)).collect_vec()\n   |     \
    \                                       ^^\n   |                             \
    \               |\n   |                                            expected `&isize`,\
    \ found `isize`\n   |                                            help: consider\
    \ borrowing here: `&*b`\n\nerror[E0599]: no method named `collect_vec` found for\
    \ struct `Map` in the current scope\n  --> /tmp/tmp279b3pvp.rs:11:49\n   |\n11\
    \ |     l.zip(l2.iter()).map(|(a, b)| (*a).cmp(*b)).collect_vec()\n   |      \
    \                                           ^^^^^^^^^^^ method not found in `Map<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmp279b3pvp.rs:11:26: 11:47]>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut lv = l1.to_vec();\n    lv.sort();\n\
    \    let mut lv2: Vec<isize> = l2.to_vec();\n    vec![lv.iter().collect::<Vec<_>>()].intersect(lv2.iter()).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `intersect` found for struct `Vec<Vec<&isize>>`\
    \ in the current scope\n  --> /tmp/tmpgs548g0l.rs:10:41\n   |\n10 |     vec![lv.iter().collect::<Vec<_>>()].intersect(lv2.iter()).collect()\n\
    \   |                                         ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `insert`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set = HashSet::new();\n    for\
    \ &item in l1 {\n        set.insert(item);\n    }\n    for &item in l2 {\n   \
    \     if !set.contains(item) {\n            set.insert(item);\n        }\n   \
    \ }\n    set.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp6q9zm1dc.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp6q9zm1dc.rs:8:9\n  |\n8 |     for &item in l1 {\n  |   \
    \      ^^^^^    -- this expression has type `Option<isize>`\n  |         |\n \
    \ |         expected `isize`, found reference\n  |         help: you can probably\
    \ remove the explicit borrow: `item`\n  |\n  = note:   expected type `isize`\n\
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6q9zm1dc.rs:11:9\n\
    \   |\n11 |     for &item in l2 {\n   |         ^^^^^    -- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `item`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1;\n    let mut l1 =\
    \ l1.iter().cloned().collect::<Vec<isize>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<isize>>();\n\
    \    while l1.len() > 0 && l2.len() > 0 {\n        if *l1[0] > *l2[0] {\n    \
    \        result.pop();\n            l1.pop();\n        } else {\n            result.pop();\n\
    \            l2.pop();\n        }\n    }\n    while l1.len() > 0 {\n        result.pop();\n\
    \        l1.pop();\n    }\n    while l2.len() > 0 {\n        result.pop();\n \
    \       l2.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpod97wb47.rs:11:12\n\
    \   |\n11 |         if *l1[0] > *l2[0] {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpod97wb47.rs:11:21\n   |\n\
    11 |         if *l1[0] > *l2[0] {\n   |                     ^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 && l2.len() > 0 {\n        if l1.remove(&l1[0])\
    \ == l2[0] {\n            result.append(l1[0]);\n            l1.remove(&l1[0]);\n\
    \        } else {\n            l2.remove(&l2[0]);\n        }\n    }\n    while\
    \ l1.len() > 0 {\n        result.append(l1[0]);\n        l1.remove(&l1[0]);\n\
    \    }\n    while l2.len() > 0 {\n        result.append(l2[0]);\n        l2.remove(&l2[0]);\n\
    \    }\n    result.into_iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq1m_yjeb.rs:11:22\n   |\n\
    11 |         if l1.remove(&l1[0]) == l2[0] {\n   |                      ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1m_yjeb.rs:12:27\n\
    \   |\n12 |             result.append(l1[0]);\n   |                          \
    \ ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq1m_yjeb.rs:13:23\n   |\n13 |             l1.remove(&l1[0]);\n\
    \   |                       ^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq1m_yjeb.rs:15:23\n   |\n15 |             l2.remove(&l2[0]);\n\
    \   |                       ^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq1m_yjeb.rs:19:23\n   |\n19 |         result.append(l1[0]);\n\
    \   |                       ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n\
    \   = note: expected mutable reference `&mut Vec<_>`\n                       \
    \    found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1m_yjeb.rs:20:19\n\
    \   |\n20 |         l1.remove(&l1[0]);\n   |                   ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1m_yjeb.rs:23:23\n\
    \   |\n23 |         result.append(l2[0]);\n   |                       ^^^^^ expected\
    \ `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq1m_yjeb.rs:24:19\n   |\n24 |         l2.remove(&l2[0]);\n\
    \   |                   ^^^^^^ expected `usize`, found `&isize`\n\nerror: aborting\
    \ due to 8 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() != l2.len() {\n        panic!(\"\
    Vectors must be the same length.\")\n    }\n    let mut lc: Vec<isize> = vec![];\n\
    \    let mut i = 0;\n    while i < l1.len() {\n        let found = false;\n  \
    \      for j in 0..i.i+1 {\n            if l1[i] == l2[j] {\n                found\
    \ = true;\n                lc.push(l1[i]);\n                i += 1;\n        \
    \        break;\n            }\n        }\n        if !found {\n            lc.push(l1[i]);\n\
    \            i += 1;\n        }\n    }\n    lc\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp5qigmanl.rs:14:23\n   |\n14 |         for j in 0..i.i+1 {\n   |\
    \                       ^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0610`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i\
    \ in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphves377b.rs:9:36\n  |\n9 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n9 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphves377b.rs:13:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n13 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.clone();\n    let mut l2\
    \ = l2.clone();\n    let mut l3: Vec<isize> = vec![];\n    while l1.len() != 0\
    \ || l2.len() != 0 {\n        let mut min = 0;\n        if l1.len() != 0 {\n \
    \           min = l1.iter().min().unwrap();\n        }\n        if l2.len() !=\
    \ 0 {\n            min = if min > l2.iter().min().unwrap() { min } else { min\
    \ };\n        }\n        l3.push(min);\n        l1.remove(min);\n        l2.remove(min);\n\
    \    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzt1xhjed.rs:13:19\n   |\n\
    11 |         let mut min = 0;\n   |                       - expected due to this\
    \ value\n12 |         if l1.len() != 0 {\n13 |             min = l1.iter().min().unwrap();\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n13 |             min = *l1.iter().min().unwrap();\n\
    \   |                   +\n\nerror[E0277]: can't compare `isize` with `&isize`\n\
    \  --> /tmp/tmpzt1xhjed.rs:16:26\n   |\n16 |             min = if min > l2.iter().min().unwrap()\
    \ { min } else { min };\n   |                          ^ no implementation for\
    \ `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzt1xhjed.rs:19:19\n   |\n19 |         l1.remove(min);\n   |        \
    \           ^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n19\
    \ |         l1.remove(min.try_into().unwrap());\n   |                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzt1xhjed.rs:20:19\n   |\n20 |\
    \         l2.remove(min);\n   |                   ^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |         l2.remove(min.try_into().unwrap());\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1.to_vec();\n    let mut\
    \ v2 = l2.to_vec();\n    let mut common = Vec::new();\n\n    while v1.len() >\
    \ 0 && v2.len() > 0 {\n        if *v1.get() as u64 == *v2.get() as u64 {\n   \
    \         common.push(*v1.get() as isize);\n            v1.pop();\n          \
    \  v2.pop();\n        } else {\n            while v1.len() > 0 && v2.len() > 0\
    \ {\n                common.push(*v1.get() as isize);\n                v1.pop();\n\
    \                v2.pop();\n            }\n        }\n    }\n\n    while v1.len()\
    \ > 0 {\n        common.push(*v1.get() as isize);\n        v1.pop();\n    }\n\n\
    \    while v2.len() > 0 {\n        common.push(*v2.get() as isize);\n        v2.pop();\n\
    \    }\n\n    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpy8__mgzc.rs:12:16\n    |\n12  |         if *v1.get() as u64 ==\
    \ *v2.get() as u64 {\n    |                ^^^- supplied 0 arguments\n    |  \
    \              |\n    |                expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0614]: type `Option<&_>` cannot be dereferenced\n\
    \  --> /tmp/tmpy8__mgzc.rs:12:12\n   |\n12 |         if *v1.get() as u64 == *v2.get()\
    \ as u64 {\n   |            ^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmpy8__mgzc.rs:12:36\n    |\n12 \
    \ |         if *v1.get() as u64 == *v2.get() as u64 {\n    |                 \
    \                   ^^^- supplied 0 arguments\n    |                         \
    \           |\n    |                                    expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0614]: type `Option<&_>`\
    \ cannot be dereferenced\n  --> /tmp/tmpy8__mgzc.rs:12:32\n   |\n12 |        \
    \ if *v1.get() as u64 == *v2.get() as u64 {\n   |                            \
    \    ^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmpy8__mgzc.rs:13:29\n    |\n13  |             common.push(*v1.get()\
    \ as isize);\n    |                             ^^^- supplied 0 arguments\n  \
    \  |                             |\n    |                             expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0614]: type\
    \ `Option<&_>` cannot be dereferenced\n  --> /tmp/tmpy8__mgzc.rs:13:25\n   |\n\
    13 |             common.push(*v1.get() as isize);\n   |                      \
    \   ^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmpy8__mgzc.rs:18:33\n    |\n18  |              \
    \   common.push(*v1.get() as isize);\n    |                                 ^^^-\
    \ supplied 0 arguments\n    |                                 |\n    |       \
    \                          expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0614]: type `Option<&_>` cannot be dere"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    lazy_static! {\n        static ref LEN:\
    \ usize = std::cmp::max(l1.len(), l2.len());\n        static ref SMALL: usize\
    \ = std::cmp::max(l1.len() / 2, l2.len() / 2);\n        static ref BIG: usize\
    \ = std::cmp::max(\n            std::cmp::min(l1.len() / 2, l2.len() / 2),\n \
    \           std::cmp::min(l1.len() / 2, l2.len() / 2),\n        );\n    }\n\n\
    \    let len = std::cmp::max(l1.len(), l2.len());\n    let small = l1.len() /\
    \ 2;\n    let big = std::cmp::max(l1.len() / 2, l2.len() / 2);\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \n    let mut i = 0;\n    let mut j = 0;\n\n    while i < len {\n        let mut\
    \ cmp = std::cmp::max(l1.len(), l2.len());\n        let small = std::cmp::max(l1.len()\
    \ / 2, l2.len() / 2);\n        let big = std::cmp::max(std::cmp::min(l1.len()\
    \ / 2, l2.len() / 2), std::cmp::min(l1.len() / 2, l2.len() / 2));\n\n        while\
    \ cmp > 0 {\n            if i < j {\n                l1.swap(i, j);\n        \
    \        cmp = cmp - 1;\n                i += 1;\n                j += 1;\n  \
    \              continue;\n            }\n\n            if i >= big {\n       \
    \         l2.swap(i, j);\n                cmp = cmp - 1;\n                i +=\
    \ 1;\n                j += 1;\n                continue;\n            }\n\n  \
    \          if j < small {\n                l1.swap(i, j);\n                cmp\
    \ = cmp - 1;\n                i += 1;\n                j += 1;\n             \
    \   continue;\n            }\n\n            l1.swap(i, j);\n            i += 1;\n\
    \            j += 1;\n        }\n    }\n\n    Vec::from_elem(l1.iter(), &l1)\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpk5s3nfxe.rs:7:5\n\
    \  |\n7 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0599]: no function\
    \ or associated item named `from_elem` found for struct `Vec<_, _>` in the current\
    \ scope\n  --> /tmp/tmpk5s3nfxe.rs:61:10\n   |\n61 |     Vec::from_elem(l1.iter(),\
    \ &l1)\n   |          ^^^^^^^^^ function or associated item not found in `Vec<_,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut vec = vec![];\n\n    for v in l1.iter().chain(l2.iter())\
    \ {\n        if vec.iter().any(|&x| x == v) {\n            continue;\n       \
    \ }\n\n        vec.push(v);\n    }\n\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd17sma4i.rs:17:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n17 |     vec\n   |     ^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() < l2.len() {\n        (l1 &\
    \ l2).clone()\n    } else {\n        (l2 & l1).clone()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `Vec<isize> & Vec<isize>`\n --> /tmp/tmp853bz01w.rs:8:13\n\
    \  |\n8 |         (l1 & l2).clone()\n  |          -- ^ -- Vec<isize>\n  |    \
    \      |\n  |          Vec<isize>\n\nerror[E0369]: no implementation for `Vec<isize>\
    \ & Vec<isize>`\n  --> /tmp/tmp853bz01w.rs:10:13\n   |\n10 |         (l2 & l1).clone()\n\
    \   |          -- ^ -- Vec<isize>\n   |          |\n   |          Vec<isize>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)|\
    \ a == b).map(|(a, b)| a).collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpzfy_awtp.rs:7:70\n     |\n7\
    \    |     l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).map(|(a, b)| a).collect()\n\
    \     |                                                                      ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  let mut c = Vec::new();\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] < l2[j] {\n            c.push(l1[i]);\n            i += 1;\n      \
    \  } else {\n            c.push(l2[j]);\n            j += 1;\n        }\n    }\n\
    \    if i == l1.len() {\n        c\n    } else if j == l2.len() {\n        c\n\
    \    } else {\n        c.clone()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpiwl_02sa.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    common_inner(l1, l2, true)\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `common_inner` in this scope\n --> /tmp/tmp5rf2la70.rs:7:5\n\
    \  |\n7 |     common_inner(l1, l2, true)\n  |     ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().cloned().chain(l2.iter().cloned()).collect::<Vec<_>>()\n\
    \        .sort_by(|a, b| {\n            if *a > *b {\n                -1\n   \
    \         } else {\n                1\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyq_4u1cs.rs:10:17\n   |\n\
    10 |                 -1\n   |                 ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyq_4u1cs.rs:12:17\n\
    \   |\n12 |                 1\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpyq_4u1cs.rs:15:10\n\
    \   |\n15 |         .collect()\n   |          ^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c = vec![];\n    for &x in l1 {\n\
    \        if l2.iter().any(|&y| *y == x) {\n            c.push(x);\n        }\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq8pdzuxl.rs:8:9\n  |\n8 |\
    \     for &x in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `x`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n --> /tmp/tmpq8pdzuxl.rs:9:31\n  |\n9 |         if l2.iter().any(|&y|\
    \ *y == x) {\n  |                               ^^\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common = vec![0; l1.len()];\n \
    \   for i in (0..l1.len()).rev() {\n        let index = l1[i] as usize;\n    \
    \    if l2.contains(index) {\n            common[i] = index;\n        }\n    }\n\
    \    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbnt3of0.rs:10:24\n   |\n\
    10 |         if l2.contains(index) {\n   |                        ^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppbnt3of0.rs:14:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n14 |     common\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] < l2[j] {\n            i += 1;\n        } else {\n            result\
    \ += l1[i..].to_vec();\n            i += 1;\n        }\n        j += 1\n    }\n\
    \    result += l1[i..].to_vec();\n    result.sort();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<_>`\n  --> /tmp/tmpb35qpfa8.rs:14:13\n   |\n14 |             result +=\
    \ l1[i..].to_vec();\n   |             ------^^^^^^^^^^^^^^^^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpb35qpfa8.rs:19:5\n\
    \   |\n19 |     result += l1[i..].to_vec();\n   |     ------^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Vec<_>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0368`.\n"
  stdout: ''
  timestamp: 1659976131
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort();\n  \
    \  l2.sort();\n    let mut common = Vec::new();\n    while l1.len() != 0 && l2.len()\
    \ != 0 {\n        if l1[0] > l2[0] {\n            l1.remove(0);\n        } else\
    \ {\n            l2.remove(0);\n        }\n        common.push(l1[0]);\n     \
    \   l1.remove(0);\n        l2.remove(0);\n    }\n    while l1.len() != 0 {\n \
    \       common.push(l1[0]);\n        l1.remove(0);\n    }\n    while l2.len()\
    \ != 0 {\n        common.push(l2[0]);\n        l2.remove(0);\n    }\n    common\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''removal index (is 0) should be < len (is
    0)'', /tmp/tmp10rv1f2u.rs:20:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c: Vec<isize> = l1.iter().cloned().collect();\n\
    \    c.sort();\n    c.dedup();\n    c.iter().zip(l2.iter().cloned().collect()).filter(|(_,\
    \ y)| y == true).collect()\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&_` with `bool`\n  --> /tmp/tmp38vpue38.rs:10:66\n\
    \   |\n10 |     c.iter().zip(l2.iter().cloned().collect()).filter(|(_, y)| y ==\
    \ true).collect()\n   |                                                      \
    \            ^^ no implementation for `&_ == bool`\n   |\n   = help: the trait\
    \ `PartialEq<bool>` is not implemented for `&_`\n\nerror[E0277]: a value of type\
    \ `Vec<isize>` cannot be built from an iterator over elements of type `(&isize,\
    \ _)`\n    --> /tmp/tmp38vpue38.rs:10:75\n     |\n10   |     c.iter().zip(l2.iter().cloned().collect()).filter(|(_,\
    \ y)| y == true).collect()\n     |                                           \
    \                                ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=(&isize, _)>`\n     |\n     = help: the\
    \ trait `FromIterator<(&isize, _)>` is not implemented for `Vec<isize>`\n    \
    \ = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in\
    \ l1.iter() {\n        if l2.iter().any(|j| i == j) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpapbkepn0.rs:13:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n13 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize> = vec![];\n   \
    \ for (i, e1) in l1.iter().enumerate() {\n        for (j, e2) in l2.iter().enumerate()\
    \ {\n            if e1 == e2 {\n                if i != j {\n                \
    \    ret.append(e1);\n                }\n                continue;\n         \
    \   }\n            if i == j {\n                continue;\n            }\n   \
    \         if e1 < e2 {\n                ret.append(e1);\n            } else {\n\
    \                ret.append(e2);\n            }\n        }\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqqhibqc6.rs:12:32\n   |\n\
    12 |                     ret.append(e1);\n   |                               \
    \ ^^ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<isize>`\n                      found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqqhibqc6.rs:20:28\n   |\n20 |              \
    \   ret.append(e1);\n   |                            ^^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut Vec<isize>`\n             \
    \         found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqqhibqc6.rs:22:28\n\
    \   |\n22 |                 ret.append(e2);\n   |                            ^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<isize>`\n                      found reference `&isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = HashSet::new();\n    for &i\
    \ in l1.iter() {\n        if !s.insert(i) {\n            continue;\n        }\n\
    \        for &j in l2.iter() {\n            if i == j {\n                continue;\n\
    \            }\n            if !s.insert(j) {\n                continue;\n   \
    \         }\n        }\n        return vec![];\n    }\n    return l1;\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpjz_uknkx.rs:7:17\n  |\n7 |     let mut s = HashSet::new();\n  |    \
    \             ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i\
    \ in l1.iter() {\n        match l2.iter().position(|&x| x == i) {\n          \
    \  Some(i2) => {\n                result.push(i);\n            }\n           \
    \ None => {}\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwuroi46e.rs:9:44\n  |\n9 |\
    \         match l2.iter().position(|&x| x == i) {\n  |                       \
    \                     ^ expected `isize`, found `&isize`\n  |\nhelp: consider\
    \ dereferencing the borrow\n  |\n9 |         match l2.iter().position(|&x| x ==\
    \ *i) {\n  |                                            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwuroi46e.rs:16:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n16 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut iter1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut iter2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut itc\
    \ = iter1.clone();\n    let mut res: Vec<_> = iter1.clone();\n    while iter1.any()\
    \ || iter2.any() {\n        if iter1.any() && iter2.any() {\n            if iter1.any()\
    \ == iter2.any() {\n                res.push(iter1.pop().unwrap());\n        \
    \        iter2.pop();\n            } else {\n                let mut itc1 = iter1.iter().cloned().collect::<Vec<_>>();\n\
    \                let mut itc2 = iter2.iter().cloned().collect::<Vec<_>>();\n \
    \               while itc1.any() || itc2.any() {\n                    if itc1.any()\
    \ && itc2.any() {\n                        if itc1.any() == itc2.any() {\n   \
    \                         res.push(itc1.pop().unwrap());\n                   \
    \         itc2.pop();\n                        } else {\n                    \
    \        let mut itc3 = itc.iter().cloned().collect::<Vec<_>>();\n           \
    \                 while itc3.any() {\n                                res.push(itc3.pop().unwrap());\n\
    \                            }\n                            iter2.pop();\n   \
    \                         iter1.pop();\n                            itc1.pop();\n\
    \                            itc2.pop();\n                        }\n        \
    \            } else if itc1.any() {\n                        res.push(itc1.pop().unwrap());\n\
    \                        itc1.pop();\n                    } else if itc2.any()\
    \ {\n                        res.push(itc2.pop().unwrap());\n                \
    \        itc2.pop();\n                    } else {\n                        itc3.pop();\n\
    \                    }\n                }\n                iter1.pop();\n    \
    \            iter2.pop();\n            }\n        } else if iter1.any() {\n  \
    \          res.push(iter1.pop().unwrap());\n            iter1.pop();\n       \
    \ } else if iter2.any() {\n            res.push(iter2.pop().unwrap());\n     \
    \       iter2.pop();\n        } else {\n            itc.pop();\n        }\n  \
    \  }\n    if res.is_empty() {\n        res\n    } else {\n        res\n    }\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `itc3` in this scope\n  --> /tmp/tmpg5h1t2ox.rs:41:25\n\
    \   |\n41 |                         itc3.pop();\n   |                        \
    \ ^^^^ help: a local variable with a similar name exists: `itc`\n\nerror[E0599]:\
    \ no method named `any` found for struct `Vec<isize>` in the current scope\n \
    \ --> /tmp/tmpg5h1t2ox.rs:11:17\n   |\n11 |     while iter1.any() || iter2.any()\
    \ {\n   |                 ^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `any` found for struct `Vec<isize>` in the current scope\n \
    \ --> /tmp/tmpg5h1t2ox.rs:11:32\n   |\n11 |     while iter1.any() || iter2.any()\
    \ {\n   |                                ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpg5h1t2ox.rs:12:18\n   |\n12 |         if iter1.any() &&\
    \ iter2.any() {\n   |                  ^^^ method not found in `Vec<isize>`\n\n\
    error[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpg5h1t2ox.rs:12:33\n   |\n12 |         if iter1.any() &&\
    \ iter2.any() {\n   |                                 ^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpg5h1t2ox.rs:13:22\n   |\n13 |          \
    \   if iter1.any() == iter2.any() {\n   |                      ^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpg5h1t2ox.rs:13:37\n   |\n13\
    \ |             if iter1.any() == iter2.any() {\n   |                        \
    \             ^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `any` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpg5h1t2ox.rs:19:28\n\
    \   |\n19 |                 while itc1.any() || itc2.any() {\n   |           \
    \                 ^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `any` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpg5h1t2ox.rs:19:42\n\
    \   |\n19 |                 w"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common = vec![];\n    for i in\
    \ l1.iter() {\n        for j in l2.iter() {\n            if i != j && l1.iter().any(|&x|\
    \ x == i) && l2.iter().any(|&x| x == j) {\n                common.push(i);\n \
    \               break;\n            }\n        }\n    }\n    common\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaxo2dsgl.rs:10:50\n   |\n\
    10 |             if i != j && l1.iter().any(|&x| x == i) && l2.iter().any(|&x|\
    \ x == j) {\n   |                                                  ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    10 |             if i != j && l1.iter().any(|&x| x == *i) && l2.iter().any(|&x|\
    \ x == j) {\n   |                                                  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaxo2dsgl.rs:10:80\n   |\n10 |             if\
    \ i != j && l1.iter().any(|&x| x == i) && l2.iter().any(|&x| x == j) {\n   | \
    \                                                                            \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n10 |             if i != j && l1.iter().any(|&x| x == i) && l2.iter().any(|&x|\
    \ x == *j) {\n   |                                                           \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxo2dsgl.rs:16:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n16 |     common\n   |     ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut a = l1.clone();\n    let mut b\
    \ = l2.clone();\n    a.sort_unstable();\n    b.sort_unstable();\n    a.dedup();\n\
    \    b.dedup();\n    b.retain(a.iter());\n    b\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `std::slice::Iter<'_,\
    \ isize>`\n    --> /tmp/tmp_h1lctch.rs:13:14\n     |\n13   |     b.retain(a.iter());\n\
    \     |       ------ ^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found `std::slice::Iter<'_,\
    \ isize>`\n     |       |\n     |       required by a bound introduced by this\
    \ call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is not implemented\
    \ for `std::slice::Iter<'_, isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut m = l1.len();\n    let mut n =\
    \ l2.len();\n    let mut j = 0;\n    let mut i = 0;\n    let mut min = l1.len();\n\
    \    while j < n {\n        if l1[j] < l2[i] {\n            m--;\n           \
    \ i += 1;\n        } else {\n            j += 1;\n        }\n        if m < 0\
    \ {\n            m = l1.len();\n        }\n        if n < 0 {\n            n =\
    \ l2.len();\n        }\n    }\n    if i < l2.len() {\n        min = i;\n    }\n\
    \    let mut k = i;\n    while k < min {\n        l1.swap(k, k+1);\n        k\
    \ += 1;\n    }\n    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpf8u54wos.rs:14:16\n\
    \   |\n14 |             m--;\n   |                ^ expected expression\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return vec![];\n    }\n    if l1.len() == 1 {\n        return l2;\n  \
    \  }\n    if l2.len() == 1 {\n        return l1;\n    }\n    let mut l3: Vec<isize>\
    \ = l1.iter().cloned().collect();\n    let mut l4: Vec<isize> = l2.iter().cloned().collect();\n\
    \    while l3.len() != l4.len() {\n        if l3[l3.len() - 1] > l4[l4.len() -\
    \ 1] {\n            l3.remove(l3.len() - 1);\n        } else {\n            l4.remove(l4.len()\
    \ - 1);\n        }\n    }\n    l3.reverse();\n    l4.reverse();\n    l3.clone()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 2, 653, 34, 3, 4, 1]`,\n right: `[1, 5, 653]`', /tmp/tmp9_mgv3iy.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l = vec![];\n    l1.into_iter().cloned().sort_unstable().cloned().dedup().cloned().push_front(l1.iter().cloned().cloned().last().unwrap());\n\
    \    l2.into_iter().cloned().sort_unstable().cloned().dedup().cloned().push_front(l2.iter().cloned().cloned().last().unwrap());\n\
    \    l.iter().cloned().dedup().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpz28aa9s8.rs:8:20\n     |\n8    |     l1.into_iter().cloned().sort_unstable().cloned().dedup().cloned().push_front(l1.iter().cloned().cloned().last().unwrap());\n\
    \     |                    ^^^^^^ expected reference, found `isize`\n     |\n\
    \     = note: expected reference `&_`\n                     found type `isize`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: no method named `sort_unstable`\
    \ found for struct `Cloned` in the current scope\n --> /tmp/tmpz28aa9s8.rs:8:29\n\
    \  |\n8 |     l1.into_iter().cloned().sort_unstable().cloned().dedup().cloned().push_front(l1.iter().cloned().cloned().last().unwrap());\n\
    \  |                             ^^^^^^^^^^^^^ method not found in `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as Iterator>::Item\
    \ == &&_`\n    --> /tmp/tmpz28aa9s8.rs:8:101\n     |\n8    |     l1.into_iter().cloned().sort_unstable().cloned().dedup().cloned().push_front(l1.iter().cloned().cloned().last().unwrap());\n\
    \     |                                                                      \
    \                               ^^^^^^ expected reference, found `isize`\n   \
    \  |\n     = note: expected reference `&&_`\n                found reference `&isize`\n\
    \     = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `last` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpz28aa9s8.rs:8:110\n\
    \   |\n8  |       l1.into_iter().cloned().sort_unstable().cloned().dedup().cloned().push_front(l1.iter().cloned().cloned().last().unwrap());\n\
    \   |                                                                        \
    \                                        ^^^^ method cannot be called on `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait "
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut cur = l1.clone();\n    let mut count = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if *cur != *l2[count] {\n          \
    \  i += 1;\n        } else {\n            count += 1;\n        }\n        cur.push(*cur);\n\
    \    }\n    cur.truncate(count);\n    l2.append(&mut cur);\n    l1\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp3jer9or9.rs:16:20\n\
    \   |\n16 |         if *cur != *l2[count] {\n   |                    ^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3jer9or9.rs:21:18\n   |\n21 |\
    \         cur.push(*cur);\n   |                  ^^^^ expected `isize`, found\
    \ slice `[isize]`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)|\
    \ a.is_common(&b)).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_common` found for reference `&&isize`\
    \ in the current scope\n --> /tmp/tmpxr9l6qvn.rs:7:48\n  |\n7 |     l1.iter().zip(l2.iter()).filter(|(a,\
    \ b)| a.is_common(&b)).collect::<Vec<_>>()\n  |                              \
    \                  ^^^^^^^^^ method not found in `&&isize`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpxr9l6qvn.rs:7:5\n  |\n6 | fn common(l1: Vec<isize>, l2:\
    \ Vec<isize>) -> Vec<isize> {\n  |                                           \
    \   ---------- expected `Vec<isize>` because of return type\n7 |     l1.iter().zip(l2.iter()).filter(|(a,\
    \ b)| a.is_common(&b)).collect::<Vec<_>>()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n\
    \             found struct `Vec<(&isize, &isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return vec![];\n    }\n\n    // Create a vector of the union of the two\
    \ sets of elements.\n    let mut result = vec![];\n    let mut seen = vec![false;\
    \ l1.len()];\n    for i in l1.iter() {\n        if !seen[i] {\n            result.push(i);\n\
    \            seen[i] = true;\n        }\n    }\n    for i in l2.iter() {\n   \
    \     if !seen[i] {\n            result.push(i);\n            seen[i] = true;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[bool]` cannot be indexed by `&isize`\n  --> /tmp/tmpo8daasto.rs:15:13\n\
    \   |\n15 |         if !seen[i] {\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `&isize`\n  --> /tmp/tmpo8daasto.rs:17:13\n   |\n17 |           \
    \  seen[i] = true;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `&isize`\n  --> /tmp/tmpo8daasto.rs:21:13\n   |\n21 |         if\
    \ !seen[i] {\n   |             ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpo8daasto.rs:23:13\n   |\n23 |             seen[i] = true;\n   |\
    \             ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<bool>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo8daasto.rs:26:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n26 |    "
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    vec!l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(a,\
    \ b)| a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `l1`\n --> /tmp/tmp6wdnb9z1.rs:7:9\n\
    \  |\n7 |     vec!l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(a, b)|\
    \ a == b).collect()\n  |         ^^ expected one of `(`, `[`, or `{`\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1_copy: Vec<isize> = l1.iter().cloned().collect();\n\
    \    let mut l2_copy: Vec<isize> = l2.iter().cloned().collect();\n    l1_copy.sort_unstable();\n\
    \    l2_copy.sort_unstable();\n    l1_copy.dedup();\n    l2_copy.dedup();\n  \
    \  l1_copy.retain(l2_copy);\n    l1_copy\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \    --> /tmp/tmpyh_zhvs1.rs:13:20\n     |\n13   |     l1_copy.retain(l2_copy);\n\
    \     |             ------ ^^^^^^^ expected an `FnMut<(&isize,)>` closure, found\
    \ `Vec<isize>`\n     |             |\n     |             required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is\
    \ not implemented for `Vec<isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    c.sort();\n    if l2.len() <= c.len() {\n        c.extend(l2.iter().cloned().collect::<Vec<_>>());\n\
    \    } else {\n        c.extend(l2.iter().cloned().collect::<Vec<_>>().rev());\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp70hj86jj.rs:12:57\n\
    \    |\n12  |           c.extend(l2.iter().cloned().collect::<Vec<_>>().rev());\n\
    \    |                                                           ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ l1 = l1.to_owned();\n    let mut l2 = l2.to_owned();\n    while l1.len() !=\
    \ 0 || l2.len() != 0 {\n        let mut found = false;\n        if l1.len() ==\
    \ 0 {\n            while l2.len() != 0 {\n                res.push(l2.remove(0));\n\
    \                found = true;\n            }\n        } else if l2.len() == 0\
    \ {\n            while l1.len() != 0 {\n                res.push(l1.remove(0));\n\
    \                found = true;\n            }\n        } else {\n            while\
    \ l1.len() != 0 && l2.len() != 0 {\n                if l1.get(0) < l2.get(0) &&\
    \ (l1.len() == 1 || l2.len() == 1) {\n                    res.push(l1.remove(0));\n\
    \                    found = true;\n                } else {\n               \
    \     res.push(l2.remove(0));\n                    found = true;\n           \
    \     }\n            }\n        }\n        if found {\n            debug!(\"common\
    \ {} and {}\", l1, l2);\n        } else {\n            break;\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmpkcxepkcj.rs:34:13\n\
    \   |\n34 |             debug!(\"common {} and {}\", l1, l2);\n   |          \
    \   ^^^^^\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = l1.len() - 1;\n    let mut\
    \ j = l2.len() - 1;\n    while i >= 0 && j >= 0 {\n        if l1[i] > l2[j] {\n\
    \            i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n\
    \    if j == -1 {\n        i += 1;\n    }\n    if i == -1 {\n        j += 1;\n\
    \    }\n    l1[i..].iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp0f3pivb_.rs:16:13\n\
    \   |\n16 |     if j == -1 {\n   |             ^^\n   |             |\n   |  \
    \           cannot apply unary operator `-`\n   |             help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n  --> /tmp/tmp0f3pivb_.rs:19:13\n   |\n19 |     if i == -1 {\n\
    \   |             ^^\n   |             |\n   |             cannot apply unary\
    \ operator `-`\n   |             help: you may have meant the maximum value of\
    \ `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0600`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1;\n    let mut i = 1;\n \
    \   let mut j = 1;\n    let mut found = false;\n    while i < l.len() && j < l2.len()\
    \ {\n        if l[i] < l[j] {\n            l.swap(i, j);\n            i += 1;\n\
    \            found = true;\n        } else {\n            i += 1;\n          \
    \  found = true;\n        }\n        j += 1\n    }\n    if found {\n        if\
    \ l.len() == l2.len() {\n            return l;\n        }\n        while i < l.len()\
    \ {\n            l.swap(i, l.len() - 1);\n            i += 1;\n        }\n   \
    \ }\n    return l;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpcjmkwnom.rs:27:23\n   |\n27 |             l.swap(i,\
    \ l.len() - 1);\n   |             ----------^^^^^^^-----\n   |             | |\
    \       |\n   |             | |       immutable borrow occurs here\n   |     \
    \        | mutable borrow later used by call\n   |             mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmpcjmkwnom.rs:27:23\n   |\n27 |             l.swap(i, l.len() - 1);\n\
    \   |                       ^^^^^^^\nhelp: ...and then using that local as the\
    \ argument to this call\n  --> /tmp/tmpcjmkwnom.rs:27:13\n   |\n27 |         \
    \    l.swap(i, l.len() - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: -1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n    let mut i\
    \ = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n\
    \            l3.push(l1[i]);\n            i += 1;\n        } else {\n        \
    \    if l1[i] > l2[i] {\n                l3.push(l1[i]);\n            } else {\n\
    \                l3.push(l2[i]);\n            }\n        }\n    }\n    while i\
    \ < l1.len() {\n        l3.push(l1[i]);\n        i += 1;\n    }\n    while i <\
    \ l2.len() {\n        l3.push(l2[i]);\n        i += 1;\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976137
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.retain(l2.clone());\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \    --> /tmp/tmpb3vgihcz.rs:8:15\n     |\n8    |     l3.retain(l2.clone());\n\
    \     |        ------ ^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found\
    \ `Vec<isize>`\n     |        |\n     |        required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is\
    \ not implemented for `Vec<isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter()\n        .zip(l2.iter())\n  \
    \      .filter(|(&a, &b)| a == b)\n        .cloned()\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmppx7wtgxu.rs:9:17: 9:34]>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmppx7wtgxu.rs:10:10\n     |\n10   |\
    \         .cloned()\n     |          ^^^^^^ expected reference, found tuple\n\
    \     |\n     = note: expected reference `&_`\n                    found tuple\
    \ `(&isize, &isize)`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<Filter<Zip<std::slice::Iter<'_, isize>,\
    \ std::slice::Iter<'_, isize>>, [closure@/tmp/tmppx7wtgxu.rs:9:17: 9:34]>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmppx7wtgxu.rs:11:10\n   |\n\
    11 |            .collect()\n   |             ^^^^^^^ method cannot be called on\
    \ `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmppx7wtgxu.rs:9:17: 9:34]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmppx7wtgxu.rs:9:17: 9:34]>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmppx7wtgxu.rs:9:17: 9:34]>>:\
    \ Iterator`\n           `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmppx7wtgxu.rs:9:17: 9:34]>>: Iterator`\n           which\
    \ is required by `&mut Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmppx7wtgxu.rs:9:17: 9:34]>>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = l1.clone();\n    s.sort();\n\
    \    let mut d = l2.clone();\n    d.sort();\n    let mut result: Vec<isize> =\
    \ vec![];\n    let mut i = 1;\n    while i < s.len() && i < d.len() {\n      \
    \  if s[i].0 > d[i].0 {\n            result.push(s[i]);\n            i += 1;\n\
    \        } else {\n            result.push(d[i]);\n            i += 1;\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpxnvyrtzs.rs:14:17\n   |\n14 |         if s[i].0 > d[i].0 {\n  \
    \ |                 ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpxnvyrtzs.rs:14:26\n   |\n14 |         if\
    \ s[i].0 > d[i].0 {\n   |                          ^\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0610`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1;\n    let mut l2 =\
    \ l2;\n    while l1.len() != l2.len() {\n        if l1[0] < l2[0] {\n        \
    \    result.insert(0, l1[0]);\n            l1.remove(0);\n        } else {\n \
    \           result.insert(0, l2[0]);\n            l2.remove(0);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l1`\n --> /tmp/tmp7014xj3x.rs:9:11\n\
    \  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \      -- move occurs because `l1` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n7 |     let mut result = l1;\n  |                      --\
    \ value moved here\n8 |     let mut l2 = l2;\n9 |     while l1.len() != l2.len()\
    \ {\n  |           ^^^^^^^^ value borrowed here after move\n\nerror[E0596]: cannot\
    \ borrow `l1` as mutable, as it is not declared as mutable\n  --> /tmp/tmp7014xj3x.rs:12:13\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \         -- help: consider changing this to be mutable: `mut l1`\n...\n12 | \
    \            l1.remove(0);\n   |             ^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0596.\nFor more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() > l2.len() {\n        l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(_,\
    \ &b)| b == b).collect()\n    } else {\n        l2.iter().cloned().zip(l1.iter().cloned()).filter(|&(_,\
    \ &b)| b == b).collect()\n    }\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm14mci8q.rs:8:65\n  |\n8 |\
    \         l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(_, &b)| b == b).collect()\n\
    \  |                                                                 ^^- expected\
    \ due to this\n  |                                                           \
    \      |\n  |                                                                \
    \ expected `isize`, found reference\n  |                                     \
    \                            help: you can probably remove the explicit borrow:\
    \ `b`\n  |\n  = note:   expected type `isize`\n          found reference `&_`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(isize, isize)`\n    --> /tmp/tmpm14mci8q.rs:8:78\n \
    \    |\n8    |         l1.iter().cloned().zip(l2.iter().cloned()).filter(|&(_,\
    \ &b)| b == b).collect()\n     |                                             \
    \                                 ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=(isize, isize)>`\n     |\n     = help:\
    \ the trait `FromIterator<(isize, isize)>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm14mci8q.rs:10:65\n\
    \   |\n10 |         l2.iter().cloned().zip(l1.iter().cloned()).filter(|&(_, &b)|\
    \ b == b).collect()\n   |                                                    \
    \             ^^- expected due to this\n   |                                 \
    \                                |\n   |                                     \
    \                            expected `isize`, found reference\n   |         \
    \                                                        help: you can probably\
    \ remove the explicit borrow: `b`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `(isize, isize)`\n  \
    \  --> /tmp/tmpm14mci8q.rs:10:78\n     |\n10   |         "
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::with_capacity(l1.len());\n\
    \    for i in l1.iter().filter(|&x| l2.iter().all(|&y| *x == *y)) {\n        l3.push(i);\n\
    \    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpc7qyk1u2.rs:8:61\n\
    \  |\n8 |     for i in l1.iter().filter(|&x| l2.iter().all(|&y| *x == *y)) {\n\
    \  |                                                             ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc7qyk1u2.rs:11:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n11 |  \
    \   l3\n   |     ^^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n\n    for i in\
    \ l1.iter() {\n        match result.binary_search_by(|&i| i as usize) {\n    \
    \        Some(pos) => result.insert(pos, *i),\n            None => {\n       \
    \         result.push(*i);\n            }\n        }\n    }\n\n    for i in l2.iter()\
    \ {\n        match result.binary_search_by(|&i| i as usize) {\n            Some(pos)\
    \ => result.insert(pos, *i),\n            None => {\n                result.push(*i);\n\
    \            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmcnla83.rs:10:44\n   |\n\
    10 |         match result.binary_search_by(|&i| i as usize) {\n   |          \
    \                                  ^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfmcnla83.rs:11:13\n\
    \   |\n10 |         match result.binary_search_by(|&i| i as usize) {\n   |   \
    \            ---------------------------------------- this expression has type\
    \ `Result<usize, usize>`\n11 |             Some(pos) => result.insert(pos, *i),\n\
    \   |             ^^^^^^^^^ expected enum `Result`, found enum `Option`\n   |\n\
    \   = note: expected enum `Result<usize, usize>`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfmcnla83.rs:12:13\n   |\n10 |\
    \         match result.binary_search_by(|&i| i as usize) {\n   |             \
    \  ---------------------------------------- this expression has type `Result<usize,\
    \ usize>`\n11 |             Some(pos) => result.insert(pos, *i),\n12 |       \
    \      None => {\n   |             ^^^^ expected enum `Result`, found enum `Option`\n\
    \   |\n   = note: expected enum `Result<usize, usize>`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfmcnla83.rs:19:44\n\
    \   |\n19 |         match result.binary_search_by(|&i| i as usize) {\n   |   \
    \                                         ^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfmcnla83.rs:20:13\n\
    \   |\n19 |         match result.binary_search_by(|&i| i as usize) {\n   |   \
    \            ---------------------------------------- this expression has type\
    \ `Result<usize, usize>`\n20 |             Some(pos) => result.insert(pos, *i),\n\
    \   |             ^^^^^^^^^ expected enum `Result`, found enum `Option`\n   |\n\
    \   = note: expected enum `Result<usize, usize>`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfmcnla83.rs:21:13\n   |\n19 |\
    \         match result.binary_search_by(|&i| i as usize) {\n   |             \
    \  -----------------------------------"
  stdout: ''
  timestamp: 1659976132
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().cloned().filter(|&x| l2.iter().any(|&y|\
    \ x == y)).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpnspyrr4j.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter()\n        .zip(l2.iter())\n  \
    \      .filter(|(l, r)| l < r)\n        .map(|(l, r)| l)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmp0ug1jj57.rs:11:10\n     |\n\
    11   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common: Vec<isize> = vec![];\n\
    \    for &i in l1 {\n        for &j in l2 {\n            if i == j {\n       \
    \         common.push(i);\n                break;\n            }\n        }\n\
    \    }\n    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp704m3za5.rs:8:9\n  |\n8 |\
    \     for &i in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp704m3za5.rs:9:13\n  |\n9 |         for &j in l2 {\n  |         \
    \    ^^    -- this expression has type `Option<isize>`\n  |             |\n  |\
    \             expected `isize`, found reference\n  |             help: you can\
    \ probably remove the explicit borrow: `j`\n  |\n  = note:   expected type `isize`\n\
    \          found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    debug_assert!((l1.len() >= l2.len()) ||\
    \ (l1.len() == 0));\n    let mut i = 0;\n    let mut j = 0;\n    let mut u: Vec<isize>\
    \ = l1.iter().cloned().collect();\n    let mut v: Vec<isize> = l2.iter().cloned().collect();\n\
    \    while i < u.len() && j < v.len() {\n        if u[i] == v[j] {\n         \
    \   i += 1;\n            j += 1;\n        }\n        else {\n            let m\
    \ = minmax(u[i], v[j]);\n            u.swap(i, u[m]);\n            v.swap(j, v[m]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    u\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `minmax` in this scope\n  --> /tmp/tmp7b8wje5w.rs:18:21\n\
    \   |\n18 |             let m = minmax(u[i], v[j]);\n   |                    \
    \ ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s = vec![];\n    l1.iter().zip(l2.iter()).for_each(|(a,\
    \ b)| {\n        if a == b { s.push(a); }\n    });\n    s\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjobg22v6.rs:11:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n11 |     s\n   |     ^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n    for &n in\
    \ l1.iter().zip(l2.iter()).flat_map(|(x, y)| (x, y)) {\n        if *n == *n ==\
    \ 0 {\n            l3.push(*n);\n        }\n    }\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n --> /tmp/tmpqa27zc9g.rs:9:15\n\
    \  |\n9 |         if *n == *n == 0 {\n  |               ^^    ^^\n  |\nhelp: split\
    \ the comparison into two\n  |\n9 |         if *n == *n && *n == 0 {\n  |    \
    \                 +++++\n\nerror[E0277]: `(&isize, &isize)` is not an iterator\n\
    \    --> /tmp/tmpqa27zc9g.rs:8:49\n     |\n8    |     for &n in l1.iter().zip(l2.iter()).flat_map(|(x,\
    \ y)| (x, y)) {\n     |                                        -------- ^^^^^^^^^^^^^^^\
    \ `(&isize, &isize)` is not an iterator\n     |                              \
    \          |\n     |                                        required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `(&isize, &isize)`\n     = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `(&isize, &isize)`\nnote: required by a bound\
    \ in `flat_map`\n\nerror[E0277]: `(&isize, &isize)` is not an iterator\n  -->\
    \ /tmp/tmpqa27zc9g.rs:8:15\n   |\n8  |     for &n in l1.iter().zip(l2.iter()).flat_map(|(x,\
    \ y)| (x, y)) {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `(&isize, &isize)` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `(&isize, &isize)`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `(&isize, &isize)`\nnote: required\
    \ by a bound in `FlatMap`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqa27zc9g.rs:9:24\n\
    \  |\n9 |         if *n == *n == 0 {\n  |                        ^ expected `bool`,\
    \ found integer\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.clone();\n    let mut l2\
    \ = l2.clone();\n    while l1.len() > 0 && l2.len() > 0 {\n        let mut min:\
    \ usize = (l1.len() as usize).cmp(l2.len() as usize);\n        if min == 0 {\n\
    \            break;\n        }\n        if l1.len() > l2.len() {\n           \
    \ while l1[min] < l2[min] {\n                l1[min] += 1;\n                min\
    \ -= 1;\n            }\n        } else {\n            while l2[min] < l1[min]\
    \ {\n                l2[min] += 1;\n                min -= 1;\n            }\n\
    \        }\n    }\n    l1.shrink_to_fit();\n    l2.shrink_to_fit();\n    if l1.len()\
    \ == 0 {\n        return l2;\n    }\n    if l2.len() == 0 {\n        return l1;\n\
    \    }\n    if l1.len() > l2.len() {\n        l1.reverse();\n    }\n    l2.reverse();\n\
    \    l1.extend(l2).collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1m0zzn2_.rs:10:54\n   |\n\
    10 |         let mut min: usize = (l1.len() as usize).cmp(l2.len() as usize);\n\
    \   |                                                      ^^^^^^^^^^^^^^^^^\n\
    \   |                                                      |\n   |           \
    \                                           expected `&usize`, found `usize`\n\
    \   |                                                      help: consider borrowing\
    \ here: `&(l2.len() as usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1m0zzn2_.rs:10:30\n\
    \   |\n10 |         let mut min: usize = (l1.len() as usize).cmp(l2.len() as usize);\n\
    \   |                      -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `std::cmp::Ordering`\n   |                    \
    \  |\n   |                      expected due to this\n\nerror[E0599]: `()` is\
    \ not an iterator\n  --> /tmp/tmp1m0zzn2_.rs:38:19\n   |\n38 |     l1.extend(l2).collect::<Vec<isize>>()\n\
    \   |                   ^^^^^^^ `()` is not an iterator\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `(): Iterator`\n    \
    \       which is required by `&mut (): Iterator`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() < l2.len() {\n        l1.par_iter().cloned().chain(l2.par_iter().cloned()).collect()\n\
    \    } else {\n        l2.par_iter().cloned().chain(l1.par_iter().cloned()).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `par_iter` found for struct `Vec<isize>`\
    \ in the current scope\n --> /tmp/tmp39yhxb6w.rs:8:12\n  |\n8 |         l1.par_iter().cloned().chain(l2.par_iter().cloned()).collect()\n\
    \  |            ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `iter`\n\nerror[E0599]: no method named `par_iter` found for struct `Vec<isize>`\
    \ in the current scope\n --> /tmp/tmp39yhxb6w.rs:8:41\n  |\n8 |         l1.par_iter().cloned().chain(l2.par_iter().cloned()).collect()\n\
    \  |                                         ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `iter`\n\nerror[E0599]: no method named `par_iter`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp39yhxb6w.rs:10:12\n\
    \   |\n10 |         l2.par_iter().cloned().chain(l1.par_iter().cloned()).collect()\n\
    \   |            ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `iter`\n\nerror[E0599]: no method named `par_iter` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp39yhxb6w.rs:10:41\n   |\n10 |         l2.par_iter().cloned().chain(l1.par_iter().cloned()).collect()\n\
    \   |                                         ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `iter`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = l1.len();\n    let mut j =\
    \ l2.len();\n    let mut m = i; // current smallest common index\n    let mut\
    \ n = j; // current largest common index\n    while i >= 0 && j >= 0 {\n     \
    \   if l1[i] < l2[j] {\n            i -= 1;\n        } else {\n            j -=\
    \ 1;\n        }\n        if i > 0 && j > 0 && l1[i] == l2[j] {\n            if\
    \ m == i && n > j {\n                n = j;\n                j = i;\n        \
    \    } else if m > i && n == j {\n                m = i;\n                i =\
    \ m;\n            }\n        }\n    }\n    vec![i] // if m == i then this element\
    \ belongs in both vectors\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqhdvab_s.rs:27:10\n   |\n\
    27 |     vec![i] // if m == i then this element belongs in both vectors\n   |\
    \          ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n27 |     vec![i.try_into().unwrap()]\
    \ // if m == i then this element belongs in both vectors\n   |           ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return vec![];\n    }\n\n    let mut l1 = l1.iter().cloned().collect();\n\
    \    let mut l2 = l2.iter().cloned().collect();\n\n    while l1.len() > 0 && l2.len()\
    \ > 0 {\n        if l1[0] < l2[0] {\n            l1.remove(0);\n        } else\
    \ {\n            l2.remove(0);\n        }\n    }\n\n    vec![l1.clone(), l2.clone()]\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp574g3bbh.rs:14:11\n\
    \   |\n11 |     let mut l1 = l1.iter().cloned().collect();\n   |         ------\
    \ consider giving `l1` a type\n...\n14 |     while l1.len() > 0 && l2.len() >\
    \ 0 {\n   |           ^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|&(_, &b)|\
    \ b == 1).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpuqnrz89h.rs:7:56\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|&(_, &b)| b == 1).collect()\n\
    \     |                                                        ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().cloned().zip2(&mut l2, |x, y|\
    \ {\n        match x {\n            x if x == y => x,\n            _ => x,\n \
    \       }\n    }).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `zip2` found for struct `Cloned` in the current\
    \ scope\n --> /tmp/tmpcbb8vnwk.rs:7:24\n  |\n7 |     l1.iter().cloned().zip2(&mut\
    \ l2, |x, y| {\n  |                        ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|&x| l2.iter().any(|&y|\
    \ x != y)).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmpl4jlhdgh.rs:7:48\n\
    \  |\n7 |     l1.iter().filter(|&x| l2.iter().any(|&y| x != y)).collect()\n  |\
    \                                                ^^ no implementation for `&isize\
    \ == isize`\n  |\n  = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from an\
    \ iterator over elements of type `&isize`\n    --> /tmp/tmpl4jlhdgh.rs:7:55\n\
    \     |\n7    |     l1.iter().filter(|&x| l2.iter().any(|&y| x != y)).collect()\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n        \
    \    i += 1;\n        } else if l1[i] == l2[j] {\n            i += 1;\n      \
    \      j += 1;\n        } else {\n            j += 1;\n        }\n    }\n    vec![l1[i]\
    \ as usize, l2[j] as usize]\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxyu6opnf.rs:19:10\n   |\n\
    19 |     vec![l1[i] as usize, l2[j] as usize]\n   |          ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     vec![(l1[i] as\
    \ usize).try_into().unwrap(), l2[j] as usize]\n   |          +              +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.clone();\n    l.sort_unstable();\n\
    \    l2.sort_unstable();\n    l.iter().zip(l2.iter()).filter(|&(a, b)| a == b).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpzy4blh2v.rs:10:36: 10:52]>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpzy4blh2v.rs:10:54\n     |\n10   |\
    \     l.iter().zip(l2.iter()).filter(|&(a, b)| a == b).cloned().collect()\n  \
    \   |                                                      ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(&isize, &isize)`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpzy4blh2v.rs:10:36: 10:52]>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpzy4blh2v.rs:10:63\n \
    \  |\n10 |        l.iter().zip(l2.iter()).filter(|&(a, b)| a == b).cloned().collect()\n\
    \   |                                                                  ^^^^^^^\
    \ method cannot be called on `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpzy4blh2v.rs:10:36: 10:52]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpzy4blh2v.rs:10:36: 10:52]> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpzy4blh2v.rs:10:36: 10:52]>>: Iterator`\n         \
    \  `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpzy4blh2v.rs:10:36: 10:52]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpzy4blh2v.rs:10:36: 10:52]>>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    while i < l1.len()\
    \ && i < l2.len() {\n        if l1.get_mut(i) == l2.get_mut(i) {\n           \
    \ i += 1;\n        } else {\n            l1.swap(i, l1.len() - 1);\n         \
    \   l2.swap(i, l2.len() - 1);\n        }\n    }\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \ --> /tmp/tmp0n70cunb.rs:9:12\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n  |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n9 |         if l1.get_mut(i) == l2.get_mut(i) {\n  |        \
    \    ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `l2`\
    \ as mutable, as it is not declared as mutable\n --> /tmp/tmp0n70cunb.rs:9:29\n\
    \  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                      -- help: consider changing this to be mutable: `mut l2`\n\
    ...\n9 |         if l1.get_mut(i) == l2.get_mut(i) {\n  |                    \
    \         ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `l1` as mutable, as it is not declared as mutable\n  --> /tmp/tmp0n70cunb.rs:12:13\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \         -- help: consider changing this to be mutable: `mut l1`\n...\n12 | \
    \            l1.swap(i, l1.len() - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `l1` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmp0n70cunb.rs:12:24\n   |\n12 |\
    \             l1.swap(i, l1.len() - 1);\n   |             -----------^^^^^^^^-----\n\
    \   |             |  |       |\n   |             |  |       immutable borrow occurs\
    \ here\n   |             |  mutable borrow later used by call\n   |          \
    \   mutable borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmp0n70cunb.rs:12:24\n   |\n12 |             l1.swap(i, l1.len() -\
    \ 1);\n   |                        ^^^^^^^^\nhelp: ...and then using that local\
    \ as the argument to this call\n  --> /tmp/tmp0n70cunb.rs:12:13\n   |\n12 |  \
    \           l1.swap(i, l1.len() - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0596]: cannot borrow `l2` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp0n70cunb.rs:13:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                "
  stdout: ''
  timestamp: 1659976132
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  let mut ret: Vec<isize> = vec![];\n    while i < l1.len() && j < l2.len() {\n\
    \        if l1[i] == l2[j] {\n            ret.push(l1[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmp2_9_8gev.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|&(a, b)|\
    \ a == b).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzwl_d9ho.rs:7:5\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n7 |     l1.iter().zip(l2.iter()).filter(|&(a, b)| a == b).collect::<Vec<_>>()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n\
    \             found struct `Vec<(&isize, &isize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1\n        .iter()\n    \
    \    .cloned()\n        .chain(l2.iter().cloned())\n        .collect::<Vec<_>>();\n\
    \n    let mut l3 = l3.dedup();\n    while l3.len() > 1 {\n        l3.pop();\n\
    \        l3.pop();\n    }\n\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpw2yuwtso.rs:14:14\n   |\n14 |     while l3.len() > 1 {\n\
    \   |              ^^^ method not found in `()`\n\nerror[E0599]: no method named\
    \ `pop` found for unit type `()` in the current scope\n  --> /tmp/tmpw2yuwtso.rs:15:12\n\
    \   |\n15 |         l3.pop();\n   |            ^^^ method not found in `()`\n\n\
    error[E0599]: no method named `pop` found for unit type `()` in the current scope\n\
    \  --> /tmp/tmpw2yuwtso.rs:16:12\n   |\n16 |         l3.pop();\n   |         \
    \   ^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2yuwtso.rs:19:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n19 |     l3\n   |     ^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c = vec![];\n    let mut m = vec![];\n\
    \    let mut n = vec![];\n\n    for i in l1.iter() {\n        if m.len() == 0\
    \ {\n            m.push(i);\n            c.push(i);\n        } else {\n      \
    \      if l2.iter().any(|&i| **i == i) {\n                m.push(i);\n       \
    \     } else {\n                n.push(i);\n            }\n        }\n    }\n\n\
    \    if n.len() > c.len() {\n        c.extend(n);\n    } else {\n        c.extend(m);\n\
    \    }\n\n    c\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpdpjbeclm.rs:16:36\n\
    \   |\n16 |             if l2.iter().any(|&i| **i == i) {\n   |              \
    \                      ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpjbeclm.rs:30:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n30 |     c\n   |     ^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    match (l1, l2) {\n        (vec![], vec![])\
    \ => vec![],\n        (vec![], vec![_]) => vec![],\n        (vec![_], vec![])\
    \ => vec![],\n        (vec![_], vec![_]) => (vec![_]),\n        (l1, l2) => {\n\
    \            let mut i = 0;\n            let mut j = l1.len() as isize;\n    \
    \        let mut ret = vec![];\n            loop {\n                let a = (&l1[i])[0];\n\
    \                let b = (&l2[j])[0];\n                if a < b {\n          \
    \          i += 1;\n                } else if b < a {\n                    j +=\
    \ 1;\n                } else {\n                    ret.push((&l1[i])[0]);\n \
    \                   i += 1;\n                    j += 1;\n                }\n\
    \                if i == l1.len() {\n                    break;\n            \
    \    }\n                if j == l2.len() {\n                    break;\n     \
    \           }\n            }\n            vec![ret]\n        }\n    }\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: no rules expected the token `_`\n --> /tmp/tmp5e2076ca.rs:9:23\n\
    \  |\n9 |         (vec![], vec![_]) => vec![],\n  |                       ^ no\
    \ rules expected this token in macro call\n\nerror: no rules expected the token\
    \ `_`\n  --> /tmp/tmp5e2076ca.rs:10:15\n   |\n10 |         (vec![_], vec![]) =>\
    \ vec![],\n   |               ^ no rules expected this token in macro call\n\n\
    error: no rules expected the token `_`\n  --> /tmp/tmp5e2076ca.rs:11:15\n   |\n\
    11 |         (vec![_], vec![_]) => (vec![_]),\n   |               ^ no rules expected\
    \ this token in macro call\n\nerror: no rules expected the token `_`\n  --> /tmp/tmp5e2076ca.rs:11:24\n\
    \   |\n11 |         (vec![_], vec![_]) => (vec![_]),\n   |                   \
    \     ^ no rules expected this token in macro call\n\nerror: no rules expected\
    \ the token `_`\n  --> /tmp/tmp5e2076ca.rs:11:37\n   |\n11 |         (vec![_],\
    \ vec![_]) => (vec![_]),\n   |                                     ^ no rules\
    \ expected this token in macro call\n\nerror: arbitrary expressions aren't allowed\
    \ in patterns\n --> /tmp/tmp5e2076ca.rs:8:10\n  |\n8 |         (vec![], vec![])\
    \ => vec![],\n  |          ^^^^^^\n  |\n  = note: this error originates in the\
    \ macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror: arbitrary expressions aren't allowed in patterns\n --> /tmp/tmp5e2076ca.rs:8:18\n\
    \  |\n8 |         (vec![], vec![]) => vec![],\n  |                  ^^^^^^\n \
    \ |\n  = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n --> /tmp/tmp5e2076ca.rs:9:10\n  |\n9 |         (vec![],\
    \ vec![_]) => vec![],\n  |          ^^^^^^\n  |\n  = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmp5e2076ca.rs:10:19\n\
    \   |\n10 |         (vec![_], vec![]) => vec![],\n   |                   ^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace f"
  stdout: ''
  timestamp: 1659976132
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n \
    \       return vec![];\n    }\n    let mut result: Vec<isize> = vec![l2[0]];\n\
    \    let mut j = 0;\n    for i in l1 {\n        if i == l2[j] {\n            result[j]\
    \ += 1;\n            j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6]`,\n right: `[1, 5, 653]`', /tmp/tmpp9zm90pe.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976132
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.len() as isize;\n    let\
    \ mut l_copy = l1.len() as isize;\n    let mut r1 = l1.len();\n    let mut r2\
    \ = l2.len();\n    while l > 0 && r1 > 0 {\n        if l1[l - 1] > r1[r1 - 1]\
    \ {\n            r1 -= 1;\n        } else {\n            l -= 1;\n        }\n\
    \    }\n    while l > 0 && r2 > 0 {\n        if l1[l - 1] > r2[r2 - 1] {\n   \
    \         r2 -= 1;\n        } else {\n            l -= 1;\n        }\n    }\n\
    \    if l > r2 {\n        l.extend(r2);\n    }\n    if r1 > l {\n        r2.extend(r1);\n\
    \    }\n    &l1[..r2]\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkj776f_8.rs:12:12\n\
    \   |\n12 |         if l1[l - 1] > r1[r1 - 1] {\n   |            ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0608]: cannot index\
    \ into a value of type `usize`\n  --> /tmp/tmpkj776f_8.rs:12:24\n   |\n12 |  \
    \       if l1[l - 1] > r1[r1 - 1] {\n   |                        ^^^^^^^^^^\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkj776f_8.rs:19:12\n\
    \   |\n19 |         if l1[l - 1] > r2[r2 - 1] {\n   |            ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0608]: cannot index\
    \ into a value of type `usize`\n  --> /tmp/tmpkj776f_8.rs:19:24\n   |\n19 |  \
    \       if l1[l - 1] > r2[r2 - 1] {\n   |                        ^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkj776f_8.rs:25:12\n   |\n25 |  \
    \   if l > r2 {\n   |            ^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |     if l > r2.try_into().unwrap() {\n   |              ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `extend` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpkj776f_8.rs:26:11\n   |\n26 |         l.extend(r2);\n \
    \  |           ^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkj776f_8.rs:28:13\n   |\n28 |     if r1 > l {\n   |   \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n28 |     if\
    \ r1 "
  stdout: ''
  timestamp: 1659976132
