language: rs
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut names: Vec<&str> = extensions.iter().map(|e| &e.to_lowercase()).collect();\n\
    \    for &n in names {\n        let mut found = false;\n        for e in extensions\
    \ {\n            if e.to_lowercase() == n {\n                found = true;\n \
    \               break;\n            }\n        }\n        if !found {\n      \
    \      let i = names.iter().position(|&n| n == &n);\n            strength += i\
    \ - names.len();\n        }\n    }\n    let s = strength % class_name.len();\n\
    \    if s > 0 {\n        let s = s - class_name.len();\n        &class_name[..class_name.len()-s]\
    \ + class_name + &class_name[class_name.len()..class_name.len() + s]\n    } else\
    \ {\n        class_name\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpdnwvojj4.rs:19:77\n     |\n\
    19   |     let mut names: Vec<&str> = extensions.iter().map(|e| &e.to_lowercase()).collect();\n\
    \     |                                                                      \
    \       ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<&str>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n  --> /tmp/tmpdnwvojj4.rs:20:10\n\
    \   |\n20 |     for &n in names {\n   |          ^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\n\nerror[E0277]: can't compare\
    \ `str` with `&str`\n  --> /tmp/tmpdnwvojj4.rs:29:50\n   |\n29 |             let\
    \ i = names.iter().position(|&n| n == &n);\n   |                             \
    \                     ^^ no implementation for `str == &str`\n   |\n   = help:\
    \ the trait `PartialEq<&str>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&&str>` for `&str`\n\nerror[E0369]: cannot subtract `usize`\
    \ from `Option<usize>`\n  --> /tmp/tmpdnwvojj4.rs:30:27\n   |\n30 |          \
    \   strength += i - names.len();\n   |                         - ^ -----------"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return class_name;\n    }\n    let mut strength = -1;\n    let mut extension\
    \ = String::from(\"\");\n    let mut extension_pos = 0;\n    for extension in\
    \ extensions {\n        let mut letter_counter = 0;\n        for letter in extension.chars()\
    \ {\n            if letter == 'C' {\n                if letter_counter > 0 {\n\
    \                    // found C letter earlier \n                    break \n\
    \                }\n            } else {\n                letter_counter += 1;\n\
    \            }\n        }\n        if strength == -1 {\n            strength =\
    \ letter_counter - 1;\n        } else {\n            if letter_counter > strength\
    \ {\n                strength = letter_counter - 1;\n                extension\
    \ = extension.clone();\n                extension_pos = 0;\n            }\n  \
    \      }\n    }\n    extension.clone() + String::from(class_name + \".\") + extensions[extension_pos].clone();\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3essshvx.rs:46:25\n   |\n\
    46 |     extension.clone() + String::from(class_name + \".\") + extensions[extension_pos].clone();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |           \
    \              |\n   |                         expected `&str`, found struct `String`\n\
    \   |                         help: consider borrowing here: `&String::from(class_name\
    \ + \".\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3essshvx.rs:46:58\n\
    \   |\n46 |     extension.clone() + String::from(class_name + \".\") + extensions[extension_pos].clone();\n\
    \   |                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                          |\n   |       \
    \                                                   expected `&str`, found struct\
    \ `String`\n   |                                                          help:\
    \ consider borrowing here: `&extensions[extension_pos]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3essshvx.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n46 |     extension.clone() + String::from(class_name\
    \ + \".\") + extensions[extension_pos].clone();\n   |                        \
    \                                                                   - help: remove\
    \ this semicolon\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension:\
    \ Option<String> = None;\n    \n    for i in 0..extensions.length() {\n      \
    \  let letters: usize = extensions[i].chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        let lowercase: usize = extensions[i].chars().filter(|c| c >= 'a' && c\
    \ <= 'z').count();\n        let capital: usize = extensions[i].chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let sm: usize = extensions[i].chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let strength: usize = letters - sm;\n\
    \        if strength > 0 {\n            if strongest_extension.is_none() || strength\
    \ > strongest_extension.as_ref().unwrap().chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count() {\n                strongest_extension = Some(extensions[i]);\n\
    \            }\n        }\n    }\n    \n    strongest_extension.ok().unwrap().to_owned()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmp1nzcba47.rs:20:28\n   |\n20 |     for i in\
    \ 0..extensions.length() {\n   |                            ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1nzcba47.rs:21:68\n   |\n21 |         let letters: usize\
    \ = extensions[i].chars().filter(|c| c >= 'A' && c <= 'Z').count();\n   |    \
    \                                                                ^^^\n   |   \
    \                                                                 |\n   |    \
    \                                                                expected `&char`,\
    \ found `char`\n   |                                                         \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1nzcba47.rs:21:80\n   |\n21 |         let letters: usize\
    \ = extensions[i].chars().filter(|c| c >= 'A' && c <= 'Z').count();\n   |    \
    \                                                                            ^^^\n\
    \   |                                                                        \
    \        |\n   |                                                             \
    \                   expected `&char`, found `char`\n   |                     \
    \                                                           help: consider borrowing\
    \ here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1nzcba47.rs:22:70\n\
    \   |\n22 |         let lowercase: usize = extensions[i].chars().filter(|c| c\
    \ >= 'a' && c <= 'z').count();\n   |                                         \
    \                             ^^^\n   |                                      \
    \                                |\n   |                                     \
    \                                 expected `&char`, found `char`\n   |       \
    \                                                               help: consider\
    \ borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1nzcba47.rs:22:82\n\
    \   |\n22 |         let lowercase: usize = extensions[i].chars("
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extenstions = extensions;\n\
    \    let mut strength: i32 = -1i32;\n    let mut current_strength: i32 = -1i32;\n\
    \    let mut current_extenstions: Vec<String> = extensions.clone();\n    while\
    \ current_extenstions.len() > 0 {\n        let mut i = 0;\n        let mut extension_strength\
    \ = -1;\n        while i < extensions.len() {\n            if current_extenstions[i]\
    \ == class_name {\n                extension_strength += 1;\n            }\n \
    \           i += 1;\n        }\n        if extension_strength > strength {\n \
    \           strength = extension_strength;\n            current_extenstions =\
    \ extenstions.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, extenstions.first())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `Option<&String>` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmp1ie7vhao.rs:36:34\n   |\n36 |     format!(\"{}.{}\", class_name,\
    \ extenstions.first())\n   |                                  ^^^^^^^^^^^^^^^^^^^\
    \ `Option<&String>` cannot be formatted with the default formatter\n   |\n   =\
    \ help: the trait `std::fmt::Display` is not implemented for `Option<&String>`\n\
    \   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions.iter().cloned().sort_by(|a,\
    \ b| \n        if a.to_ascii_lowercase().cmp(b.to_ascii_lowercase()) < 0 {\n \
    \           -1\n        } else {\n            1\n        }\n    )\n    .next()\n\
    \    .unwrap()\n    .format(&class_name)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp18lou2gk.rs:18:32\n   |\n18 |     extensions.iter().cloned().sort_by(|a,\
    \ b| \n   |                                ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.clone();\n    extensions_sorted.sort_unstable();\n    let mut min_strength\
    \ = extensions_sorted.len();\n    for extension in extensions_sorted {\n     \
    \   let mut extension_length = extension.len();\n        let mut current_strength\
    \ = extension_length;\n        for char in extension.chars() {\n            if\
    \ char == '_' {\n                current_strength -= 1;\n            } else {\n\
    \                current_strength += 1;\n            }\n        }\n        if\
    \ current_strength < min_strength {\n            min_strength = current_strength;\n\
    \        }\n    }\n    let mut class_name = class_name.to_string();\n    class_name.replace_range(class_name.len()\
    \ - min_strength.0, class_name.len() - min_strength.1, '_');\n    return class_name;\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpqd6o_9ca.rs:36:62\n   |\n36 |     class_name.replace_range(class_name.len()\
    \ - min_strength.0, class_name.len() - min_strength.1, '_');\n   |           \
    \                                                   ^\n\nerror[E0610]: `usize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpqd6o_9ca.rs:36:97\n\
    \   |\n36 |     class_name.replace_range(class_name.len() - min_strength.0, class_name.len()\
    \ - min_strength.1, '_');\n   |                                              \
    \                                                   ^\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n    --> /tmp/tmpqd6o_9ca.rs:36:16\n\
    \     |\n36   |     class_name.replace_range(class_name.len() - min_strength.0,\
    \ class_name.len() - min_strength.1, '_');\n     |                ^^^^^^^^^^^^^\
    \ ---------------------------------  ---------------------------------  --- supplied\
    \ 3 arguments\n     |                |\n     |                expected 2 arguments\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut current_strength =\
    \ -1;\n    let mut best_extension: Option<String> = None;\n    for extension in\
    \ extensions {\n        let (extension_name, extension_strength) = Extension::ParseExtension(extension);\n\
    \        let extension_strength_difference = current_strength - extension_strength;\n\
    \        if extension_strength_difference < 0 {\n            current_strength\
    \ = extension_strength;\n            best_extension = Some(extension_name);\n\
    \        } else if extension_strength_difference == 0 {\n            current_strength\
    \ = extension_strength;\n            best_extension = Some(extension_name);\n\
    \        }\n    }\n    match best_extension {\n        Some(extension) => format!(\"\
    {}{}.{}\", class_name, extension_name, current_strength),\n        None => format!(\"\
    {}{}.{}\", class_name, String::from(\"XX\"), current_strength),\n    }\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Extension`\n \
    \ --> /tmp/tmpmbm0t_fa.rs:21:52\n   |\n21 |         let (extension_name, extension_strength)\
    \ = Extension::ParseExtension(extension);\n   |                              \
    \                      ^^^^^^^^^ use of undeclared type `Extension`\n\nerror[E0425]:\
    \ cannot find value `extension_name` in this scope\n  --> /tmp/tmpmbm0t_fa.rs:32:59\n\
    \   |\n32 |         Some(extension) => format!(\"{}{}.{}\", class_name, extension_name,\
    \ current_strength),\n   |                                                   \
    \        ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extension_strength(class_name,\
    \ extensions, 0)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `extension_strength` in this scope\n\
    \  --> /tmp/tmpqq0z8pcr.rs:18:5\n   |\n18 |     extension_strength(class_name,\
    \ extensions, 0)\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut class_name = class_name.to_string();\n\
    \n    let mut extensions = extensions.iter().map(|x| x.to_string()).collect::<Vec<_>>();\n\
    \n    // Initialize max extension strength.\n    let mut max_extension_strength\
    \ = 0;\n\n    // Initialize max extension name.\n    let mut max_extension_name:\
    \ String = \"\";\n\n    for extension in extensions {\n        // Find the extension\
    \ name by splitting it on upper case characters.\n        let mut extension_name\
    \ = extension.clone();\n\n        for ch in extension_name.chars() {\n       \
    \     if ch.is_uppercase() {\n                break;\n            }\n        \
    \    extension_name.push(ch);\n        }\n\n        // Find the extension strength\
    \ by splitting it on lowercase characters.\n        let mut extension_strength:\
    \ u8;\n        let mut extension_name = extension.clone();\n        for ch in\
    \ extension_name.chars() {\n            if ch.is_lowercase() {\n             \
    \   break;\n            }\n            extension_name.push(ch);\n        }\n\n\
    \        // Update the max extension strength if needed.\n        max_extension_strength\
    \ = if extension_strength > max_extension_strength { extension_strength } else\
    \ { max_extension_strength };\n        max_extension_name = extension_name if\
    \ extension_strength > max_extension_strength { extension_name } else { max_extension_name\
    \ };\n    }\n\n    // If there are multiple extensions with the same max extension\
    \ strength,\n    // choose the one that comes first in the vector (lexicographically).\n\
    \    if extensions.iter().any(|&(_, x)| x == max_extension_name) {\n        extensions\
    \ = extensions\n            .iter()\n            .filter(|&(_, x)| x == max_extension_name)\n\
    \            .cloned()\n            .collect::<Vec<_>>();\n    }\n\n    let max_extension_strength:\
    \ u8 = max_extension_strength;\n    let max_extension_name: String = max_extension_name;\n\
    \n    // Return the max extension name.\n    class_name.to_string().format(\"\
    .{0}\", max_extension_name)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmptibhfq7x.rs:51:45\n   |\n51 |         max_extension_name\
    \ = extension_name if extension_strength > max_extension_strength { extension_name\
    \ } else { max_extension_name };\n   |                                       \
    \      ^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptibhfq7x.rs:26:42\n   |\n26 |     let mut max_extension_name: String\
    \ = \"\";\n   |                                 ------   ^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                                 |  \
    \      |\n   |                                 |        expected struct `String`,\
    \ found `&str`\n   |                                 expected due to this\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptibhfq7x.rs:56:32\n   |\n56 |  \
    \   if extensions.iter().any(|&(_, x)| x == max_extension_name) {\n   |      \
    \                          ^^^^^-\n   |                                |    |\n\
    \   |                                |    expected due to this\n   |         \
    \                       expected struct `String`, found tuple\n   |\n   = note:\
    \ expected struct `String`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptibhfq7x.rs:59:23\n   |\n59 |             .filter(|&(_,\
    \ x)| x == max_extension_name)\n   |                       ^^^^^-\n   |      \
    \                 |    |\n   |                       |    expected due to this\n\
    \   |                       expected struct `String`, found tuple\n   |\n   =\
    \ note: expected struct `String`\n               found tuple `(_, _)`\n\nerror[E0599]:\
    \ no method named `format` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmptibhfq7x.rs:68:28\n   |\n68 |     class_name.to_string().format(\".{0}\"\
    , max_extension_name)\n   |                            ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() > 0 {\
    \ \n        let mut extensions = extensions.clone();\n        let mut len = extensions[0].len();\n\
    \        for element in &extensions {\n            len += element.len();\n   \
    \     }\n        let mut strength = -1;\n        let mut index = -1;\n       \
    \ for element in &extensions {\n            strength = strength.max(element.to_lowercase().chars().count());\n\
    \            index = elements.iter().position(|&x| x.to_lowercase().chars().count()\
    \ == strength);\n            if index != -1 {\n                break;\n      \
    \      }\n        }\n        let mut sliced = &extensions[index];\n        if\
    \ sliced.len() != 0 {\n            sliced = sliced.to_string();\n        }\n \
    \       let mut class_name = class_name.to_string();\n        let mut strongest_extension\
    \ = class_name.to_string();\n        for element in &extensions {\n          \
    \  if element.to_lowercase().chars().count() > strength {\n                strongest_extension\
    \ = element.to_string();\n            }\n        }\n        return strongest_extension;\n\
    \    }\n    return class_name;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `elements` in this scope\n  --> /tmp/tmp2j1fytlq.rs:28:21\n\
    \   |\n28 |             index = elements.iter().position(|&x| x.to_lowercase().chars().count()\
    \ == strength);\n   |                     ^^^^^^^^ help: a local variable with\
    \ a similar name exists: `element`\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmp2j1fytlq.rs:24:28\n   |\n24 |         let mut\
    \ strength = -1;\n   |                            ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmp2j1fytlq.rs:25:25\n   |\n25 |         let mut index\
    \ = -1;\n   |                         ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmp2j1fytlq.rs:29:25\n   |\n29 |             if index\
    \ != -1 {\n   |                         ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2j1fytlq.rs:35:22\n\
    \   |\n33 |         let mut sliced = &extensions[index];\n   |               \
    \           ------------------ expected due to this value\n34 |         if sliced.len()\
    \ != 0 {\n35 |             sliced = sliced.to_string();\n   |                \
    \      ^^^^^^^^^^^^^^^^^^\n   |                      |\n   |                 \
    \     expected `&String`, found struct `Strin"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for (index, extension) in extensions.iter().enumerate() {\n        extensions_map.insert(extension.to_lowercase(),\
    \ index);\n    }\n\n    let mut strength = 0;\n    let mut extension_index = 0;\n\
    \    while extension_index < extensions.len() {\n        let extension = &extensions[extension_index];\n\
    \        let extension_index = extensions_map.get(extension.to_lowercase()).unwrap();\n\
    \n        let c = extension.chars().filter(|&c| c >= 'A' && c <= 'Z').count();\n\
    \        let s = extension.chars().filter(|&c| c >= 'a' && c <= 'z').count();\n\
    \        strength += (c - s);\n    }\n    String::from(class_name + extensions[strength].to_string().to_lowercase())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpy5qfd_mw.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmpy5qfd_mw.rs:31:21\n\
    \   |\n31 |         strength += (c - s);\n   |                     ^     ^\n \
    \  |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n31 -         strength += (c - s);\n31 +         strength += c - s;\n  \
    \ | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy5qfd_mw.rs:33:31\n   |\n\
    33 |     String::from(class_name + extensions[strength].to_string().to_lowercase())\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                               |\n   |                               expected\
    \ `&str`, found struct `String`\n   |                               help: consider\
    \ borrowing here: `&extensions[strength].to_string().to_lowercase()`\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map: HashMap<String,\
    \ usize> = extensions.iter().map(|x| {\n        (x.to_ascii_lowercase(), x.len()\
    \ + 1)\n    }).collect();\n    \n    let mut strength = -1;\n    let mut strongest:\
    \ String = class_name;\n    for (extension_name, count) in extensions_map.iter()\
    \ {\n        if count > strength {\n            strength = count;\n          \
    \  strongest = class_name + \".\" + extension_name;\n        }\n    }\n    strongest\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpqrasv1o6.rs:18:29\n\
    \   |\n18 |     let mut extensions_map: HashMap<String, usize> = extensions.iter().map(|x|\
    \ {\n   |                             ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = extensions.iter().cloned().collect::<HashMap<_,\
    \ _>>();\n    extensions_map.sort_by_key(|&(k1, _)| k1.chars().fold(0, |res, c|\
    \ {\n        res + (c.to_ascii_lowercase().unwrap() as u128 - c.to_ascii_uppercase().unwrap()\
    \ as u128) as i32\n    })).into_iter().take(1).next()\n        .map(|(k1, v1)|\
    \ k1 + String::from(\".\") + v1)\n        .unwrap_or_else(|_| class_name + \"\
    .\" + extensions[0])\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpopm9e0et.rs:18:67\n\
    \   |\n18 |     let mut extensions_map = extensions.iter().cloned().collect::<HashMap<_,\
    \ _>>();\n   |                                                               \
    \    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpopm9e0et.rs:23:48\n   |\n23 |         .unwrap_or_else(|_| class_name\
    \ + \".\" + extensions[0])\n   |                                             \
    \   ^^^^^^^^^^^^^\n   |                                                |\n   |\
    \                                                expected `&str`, found struct\
    \ `String`\n   |                                                help: consider\
    \ borrowing here: `&extensions[0]`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0412.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n  let mut strength = -1i32;\n\
    \  for ext in extensions.iter() {\n    let cap = ext.chars().filter(|c| c.is_uppercase()).count();\n\
    \    let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n    strength\
    \ = (cap - sm) as i32 / cap as i32;\n    if strength > 0 {\n      break;\n   \
    \ }\n  }\n  let class_name = format!(\"{}.{}\", class_name, extensions.iter().cloned().sorted().first().unwrap());\n\
    \  if strength > 0 {\n    class_name.to_string()\n  } else {\n    String::from(\"\
    ErrorStrongestExtension\")\n  }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpt_cb0ssj.rs:27:76\n   |\n27 |   let class_name\
    \ = format!(\"{}.{}\", class_name, extensions.iter().cloned().sorted().first().unwrap());\n\
    \   |                                                                        \
    \    ^^^^^^ method not found in `Cloned<std::slice::Iter<'_, String>>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = vec![];\n\
    \n    for extension in extensions {\n        let mut class_name = class_name;\n\
    \        let mut extension = extension;\n        let mut extension_len = extension.len();\n\
    \n        let mut max_strength = -1;\n        let mut max_extension = String::from(\"\
    \");\n\n        for mut i = 0; i < extension_len; i++ {\n            let mut char\
    \ = String::from(\"\");\n            let mut index = i;\n            let mut char_length\
    \ = extension.len();\n            while index > 0 && char_length > 0 {\n     \
    \           char = extension[index - char_length..index];\n                char_length\
    \ = char_length - 1;\n                index = index - 1;\n            }\n    \
    \        let mut char_digits = char.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \            let mut char_letters = char.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \            let mut strength = char_digits - char_letters;\n\n            if\
    \ strength > max_strength {\n                max_extension = extension;\n    \
    \            max_strength = strength;\n            }\n        }\n        result.push(format!(\"\
    {}.{}\", class_name, max_extension));\n    }\n\n    result.iter().fold(String::from(\"\
    \"), |mut result, _| {\n        if result.is_empty() {\n            return result;\n\
    \        }\n        let mut last_index = result.len();\n        for _ in 0..result.len()\
    \ - 1 {\n            if result.chars().any(|c| !c.is_ascii_whitespace()) {\n \
    \               last_index = result.len();\n                break;\n         \
    \   }\n        }\n        let mut last_char = result.chars().nth(last_index).unwrap();\n\
    \        if !last_char.ascii_ascii_casefold().is_ascii_ascii_whitespace() {\n\
    \            last_char = String::from(\"\");\n        }\n        result.set_len(result.len()\
    \ - 1);\n        result + last_char + String::from(\"\") + &result[..]\n    }).to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpxue8zd0b.rs:28:18\n  \
    \ |\n28 |         for mut i = 0; i < extension_len; i++ {\n   |              \
    \    ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n \
    \ --> /tmp/tmpxue8zd0b.rs:28:19\n   |\n28 |         for mut i = 0; i < extension_len;\
    \ i++ {\n   |                   ^ expected expression\n\nerror[E0599]: no method\
    \ named `ascii_ascii_casefold` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpxue8zd0b.rs:61:23\n   |\n61 |         if !last_char.ascii_ascii_casefold().is_ascii_ascii_whitespace()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxue8zd0b.rs:62:25\n   |\n60 |\
    \         let mut last_char = result.chars().nth(last_index).unwrap();\n   | \
    \                            --------------------------------------- expected\
    \ due to this value\n61 |         if !last_char.ascii_ascii_casefold().is_ascii_ascii_whitespace()\
    \ {\n62 |             last_char = String::from(\"\");\n   |                  \
    \       ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]:\
    \ no method named `set_len` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpxue8zd0b.rs:64:16\n   |\n64 |         result.set_len(result.len()\
    \ - 1);\n   |                ^^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxue8zd0b.rs:65:18\n   |\n65 |         result\
    \ + last_char + String::from(\"\") + &result[..]\n   |                  ^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxue8zd0b.rs:65:30\n\
    \   |\n65 |         result + last_char + String::from(\"\") + &result[..]\n  \
    \ |                              ^^^^^^^^^^^^^^^^\n   |                      \
    \        |\n   |                              expected `&str`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&String::from(\"\
    \")`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --expl"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.clone();\n    let mut max_extension_strength = 0;\n    for (i,\
    \ element) in extensions_sorted.iter().enumerate() {\n        let c = element[..].chars().filter(|&c|\
    \ c.is_upper()).count();\n        let s = element[..].chars().filter(|&c| c.is_lower()).count();\n\
    \        if c > s {\n            max_extension_strength = i;\n        }\n    }\n\
    \    let strength = max_extension_strength - extensions.iter().filter(|&element|\
    \ element.starts_with(class_name.as_str())).count();\n    class_name.to_string().concat(\"\
    .\").to_string(strength.to_string()).to_string(&extensions_sorted[strength])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpshlzbi3x.rs:21:51\n   |\n21 |         let c = element[..].chars().filter(|&c|\
    \ c.is_upper()).count();\n   |                                               \
    \    ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\
    \nerror[E0599]: no method named `is_lower` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpshlzbi3x.rs:22:51\n   |\n22 |         let s = element[..].chars().filter(|&c|\
    \ c.is_lower()).count();\n   |                                               \
    \    ^^^^^^^^ help: there is an associated function with a similar name: `is_lowercase`\n\
    \nerror[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpshlzbi3x.rs:28:28\n   |\n28 |     class_name.to_string().concat(\"\
    .\").to_string(strength.to_string()).to_string(&extensions_sorted[strength])\n\
    \   |                            ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions[\n        extensions.iter().filter(|x|\
    \ x.chars().filter(|x| x.is_uppercase()).count() >\n                         \
    \            x.chars().filter(|x| x.is_lowercase()).count()\n        ).min(|a,\
    \ b| {\n            a.chars().filter(|x| x.is_uppercase()).count() <\n       \
    \     b.chars().filter(|x| x.is_uppercase()).count()\n        }).unwrap().to_string()\
    \ + \".\" +\n        extensions[\n            extensions.iter().filter(|x| x.chars().filter(|x|\
    \ x.is_lowercase()).count() >\n                                     x.chars().filter(|x|\
    \ x.is_lowercase()).count()\n        ).min(|a, b| {\n            a.chars().filter(|x|\
    \ x.is_lowercase()).count() <\n            b.chars().filter(|x| x.is_lowercase()).count()\n\
    \        }).unwrap().to_string()\n    ]\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp6gorlilo.rs:18:15\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - closing delimiter possibly meant for this\n18 |     extensions[\n\
    \   |               ^ unclosed delimiter\n...\n33 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0282]: type annotations needed\n  --> /tmp/tmp6gorlilo.rs:21:16\n\
    \   |\n21 |         ).min(|a, b| {\n   |                ^ consider giving this\
    \ closure parameter a type\n   |\n   = note: type must be known at this point\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp6gorlilo.rs:21:11\n     |\n21   |           ).min(|a, b| {\n\
    \     |  ___________^^^_-\n     | |           |\n     | |           expected 0\
    \ arguments\n22   | |             a.chars().filter(|x| x.is_uppercase()).count()\
    \ <\n23   | |             b.chars().filter(|x| x.is_uppercase()).count()\n24 \
    \  | |         }).unwrap().to_string() + \".\" +\n     | |_________- supplied\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp6gorlilo.rs:28:11\n\
    \     |\n28   |           ).min(|a, b| {\n     |  ___________^^^_-\n     | | \
    \          |\n     | |           expected 0 arguments\n29   | |             a.chars().filter(|x|\
    \ x.is_lowercase()).count() <\n30   | |             b.chars().filter(|x| x.is_lowercase()).count()\n\
    31   | |         }).unwrap().to_string()\n     | |_________- supplied 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0277]: the type `[String]`\
    \ cannot be indexed by `String`\n  --> /tmp/tmp6gorlilo.rs:25:9\n   |\n25 | /\
    \         extensions[\n26 | |             extensions.iter().filter(|x| x.chars().filter(|x|\
    \ x.is_lowercase()).count() >\n27 | |                                      x.chars().filter(|x|\
    \ x.is_lowercase()).count()\n28 | |         ).min(|a, b| {\n...  |\n31 | |   \
    \      }).unwrap().to_string()\n32 | |     ]\n   | |_____^ slice i"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Write your code here\n\
    \    \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzjv4fwmu.rs:17:72\n   |\n\
    17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut current_strongest_ext\
    \ = \"\";\n    for ext in extensions {\n        let strength = (ext.to_lowercase().chars().count()).saturating_sub((ext.to_uppercase().chars().count()).saturating_sub(1));\n\
    \        if strength > 0 {\n            current_strongest_ext = class_name + \"\
    .\" + ext;\n            break;\n        }\n    }\n    return current_strongest_ext;\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_co1kakf.rs:22:56\n   |\n\
    22 |             current_strongest_ext = class_name + \".\" + ext;\n   |     \
    \                                                   ^^^\n   |                \
    \                                        |\n   |                             \
    \                           expected `&str`, found struct `String`\n   |     \
    \                                                   help: consider borrowing here:\
    \ `&ext`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_co1kakf.rs:22:37\n\
    \   |\n18 |     let mut current_strongest_ext = \"\";\n   |                  \
    \                   -- expected due to this value\n...\n22 |             current_strongest_ext\
    \ = class_name + \".\" + ext;\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                     |\n   |                            \
    \         expected `&str`, found struct `String`\n   |                       \
    \              help: consider borrowing here: `&(class_name + \".\" + ext)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_co1kakf.rs:26:12\n   |\n17 | fn\
    \ Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n\
    \   |                                                                        ------\
    \ expected `String` because of return type\n...\n26 |     return current_strongest_ext;\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = String::from(class_name);\n\
    \    let mut extension_vec: Vec<String> = extensions.to_vec();\n    extension_vec.sort();\n\
    \    let mut count = 0;\n    for extension in &extension_vec {\n        let mut\
    \ new_str: String = extension.clone();\n        let mut counter: isize = 0;\n\
    \        let mut last: String;\n        for c in &new_str {\n            if c.is_uppercase()\
    \ {\n                counter = counter + 1;\n                if last != \"\" {\n\
    \                    last = extension.clone();\n                }\n          \
    \  } else if c.is_lowercase() {\n                counter = counter - 1;\n    \
    \        }\n            if counter == 0 {\n                break;\n          \
    \  }\n        }\n        if counter == 0 {\n            break;\n        }\n  \
    \      result = result.push_str(&last);\n    }\n    if result == class_name {\n\
    \        result.push_str(&extensions[0])\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpzbzpx7f6.rs:26:18\n\
    \   |\n26 |         for c in &new_str {\n   |                  ^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzbzpx7f6.rs:42:18\n\
    \   |\n18 |     let mut result = String::from(class_name);\n   |             \
    \         ------------------------ expected due to this value\n...\n42 |     \
    \    result = result.push_str(&last);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpzbzpx7f6.rs:42:25\n   |\n42 |         result\
    \ = result.push_str(&last);\n   |                  ------ ^^^^^^^^ this call modifies\
    \ `result` in-place\n   |                  |\n   |                  you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min = String::new();\n\
    \    let mut max = String::new();\n    for (i, ex) in extensions.iter().enumerate()\
    \ {\n        let ext: &str = ex;\n        let cap = ext\n            .chars()\n\
    \            .filter(|&c| c.is_uppercase())\n            .count();\n        let\
    \ sm = ext\n            .chars()\n            .filter(|&c| c.is_lowercase())\n\
    \            .count();\n        if cap > sm {\n            if cap > 0 {\n    \
    \            min.push_str(ext);\n            } else {\n                max.push_str(ext);\n\
    \            }\n        } else if sm > cap {\n            if sm > 0 {\n      \
    \          min.push_str(ext);\n            } else {\n                max.push_str(ext);\n\
    \            }\n        }\n    }\n    if min.is_empty() {\n        return max;\n\
    \    }\n    if max.is_empty() {\n        return min;\n    }\n    let cap = min.chars().filter(|&c|\
    \ c.is_uppercase()).count();\n    let sm = min.chars().filter(|&c| c.is_lowercase()).count();\n\
    \    let result = if cap > sm {\n        min\n    } else {\n        max\n    };\n\
    \    format!(\"{}.{}\", class_name, result)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tENeIGHt8OKe\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpptcabzlg.rs:62:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut class_name = String::from(class_name);\n\
    \    let mut extensions = extensions.clone();\n    let mut index = 0;\n    let\
    \ mut highest_strength = -1;\n\n    while extensions.len() > 0 {\n        let\
    \ mut current_strength = 0;\n        let mut current_extension = extensions.remove(0);\n\
    \        \n        for i in 0..class_name.len() {\n            let letter = class_name[i];\n\
    \            \n            if letter == current_extension[0] {\n             \
    \   current_strength += 1;\n            } else {\n                break;\n   \
    \         }\n        }\n\n        if current_strength > highest_strength {\n \
    \           highest_strength = current_strength;\n            index = current_extension.len();\n\
    \        }\n    }\n    class_name.set_len(0);\n    class_name.push_str(&extensions[index]);\n\
    \    class_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiv_8kz77.rs:28:26\n\
    \   |\n28 |             let letter = class_name[i];\n   |                    \
    \      ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpiv_8kz77.rs:30:26\n   |\n30 |             if letter == current_extension[0]\
    \ {\n   |                          ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `set_len` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpiv_8kz77.rs:42:16\n   |\n42 |     class_name.set_len(0);\n\
    \   |                ^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut counter = 0;\n        for\
    \ char in extension {\n            if char == char.to_upper() {\n            \
    \    counter++;\n            }\n        }\n        extensions_map.insert(counter,\
    \ extension);\n    }\n    extensions_map.keys().max().unwrap().to_string()\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp0gfg4r75.rs:23:24\n\
    \   |\n23 |                 counter++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23 |               \
    \  { let tmp = counter; counter += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n23 -                 counter++;\n23 +        \
    \         counter += 1;\n   | \n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashMap`\n  --> /tmp/tmp0gfg4r75.rs:18:30\n   |\n18 |     let mut extensions_map\
    \ = HashMap::new();\n   |                              ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp0gfg4r75.rs:21:21\n\
    \   |\n21 |         for char in extension {\n   |                     ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        strength = (cap - sm) as i32;\n  \
    \  }\n\n    if strength == -1 {\n        format!(\"{}.\", class_name)\n    } else\
    \ {\n        format!(\"{}.{}\", class_name, extensions[strength].to_lowercase())\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `i32`\n  --> /tmp/tmpeyysqu3g.rs:28:38\n\
    \   |\n28 |         format!(\"{}.{}\", class_name, extensions[strength].to_lowercase())\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `i32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i32>` for `Vec<String>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let extension = extensions.iter().position(|x|\
    \ x.is_upper()).unwrap();\n    let extension_strength = extensions.iter().position(|x|\
    \ x.chars().count(|x| x.is_uppercase())).unwrap();\n    (class_name.to_string()\
    \ + &extensions[extension].to_string() + &extensions[extension_strength].to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpjciq1lp0.rs:18:54\n   |\n18 |     let extension\
    \ = extensions.iter().position(|x| x.is_upper()).unwrap();\n   |             \
    \                                         ^^^^^^^^ method not found in `&String`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpjciq1lp0.rs:19:71\n    |\n19  |     let extension_strength = extensions.iter().position(|x|\
    \ x.chars().count(|x| x.is_uppercase())).unwrap();\n    |                    \
    \                                                   ^^^^^ --------------------\
    \ supplied 1 argument\n    |                                                 \
    \                      |\n    |                                              \
    \                         expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjciq1lp0.rs:19:61\n\
    \   |\n19 |     let extension_strength = extensions.iter().position(|x| x.chars().count(|x|\
    \ x.is_uppercase())).unwrap();\n   |                                         \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut ext_map = extensions_map.entry(extension.clone());\n\
    \        if let Some(mut v) = ext_map.mutate() {\n            v.insert(String::from(class_name.clone()));\n\
    \        }\n    }\n    \n    // sort the map by the number of extensions\n   \
    \ extensions_map.sort_by(|a, b| b.value.len());\n\n    // Return the strongest\
    \ extension name\n    if let Some((_, value)) = extensions_map.iter().next() {\n\
    \        let strength = value.len();\n        let mut strongest_name = class_name.clone();\n\
    \        let mut prev_letter: Char = 0;\n        for letter in value {\n     \
    \       if prev_letter != letter + 32 {\n                strongest_name += &format!(\"\
    {}\", letter);\n            }\n            prev_letter = letter + 32;\n      \
    \  }\n        return strongest_name;\n    }\n    return String::from(\"\");\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpn2y8hqm8.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpn2y8hqm8.rs:33:30\n\
    \   |\n33 |         let mut prev_letter: Char = 0;\n   |                     \
    \         ^^^^ help: a builtin type with a similar name exists (notice the capitalization):\
    \ `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions\n        .iter()\n\
    \        .fold(String::from(class_name), |mut current, name| {\n            if\
    \ let Some(index) = class_name.iter().position(|c| c.is_uppercase())\n       \
    \             .cloned()\n                    .find(|c| c.is_lowercase())\n   \
    \         {\n                let name = &name[index..];\n                let current_strength\
    \ = current.to_lowercase().chars().count();\n                let extension_strength\
    \ = name.chars().count();\n                let strength = current_strength - extension_strength;\n\
    \                let mut current_str = String::from(current);\n              \
    \  let mut name = String::from(name);\n                if strength > 0 {\n   \
    \                 current_str.push_str(&name.chars().rev());\n               \
    \     name.push_str(&name.chars().rev());\n                }\n               \
    \ String::from(current_str)\n            } else {\n                current\n \
    \           }\n        })\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpoq_nve3g.rs:21:45\n   |\n21 |             if let Some(index)\
    \ = class_name.iter().position(|c| c.is_uppercase())\n   |                   \
    \                          ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n21 |             if let Some(index)\
    \ = class_name.chars().position(|c| c.is_uppercase())\n   |                  \
    \                           ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoq_nve3g.rs:32:42\n\
    \   |\n32 |                     current_str.push_str(&name.chars().rev());\n \
    \  |                                          ^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found struct `Rev`\n   |\n   = note: expected reference `&str`\n           \
    \   found reference `&Rev<Chars<'_>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoq_nve3g.rs:33:35\n   |\n33 |                     name.push_str(&name.chars().rev());\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ struct `Rev`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&Rev<Chars<'_>>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut best_name = String::from(\"\");\n    for ext in extensions {\n    \
    \    let cname = class_name + ext;\n        if strength == 0 || cname.chars().filter(|c|\
    \ c.is_uppercase()).count() > strength {\n            strength = cname.chars().filter(|c|\
    \ c.is_uppercase()).count() - ext.chars().filter(|c| c.is_lowercase()).count();\n\
    \            best_name = cname;\n        }\n    }\n    \n    format!(\"{}.{}\"\
    , class_name, best_name)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw7cyhpff.rs:21:34\n   |\n\
    21 |         let cname = class_name + ext;\n   |                             \
    \     ^^^\n   |                                  |\n   |                     \
    \             expected `&str`, found struct `String`\n   |                   \
    \               help: consider borrowing here: `&ext`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions[0]\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `class_name`\n  --> /tmp/tmpnt8at0by.rs:17:24\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                        ^^^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_class_name`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmpnt8at0by.rs:18:5\n   |\n18 |     extensions[0]\n   |     ^^^^^^^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut highest_strength_extension: Option<String> = None;\n    for ext in\
    \ extensions {\n        let cap_ext = ext.to_lowercase().chars().filter(|c| *c\
    \ >= 'A').count() - ext.to_lowercase().chars().filter(|c| *c <= 'Z').count();\n\
    \        let sl_ext = ext.to_lowercase().chars().filter(|c| *c >= 'a').count()\
    \ - ext.to_lowercase().chars().filter(|c| *c <= 'z').count();\n        if cap_ext\
    \ > 0 && sl_ext > 0 {\n            let strength = cap_ext as f32 - sl_ext as f32;\n\
    \            if strength > strength {\n                strength = strength;\n\
    \                highest_strength_extension = Some(ext);\n            }\n    \
    \    }\n    }\n    if let Some(extension) = highest_strength_extension {\n   \
    \     format!(\"{}.{}\", class_name, extension)\n    } else {\n        format!(\"\
    {}\", class_name)\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpewe1bvus.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `strength`\
    \ is never read\n  --> /tmp/tmpewe1bvus.rs:26:17\n   |\n26 |                 strength\
    \ = strength;\n   |                 ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpewe1bvus.rs:18:9\n   |\n\
    18 |     let mut strength = -1;\n   |         ----^^^^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0384]: cannot assign twice to immutable variable `strength`\n\
    \  --> /tmp/tmpewe1bvus.rs:26:17\n   |\n24 |             let strength = cap_ext\
    \ as f32 - sl_ext as f32;\n   |                 --------\n   |               \
    \  |\n   |                 first assignment to `strength`\n   |              \
    \   help: consider making this binding mutable: `mut strength`\n25 |         \
    \    if strength > strength {\n26 |                 strength = strength;\n   |\
    \                 ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension:\
    \ usize = -1;\n    let mut num_of_lower = 0;\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| match c {\n            'A'...'Z'\
    \ => true,\n            _ => false,\n        }).count();\n        let sm = extension.chars().filter(|c|\
    \ match c {\n            'a'...'z' => true,\n            _ => false,\n       \
    \ }).count();\n        if cap > sm {\n            num_of_lower += 1;\n       \
    \ } else {\n            num_of_lower -= 1;\n        }\n        strongest_extension\
    \ = if strongest_extension == -1 || cap > strongest_extension {\n            cap\n\
    \        } else {\n            strongest_extension\n        };\n    }\n    strongest_extension\
    \ = if strongest_extension == -1 || num_of_lower > strongest_extension {\n   \
    \     num_of_lower\n    } else {\n        strongest_extension\n    };\n    class_name.to_string()\
    \ + extensions[strongest_extension].to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpicqolz11.rs:22:16\n\
    \   |\n22 |             'A'...'Z' => true,\n   |                ^^^ help: use\
    \ `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpicqolz11.rs:26:16\n\
    \   |\n26 |             'a'...'z' => true,\n   |                ^^^ help: use\
    \ `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpicqolz11.rs:18:42\n\
    \   |\n18 |     let mut strongest_extension: usize = -1;\n   |               \
    \                           ^^\n   |                                         \
    \ |\n   |                                          cannot apply unary operator\
    \ `-`\n   |                                          help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpicqolz11.rs:34:57\n   |\n34 |         strongest_extension = if\
    \ strongest_extension == -1 || cap > strongest_extension {\n   |             \
    \                                            ^^\n   |                        \
    \                                 |\n   |                                    \
    \                     cannot apply unary operator `-`\n   |                  \
    \                                       help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut total_extensions =\
    \ extensions.len();\n    for extension in extensions {\n        let num_upper\
    \ = extension.chars().filter(|&c| c.is_upper()).count();\n        let num_lower\
    \ = extension.chars().filter(|&c| c.is_lowercase()).count();\n        total_extensions\
    \ = (num_upper - num_lower) / num_upper as f64 + total_extensions as f64;\n  \
    \  }\n    let strength = total_extensions as f64;\n    match strength {\n    \
    \    1.0 => class_name.to_string(),\n        0.0 => \"\",\n        strength =>\
    \ format!(\"{}.{}\", class_name, extensions[total_extensions..total_extensions..-1].to_string()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `..`\n  --> /tmp/tmpvkk0lcqx.rs:28:95\n   |\n28 |         strength => format!(\"\
    {}.{}\", class_name, extensions[total_extensions..total_extensions..-1].to_string()),\n\
    \   |                                                                        \
    \                       ^^ expected one of 7 possible tokens\n\nerror[E0599]:\
    \ no method named `is_upper` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpvkk0lcqx.rs:20:57\n   |\n20 |         let num_upper = extension.chars().filter(|&c|\
    \ c.is_upper()).count();\n   |                                               \
    \          ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_uppercase`\n\nerror[E0277]: cannot divide `usize` by `f64`\n  --> /tmp/tmpvkk0lcqx.rs:22:52\n\
    \   |\n22 |         total_extensions = (num_upper - num_lower) / num_upper as\
    \ f64 + total_extensions as f64;\n   |                                       \
    \             ^ no implementation for `usize / f64`\n   |\n   = help: the trait\
    \ `Div<f64>` is not implemented for `usize`\n   = help: the following other types\
    \ implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n          \
    \   <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n            \
    \ <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a\
    \ i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a isize\
    \ as Div<isize>>\n           and 54 others\n\nerror[E0308]: `match` arms have\
    \ incompatible types\n  --> /tmp/tmpvkk0lcqx.rs:27:16\n   |\n25 | /     match\
    \ strength {\n26 | |         1.0 => class_name.to_string(),\n   | |          \
    \      ---------------------- this is found to be of type `String`\n27 | |   \
    \      0.0 => \"\",\n   | |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   | |                |\n   | |                expected struct\
    \ `String`, found `&str`\n28 | |         strength => format!(\"{}.{}\", class_name,\
    \ extensions[total_extensions..total_extensions..-1].to_string()),\n29 | |   \
    \  }\n   | |_____- `match` arms have incompa"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = None;\n    let mut strength = -1i32;\n    for extension in extensions {\n\
    \        let c = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \        let s = extension.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n\
    \        let cap = c + s;\n        let sm = extension.chars().filter(|c| *c >=\
    \ 'A' && *c <= 'Z').count();\n        let strength = if cap > sm {\n         \
    \   cap - sm\n        } else {\n            sm\n        };\n        if strength\
    \ >= 0 {\n            strongest_extension = Some(extension);\n            break;\n\
    \        }\n    }\n    match strongest_extension {\n        Some(name) => {\n\
    \            format!(\"{}.{}\", class_name, name)\n        }\n        None =>\
    \ format!(\"{}.{}\", class_name, extensions[0].to_owned()),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmp7bmcza56.rs:19:13\n\
    \   |\n19 |     let mut strength = -1i32;\n   |             ^^^^^^^^ help: if\
    \ this is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmp7bmcza56.rs:19:9\n   |\n19 |     let mut strength\
    \ = -1i32;\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `extensions`\n   --> /tmp/tmp7bmcza56.rs:39:46\n    |\n\
    17  | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n    |                                            ---------- move occurs because\
    \ `extensions` has type `Vec<String>`, which does not implement the `Copy` trait\n\
    ...\n20  |     for extension in extensions {\n    |                      ----------\
    \ `extensions` moved due to this implicit call to `.into_iter()`\n...\n39  | \
    \        None => format!(\"{}.{}\", class_name, extensions[0].to_owned()),\n \
    \   |                                              ^^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `extensions`\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n    |\n20  |     for extension\
    \ in &extensions {\n    |                      +\n\nerror: aborting due to previous\
    \ error; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min_strength: i32\
    \ = std::i32::MAX;\n    let mut best_extension: String = String::from(\"\");\n\
    \    extensions.iter().for_each(|e| {\n        if let Ok(s) = e.to_lowercase().as_ref()\
    \ {\n            if let Ok(i) = s.to_ascii_lowercase().find(|x| *x >= 'a') {\n\
    \                min_strength = i as i32;\n            }\n        }\n    });\n\
    \n    for (i, e) in extensions.iter().enumerate() {\n        if let Ok(s) = e.to_lowercase().as_ref()\
    \ {\n            if let Ok(i) = s.to_ascii_lowercase().find(|x| *x >= 'a') {\n\
    \                if min_strength == i as i32 {\n                    best_extension\
    \ = e.to_owned();\n                    min_strength = std::i32::MAX;\n       \
    \         }\n            }\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ best_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: AsRef<Result<_, _>>` is not satisfied\n\
    \  --> /tmp/tmp5nuvistx.rs:21:41\n   |\n21 |         if let Ok(s) = e.to_lowercase().as_ref()\
    \ {\n   |                                         ^^^^^^ the trait `AsRef<Result<_,\
    \ _>>` is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `AsRef<T>`:\n             <String as AsRef<OsStr>>\n       \
    \      <String as AsRef<Path>>\n             <String as AsRef<[u8]>>\n       \
    \      <String as AsRef<str>>\n             <str as AsRef<OsStr>>\n          \
    \   <str as AsRef<Path>>\n             <str as AsRef<[u8]>>\n             <str\
    \ as AsRef<str>>\n\nerror[E0277]: the trait bound `String: AsRef<Result<_, _>>`\
    \ is not satisfied\n  --> /tmp/tmp5nuvistx.rs:29:41\n   |\n29 |         if let\
    \ Ok(s) = e.to_lowercase().as_ref() {\n   |                                  \
    \       ^^^^^^ the trait `AsRef<Result<_, _>>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `AsRef<T>`:\n    \
    \         <String as AsRef<OsStr>>\n             <String as AsRef<Path>>\n   \
    \          <String as AsRef<[u8]>>\n             <String as AsRef<str>>\n    \
    \         <str as AsRef<OsStr>>\n             <str as AsRef<Path>>\n         \
    \    <str as AsRef<[u8]>>\n             <str as AsRef<str>>\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut name_extension = class_name;\n    for extension in extensions.iter()\
    \ {\n        if extension.chars().count() > strength {\n            strength =\
    \ extension.chars().count();\n            name_extension = &format!(\"{}.{}\"\
    , class_name, extension);\n        }\n    }\n    return name_extension;\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmplsq_5rjp.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplsq_5rjp.rs:23:30\n   |\n19 |     let mut name_extension = class_name;\n\
    \   |                              ---------- expected due to this value\n...\n\
    23 |             name_extension = &format!(\"{}.{}\", class_name, extension);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\nhelp: consider removing the borrow\n\
    \   |\n23 -             name_extension = &format!(\"{}.{}\", class_name, extension);\n\
    23 +             name_extension = format!(\"{}.{}\", class_name, extension);\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut exts = extensions.iter().cloned();\n\
    \    let mut max_strength = -1;\n    let mut max_extension = String::from(\"\"\
    );\n    loop {\n        let mut current_strength = 0;\n        let mut current_extension\
    \ = String::from(\"\");\n        for extension in &mut exts {\n            let\
    \ cap = extension.chars().filter(|&x| x >= 'A' && x <= 'Z').count();\n       \
    \     let sm = extension.chars().filter(|&x| x >= 'a' && x <= 'z').count();\n\
    \            current_strength += cap - sm;\n            current_extension += extension;\n\
    \        }\n        if current_strength > max_strength {\n            max_strength\
    \ = current_strength;\n            max_extension = current_extension;\n      \
    \  }\n        if exts.next().is_none() {\n            break;\n        }\n    }\n\
    \    class_name.as_string() + \".\" + max_extension\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0u9w43bc.rs:28:34\n   |\n\
    28 |             current_extension += extension;\n   |                       \
    \           ^^^^^^^^^\n   |                                  |\n   |         \
    \                         expected `&str`, found struct `String`\n   |       \
    \                           help: consider borrowing here: `&extension`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp0u9w43bc.rs:19:28\n\
    \   |\n19 |     let mut max_strength = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0599]:\
    \ no method named `as_string` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp0u9w43bc.rs:38:16\n   |\n38 |     class_name.as_string() + \".\"\
    \ + max_extension\n   |                ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `as_str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_strength\
    \ = Vec::new();\n    for ext in extensions {\n        let cap = ext.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let strength = cap - sm;\n        extension_strength.push(strength);\n\
    \    }\n    extension_strength.sort_by_key(|&x| x).next().unwrap().to_string()\n\
    \        + \".\" + class_name.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmplpr3o00r.rs:25:44\n   |\n25 |     extension_strength.sort_by_key(|&x|\
    \ x).next().unwrap().to_string()\n   |                                       \
    \     ^^^^ method not found in `()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = 0;\n  \
    \  let mut classname = class_name;\n    let mut extension = String::new();\n \
    \   \n    // Loop over each of the extensions\n    for i in 0..extensions.len()\
    \ {\n        // Get the uppercase number of a certain letter \n        let cap\
    \ = extensions[i].to_uppercase().chars().count();\n        // Get the lowercase\
    \ number of a certain letter\n        let sm = extensions[i].to_lowercase().chars().count();\n\
    \        // Get the strength of the extension\n        let score = cap - sm;\n\
    \        // Check if there are multiple extensions with the same strength\n  \
    \      // and select the one that comes first in the vector\n        if strength\
    \ != score && strength != 0 {\n            classname += &extensions[i];\n    \
    \        extension = extensions[i];\n            strength = score;\n        }\n\
    \    }\n\n    classname + &extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpqq_jyat1.rs:34:25\n\
    \   |\n34 |             extension = extensions[i];\n   |                     \
    \    ^^^^^^^^^^^^^ move occurs because value has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension:\
    \ Option<String> = None;\n    let mut max_strength: Option<usize> = None;\n  \
    \  for extension in extensions.iter() {\n        let extension_strength: usize\
    \ = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() - extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        if max_strength.is_none() {\n    \
    \        max_strength = Some(extension_strength);\n        } else if extension_strength\
    \ > max_strength {\n            max_strength = Some(extension_strength);\n   \
    \     }\n    }\n    for extension in extensions.iter() {\n        let extension_strength:\
    \ usize = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() - extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        if extension_strength == max_strength\
    \ {\n            if strongest_extension.is_none() {\n                strongest_extension\
    \ = Some(extension);\n            }\n        }\n    }\n    if strongest_extension.is_none()\
    \ {\n        return class_name;\n    }\n    match max_strength {\n        Some(strength)\
    \ => class_name.to_string() + strongest_extension.as_ref().unwrap().to_string(),\n\
    \        None => class_name\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsb7ihxu0.rs:24:40\n   |\n\
    24 |         } else if extension_strength > max_strength {\n   |             \
    \                           ^^^^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsb7ihxu0.rs:30:34\n   |\n30 |\
    \         if extension_strength == max_strength {\n   |                      \
    \            ^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note:\
    \ expected type `usize`\n              found enum `Option<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsb7ihxu0.rs:32:44\n   |\n32 |              \
    \   strongest_extension = Some(extension);\n   |                             \
    \               ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                            |\n   |                     \
    \                       expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsb7ihxu0.rs:40:52\n   |\n40 |         Some(strength)\
    \ => class_name.to_string() + strongest_extension.as_ref().unwrap().to_string(),\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                    |\n   |             \
    \                                       expected `&str`, found struct `String`\n\
    \   |                                                    help: consider borrowing\
    \ here: `&strongest_extension.as_ref().unwrap().to_string()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max = -1;\n    let\
    \ mut strongest = String::from(\"\");\n    for extension in extensions.iter()\
    \ {\n        let ext = String::from(extension);\n        if ext.chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').count() > max {\n            max = ext.chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').count();\n        }\n    }\n    strongest.push_str(&class_name);\n\
    \    strongest.push_str(&extensions[extensions.iter().find_index(|&x| x.chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').count() > max)]);\n    strongest\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpmfu9hfrs.rs:18:19\n\
    \   |\n18 |     let mut max = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0599]: no method named `find_index`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpmfu9hfrs.rs:27:54\n\
    \   |\n27 |     strongest.push_str(&extensions[extensions.iter().find_index(|&x|\
    \ x.chars().filter(|&c| c >= 'A' && c <= 'Z').count() > max)]);\n   |        \
    \                                              ^^^^^^^^^^ method not found in\
    \ `std::slice::Iter<'_, String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut str = \"\";\n    while i < extensions.len() {\n        if\
    \ i < extensions.len() - 1 {\n            if extensions[i].is_uppercase() && extensions[i\
    \ + 1].is_lowercase() {\n                if extensions.iter().find(|x| x == &extensions[i]).is_ok()\
    \ {\n                    i += 1;\n                } else {\n                 \
    \   j += 1;\n                    i += 1;\n                }\n            } else\
    \ {\n                if extensions[i].is_lowercase() {\n                    i\
    \ += 1;\n                } else {\n                    j += 1;\n             \
    \       i += 1;\n                }\n            }\n        } else {\n        \
    \    if extensions[i].is_uppercase() {\n                i += 1;\n            }\
    \ else {\n                j += 1;\n                i += 1;\n            }\n  \
    \      }\n    }\n    format!(\"{}.{}\", class_name, extensions[(j + 1).to_string()])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpdmwy24sm.rs:23:30\n   |\n23 |          \
    \   if extensions[i].is_uppercase() && extensions[i + 1].is_lowercase() {\n  \
    \ |                              ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpdmwy24sm.rs:23:66\n\
    \   |\n23 |             if extensions[i].is_uppercase() && extensions[i + 1].is_lowercase()\
    \ {\n   |                                                                  ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpdmwy24sm.rs:24:49\n\
    \   |\n24 |                 if extensions.iter().find(|x| x == &extensions[i]).is_ok()\
    \ {\n   |                                                 ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&String>` for `&&String`\n\nerror[E0599]: no method named\
    \ `is_ok` found for enum `Option` in the current scope\n  --> /tmp/tmpdmwy24sm.rs:24:68\n\
    \   |\n24 |                 if extensions.iter().find(|x| x == &extensions[i]).is_ok()\
    \ {\n   |                                                                    ^^^^^\
    \ method not found in `Option<&String>`\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpdmwy24sm.rs:31"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for (index, extension) in extensions.iter().enumerate() {\n        extensions_map.insert(String::from(class_name\
    \ + extension), index);\n    }\n    let mut extensions_sorted = vec![];\n    extensions_map.sort_by_key(|key,\
    \ _| key).into_iter().for_each(|(extension, index)| {\n        extensions_sorted.push(String::from(extension\
    \ + class_name + \".\"));\n    });\n    extensions_sorted.pop();\n    extensions_sorted.reverse().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7048qdd6.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `join` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmp7048qdd6.rs:27:33\n   |\n27 |     extensions_sorted.reverse().join(\"\
    \")\n   |                                 ^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n\
    \    let mut max_extension: Option<String> = None;\n    for extension in extensions\
    \ {\n        let (mut cap, mut sm) = extension.chars().map(|c| (c as u8) - 'A').collect::<(Vec<usize>,\
    \ Vec<usize>)>();\n        let sm = sm.iter().map(|&c| *c).collect::<Vec<usize>>();\n\
    \        let cap = cap.iter().map(|&c| *c).collect::<Vec<usize>>();\n        let\
    \ cap = cap.iter().fold(0, |a, b| {\n            a > b ? a : b\n        });\n\
    \        let sm = sm.iter().fold(0, |a, b| {\n            a > b ? a : b\n    \
    \    });\n        let strength = cap - sm;\n        if strength > max_strength\
    \ {\n            max_strength = strength;\n            max_extension = Some(extension);\n\
    \        }\n    }\n    if let Some(extension) = max_extension {\n        format!(\"\
    {}.{}\", class_name, extension)\n    } else {\n        format!(\"{}\", class_name)\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `a`\n\
    \  --> /tmp/tmpxduop6t6.rs:25:21\n   |\n25 |             a > b ? a : b\n   | \
    \                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `a`\n  --> /tmp/tmpxduop6t6.rs:28:21\n\
    \   |\n28 |             a > b ? a : b\n   |                     ^ expected one\
    \ of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0277]: cannot subtract `char`\
    \ from `u8`\n  --> /tmp/tmpxduop6t6.rs:21:69\n   |\n21 |         let (mut cap,\
    \ mut sm) = extension.chars().map(|c| (c as u8) - 'A').collect::<(Vec<usize>,\
    \ Vec<usize>)>();\n   |                                                      \
    \               ^ no implementation for `u8 - char`\n   |\n   = help: the trait\
    \ `Sub<char>` is not implemented for `u8`\n   = help: the following other types\
    \ implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n          \
    \   <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n            \
    \ <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a\
    \ i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize\
    \ as Sub<isize>>\n           and 48 others\n\nerror[E0277]: a value of type `(Vec<usize>,\
    \ Vec<usize>)` cannot be built from an iterator over elements of type `_`\n  \
    \  --> /tmp/tmpxduop6t6.rs:21:76\n     |\n21   |         let (mut cap, mut sm)\
    \ = extension.chars().map(|c| (c as u8) - 'A').collect::<(Vec<usize>, Vec<usize>)>();\n\
    \     |                                                                      \
    \      ^^^^^^^ value of type `(Vec<usize>, Vec<usize>)` cannot be built from `std::iter::Iterator<Item=_>`\n\
    \     |\n     = help: the trait `FromIterator<_>` is not implemented for `(Vec<usize>,\
    \ Vec<usize>)`\n     = help: the trait `FromIterator<()>` is implemented for `()`\n\
    note: required by a bound in `collect`\n\nerror[E0614]: type `usize` cannot be\
    \ dereferenced\n  --> /tmp/tmpxduop6t6.rs:22:37\n   |\n22 |         let sm = sm.iter().map(|&c|\
    \ *c).collect::<Vec<usize>>();\n   |                                     ^"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension:\
    \ String = String::from(class_name);\n\n    for extension in extensions {\n  \
    \      let c = extension.chars().count();\n        let s = extension.chars().filter(|&x|\
    \ x.is_ascii_lowercase()).count();\n        let c = c.saturating_add((s - c).saturating_add(c));\n\
    \        strongest_extension += &format!(\"{}.{}\", class_name, extension);\n\
    \    }\n\n    strongest_extension.into()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `c`\n  --> /tmp/tmpms1pad5z.rs:23:13\n   |\n\
    23 |         let c = c.saturating_add((s - c).saturating_add(c));\n   |      \
    \       ^ help: if this is intentional, prefix it with an underscore: `_c`\n \
    \  |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]: borrow\
    \ of moved value: `class_name`\n  --> /tmp/tmpms1pad5z.rs:24:50\n   |\n17 | fn\
    \ Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n\
    \   |                        ---------- move occurs because `class_name` has type\
    \ `String`, which does not implement the `Copy` trait\n18 |     let mut strongest_extension:\
    \ String = String::from(class_name);\n   |                                   \
    \                     ---------- value moved here\n...\n24 |         strongest_extension\
    \ += &format!(\"{}.{}\", class_name, extension);\n   |                       \
    \                           ^^^^^^^^^^ value borrowed here after move\n   |\n\
    \   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n\
    \        return String::from(\"\");\n    }\n\n    let mut sorted_extensions =\
    \ extensions\n        .iter()\n        .cloned()\n        .sort_by(|a, b| {\n\
    \            let mut a_strength = a.chars().filter(|c| c.is_uppercase()).count()\
    \ - a.chars().filter(|c| c.is_lowercase()).count();\n            let mut b_strength\
    \ = b.chars().filter(|c| c.is_uppercase()).count() - b.chars().filter(|c| c.is_lowercase()).count();\n\
    \            a_strength.cmp(&b_strength)\n        });\n\n    sorted_extensions.next().unwrap().to_string()\
    \ + class_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n \
    \   assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp02whezrj.rs:25:10\n   |\n25 |         .sort_by(|a,\
    \ b| {\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_ext = \"\
    \".to_string();\n    for ext in extensions.iter() {\n        let ext = ext.to_string();\n\
    \        let mut ext_len = 0;\n        for char in exc {\n            if char\
    \ == char.to_lowercase() {\n                ext_len += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        let strength =\
    \ ext_len as usize / ext.len();\n        if strength > strongest_ext.chars().nth(0).unwrap()\
    \ {\n            strongest_ext = ext.to_string();\n        }\n    }\n    class_name\
    \ + \".\" + strongest_ext\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `exc` in this scope\n  --> /tmp/tmpln9crchq.rs:22:21\n\
    \   |\n22 |         for char in exc {\n   |                     ^^^ help: a local\
    \ variable with a similar name exists: `ext`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpln9crchq.rs:30:23\n   |\n30 |         if strength > strongest_ext.chars().nth(0).unwrap()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpln9crchq.rs:34:24\n\
    \   |\n34 |     class_name + \".\" + strongest_ext\n   |                     \
    \   ^^^^^^^^^^^^^\n   |                        |\n   |                       \
    \ expected `&str`, found struct `String`\n   |                        help: consider\
    \ borrowing here: `&strongest_ext`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::from(\"\");\n    for extension in extensions {\n        let class_name\
    \ = format!(\"{}.{}\", class_name, extension);\n        let extension_strength\
    \ = extension.chars().filter(|c| c.is_uppercase().count_chars() > c.is_lowercase().count_chars()).count()\
    \ as i32 - extension.chars().filter(|c| c.is_lowercase().count_chars() > c.is_uppercase().count_chars()).count()\
    \ as i32;\n        if extension_strength > 0 {\n            strongest_extension\
    \ = format!(\"{}.{}\", class_name, extension);\n            break;\n        }\n\
    \    }\n    strongest_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `count_chars` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmpbv87hct8.rs:21:80\n   |\n21 | ...   let extension_strength\
    \ = extension.chars().filter(|c| c.is_uppercase().count_chars() > c.is_lowercase().count_chars()).count()\
    \ as i...\n   |                                                              \
    \                ^^^^^^^^^^^ method not found in `bool`\n\nerror[E0599]: no method\
    \ named `count_chars` found for type `bool` in the current scope\n  --> /tmp/tmpbv87hct8.rs:21:113\n\
    \   |\n21 | ...is_uppercase().count_chars() > c.is_lowercase().count_chars()).count()\
    \ as i32 - extension.chars().filter(|c| c.is_lowercase().count_ch...\n   |   \
    \                                                 ^^^^^^^^^^^ method not found\
    \ in `bool`\n\nerror[E0599]: no method named `count_chars` found for type `bool`\
    \ in the current scope\n  --> /tmp/tmpbv87hct8.rs:21:191\n   |\n21 | ...- extension.chars().filter(|c|\
    \ c.is_lowercase().count_chars() > c.is_uppercase().count_chars()).count() as\
    \ i32;\n   |                                                    ^^^^^^^^^^^ method\
    \ not found in `bool`\n\nerror[E0599]: no method named `count_chars` found for\
    \ type `bool` in the current scope\n  --> /tmp/tmpbv87hct8.rs:21:224\n   |\n21\
    \ | ...is_lowercase().count_chars() > c.is_uppercase().count_chars()).count()\
    \ as i32;\n   |                                                    ^^^^^^^^^^^\
    \ method not found in `bool`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut strongest_name = class_name;\n    for extension in extensions {\n\
    \        let mut length = extension.len();\n        match length {\n         \
    \   0 => {\n                strength = -1;\n                strongest_name = extension;\n\
    \                break;\n            }\n            _ => {\n                let\
    \ mut fraction = (length as f64) / (class_name.len() as f64);\n              \
    \  let mut uppercase = 0;\n                let mut lowercase = 0;\n          \
    \      for letter in extension.chars() {\n                    match letter {\n\
    \                        'A' => uppercase = 1,\n                        'B' =>\
    \ lowercase = 1,\n                        'C' => uppercase = 2,\n            \
    \            _ => {}\n                    }\n                }\n             \
    \   fraction = uppercase - lowercase;\n                if fraction < 0 {\n   \
    \                 strength = -1;\n                    strongest_name = extension;\n\
    \                } else if fraction > strength {\n                    strength\
    \ = fraction;\n                    strongest_name = extension;\n             \
    \   }\n            }\n        }\n    }\n    strongest_name\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_3jgte8.rs:40:28\n   |\n\
    29 |                 let mut fraction = (length as f64) / (class_name.len() as\
    \ f64);\n   |                                    -------------------------------------------\
    \ expected due to this value\n...\n40 |                 fraction = uppercase -\
    \ lowercase;\n   |                            ^^^^^^^^^^^^^^^^^^^^^ expected `f64`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_3jgte8.rs:41:31\n\
    \   |\n41 |                 if fraction < 0 {\n   |                          \
    \     ^\n   |                               |\n   |                          \
    \     expected `f64`, found integer\n   |                               help:\
    \ use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_3jgte8.rs:44:38\n\
    \   |\n44 |                 } else if fraction > strength {\n   |            \
    \                          ^^^^^^^^ expected `f64`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd_3jgte8.rs:45:32\n   |\n18 |     let mut strength\
    \ = -1;\n   |                        -- expected due to this value\n...\n45 |\
    \                     strength = fraction;\n   |                             \
    \   ^^^^^^^^ expected integer, found `f64`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut counter: usize = 0;\n\
    \n    for extension in extensions {\n        if extension.chars().filter(|c| c.is_upper()).count()\
    \ > counter.chars().filter(|c| c.is_upper()).count() {\n            counter =\
    \ extension.chars().filter(|c| c.is_upper()).count();\n        }\n        if extension.chars().filter(|c|\
    \ c.is_lowercase()).count() > counter.chars().filter(|c| c.is_lowercase()).count()\
    \ {\n            counter = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        }\n    }\n\n    format!(\"{}.{}\", class_name, extensions[counter])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp7vse6cg4.rs:21:43\n   |\n21 |         if extension.chars().filter(|c|\
    \ c.is_upper()).count() > counter.chars().filter(|c| c.is_upper()).count() {\n\
    \   |                                           ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named\
    \ `chars` found for type `usize` in the current scope\n  --> /tmp/tmp7vse6cg4.rs:21:73\n\
    \   |\n21 |         if extension.chars().filter(|c| c.is_upper()).count() > counter.chars().filter(|c|\
    \ c.is_upper()).count() {\n   |                                              \
    \                           ^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `is_upper` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmp7vse6cg4.rs:22:54\n   |\n22 |             counter = extension.chars().filter(|c|\
    \ c.is_upper()).count();\n   |                                               \
    \       ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\
    \nerror[E0599]: no method named `chars` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp7vse6cg4.rs:24:77\n   |\n24 |         if extension.chars().filter(|c|\
    \ c.is_lowercase()).count() > counter.chars().filter(|c| c.is_lowercase()).count()\
    \ {\n   |                                                                    \
    \         ^^^^^ method not found in `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n    let\
    \ mut counter = 0;\n    let mut strongest_extension: String = \"\";\n    for extension\
    \ in extensions {\n        if counter == 0 {\n            strongest_extension\
    \ += extension;\n        } else {\n            let mut strength = extension.chars().filter(|x|x\
    \ == 'A'..='Z').count() - extension.chars().filter(|x|x == 'a'..='z').count();\n\
    \            if strength > counter {\n                strongest_extension = extension;\n\
    \                counter = strength;\n            }\n        }\n    }\n    class_name\
    \ + strongest_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc8ubo6fa.rs:20:43\n   |\n\
    20 |     let mut strongest_extension: String = \"\";\n   |                   \
    \               ------   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |        |\n   |                      \
    \            |        expected struct `String`, found `&str`\n   |           \
    \                       expected due to this\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc8ubo6fa.rs:23:36\n   |\n23 |             strongest_extension +=\
    \ extension;\n   |                                    ^^^^^^^^^\n   |        \
    \                            |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpc8ubo6fa.rs:25:62\n   |\n25 |             let mut\
    \ strength = extension.chars().filter(|x|x == 'A'..='Z').count() - extension.chars().filter(|x|x\
    \ == 'a'..='z').count();\n   |                                               \
    \               ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc8ubo6fa.rs:25:71\n   |\n25 |             let mut strength = extension.chars().filter(|x|x\
    \ == 'A'..='Z').count() - extension.chars().filter(|x|x == 'a'..='z').count();\n\
    \   |                                                                       ^^^\
    \ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc8ubo6fa.rs:25:60\n\
    \   |\n25 |             let mut strength = extension.chars().filter(|x|x == 'A'..='Z').count()\
    \ - extension.chars().filter(|x|x == 'a'..='z').count();\n   |               \
    \                                             ^^^^^^^^^^^^^^ expected `bool`,\
    \ found struct `RangeInclusive`\n   |\n   = note: expected type `bool`\n     \
    \       found struct `RangeInclusive<bool>`\n\nerror[E0277]: can't compare `&char`\
    \ with `"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    debug_assert!(extensions.iter().all(|&e|\
    \ e.is_ascii_uppercase()));\n    debug_assert!(extensions.iter().all(|&e| e.is_ascii_lowercase()));\n\
    \    let mut strength = vec![-1i32, -1i32];\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_ascii_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_ascii_lowercase()).count();\n        let strength_\
    \ = cap - sm;\n        if strength == strength_ {\n            continue;\n   \
    \     }\n        if strength > strength_ {\n            strength = strength_;\n\
    \        }\n    }\n    let mut extension = String::from(\"\");\n    for e in extensions\
    \ {\n        let cap = e.chars().filter(|c| c.is_ascii_uppercase()).count();\n\
    \        let sm = e.chars().filter(|c| c.is_ascii_lowercase()).count();\n    \
    \    if cap == sm {\n            extension = e.to_string();\n            break;\n\
    \        }\n    }\n    extension.push_str(&class_name.to_string());\n    extension.push_str(&extensions[strength\
    \ as usize].to_string());\n    extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpverczflq.rs:18:48\n   |\n18 |     debug_assert!(extensions.iter().all(|&e|\
    \ e.is_ascii_uppercase()));\n   |                                            \
    \    ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_ascii_uppercase`\n\nerror[E0599]: no method named `is_ascii_lowercase` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpverczflq.rs:19:48\n\
    \   |\n19 |     debug_assert!(extensions.iter().all(|&e| e.is_ascii_lowercase()));\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_lowercase`\n\n\
    error[E0277]: can't compare `Vec<i32>` with `usize`\n  --> /tmp/tmpverczflq.rs:25:21\n\
    \   |\n25 |         if strength == strength_ {\n   |                     ^^ no\
    \ implementation for `Vec<i32> == usize`\n   |\n   = help: the trait `PartialEq<usize>`\
    \ is not implemented for `Vec<i32>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpverczflq.rs:28:23\n   |\n28 |         if strength > strength_\
    \ {\n   |                       ^^^^^^^^^ expected struct `Vec`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<i32>`\n                found type `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpverczflq.rs:29:24\n   |\n20 |\
    \     let mut strength = vec![-1i32, -1i32];\n   |                        ------------------\
    \ expected due to this value\n...\n29 |             strength = strength_;\n  \
    \ |                        ^^^^^^^^^ expected struct `Vec`, found `usize`\n  \
    \ |\n   = note: expected struct `Vec<i32>`\n                found type `usize`\n\
    \nerror[E0605]: non-primitive cast: `Vec<i32>` a"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut s = String::from(class_name);\n\
    \    let mut strength = 1;\n    for extension in extensions {\n        match extension.chars().collect::<Vec<char>>().count(|c|\
    \ *c.to_lowercase() <= s.chars().collect::<Vec<char>>().count(|c| *c.to_uppercase()))\
    \ {\n            1 => {},\n            2 => {\n                s = s.concat(\"\
    .\".to_owned());\n                strength = -1;\n            },\n           \
    \ _ => {}\n        }\n    }\n    s.concat(f\".{extensions[extensions.iter().position(|x|\
    \ x.to_lowercase() == extensions[0].to_lowercase()).unwrap()]}\".to_owned())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `\".{extensions[extensions.iter().position(|x| x.to_lowercase() == extensions[0].to_lowercase()).unwrap()]}\"\
    `\n  --> /tmp/tmpjsw9kgwg.rs:30:15\n   |\n30 |     s.concat(f\".{extensions[extensions.iter().position(|x|\
    \ x.to_lowercase() == extensions[0].to_lowercase()).unwrap()]}\".to_owned())\n\
    \   |               -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |               |\n   |               expected one of 8 possible tokens\n\
    \   |               help: missing `,`\n\nerror[E0425]: cannot find value `f` in\
    \ this scope\n  --> /tmp/tmpjsw9kgwg.rs:30:14\n   |\n30 |     s.concat(f\".{extensions[extensions.iter().position(|x|\
    \ x.to_lowercase() == extensions[0].to_lowercase()).unwrap()]}\".to_owned())\n\
    \   |              ^ help: a local variable with a similar name exists: `s`\n\n\
    error[E0599]: no method named `count` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmpjsw9kgwg.rs:21:56\n   |\n21 | ...   match extension.chars().collect::<Vec<char>>().count(|c|\
    \ *c.to_lowercase() <= s.chars().collect::<Vec<char>>().count(|c| *c.to_uppe...\n\
    \   |                                                      ^^^^^\n   |       \
    \                                               |\n   |                      \
    \                                method cannot be called on `Vec<char>` due to\
    \ unsatisfied trait bounds\n   |                                             \
    \         help: consider using `len` instead\n   |\n   = note: `count` is defined\
    \ on `Iterator`, which `Vec<char>` does not implement\n\nerror[E0599]: no method\
    \ named `count` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpjsw9kgwg.rs:21:120\n\
    \   |\n21 | ...ars().collect::<Vec<char>>().count(|c| *c.to_uppercase())) {\n\
    \   |                                 ^^^^^\n   |                            \
    \     |\n   |                                 method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |                                 help:\
    \ consider us"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n  let mut strength = -1;\n  let\
    \ mut extension = vec![\"\"];\n  for extension in extensions {\n    if let Some(strength)\
    \ = class_name.chars().filter(|c| c == extension.chars()).count() {\n      if\
    \ strength >= 0 {\n        break;\n      }\n    }\n  }\n  if strength >= 0 {\n\
    \    extension.iter().filter_map(|&x| x.chars().count()).min().unwrap().to_string()\n\
    \  } else {\n    String::from(\"\")\n  }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `Chars<'_>`\n  --> /tmp/tmpbaj2baco.rs:21:61\n\
    \   |\n21 |     if let Some(strength) = class_name.chars().filter(|c| c == extension.chars()).count()\
    \ {\n   |                                                             ^^ no implementation\
    \ for `&char == Chars<'_>`\n   |\n   = help: the trait `PartialEq<Chars<'_>>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbaj2baco.rs:21:12\n\
    \   |\n21 |     if let Some(strength) = class_name.chars().filter(|c| c == extension.chars()).count()\
    \ {\n   |            ^^^^^^^^^^^^^^   -------------------------------------------------------------\
    \ this expression has type `usize`\n   |            |\n   |            expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbaj2baco.rs:28:38\n\
    \   |\n28 |     extension.iter().filter_map(|&x| x.chars().count()).min().unwrap().to_string()\n\
    \   |                                      ^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n28 |     extension.iter().filter_map(|&x|\
    \ Some(x.chars().count())).min().unwrap().to_string()\n   |                  \
    \                    +++++                 +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = String::from(\"\
    \");\n    \n    for (i, extension) in extensions.iter().enumerate() {\n      \
    \  let cap = extension.chars().map(|x|x == 'A'..='Z').filter(|x|!x.is_empty()).count()\
    \ as i64;\n        let sm = extension.chars().map(|x|x == 'a'..='z').filter(|x|!x.is_empty()).count()\
    \ as i64;\n        let strength = cap - sm;\n        if strength >= 0 {\n    \
    \        if i == 0 {\n                result = class_name+\".\"+extension;\n \
    \           } else {\n                result = result + \".\"+extension;\n   \
    \         }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjf_u7x6a.rs:21:55\n   |\n\
    21 |         let cap = extension.chars().map(|x|x == 'A'..='Z').filter(|x|!x.is_empty()).count()\
    \ as i64;\n   |                                                       ^^^ expected\
    \ `bool`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjf_u7x6a.rs:22:54\n\
    \   |\n22 |         let sm = extension.chars().map(|x|x == 'a'..='z').filter(|x|!x.is_empty()).count()\
    \ as i64;\n   |                                                      ^^^ expected\
    \ `bool`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut class_name_parts: Vec<String> = class_name.splitn(2, \".\").collect();\n\
    \    for extension in extensions {\n        let extension_parts = extension.splitn(2,\
    \ \".\").collect();\n        let strength_part = extension_parts[1] - extension_parts[0];\n\
    \        if strength > 0 {\n            if strength_part > strength {\n      \
    \          class_name_parts = class_name_parts[0..1];\n                strength\
    \ = strength_part;\n            } else {\n                continue;\n        \
    \    }\n        }\n        class_name_parts.push(extension);\n    }\n    class_name.concat(\"\
    .\").join(&class_name_parts.join(\".\"))\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp0z41m5h2.rs:19:71\n     |\n19\
    \   |     let mut class_name_parts: Vec<String> = class_name.splitn(2, \".\").collect();\n\
    \     |                                                                      \
    \ ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0z41m5h2.rs:25:36\n\
    \   |\n19 |     let mut class_name_parts: Vec<String> = class_name.splitn(2, \"\
    .\").collect();\n   |                               ----------- expected due to\
    \ this type\n...\n25 |                 class_name_parts = class_name_parts[0..1];\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |                                    |\n\
    \   |                                    expected struct `Vec`, found slice\n\
    \   |\n   = note: expected struct `Vec<String>`\n               found slice `[String]`\n\
    \nerror[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0z41m5h2.rs:33:16\n   |\n33 |     class_name.concat(\"\
    .\").join(&class_name_parts.join(\".\"))\n   |                ^^^^^^ method not\
    \ found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut num_upper = 0;\n \
    \   let mut num_lower = 0;\n    for e in extensions {\n        if e.chars().filter(|c|\
    \ *c == c.to_ascii_lowercase()).count() > num_lower {\n            num_lower =\
    \ e.chars().filter(|c| *c == c.to_ascii_uppercase()).count();\n        }\n   \
    \     if e.chars().filter(|c| *c == c.to_ascii_uppercase()).count() > num_upper\
    \ {\n            num_upper = e.chars().filter(|c| *c == c.to_ascii_lowercase()).count();\n\
    \        }\n    }\n    let strength = (num_upper - num_lower) as i32;\n    let\
    \ extension = match extensions.iter().position(|x| *x == class_name).cloned()\
    \ {\n        None => String::from(\"unknown\"),\n        Some(idx) => &extensions[*idx\
    \ as usize],\n    };\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmp8tq430cy.rs:29:76\n\
    \    |\n29  |       let extension = match extensions.iter().position(|x| *x ==\
    \ class_name).cloned() {\n    |                                              \
    \                                ^^^^^^ `Option<usize>` is not an iterator\n \
    \   |\n    = note: the following trait bounds were not satisfied:\n          \
    \  `Option<usize>: Iterator`\n            which is required by `&mut Option<usize>:\
    \ Iterator`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut longest_name = \"\";\n    for (i, ext_name) in extensions {\n    \
    \    let ext_cap = ext_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        let ext_sm = ext_name.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        let ext_strength = ext_cap - ext_sm;\n        if ext_strength > strength\
    \ {\n            strength = ext_strength;\n            longest_name = ext_name;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, longest_name)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13_3ct2_.rs:20:9\n   |\n\
    20 |     for (i, ext_name) in extensions {\n   |         ^^^^^^^^^^^^^    ----------\
    \ this expression has type `Option<String>`\n   |         |\n   |         expected\
    \ struct `String`, found tuple\n   |\n   = note: expected struct `String`\n  \
    \             found tuple `(_, _)`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut map = HashMap::new();\n\
    \n    for (index, extension) in extensions.iter().enumerate() {\n        map.entry(extension.as_str()).or_insert(0);\n\
    \        if index == 0 {\n            map.entry(class_name.as_str()).or_insert(0);\n\
    \        }\n    }\n\n    let mut counter = map.entry(class_name.as_str()).or_insert(0);\n\
    \    let mut max = counter.clone();\n\n    map.entry(extensions[0].as_str()).or_insert(1);\n\
    \n    for (i, extension) in extensions.iter().enumerate() {\n        if i != 0\
    \ {\n            map.entry(extension.as_str()).or_insert(0);\n        }\n\n  \
    \      if map.contains_key(extension.as_str()) {\n            let counter = map.entry(extension.as_str()).or_insert(0);\n\
    \            if counter.value > max.value {\n                max = counter;\n\
    \            }\n        }\n    }\n\n    if max.value > 0 {\n        format!(\"\
    {}{}\", class_name, max.key)\n    } else {\n        class_name\n    }\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpbiikqyxv.rs:18:19\n   |\n18 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    match extensions {\n     \
    \   vec![] => \"\",\n        vec![String::new()] => \"\",\n        vec![ext] =>\
    \ {\n            let mut counts = HashMap::new();\n            for ext in extensions\
    \ {\n                counts.entry(ext.to_lowercase()).or_insert(0);\n        \
    \    }\n            let cap = class_name.chars().filter(|c| *c >= 'A' && *c <=\
    \ 'Z').count();\n            let sm = class_name.chars().filter(|c| *c >= 'a'\
    \ && *c <= 'z').count();\n            let strength = cap - sm;\n            match\
    \ counts.entry(strength).or_insert(0) {\n                0 => \"\".to_string(),\n\
    \                _ => extensions.iter().filter(|ext| *ext == class_name)\n   \
    \                 .cloned()\n                    .filter(|c| *c >= 'A' && *c <=\
    \ 'Z').count()\n                    .to_string()\n            }\n        }\n \
    \   }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ext` in this scope\n  --> /tmp/tmpfltke_dj.rs:21:14\n\
    \   |\n21 |         vec![ext] => {\n   |              ^^^ not found in this scope\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpfltke_dj.rs:22:30\n\
    \   |\n22 |             let mut counts = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: arbitrary\
    \ expressions aren't allowed in patterns\n  --> /tmp/tmpfltke_dj.rs:19:9\n   |\n\
    19 |         vec![] => \"\",\n   |         ^^^^^^\n   |\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: arbitrary expressions aren't allowed in patterns\n\
    \  --> /tmp/tmpfltke_dj.rs:20:9\n   |\n20 |         vec![String::new()] => \"\"\
    ,\n   |         ^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this error originates in\
    \ the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpfltke_dj.rs:21:9\n\
    \   |\n21 |         vec![ext] => {\n   |         ^^^^^^^^^\n   |\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfltke_dj.rs:19:19\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \              ------ expected `String` because of return type\n18 |     match\
    \ extensions {\n19 |         vec![] => \"\",\n   |                   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                   |\n  \
    \ |                   expected struct `String`, found `&str`\n\nerror[E0277]:\
    \ can't compare `&String` with `String`\n  --> /tmp/tmpfltke_dj.rs:31:58\n   |\n\
    31 |                 _ => extensions.iter().filter(|ext| *ext == class_name)\n\
    \   |                                                          ^^ no implementation\
    \ for `&String == St"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = Vec::new();\n    let mut num_of_uppercase = 0;\n    let mut num_of_lowercase\
    \ = 0;\n    let mut total_num_of_uppercase = 0;\n    let mut total_num_of_lowercase\
    \ = 0;\n    extensions.iter().for_each(|e| {\n        match e.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count() {\n            1 => total_num_of_uppercase +=\
    \ 1,\n            2 => total_num_of_lowercase += 1,\n            _ => (),\n  \
    \      };\n        if e.chars().filter(|c| *c >= 'a' && *c <= 'z').count() > num_of_lowercase\
    \ {\n            num_of_lowercase = e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n\
    \        }\n        if e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() >\
    \ num_of_uppercase {\n            num_of_uppercase = e.chars().filter(|c| *c >=\
    \ 'A' && *c <= 'Z').count();\n        }\n    });\n    strongest_extension.push(class_name);\n\
    \    if num_of_uppercase == num_of_lowercase {\n        strongest_extension.push(class_name.to_lowercase());\n\
    \    } else {\n        strongest_extension.push(class_name.to_lowercase() + \"\
    _\" + String::from(\"_\".to_string(num_of_lowercase - num_of_uppercase)));\n \
    \   }\n    strongest_extension.join(\"\").to_owned()\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpwfyxb4sl.rs:40:85\n     |\n40   |         strongest_extension.push(class_name.to_lowercase()\
    \ + \"_\" + String::from(\"_\".to_string(num_of_lowercase - num_of_uppercase)));\n\
    \     |                                                                      \
    \               ^^^^^^^^^ ----------------------------------- supplied 1 argument\n\
    \     |                                                                      \
    \               |\n     |                                                    \
    \                                 expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwfyxb4sl.rs:40:68\n\
    \   |\n40 |         strongest_extension.push(class_name.to_lowercase() + \"_\"\
    \ + String::from(\"_\".to_string(num_of_lowercase - num_of_uppercase)));\n   |\
    \                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                                    |\n \
    \  |                                                                    expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                            help: consider borrowing here: `&String::from(\"\
    _\".to_string(num_of_lowercase - num_of_uppercase))`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let extension_strength = extensions\n\
    \        .iter()\n        .zip(extensions.iter().map(|e| e.chars().count()))\n\
    \        .map(|(extension, count)| {\n            let class_name = extension.chars().collect::<Vec<_>>();\n\
    \            let letter_count = extension.chars().filter(|c| c.is_ascii_lowercase()).count();\n\
    \            (letter_count, class_name)\n        })\n        .filter_map(|(count,\
    \ class_name)| {\n            if count == extension_strength.len() {\n       \
    \         Some(class_name)\n            } else {\n                None\n     \
    \       }\n        })\n        .enumerate()\n        .max();\n    class_name\n\
    \        .to_string() + \n        extension_strength.as_ref()\n            .expect(\"\
    No extension with the given strength\")\n            .value\n            .join()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `extension_strength` in this scope\n  -->\
    \ /tmp/tmpg4ng9872.rs:27:25\n   |\n27 |             if count == extension_strength.len()\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0609]: no field `value` on type `&(usize, Vec<char>)`\n  --> /tmp/tmpg4ng9872.rs:39:14\n\
    \   |\n39 |             .value\n   |              ^^^^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0609.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut s = String::from(class_name);\n\
    \    extensions.sort_by(|a, b| b.cmp(a));\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        let len = e - class_name;\n        let sm = e.chars().filter(|c|\
    \ c.is_ascii_lowercase).count();\n        let cap = e.chars().filter(|c| c.is_ascii_uppercase).count();\n\
    \        let diff = cap - sm;\n        let strength = if diff < 0 {\n        \
    \    -1\n        } else if diff == 0 {\n            0\n        } else {\n    \
    \        diff / (cap - sm)\n        };\n        let mut j = i;\n        while\
    \ j > 0 && extensions[j - 1] == e {\n            j -= 1;\n        }\n        let\
    \ mut l = j;\n        while l > 0 && extensions[l - 1] == e {\n            l -=\
    \ 1;\n        }\n        let strength = (strength * (j - i) + 1) / (j - l + 1);\n\
    \        s = s.to_owned() + &e.to_owned() + &format!(\"{}\", strength).to_string();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `String` from `&String`\n  --> /tmp/tmpygh0g63z.rs:21:21\n\
    \   |\n21 |         let len = e - class_name;\n   |                   - ^ ----------\
    \ String\n   |                   |\n   |                   &String\n\nerror[E0615]:\
    \ attempted to take value of method `is_ascii_lowercase` on type `&char`\n  -->\
    \ /tmp/tmpygh0g63z.rs:22:41\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c.is_ascii_lowercase).count();\n   |                                       \
    \  ^^^^^^^^^^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call\
    \ the method\n   |\n22 |         let sm = e.chars().filter(|c| c.is_ascii_lowercase()).count();\n\
    \   |                                                           ++\n\nerror[E0615]:\
    \ attempted to take value of method `is_ascii_uppercase` on type `&char`\n  -->\
    \ /tmp/tmpygh0g63z.rs:23:42\n   |\n23 |         let cap = e.chars().filter(|c|\
    \ c.is_ascii_uppercase).count();\n   |                                       \
    \   ^^^^^^^^^^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call\
    \ the method\n   |\n23 |         let cap = e.chars().filter(|c| c.is_ascii_uppercase()).count();\n\
    \   |                                                            ++\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpygh0g63z.rs:26:13\n\
    \   |\n26 |             -1\n   |             ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpygh0g63z.rs:33:42\n   |\n33 |         while j > 0 && extensions[j\
    \ - 1] == e {\n   |                                          ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_index = 0;\n \
    \   let mut max_extension = \"\";\n    for extension in extensions.iter() {\n\
    \        if extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() == class_name.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() && extension.chars().filter(|c| *c >= 'A' &&\
    \ *c <= 'Z').count() > 0 {\n            let index = (extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count() + class_name.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').count()).fract();\n            if index > max_index {\n         \
    \       max_index = index;\n                max_extension = extension;\n     \
    \       }\n        }\n    }\n    if max_index > 0 {\n        format!(\"{}.{}\"\
    , class_name, max_extension)\n    } else {\n        class_name\n    }\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `fract` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpyyqevuoc.rs:22:152\n   |\n22 | ...ars().filter(|c| *c >=\
    \ 'a' && *c <= 'z').count()).fract();\n   |                                  \
    \                    ^^^^^ method not found in `usize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_strength:\
    \ Vec<i64> = extensions.iter().map(|e| e.chars().filter(|x| x >= 'A' && x <= 'Z').count()\
    \ - e.chars().filter(|x| x >= 'a' && x <= 'z').count()).collect();\n    let mut\
    \ extensions_strength_max = extensions_strength.iter().max().unwrap();\n    let\
    \ mut extensions_index = vec![0; extensions_strength.len()];\n    \n    for i\
    \ in 0..extensions_strength.len() {\n        if extensions_strength[i] == extensions_strength_max\
    \ {\n            extensions_index[i] = i - 1;\n        }\n    }\n    \n    let\
    \ mut extensions_strength_index = extensions_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_index\
    \ = extensions_strength_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n\
    \n    let mut extensions_strength_mut_index = extensions_strength_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_mut_index\
    \ = extensions_strength_mut_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n\
    \    let mut extensions_strength_mut_index = extensions_strength_mut_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    \n    for mut i in 0..extensions_strength.len()\
    \ {\n        extensions_strength_mut_index[i] = extensions_strength_index[i];\n\
    \    }\n    \n    let mut extensions_strength_mut_index = extensions_strength_mut_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_mut_index\
    \ = extensions_strength_mut_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n\
    \    \n    let mut extensions_strength_mut_index = extensions_strength_mut_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_mut_index\
    \ = extensions_strength_mut_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n\
    \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx7pvrt3_.rs:18:97\n   |\n\
    18 | ...ions.iter().map(|e| e.chars().filter(|x| x >= 'A' && x <= 'Z').count()\
    \ - e.chars().filter(|x| x >= 'a' && x <= 'z').count()).collect();\n   |     \
    \                                             ^^^\n   |                      \
    \                            |\n   |                                         \
    \         expected `&char`, found `char`\n   |                               \
    \                   help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx7pvrt3_.rs:18:109\n   |\n18 | ...map(|e| e.chars().filter(|x|\
    \ x >= 'A' && x <= 'Z').count() - e.chars().filter(|x| x >= 'a' && x <= 'z').count()).collect();\n\
    \   |                                                  ^^^\n   |             \
    \                                     |\n   |                                \
    \                  expected `&char`, found `char`\n   |                      \
    \                            help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx7pvrt3_.rs:18:150\n   |\n18 | ...x <= 'Z').count()\
    \ - e.chars().filter(|x| x >= 'a' && x <= 'z').count()).collect();\n   |     \
    \                                             ^^^\n   |                      \
    \                            |\n   |                                         \
    \         expected `&char`, found `char`\n   |                               \
    \                   help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx7pvrt3_.rs:18:162\n   |\n18 | ...unt() - e.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count()).collect();\n   |                            \
    \                      ^^^\n   |                                             \
    \     |\n   |                                                  expected `&char`,\
    \ found `char`\n   |                                                  help: consider\
    \ borrowing here: `&'z'`\n\nerror[E0277]: a value of type `Vec<i64>` cannot be\
    \ built from an iterator over elements of type `usize`\n    --> /tmp/tmpx7pvrt3_.rs:18:176\n\
    \     |\n18   | ... &&"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    for extension in extensions.iter().cloned() {\n        let (letters, count)\
    \ = (extension.chars().filter(|c| c.is_ascii_letter()).count(), 1);\n        let\
    \ (letters_upper, count_upper) = (extension.chars().filter(|c| c.is_ascii_letter()).filter(|c|\
    \ c.is_uppercase()).count(), 1);\n        let (letters_lower, count_lower) = (extension.chars().filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c.is_lowercase()).count(), 1);\n        \n \
    \       strength += (letters - count_lower) * (letters - count_upper);\n    }\n\
    \    \n    if strength == 0 {\n        class_name + \".\" + extensions[0]\n  \
    \  } else {\n        let strength_upper = strength / 2;\n        let strength_lower\
    \ = strength_upper - strength;\n        match strength_lower {\n            0\
    \ => class_name + \".\" + extensions[0],\n            1 => class_name + \".\"\
    \ + extensions[1],\n            _ => class_name + String::from(\"_\").to_string()\
    \ + extensions[(extensions.len() - 1).abs() as usize],\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9xp12222.rs:20:64\n   |\n20 |         let\
    \ (letters, count) = (extension.chars().filter(|c| c.is_ascii_letter()).count(),\
    \ 1);\n   |                                                                ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp9xp12222.rs:21:76\n   |\n21 |         let (letters_upper,\
    \ count_upper) = (extension.chars().filter(|c| c.is_ascii_letter()).filter(|c|\
    \ c.is_uppercase()).count(), 1);\n   |                                       \
    \                                     ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmp9xp12222.rs:22:76\n\
    \   |\n22 |         let (letters_lower, count_lower) = (extension.chars().filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c.is_lowercase()).count(), 1);\n   |       \
    \                                                                     ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9xp12222.rs:24:21\n   |\n24 |         strength\
    \ += (letters - count_lower) * (letters - count_upper);\n   |                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found\
    \ `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i64`\n  --> /tmp/tmp9xp12222.rs:24:18\n\
    \   |\n24 |         strength += (letters - count_lower) * (letters - count_upper);\n\
    \   |                  ^^ no implementation for `i64 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `i64`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i1"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_strength: i64\
    \ = 0;\n    let mut best_extension: Option<String> = None;\n    for ext in extensions\
    \ {\n        let ext = ext\n            .clone()\n            .to_lowercase()\n\
    \            .to_ascii_lowercase()\n            .to_vec();\n        let cap =\
    \ ext.len();\n        let sm = ext.iter().filter(|&char| char == '_').count();\n\
    \        let strength = cap - sm;\n        if strength > best_strength {\n   \
    \         best_strength = strength;\n            best_extension = Some(ext);\n\
    \        }\n    }\n    match best_extension {\n        Some(ext) => format!(\"\
    {}.{}\", class_name, ext),\n        None => class_name,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_vec` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu_vocw0f.rs:25:14\n   |\n25 |             .to_vec();\n\
    \   |              ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut name = String::from(class_name);\n    for extension in extensions\
    \ {\n        let mut chars = String::from(extension);\n        if chars.chars().all(|c|\
    \ c >= 'a' && c <= 'z') {\n            chars.push_str(c.to_uppercase());\n   \
    \     } else {\n            chars.push_str(c.to_lowercase());\n        }\n   \
    \     if strength < chars.chars().count() - name.chars().count() {\n         \
    \   strength = chars.chars().count() - name.chars().count();\n            name\
    \ = chars;\n        }\n    }\n    format!(\"{}.{}\", name, strength)\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpvr1s4n6w.rs:23:28\n\
    \   |\n23 |             chars.push_str(c.to_uppercase());\n   |              \
    \              ^ not found in this scope\n\nerror[E0425]: cannot find value `c`\
    \ in this scope\n  --> /tmp/tmpvr1s4n6w.rs:25:28\n   |\n25 |             chars.push_str(c.to_lowercase());\n\
    \   |                            ^ not found in this scope\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpvr1s4n6w.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Compute the length of the\
    \ longest extension\n    let mut max_len = -1;\n    for e in extensions {\n  \
    \      let len = e.len();\n        if max_len < len {\n            max_len = len;\n\
    \        }\n    }\n\n    // Compute the number of capital letters\n    let cap_len\
    \ = class_name.chars().filter(|c| *c == ('A' as u8)).count() as u32;\n\n    //\
    \ Compute the number of lowercase letters\n    let sm = class_name.chars().filter(|c|\
    \ *c == ('a' as u8)).count() as u32;\n\n    // Compute the strength of the extension\n\
    \    let strength = (cap_len - sm) as f64 / cap_len;\n\n    // Find the strongest\
    \ extension\n    extensions.iter().find(|e| *e.len()*max_len >= strength).unwrap_or(\"\
    \")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpv9q5ew00.rs:19:23\n\
    \   |\n19 |     let mut max_len = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv9q5ew00.rs:28:55\n   |\n28 |     let cap_len = class_name.chars().filter(|c|\
    \ *c == ('A' as u8)).count() as u32;\n   |                                   \
    \                    ^^^^^^^^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv9q5ew00.rs:31:50\n   |\n31 |     let sm = class_name.chars().filter(|c|\
    \ *c == ('a' as u8)).count() as u32;\n   |                                   \
    \               ^^^^^^^^^^^ expected `char`, found `u8`\n\nerror[E0277]: cannot\
    \ divide `f64` by `u32`\n  --> /tmp/tmpv9q5ew00.rs:34:42\n   |\n34 |     let strength\
    \ = (cap_len - sm) as f64 / cap_len;\n   |                                   \
    \       ^ no implementation for `f64 / u32`\n   |\n   = help: the trait `Div<u32>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpv9q5ew00.rs:37:32\n   |\n37 |     extensions.iter().find(|e| *e.len()*max_len\
    \ >= strength).unwrap_or(\"\")\n   |                                ^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv9q5ew00.rs:37:72\n   |\n37 |\
    \     extensions.iter().find(|e| *e.len()*max_len >= strength).unwrap_or(\"\"\
    )\n   |                                                                      \
    \  ^^ expec"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n\n    //\
    \ Return result of your code\n    return \"\"\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6ry2nl5.rs:21:12\n   |\n\
    17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |                                                                    \
    \    ------ expected `String` because of return type\n...\n21 |     return \"\"\
    \n   |            ^^- help: try using a conversion method: `.to_string()`\n  \
    \ |            |\n   |            expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        format!(\"{}.\", class_name)\n    } else {\n        let mut c = class_name;\n\
    \        for i in extensions.iter().rev() {\n            let mut x = i;\n    \
    \        if let Some(y) = extensions.iter().skip(i).find(|x| *x == x) {\n    \
    \            *y = *x;\n            }\n            c = c.to_string();\n       \
    \ }\n        format!(\"{}.{}\", c, &extensions.iter().take(extensions.len() -\
    \ 1).collect::<String>().unwrap())\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkzkk8656.rs:24:53\n   |\n\
    24 |             if let Some(y) = extensions.iter().skip(i).find(|x| *x == x)\
    \ {\n   |                                                     ^ expected `usize`,\
    \ found `&String`\n\nerror[E0277]: can't compare `String` with `&String`\n  -->\
    \ /tmp/tmpkzkk8656.rs:24:68\n   |\n24 |             if let Some(y) = extensions.iter().skip(i).find(|x|\
    \ *x == x) {\n   |                                                           \
    \         ^^ no implementation for `String == &String`\n   |\n   = help: the trait\
    \ `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&&String>` for `&String`\n\nerror[E0277]: a value of type\
    \ `String` cannot be built from an iterator over elements of type `&String`\n\
    \    --> /tmp/tmpkzkk8656.rs:29:75\n     |\n29   |         format!(\"{}.{}\",\
    \ c, &extensions.iter().take(extensions.len() - 1).collect::<String>().unwrap())\n\
    \     |                                                                      \
    \     ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ requ"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_extensions: Vec<(String,\
    \ usize)> = extensions.iter().cloned().collect();\n    best_extensions.sort();\n\
    \    let mut best_strength: usize = 0;\n    for i in 0..(best_extensions.len()\
    \ - 1) {\n        let (mut extension, strength) = best_extensions[i];\n      \
    \  if strength > best_strength {\n            best_strength = strength;\n    \
    \        best_extension = extension;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, best_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `best_extension` in this scope\n  --> /tmp/tmp5cjzjb0f.rs:25:13\n\
    \   |\n25 |             best_extension = extension;\n   |             ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `best_extensions`\n\nerror[E0425]:\
    \ cannot find value `best_extension` in this scope\n  --> /tmp/tmp5cjzjb0f.rs:28:34\n\
    \   |\n28 |     format!(\"{}.{}\", class_name, best_extension)\n   |         \
    \                         ^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `best_extensions`\n\nerror[E0277]: a value of type `Vec<(String,\
    \ usize)>` cannot be built from an iterator over elements of type `String`\n \
    \   --> /tmp/tmp5cjzjb0f.rs:18:80\n     |\n18   |     let mut best_extensions:\
    \ Vec<(String, usize)> = extensions.iter().cloned().collect();\n     |       \
    \                                                                         ^^^^^^^\
    \ value of type `Vec<(String, usize)>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Vec<(String, usize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = Vec::new();\n\
    \    let mut strength = usize::MAX;\n    for e in extensions {\n        let mut\
    \ c = e.chars();\n        strength = cmp::max(strength, c.count(|&x| x.is_uppercase()));\n\
    \        strength = cmp::max(strength, c.count(|&x| x.is_lowercase()));\n    }\n\
    \    \n    // This could throw an exception if there was a tie, but it won't anyway\
    \ because it's \n    // called after checking that no extension has strongest\
    \ strength\n    strongest.push(class_name);\n    for i in 0..extensions.len()\
    \ {\n        let strength = extensions[i].chars().count(|&x| x.is_uppercase());\n\
    \        if strength >= strength {\n            strongest.push(i.to_string() +\
    \ extensions[i]);\n        }\n    }\n    if strongest.len() > 1 {\n        let\
    \ first = strongest[0];\n        for i in 1..strongest.len() {\n            if\
    \ strongest[i] > first {\n                break;\n            }\n        }\n \
    \       strongest = strongest.clone() + strongest.clone();\n        strongest[first]\
    \ = strongest[first].to_string();\n        strongest[first + 1] = \"\";\n    \
    \    String::from(&strongest.join(\" \"))\n    } else {\n        String::from(&strongest.join(\"\
    \ \"))\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpygr2_nak.rs:22:20\n   |\n22 |         strength = cmp::max(strength,\
    \ c.count(|&x| x.is_uppercase()));\n   |                    ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `cmp`\n  --> /tmp/tmpygr2_nak.rs:23:20\n   |\n23 |         strength\
    \ = cmp::max(strength, c.count(|&x| x.is_lowercase()));\n   |                \
    \    ^^^ use of undeclared crate or module `cmp`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpygr2_nak.rs:22:41\n\
    \    |\n22  |         strength = cmp::max(strength, c.count(|&x| x.is_uppercase()));\n\
    \    |                                         ^^^^^ --------------------- supplied\
    \ 1 argument\n    |                                         |\n    |         \
    \                                expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpygr2_nak.rs:23:41\n    |\n23  |      \
    \   strength = cmp::max(strength, c.count(|&x| x.is_lowercase()));\n    |    \
    \                                     ^^^^^ --------------------- supplied 1 argument\n\
    \    |                                         |\n    |                      \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpygr2_nak.rs:30:46\n    |\n30  |         let strength = extensions[i].chars().count(|&x|\
    \ x.is_uppercase());\n    |                                              ^^^^^\
    \ --------------------- supplied 1 argument\n    |                           \
    \                   |\n    |                                              expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpygr2_nak.rs:32:44\n   |\n32 |             strongest.push(i.to_string()\
    \ + extensions[i]);\n   |                                            ^^^^"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.iter().all(|&x|\
    \ x.chars().any(|y|y.is_uppercase()) && x.chars().count() > 1){\n        extensions.iter().filter(|&x|\
    \ x.chars().count() > 1).max()\n    }\n    else {\n        extensions.iter().filter(|&x|\
    \ x.chars().count() == 1).max()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxdq71b5k.rs:19:9\n   |\n\
    17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |                                                                    \
    \    ------ expected `String` because of return type\n18 |     if extensions.iter().all(|&x|\
    \ x.chars().any(|y|y.is_uppercase()) && x.chars().count() > 1){\n19 |        \
    \ extensions.iter().filter(|&x| x.chars().count() > 1).max()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<&String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxdq71b5k.rs:22:9\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                               ------ expected `String` because\
    \ of return type\n...\n22 |         extensions.iter().filter(|&x| x.chars().count()\
    \ == 1).max()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<&String>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n    let\
    \ mut result = 0;\n    for extension in extensions {\n        let mut count =\
    \ 0;\n        let mut strongest_extension_str: Vec<String> = Vec::new();\n   \
    \     for c in extension {\n            if c.is_uppercase() {\n              \
    \  count += 1;\n            }\n            if c.is_lowercase() {\n           \
    \     count += 1;\n            }\n        }\n        if count == 0 {\n       \
    \     return format!(\"{}.{}\", class_name, extension);\n        }\n        if\
    \ count == 1 {\n            return format!(\"{}.{}\", class_name, extensions[0]);\n\
    \        }\n        result += count as f64 as i64;\n    }\n    format!(\"{}.{}\"\
    , class_name, extensions[result]);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp5oxay6nb.rs:23:18\n\
    \   |\n23 |         for c in extension {\n   |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `i64`\n  --> /tmp/tmp5oxay6nb.rs:39:34\n\
    \   |\n39 |     format!(\"{}.{}\", class_name, extensions[result]);\n   |    \
    \                              ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not\
    \ implemented for `i64`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i64>` for `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5oxay6nb.rs:17:72\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n...\n\
    39 |     format!(\"{}.{}\", class_name, extensions[result]);\n   |           \
    \                                          - help: remove this semicolon\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map: HashMap<String,\
    \ usize> = extensions.iter().cloned().collect();\n    let mut extensions_map:\
    \ Vec<(&usize, String)> = extensions.iter().cloned().collect();\n    let mut current_strength\
    \ = -1;\n    let mut current_extension = String::from(\"A\");\n    \n    let mut\
    \ extensions_map: HashMap<String, usize> = extensions.iter().cloned().collect();\n\
    \    while current_strength < 0 {\n        let mut next_extension = String::from(\"\
    A\");\n        for extension in extensions_map.iter() {\n            if extension.key().contains(&current_extension)\
    \ {\n                current_strength = extension.key().chars().filter(|x| x ==\
    \ &current_extension).count() as usize;\n                next_extension = extension.value();\n\
    \            }\n        }\n        if current_strength < 0 {\n            current_strength\
    \ = 0;\n        }\n        current_extension = next_extension;\n    }\n    \n\
    \    format!(\"{}.{}\", class_name, current_extension)\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpddev5fqo.rs:18:29\n\
    \   |\n18 |     let mut extensions_map: HashMap<String, usize> = extensions.iter().cloned().collect();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpddev5fqo.rs:23:29\n\
    \   |\n23 |     let mut extensions_map: HashMap<String, usize> = extensions.iter().cloned().collect();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: a value of type `Vec<(&usize, String)>` cannot be built\
    \ from an iterator over elements of type `String`\n    --> /tmp/tmpddev5fqo.rs:19:80\n\
    \     |\n19   |     let mut extensions_map: Vec<(&usize, String)> = extensions.iter().cloned().collect();\n\
    \     |                                                                      \
    \          ^^^^^^^ value of type `Vec<(&usize, String)>` cannot be built from\
    \ `std::iter::Iterator<Item=String>`\n     |\n     = help: the trait `FromIterator<String>`\
    \ is not implemented for `Vec<(&usize, String)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return class_name;\n    }\n\n    let mut extensions_count = Vec::new();\n\
    \    for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        let strength = cap - sm;\n\n     \
    \   let mut extension_count = 0;\n        match extensions_count.iter().position(|i|\
    \ i.0 > strength) {\n            Some(index) => {\n                extension_count\
    \ = index + 1;\n            }\n            None => {\n                extensions_count.push((strength,\
    \ extension_count));\n                extension_count = 1;\n            }\n  \
    \      }\n    }\n    if extensions_count.len() == 0 {\n        return class_name;\n\
    \    }\n\n    let mut extensions_max = Vec::new();\n    let mut max_strength =\
    \ -1;\n    for (_, count) in extensions_count {\n        let strength = count;\n\
    \        let mut max_count = 0;\n        if let Some(index) = extensions_max.iter().position(|i|\
    \ i.0 > strength) {\n            max_count = index + 1;\n        }\n        if\
    \ max_count > count {\n            extensions_max.push((strength, max_count));\n\
    \        }\n        if max_strength < strength {\n            max_strength = strength;\n\
    \        }\n    }\n    let mut index = -1;\n    let mut strength = max_strength;\n\
    \    for ((strength, count) in extensions_max) {\n        if count > index {\n\
    \            index = count;\n        }\n    }\n    return class_name + String::from(\"\
    .\") + extensions[index].to_str();\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, or `|`, found keyword `in`\n  --> /tmp/tmpv9zzcm8o.rs:60:28\n\
    \   |\n60 |     for ((strength, count) in extensions_max) {\n   |            \
    \                ^^ expected one of `)`, `,`, or `|`\n\nerror: unexpected parentheses\
    \ surrounding `for` loop head\n  --> /tmp/tmpv9zzcm8o.rs:60:9\n   |\n60 |    \
    \ for ((strength, count) in extensions_max) {\n   |         ^                \
    \                   ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n60\
    \ -     for ((strength, count) in extensions_max) {\n60 +     for (strength, count)\
    \ in extensions_max {\n   | \n\nerror[E0282]: type annotations needed for `&T`\n\
    \  --> /tmp/tmpv9zzcm8o.rs:29:49\n   |\n29 |         match extensions_count.iter().position(|i|\
    \ i.0 > strength) {\n   |                                                 ^ consider\
    \ giving this closure parameter the explicit type `&T`, where the type parameter\
    \ `T` is specified\n   |\n   = note: type must be known at this point\n\nerror[E0609]:\
    \ no field `0` on type `&_`\n  --> /tmp/tmpv9zzcm8o.rs:29:54\n   |\n29 |     \
    \    match extensions_count.iter().position(|i| i.0 > strength) {\n   |      \
    \                                                ^\n\nerror[E0609]: no field `0`\
    \ on type `&_`\n  --> /tmp/tmpv9zzcm8o.rs:48:67\n   |\n48 |         if let Some(index)\
    \ = extensions_max.iter().position(|i| i.0 > strength) {\n   |               \
    \                                                    ^\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpv9zzcm8o.rs:44:28\n   |\n\
    44 |     let mut max_strength = -1;\n   |                            ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv9zzcm8o.rs:65:25\n   |\n65 |     return class_name + String::from(\"\
    .\") + extensions[index].to_str();\n   |                         ^^^^^^^^^^^^^^^^^\n\
    \   |      "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_count =\
    \ extensions.length();\n    let mut strength = -1;\n\n    for e in extensions\
    \ {\n        let e = e.to_lowercase();\n        let mut count = 0;\n\n       \
    \ for c in e.chars() {\n            if c == c.to_upper() {\n                count\
    \ += 1;\n            }\n        }\n\n        let strength_fraction = (count as\
    \ f64) / (extensions_count as f64);\n        if strength > 0 && strength_fraction\
    \ > strength {\n            strength = strength_fraction;\n        }\n    }\n\n\
    \    format!(\"{}.{}\", class_name, extensions[strength].to_lowercase())\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmp1cr7tfa0.rs:18:43\n   |\n18 |     let mut extensions_count\
    \ = extensions.length();\n   |                                           ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `to_upper` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp1cr7tfa0.rs:26:23\n   |\n26 |             if c == c.to_upper() {\n \
    \  |                       ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1cr7tfa0.rs:32:48\n\
    \   |\n32 |         if strength > 0 && strength_fraction > strength {\n   |  \
    \                                              ^^^^^^^^ expected `f64`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1cr7tfa0.rs:33:24\n\
    \   |\n19 |     let mut strength = -1;\n   |                        -- expected\
    \ due to this value\n...\n33 |             strength = strength_fraction;\n   |\
    \                        ^^^^^^^^^^^^^^^^^ expected integer, found `f64`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp1cr7tfa0.rs:19:24\n\
    \   |\n19 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return class_name;\n    }\n\n    let mut strength_max = -1;\n    let\
    \ mut best_extensions = &[];\n    for (i, extension) in extensions.iter().enumerate()\
    \ {\n        let strength = Extension_Strongest(extension);\n        if strength\
    \ > strength_max {\n            best_extensions = &extensions[i];\n          \
    \  strength_max = strength;\n        }\n    }\n    if strength_max == -1 {\n \
    \       return class_name;\n    }\n\n    String::from(format!(\"{}.{}\", class_name,\
    \ best_extensions))\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Extension_Strongest`\
    \ in this scope\n  --> /tmp/tmpmbdsvhbx.rs:25:24\n   |\n25 |         let strength\
    \ = Extension_Strongest(extension);\n   |                        ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmbdsvhbx.rs:27:31\n\
    \   |\n23 |     let mut best_extensions = &[];\n   |                         \
    \      --- expected due to this value\n...\n27 |             best_extensions =\
    \ &extensions[i];\n   |                               ^^^^^^^^^^^^^^ expected\
    \ array of 0 elements, found struct `String`\n   |\n   = note: expected reference\
    \ `&[_; 0]`\n              found reference `&String`\n\nerror[E0277]: `[_; 0]`\
    \ doesn't implement `std::fmt::Display`\n  --> /tmp/tmpmbdsvhbx.rs:35:47\n   |\n\
    35 |     String::from(format!(\"{}.{}\", class_name, best_extensions))\n   | \
    \                                              ^^^^^^^^^^^^^^^ `[_; 0]` cannot\
    \ be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `[_; 0]`\n   = note: in format strings you may be able\
    \ to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates\
    \ in the macro `$crate::__export::format_args` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest = extensions.iter().position(|&e|\
    \ e.to_ascii_lowercase().contains(&class_name.to_ascii_lowercase())).unwrap();\n\
    \    if strongest == 0 {\n        let mut strongest = extensions.iter().position(|&e|\
    \ e.to_ascii_uppercase().contains(&class_name.to_ascii_uppercase())).unwrap();\n\
    \        strongest = extensions.len() as usize;\n    }\n    let strength = (strongest\
    \ - 1) / extensions.len();\n    format!(\"{}.{}\", class_name, extensions[strongest])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable `strongest` is assigned to, but never used\n  --> /tmp/tmp2ndvjf4_.rs:20:17\n\
    \   |\n20 |         let mut strongest = extensions.iter().position(|&e| e.to_ascii_uppercase().contains(&class_name.to_ascii_uppercase())).unwrap();\n\
    \   |                 ^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_strongest` instead\n\nwarning: value\
    \ assigned to `strongest` is never read\n  --> /tmp/tmp2ndvjf4_.rs:21:9\n   |\n\
    21 |         strongest = extensions.len() as usize;\n   |         ^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: unused variable: `strength`\n\
    \  --> /tmp/tmp2ndvjf4_.rs:23:9\n   |\n23 |     let strength = (strongest - 1)\
    \ / extensions.len();\n   |         ^^^^^^^^ help: if this is intentional, prefix\
    \ it with an underscore: `_strength`\n\nerror[E0507]: cannot move out of a shared\
    \ reference\n  --> /tmp/tmp2ndvjf4_.rs:18:53\n   |\n18 |     let mut strongest\
    \ = extensions.iter().position(|&e| e.to_ascii_lowercase().contains(&class_name.to_ascii_lowercase())).unwrap();\n\
    \   |                                                     ^-\n   |           \
    \                                          ||\n   |                          \
    \                           |data moved here\n   |                           \
    \                          |move occurs because `e` has type `String`, which does\
    \ not implement the `Copy` trait\n   |                                       \
    \              help: consider removing the `&`: `e`\n\nerror[E0507]: cannot move\
    \ out of a shared reference\n  --> /tmp/tmp2ndvjf4_.rs:20:57\n   |\n20 |     \
    \    let mut strongest = extensions.iter().position(|&e| e.to_ascii_uppercase().contains(&class_name.to_ascii_uppercase())).unwrap();\n\
    \   |                                                         ^-\n   |       \
    \                                                  ||\n   |                  \
    \                                       |data moved here\n   |               \
    \                                          |move o"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n\n\
    \    for (i, extension) in extensions.iter().enumerate() {\n        let class_name\
    \ = class_name[..i];\n        let class_name = class_name.to_lowercase();\n\n\
    \        let class_name_len = class_name.len();\n        let extension_name_len\
    \ = extension.len();\n        let strength = class_name_len.cmp(&extension_name_len);\n\
    \n        if strength == 0 {\n            strength = i;\n        }\n    }\n\n\
    \    class_name.to_string().as_str().to_string() + \n    extensions[strength].to_string().as_str()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpgo22ast3.rs:21:13\n   |\n21 |         let class_name = class_name[..i];\n\
    \   |             ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n21 |         let\
    \ class_name = &class_name[..i];\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgo22ast3.rs:28:24\n   |\n28 |         if strength\
    \ == 0 {\n   |                        ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgo22ast3.rs:29:24\n\
    \   |\n26 |         let strength = class_name_len.cmp(&extension_name_len);\n\
    \   |                        --------------------------------------- expected\
    \ due to this value\n...\n29 |             strength = i;\n   |               \
    \         ^ expected enum `std::cmp::Ordering`, found `usize`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpgo22ast3.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n\
    \    let mut extension = String::from(\"\");\n    for (i, x) in extensions.iter().enumerate()\
    \ {\n        if x.is_empty() {\n            continue;\n        }\n        let\
    \ mut c = x.to_lowercase();\n        let mut s = c.chars().filter(|c| *c >= 'A'\
    \ && *c <= 'Z').count();\n        c += 'A' - s.to_string();\n        if strength\
    \ > i || strength < i {\n            strength = i;\n            extension = x;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `String` from `char`\n  --> /tmp/tmp7flyvsy_.rs:26:18\n\
    \   |\n26 |         c += 'A' - s.to_string();\n   |              --- ^ -------------\
    \ String\n   |              |\n   |              char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7flyvsy_.rs:27:23\n   |\n27 |         if strength > i ||\
    \ strength < i {\n   |                       ^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n27 |         if strength > i.try_into().unwrap() ||\
    \ strength < i {\n   |                        ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7flyvsy_.rs:27:39\n   |\n27 |         if strength\
    \ > i || strength < i {\n   |                                       ^ expected\
    \ `i32`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n27 |         if strength > i\
    \ || strength < i.try_into().unwrap() {\n   |                                \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7flyvsy_.rs:28:24\n\
    \   |\n18 |     let mut strength = -1i32;\n   |                        ----- expected\
    \ due to this value\n...\n28 |             strength = i;\n   |               \
    \         ^ expected `i32`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7flyvsy_.rs:29:25\n   |\n19 |     let mut extension = String::from(\"\
    \");\n   |                         ---------------- expected due to this value\n\
    ...\n29 |             extension = x;\n   |                         ^- help: try\
    \ using a conversion method: `.to_string()`\n   |                         |\n\
    \   |                         expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n\n\
    \    for (i, &ext) in extensions.iter().enumerate() {\n        if ext.is_empty()\
    \ {\n            continue;\n        }\n\n        // Capitalization count\n   \
    \     let cap = &ext[0..ext.len().to_lowercase().find('A')];\n        let sm =\
    \ &ext[ext.len().to_lowercase().find('a')..ext.len()];\n        if cap == sm {\n\
    \            continue;\n        }\n\n        // Strength is calculated as\n  \
    \      // Capping count - Small letter count\n        let cap_count = cap.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm_count = sm.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap_count == 0 {\n            strength += -1;\n        } else {\n\
    \            strength += (cap_count - sm_count) / cap_count.max(sm_count);\n \
    \       }\n    }\n\n    // We take the one with highest strength\n    extensions.iter().max_by(|a,\
    \ b| strength.cmp(&b.len()));\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_lowercase` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmp3js8avgx.rs:26:37\n   |\n26 |         let cap\
    \ = &ext[0..ext.len().to_lowercase().find('A')];\n   |                       \
    \              ^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `to_lowercase` found for type `usize` in the current scope\n  --> /tmp/tmp3js8avgx.rs:27:33\n\
    \   |\n27 |         let sm = &ext[ext.len().to_lowercase().find('a')..ext.len()];\n\
    \   |                                 ^^^^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3js8avgx.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp3js8avgx.rs:37:25\n   |\n37 | \
    \            strength += -1;\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3js8avgx.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n\
    \    let mut strongest_name = \"\";\n    let mut current_strongest_name = \"\"\
    ;\n    for (i, extension) in extensions {\n        let length = extension.len();\n\
    \        let mut current_strength = -1;\n        for (j, char) in extension.chars().enumerate()\
    \ {\n            if j == 0 {\n                current_strength = strongest_name.chars().filter(|c|\
    \ *c != char).count();\n            } else {\n                let prev_strength\
    \ = current_strength;\n                current_strength = strongest_name.chars().filter(|c|\
    \ *c != char).count();\n                if current_strength > prev_strength ||\
    \ (i == 0 && current_strength == 0 && (length == 0 || j == length-1)) {\n    \
    \                strongest_name = extension;\n                    break;\n   \
    \             }\n            }\n        }\n        if current_strength > max_strength\
    \ {\n            max_strength = current_strength;\n            current_strongest_name\
    \ = extension;\n        }\n    }\n    class_name.to_string() + current_strongest_name\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb6bq4smp.rs:21:9\n   |\n\
    21 |     for (i, extension) in extensions {\n   |         ^^^^^^^^^^^^^^    ----------\
    \ this expression has type `Option<String>`\n   |         |\n   |         expected\
    \ struct `String`, found tuple\n   |\n   = note: expected struct `String`\n  \
    \             found tuple `(_, _)`\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmpb6bq4smp.rs:23:36\n   |\n23 |         let mut\
    \ current_strength = -1;\n   |                                    ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpb6bq4smp.rs:18:28\n   |\n18 | \
    \    let mut max_strength = -1;\n   |                            ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.iter().any(|x|\
    \ !x.is_empty()) {\n        let mut extensions = extensions.clone();\n       \
    \ let len = extensions.len();\n        let mut strength = -1;\n        for i in\
    \ 0..len {\n            if extensions[i].chars().filter(|c| c.is_uppercase()).count()\
    \ > 1 {\n                strength = len - i;\n            }\n        }\n     \
    \   let strength = strength.to_f64() / len.to_f64();\n        let mut best = String::from(class_name);\n\
    \        let mut s = String::from(class_name);\n        for i in 0..extensions.len()\
    \ {\n            if extensions[i].chars().filter(|c| c.is_uppercase()).count()\
    \ > 1 {\n                best = s.clone();\n            }\n            s = s.clone();\n\
    \        }\n        best.insert(0, \"{\");\n        best.append(\"}\");\n    \
    \    best.to_owned()\n    } else {\n        class_name.to_owned()\n    }\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5i_nyj9g.rs:21:28\n\
    \   |\n21 |         let mut strength = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmp5i_nyj9g.rs:27:33\n   |\n27 |         let strength = strength.to_f64()\
    \ / len.to_f64();\n   |                                 ^^^^^^ method not found\
    \ in `usize`\n\nerror[E0599]: no method named `to_f64` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmp5i_nyj9g.rs:27:48\n   |\n27 |         let\
    \ strength = strength.to_f64() / len.to_f64();\n   |                         \
    \                       ^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5i_nyj9g.rs:36:24\n   |\n36 |         best.insert(0, \"\
    {\");\n   |                        ^^^ expected `char`, found `&str`\n   |\nhelp:\
    \ if you meant to write a `char` literal, use single quotes\n   |\n36 |      \
    \   best.insert(0, '{');\n   |                        ~~~\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp5i_nyj9g.rs:37:14\n   |\n37 |         best.append(\"}\");\n   |    \
    \          ^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n\
    \    let mut best_extension_name = \"\";\n    for extension in extensions {\n\
    \        let (snum, lnum) = extension.chars().count();\n        let cap = snum\
    \ as f64 * 1.0 / lnum as f64;\n        if cap > max_strength {\n            max_strength\
    \ = cap;\n            best_extension_name = extension;\n        }\n    }\n   \
    \ class_name.to_string() + best_extension_name\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkw5u2acm.rs:21:13\n   |\n\
    21 |         let (snum, lnum) = extension.chars().count();\n   |             ^^^^^^^^^^^^\
    \   ------------------------- this expression has type `usize`\n   |         \
    \    |\n   |             expected `usize`, found tuple\n   |\n   = note: expected\
    \ type `usize`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkw5u2acm.rs:25:35\n   |\n19 |     let mut best_extension_name\
    \ = \"\";\n   |                                   -- expected due to this value\n\
    ...\n25 |             best_extension_name = extension;\n   |                 \
    \                  ^^^^^^^^^\n   |                                   |\n   | \
    \                                  expected `&str`, found struct `String`\n  \
    \ |                                   help: consider borrowing here: `&extension`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions\n        .iter()\n\
    \        .fold(class_name, |class_name, extension| {\n            let mut class_name\
    \ = class_name;\n            let mut extension = extension;\n            let mut\
    \ num_uppercase = 0;\n            let mut num_lowercase = 0;\n            while\
    \ let Some(letter) = &extension[num_uppercase..] {\n                match letter\
    \ {\n                    'A' as char => num_uppercase = num_uppercase + 1,\n \
    \                   'a' as char => num_lowercase = num_lowercase + 1,\n      \
    \              '_' as char => break,\n                    _ => continue,\n   \
    \             }\n            }\n            let mut strength = if num_uppercase\
    \ - num_lowercase > 0 { 1 } else { 0 };\n            if num_lowercase == 0 {\n\
    \                num_lowercase = 1;\n            }\n            strength = num_lowercase\
    \ - num_uppercase;\n            &class_name.to_string() + &extension.as_bytes().to_string()\
    \ + &format!(\"{}.{}\", num_uppercase, num_lowercase)\n        })\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpyy7zqgfo.rs:27:25\n   |\n27 |                     'A' as\
    \ char => num_uppercase = num_uppercase + 1,\n   |                         ^^\
    \ expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyy7zqgfo.rs:25:23\n   |\n25 |             while let Some(letter)\
    \ = &extension[num_uppercase..] {\n   |                       ^^^^^^^^^^^^   ---------------------------\
    \ this expression has type `&str`\n   |                       |\n   |        \
    \               expected `str`, found enum `Option`\n   |\n   = note: expected\
    \ type `str`\n              found enum `Option<_>`\n\nerror[E0599]: the method\
    \ `to_string` exists for reference `&[u8]`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpyy7zqgfo.rs:38:61\n   |\n38 |             &class_name.to_string()\
    \ + &extension.as_bytes().to_string() + &format!(\"{}.{}\", num_uppercase, num_lowercase)\n\
    \   |                                                             ^^^^^^^^^ method\
    \ cannot be called on `&[u8]` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `[u8]: std::fmt::Display`\n\
    \           which is required by `[u8]: ToString`\n           `&[u8]: std::fmt::Display`\n\
    \           which is required by `&[u8]: ToString`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    match extensions.iter().cloned().sorted().max_by(|a,\
    \ b| a.compare_with_strength(b))\n    {\n        Some(e) => format!(\"{}.{}\"\
    , class_name, e),\n        None => String::new()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp4vzdzeiz.rs:18:38\n   |\n18 |     match extensions.iter().cloned().sorted().max_by(|a,\
    \ b| a.compare_with_strength(b))\n   |                                      ^^^^^^\
    \ method not found in `Cloned<std::slice::Iter<'_, String>>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension:\
    \ String = \"\".to_string();\n    let mut current_strength: i32 = -1;\n    for\
    \ extension in extensions {\n        let class_len = class_name.len();\n     \
    \   let extension_len = extension.len();\n        let diff = class_len - extension_len;\n\
    \        let cap = class_len as i32;\n        let sm = extension_len as i32;\n\
    \        let strength = if diff == 0 {\n            0\n        } else if diff\
    \ == 1 {\n            cmp::min(diff, cap - sm)\n        } else {\n           \
    \ cmp::min(diff, cap - sm, diff / cap)\n        };\n        if strength > current_strength\
    \ {\n            current_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    strongest_extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpqovvjv9k.rs:29:13\n   |\n29 |             cmp::min(diff, cap -\
    \ sm)\n   |             ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpqovvjv9k.rs:31:13\n\
    \   |\n31 |             cmp::min(diff, cap - sm, diff / cap)\n   |           \
    \  ^^^ use of undeclared crate or module `cmp`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqovvjv9k.rs:31:45\n   |\n31 |             cmp::min(diff, cap -\
    \ sm, diff / cap)\n   |                                             ^^^ expected\
    \ `usize`, found `i32`\n\nerror[E0277]: cannot divide `usize` by `i32`\n  -->\
    \ /tmp/tmpqovvjv9k.rs:31:43\n   |\n31 |             cmp::min(diff, cap - sm, diff\
    \ / cap)\n   |                                           ^ no implementation for\
    \ `usize / i32`\n   |\n   = help: the trait `Div<i32>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extensions\
    \ = Vec::new();\n\n    for ext in extensions {\n        let mut ext_len: i32;\n\
    \n        let mut first_letter_of_ext = ext.chars().nth(0).unwrap();\n\n     \
    \   if first_letter_of_ext.is_lowercase() {\n            ext_len = ext.len() as\
    \ i32;\n        } else {\n            ext_len = ext.len() as i32;\n          \
    \  first_letter_of_ext = first_letter_of_ext.to_lowercase();\n        }\n\n  \
    \      let mut second_letter_of_ext = ext.chars().nth(1).unwrap();\n\n       \
    \ if second_letter_of_ext.is_uppercase() {\n            ext_len += 1;\n      \
    \  } else {\n            ext_len += 2;\n            second_letter_of_ext = second_letter_of_ext.to_uppercase();\n\
    \        }\n\n        if ext_len > 0 {\n            strongest_extensions.push(String::from(&class_name.to_string()[..ext_len]));\n\
    \        }\n    }\n\n    let mut max_extension_len: i32 = 0;\n\n    for ext in\
    \ strongest_extensions {\n        let mut ext_len: i32;\n\n        if ext.len()\
    \ > max_extension_len {\n            max_extension_len = ext.len();\n        }\n\
    \n        if ext.len() == 0 {\n            max_extension_len = 0;\n        }\n\
    \    }\n\n    strongest_extensions[0][..max_extension_len].to_string()\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_n37h9pa.rs:29:35\n   |\n\
    23 |         let mut first_letter_of_ext = ext.chars().nth(0).unwrap();\n   |\
    \                                       --------------------------- expected due\
    \ to this value\n...\n29 |             first_letter_of_ext = first_letter_of_ext.to_lowercase();\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_n37h9pa.rs:38:36\n   |\n32 |         let mut second_letter_of_ext =\
    \ ext.chars().nth(1).unwrap();\n   |                                        ---------------------------\
    \ expected due to this value\n...\n38 |             second_letter_of_ext = second_letter_of_ext.to_uppercase();\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `ToUppercase`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `RangeTo<i32>`\n  --> /tmp/tmp_n37h9pa.rs:42:53\n   |\n42 |  \
    \           strongest_extensions.push(String::from(&class_name.to_string()[..ext_len]));\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeTo<i32>`\n   |\n   = help: the trait `Index<RangeTo<i32>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_n37h9pa.rs:51:24\n\
    \   |\n51 |         if ext.len() > max_extension_len {\n   |                 \
    \       ^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to a `usize` and panic if the converted value doesn't fit\n   |\n51\
    \ |         if ext.len() > max_extension_len.try_into().unwra"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().sorted();\n    let mut class_name = class_name;\n\
    \n    // Find the first extension with the same strength as the one we're\n  \
    \  // currently checking\n    for e in extensions_sorted {\n        if class_name[0..e.len_utf8()].iter().all(|c|\
    \ c > 'Z') {\n            class_name += e;\n        }\n    }\n\n    class_name\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpw0sel2dp.rs:18:60\n   |\n18 |     let mut extensions_sorted\
    \ = extensions.iter().cloned().sorted();\n   |                               \
    \                             ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror[E0599]: no method named `iter` found for type `str` in the\
    \ current scope\n  --> /tmp/tmpw0sel2dp.rs:24:40\n   |\n24 |         if class_name[0..e.len_utf8()].iter().all(|c|\
    \ c > 'Z') {\n   |                                        ^^^^ method not found\
    \ in `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_set = extensions_set_from_vector(&extensions);\n\
    \    extensions_set.sort_by_key(|x| x.0.chars().count());\n    let (max_strength,\
    \ _) = extensions_set.max_by_key(|x| x.1);\n    if max_strength == -1 {\n    \
    \    return String::from(class_name);\n    } else {\n        let mut extension\
    \ = String::from(\"\");\n        let mut extension_name = String::from(\"\");\n\
    \        let mut strength = max_strength;\n        for (extension, extension_name)\
    \ in extensions_set.iter().take_while(|&(_, x)| x.1 == strength) {\n         \
    \   strength = x.1;\n        }\n        extension += extension_name;\n       \
    \ let mut idx = 1; // we skip the first extension\n        for (_, extension_name)\
    \ in extensions_set.iter().take_while(|&(_, x)| x.1 > strength) {\n          \
    \  if idx < extension.len() {\n                extension += \".\" + extension_name;\n\
    \                idx += 1;\n            } else {\n                return String::from(class_name\
    \ + extension);\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `extensions_set_from_vector` in this\
    \ scope\n  --> /tmp/tmpw1tv5ylx.rs:18:30\n   |\n18 |     let mut extensions_set\
    \ = extensions_set_from_vector(&extensions);\n   |                           \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `x` in this scope\n  --> /tmp/tmpw1tv5ylx.rs:28:24\n   |\n28 |  \
    \           strength = x.1;\n   |                        ^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw1tv5ylx.rs:30:22\n   |\n30 |\
    \         extension += extension_name;\n   |                      ^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&extension_name`\n\
    \nerror[E0369]: cannot add `_` to `&str`\n  --> /tmp/tmpw1tv5ylx.rs:34:34\n  \
    \ |\n34 |                 extension += \".\" + extension_name;\n   |         \
    \                     --- ^ -------------- _\n   |                           \
    \   |\n   |                              &str\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw1tv5ylx.rs:37:50\n   |\n37 |                 return String::from(class_name\
    \ + extension);\n   |                                                  ^^^^^^^^^\n\
    \   |                                                  |\n   |               \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                                  help: consider borrowing\
    \ here: `&extension`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1tv5ylx.rs:32:9\n\
    \   |\n17 |   fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                ------ expected `String` because of return type\n...\n32 | /\
    \         for (_, extension_name) in extensions_set.iter().take_while(|&(_, x)|\
    \ x.1 > strength) {\n33 | |             if idx < extension.len() {\n34 | |   \
    \              extension += \".\" + extension_name;\n35 | |                 idx\
    \ += 1;\n...  |\n38 | |             }\n39 | |        "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() > 0 {\n\
    \        let mut max = std::cmp::Ordering::default();\n        let mut max_idx\
    \ = -1;\n        for (idx, x) in extensions.iter().enumerate() {\n           \
    \ let c = x.to_ascii_lowercase();\n            let s = x.to_ascii_uppercase();\n\
    \            let cap = c.chars().filter(|x| *x == x).count();\n            let\
    \ sm = s.chars().filter(|x| *x == x).count();\n            let strength = cap\
    \ - sm;\n            if strength > max {\n                max = strength;\n  \
    \              max_idx = idx;\n            }\n        }\n        match extensions.iter().skip(max_idx).next()\
    \ {\n            Some(x) => class_name+String::from(x)+extensions[max_idx].to_ascii_lowercase(),\n\
    \            None => class_name,\n        }\n    } else {\n        class_name\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no variant or associated item named `default` found for enum\
    \ `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpqkwbhs4x.rs:19:43\n\
    \   |\n19 |         let mut max = std::cmp::Ordering::default();\n   |       \
    \                                    ^^^^^^^ variant or associated item not found\
    \ in `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkwbhs4x.rs:24:50\n\
    \   |\n24 |             let cap = c.chars().filter(|x| *x == x).count();\n   |\
    \                                                  ^ expected `char`, found `&char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |             let cap\
    \ = c.chars().filter(|x| *x == *x).count();\n   |                            \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkwbhs4x.rs:25:49\n\
    \   |\n25 |             let sm = s.chars().filter(|x| *x == x).count();\n   |\
    \                                                 ^ expected `char`, found `&char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n25 |             let sm\
    \ = s.chars().filter(|x| *x == *x).count();\n   |                            \
    \                     +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpqkwbhs4x.rs:20:27\n   |\n20 |         let mut max_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkwbhs4x.rs:33:35\n\
    \   |\n33 |             Some(x) => class_name+String::from(x)+extensions[max_idx].to_ascii_lowercase(),\n\
    \   |                                   ^^^^^^^^^^^^^^^\n   |                \
    \                   |\n   |                                   expected `&str`,\
    \ found struct `String`\n   |                                   help: consider\
    \ borrowing here: `&String::from(x)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqkwbhs4x.r"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_hashmap\
    \ = HashMap::new();\n    extensions.iter().for_each(|s| {\n        let mut extensions_slice\
    \ = s.chars().collect::<String>();\n        for c in extensions_slice {\n    \
    \        extensions_hashmap.insert(c, 0);\n        }\n    });\n    let mut best_extension\
    \ = None;\n    for e in extensions_hashmap.keys() {\n        if extensions_hashmap.values().contains(&e\
    \ * -1)? {\n            extensions_hashmap.remove(e);\n            if extensions_hashmap.values().contains(&e\
    \ * -1) == true {\n                best_extension = Some(String::from(class_name\
    \ + e.to_string()));\n            }\n        }\n    }\n    match best_extension\
    \ {\n        None => {\n            String::from(\"\")\n        }\n        Some(best_str)\
    \ => String::from(best_str),\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpq2k1skne.rs:18:34\n   |\n18 |     let mut extensions_hashmap = HashMap::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpq2k1skne.rs:21:18\n\
    \   |\n21 |         for c in extensions_slice {\n   |                  ^^^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpq2k1skne.rs:27:57\n\
    \   |\n17 | / fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n18 | |     let mut extensions_hashmap = HashMap::new();\n19 | |\
    \     extensions.iter().for_each(|s| {\n20 | |         let mut extensions_slice\
    \ = s.chars().collect::<String>();\n...  |\n27 | |         if extensions_hashmap.values().contains(&e\
    \ * -1)? {\n   | |                                                         ^ cannot\
    \ use the `?` operator in a function that returns `String`\n...  |\n39 | |   \
    \  }\n40 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual<_>` is not implemented for `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    match extensions.iter().max_by_key(|x|\
    \ x.chars().count()) {\n        None => String::from(class_name + \"_\" + extensions.iter().collect::<Vec<_>>().join(\"\
    .\")),\n        Some(Extension(_, s, e)) => {\n            String::from(class_name\
    \ + s.to_string().chars().collect::<Vec<_>>().join(\".\") + e.to_string().chars().collect::<Vec<_>>().join(\"\
    .\"))\n        }\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Extension` in\
    \ this scope\n  --> /tmp/tmpcm1d5w9l.rs:20:14\n   |\n20 |         Some(Extension(_,\
    \ s, e)) => {\n   |              ^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<&String>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpcm1d5w9l.rs:19:87\n   |\n19 |         None => String::from(class_name\
    \ + \"_\" + extensions.iter().collect::<Vec<_>>().join(\".\")),\n   |        \
    \                                                                            \
    \   ^^^^ method cannot be called on `Vec<&String>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `[&String]:\
    \ Join<_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0531, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0531`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut i = 0;\n    let mut\
    \ total_weight = 0;\n    let mut extension = extensions[0];\n\n    while i <=\
    \ extension.len() {\n        // The current extension name has letters up to and\
    \ including the current extension.\n        let mut current_extension = extension;\n\
    \        while i <= current_extension.len() {\n            if current_extension[i]\
    \ == class_name[i] {\n                i += 1;\n                break;\n      \
    \      } else {\n                i += 1;\n                current_extension =\
    \ current_extension.chars();\n            }\n        }\n\n        // Add the extension's\
    \ weight to the total weight\n        total_weight += i;\n\n        // If the\
    \ extension's weight is at least as strong as the previous extension, then\n \
    \       // update it\n        if total_weight <= i {\n            extension =\
    \ extensions[i];\n        }\n        i += 1;\n    }\n\n    class_name + extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3cj3l6cx.rs:26:16\n\
    \   |\n26 |             if current_extension[i] == class_name[i] {\n   |     \
    \           ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3cj3l6cx.rs:26:40\n\
    \   |\n26 |             if current_extension[i] == class_name[i] {\n   |     \
    \                                   ^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3cj3l6cx.rs:31:37\n\
    \   |\n24 |         let mut current_extension = extension;\n   |             \
    \                        --------- expected due to this value\n...\n31 |     \
    \            current_extension = current_extension.chars();\n   |            \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found struct `Chars`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3cj3l6cx.rs:46:18\n\
    \   |\n46 |     class_name + extension\n   |                  ^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&str`, found struct `String`\n\
    \   | "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = extensions_map::default();\n\
    \    let mut extensions_sorted_by_strength = extensions_sorted_by_strength::default();\n\
    \    \n    extensions_map.insert(class_name.to_owned(), extensions);\n    extensions_sorted_by_strength\
    \ = extensions_sorted_by_strength.iter().map(|(class_name, extensions)| {\n  \
    \      let strength = extensions_map[class_name].iter().map(|extension| {\n  \
    \          if extension.chars().filter(|&c| c.is_uppercase() == 1).count() > 0\
    \ {\n                -1\n            } else {\n                extension.chars().filter(|&c|\
    \ c.is_lowercase() == 1).count() - 1\n            }\n        }).max().unwrap();\n\
    \        (class_name, strength)\n    }).collect::<Vec<_>>();\n    \n    match\
    \ extensions_sorted_by_strength.iter().find(|(_, strength)| strength == -1) {\n\
    \        Some((class_name, _)) => format!(\"{}.{}\", class_name, extensions_map[class_name].iter().filter(|&c|\
    \ c.is_uppercase() == 1).cloned().collect::<Vec<_>>().into_iter().max_by_key(|e|\
    \ e).unwrap().as_str()),\n        None => {\n            println!(\"WARNING: No\
    \ extension found for {}\", class_name)\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `extensions_map`\n\
    \  --> /tmp/tmpnwgg_0t9.rs:18:30\n   |\n18 |     let mut extensions_map = extensions_map::default();\n\
    \   |                              ^^^^^^^^^^^^^^ use of undeclared crate or module\
    \ `extensions_map`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `extensions_sorted_by_strength`\n  --> /tmp/tmpnwgg_0t9.rs:19:45\n\
    \   |\n19 |     let mut extensions_sorted_by_strength = extensions_sorted_by_strength::default();\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ use of undeclared crate or module `extensions_sorted_by_strength`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnwgg_0t9.rs:36:13\n   |\n36 |             println!(\"\
    WARNING: No extension found for {}\", class_name)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\n   = note: this error originates\
    \ in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min_extension = extensions[0]\n\
    \    let mut max_extension = extensions[0]\n    for e in extensions {\n      \
    \  if e.chars().filter(|c| c.is_uppercase()).count() > min_extension.chars().filter(|c|\
    \ c.is_uppercase()).count() {\n            min_extension = e;\n        }\n   \
    \     if e.chars().filter(|c| c.is_lowercase()).count() > max_extension.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n            max_extension = e;\n        }\n   \
    \ }\n    format!(\"{}.{}\", class_name, min_extension)\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmppb_9x6k8.rs:18:42\n\
    \   |\n18 |     let mut min_extension = extensions[0]\n   |                  \
    \                        ^ help: add `;` here\n19 |     let mut max_extension\
    \ = extensions[0]\n   |     --- unexpected token\n\nerror: expected `;`, found\
    \ keyword `for`\n  --> /tmp/tmppb_9x6k8.rs:19:42\n   |\n19 |     let mut max_extension\
    \ = extensions[0]\n   |                                          ^ help: add `;`\
    \ here\n20 |     for e in extensions {\n   |     --- unexpected token\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut len = class_name.len();\n\
    \    let mut strength = -1;\n    let mut i = 0;\n    let mut current_extension\
    \ = Vec::new();\n    for extension in extensions {\n        let mut i = class_name.len()\
    \ - extension.len();\n        let mut j = class_name.len() - 1;\n        while\
    \ i <= j {\n            let mut c1 = class_name[i];\n            let mut c2 =\
    \ class_name[j];\n            if c1 == c2 && c1 != '_' && c2 != '_' {\n      \
    \          if strength == -1 {\n                    strength = extension.len();\n\
    \                } else {\n                    if extension.len() > strength {\n\
    \                        strength = extension.len();\n                       \
    \ current_extension = vec![extension];\n                    } else {\n       \
    \                 current_extension = extension;\n                    }\n    \
    \            }\n                i += 1;\n                j -= 1;\n           \
    \ } else {\n                i += 1;\n            }\n        }\n    }\n    if strength\
    \ == -1 {\n        String::from(\"$0.\").format(&class_name)\n    } else {\n \
    \       current_extension.join(&\".\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphq6d11k3.rs:26:26\n\
    \   |\n26 |             let mut c1 = class_name[i];\n   |                    \
    \      ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphq6d11k3.rs:27:26\n   |\n27 |             let mut c2 = class_name[j];\n\
    \   |                          ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmphq6d11k3.rs:19:24\n   |\n19 |     let mut strength = -1;\n   | \
    \                       ^^ the trait `Neg` is not implemented for `usize`\n  \
    \ |\n   = help: the following other types implement trait `Neg`:\n           \
    \  &f32\n             &f64\n             &i128\n             &i16\n          \
    \   &i32\n             &i64\n             &i8\n             &isize\n         \
    \  and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmphq6d11k3.rs:29:32\n   |\n29 |                 if strength == -1\
    \ {\n   |                                ^^ the trait `Neg` is not imple"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    let mut extension_found = false;\n\
    \    for &e in extensions {\n        let caps = e.chars().filter(|c| *c >= 'A'\
    \ && *c <= 'Z').count();\n        let sms = e.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').count();\n        let caps_sm = caps - sms;\n        let strength_with_sms\
    \ = caps_sm / caps;\n        if strength_with_sms > strength {\n            extension\
    \ = e;\n            strength = strength_with_sms;\n        }\n    }\n    if extension_found\
    \ {\n        format!(\"{}.{}\", class_name, extension)\n    } else {\n       \
    \ format!(\"{}\", class_name)\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnr1xnwjh.rs:21:9\n   |\n\
    21 |     for &e in extensions {\n   |         ^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `e`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -1i32;\n\
    \    let mut strength = String::new();\n\n    for e in extensions {\n        match\
    \ e.chars().count() {\n            1 => continue,\n            _ => {\n      \
    \          let c = e.chars().count();\n                let s = c.to_ascii_lowercase().count();\n\
    \                if s > strength.len() {\n                    strength = e;\n\
    \                }\n                if c > max_strength {\n                  \
    \  max_strength = c;\n                }\n            }\n        }\n    }\n   \
    \ class_name.to_string() + &strength\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmplodj1w87.rs:26:27\n   |\n26 |          \
    \       let s = c.to_ascii_lowercase().count();\n   |                        \
    \   ^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplodj1w87.rs:30:24\n   |\n30 |                 if c > max_strength\
    \ {\n   |                        ^^^^^^^^^^^^ expected `usize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |                 if c > max_strength.try_into().unwrap()\
    \ {\n   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplodj1w87.rs:31:36\n   |\n18 |     let mut max_strength\
    \ = -1i32;\n   |                            ----- expected due to this value\n\
    ...\n31 |                     max_strength = c;\n   |                        \
    \            ^ expected `i32`, found `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|&c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|&c| c.is_lowercase()).count();\n \
    \       let cap_and_sm = cap + sm;\n        if strength == -1 || cap_and_sm >\
    \ strength {\n            strength = cap_and_sm;\n            extension = extension.into();\n\
    \        }\n    }\n    extension.into()\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpfhq21umz.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpfhq21umz.rs:24:24\n   |\n24 | \
    \        if strength == -1 || cap_and_sm > strength {\n   |                  \
    \      ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: u32 = -1;\n\
    \    for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        strength += cap - sm;\n    }\n    if strength == 0 {\n        format!(\"\
    {}\", class_name)\n    } else {\n        format!(\"{}.{}\", class_name, extensions[strength].to_uppercase())\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `u32`\n  --> /tmp/tmpw3n9diyy.rs:18:29\n\
    \   |\n18 |     let mut strength: u32 = -1;\n   |                            \
    \ ^^\n   |                             |\n   |                             cannot\
    \ apply unary operator `-`\n   |                             help: you may have\
    \ meant the maximum value of `u32`: `u32::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3n9diyy.rs:22:21\n\
    \   |\n22 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `u32`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `u32`\n \
    \ --> /tmp/tmpw3n9diyy.rs:22:18\n   |\n22 |         strength += cap - sm;\n  \
    \ |                  ^^ no implementation for `u32 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `u32`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0277]: the type `[String]`\
    \ cannot be indexed by `u32`\n  --> /tmp/tmpw3n9diyy.rs:27:38\n   |\n27 |    \
    \     format!(\"{}.{}\", class_name, extensions[strength].to_uppercase())\n  \
    \ |                                      ^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `u32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<u32>` for `Vec<String>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    for extension in extensions.iter() {\n        let cap = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as u32;\n        let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() as u32;\n        strength += (cap - sm) as usize;\n\
    \    }\n\n    if strength == 0 {\n        return class_name;\n    }\n\n    if\
    \ strength == 1 {\n        return &extensions[0];\n    }\n\n    let fraction =\
    \ (strength - 1) / strength;\n    let mut index = Vec::new();\n    let mut i =\
    \ 1;\n    while i <= strength {\n        index.append(i);\n        i += fraction;\n\
    \    }\n\n    let mut res = class_name.clone();\n    for i in index.iter().rev()\
    \ {\n        res.push_str(&extensions[i - 1]);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0be0d93x.rs:20:53\n   |\n\
    20 |         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count()\
    \ as u32;\n   |                                                     ^^^\n   |\
    \                                                     |\n   |                \
    \                                     expected `&char`, found `char`\n   |   \
    \                                                  help: consider borrowing here:\
    \ `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0be0d93x.rs:20:65\n\
    \   |\n20 |         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count()\
    \ as u32;\n   |                                                              \
    \   ^^^\n   |                                                                \
    \ |\n   |                                                                 expected\
    \ `&char`, found `char`\n   |                                                \
    \                 help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0be0d93x.rs:21:52\n   |\n21 |         let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count() as u32;\n   |                                \
    \                    ^^^\n   |                                               \
    \     |\n   |                                                    expected `&char`,\
    \ found `char`\n   |                                                    help:\
    \ consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0be0d93x.rs:21:64\n\
    \   |\n21 |         let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count()\
    \ as u32;\n   |                                                              \
    \  ^^^\n   |                                                                |\n\
    \   |                                                                expected\
    \ `&char`, found `char`\n   |                                                \
    \                help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0be0d93x.rs:30:16\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return \"\";\n    }\n\n    // find the first extension with the same\
    \ strength as the first one\n    let first_extension = extensions.iter()\n   \
    \     .find(|e| extensions.iter().filter(|c| e == c).count() == 1)\n        .unwrap();\n\
    \n    let class_name = format!(\"{}.{}\", class_name, first_extension);\n    class_name\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4uifo01_.rs:19:16\n   |\n\
    17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |                                                                    \
    \    ------ expected `String` because of return type\n18 |     if extensions.len()\
    \ == 0 {\n19 |         return \"\";\n   |                ^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::from(\"\");\n    let mut strength: usize = 0;\n\n    for extension\
    \ in extensions {\n        if extension.chars().count() > strength {\n       \
    \     strongest_extension = extension;\n            strength = extension.chars().count();\n\
    \        }\n    }\n    strongest_extension.push_str(class_name.to_lowercase());\n\
    \n    for extension in extensions {\n        if extension.chars().count() == strength\
    \ {\n            strongest_extension.push_str(extension.to_lowercase());\n   \
    \     }\n    }\n\n    strongest_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmau9hume.rs:27:34\n   |\n\
    27 |     strongest_extension.push_str(class_name.to_lowercase());\n   |      \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                 \
    \                 |\n   |                                  expected `&str`, found\
    \ struct `String`\n   |                                  help: consider borrowing\
    \ here: `&class_name.to_lowercase()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmau9hume.rs:31:42\n   |\n31 |             strongest_extension.push_str(extension.to_lowercase());\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                                          |\n   |                           \
    \               expected `&str`, found struct `String`\n   |                 \
    \                         help: consider borrowing here: `&extension.to_lowercase()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions.iter().max_by_key(|e|\
    \ e.count());\n    let mut strength: i32 = -1;\n    let mut extension = String::from(\"\
    \");\n    for s in extensions {\n        if s.to_ascii_uppercase().contains(&class_name.to_ascii_uppercase())\
    \ {\n            strength -= s.to_ascii_lowercase().chars().filter(|c| c.is_uppercase()).count()\
    \ as i32 - s.to_ascii_lowercase().chars().filter(|c| c.is_lowercase()).count()\
    \ as i32;\n            extension = s;\n            break;\n        }\n    }\n\
    \    extension + String::from(format!(\"{}.{}\", class_name, extension))\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&&String` is not an iterator\n   --> /tmp/tmplq857k1e.rs:18:40\n\
    \    |\n18  |       extensions.iter().max_by_key(|e| e.count());\n    |      \
    \                                    ^^^^^ `&&String` is not an iterator\n   \
    \ |\n    = note: the following trait bounds were not satisfied:\n            `&&String:\
    \ Iterator`\n            which is required by `&mut &&String: Iterator`\n    \
    \        `&String: Iterator`\n            which is required by `&mut &String:\
    \ Iterator`\n            `String: Iterator`\n            which is required by\
    \ `&mut String: Iterator`\n            `str: Iterator`\n            which is required\
    \ by `&mut str: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplq857k1e.rs:28:17\n\
    \   |\n28 |     extension + String::from(format!(\"{}.{}\", class_name, extension))\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&String::from(format!(\"\
    {}.{}\", class_name, extension))`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_extension = String::from(\"\
    \");\n    let mut best_extension_strength = 0;\n    for extension in extensions\
    \ {\n        let mut extension_strength = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ - extension.chars().filter(|c| c.is_lowercase()).count();\n        if extension_strength\
    \ > best_extension_strength {\n            best_extension_strength = extension_strength;\n\
    \            best_extension = extension;\n        }\n    }\n    class_name.push_str(&best_extension);\n\
    \    best_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpnjcigech.rs:21:13\n\
    \   |\n21 | ...   let mut extension_strength = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ - extension.chars().filter(|c| c.is_lowercase()...\n   |           ----^^^^^^^^^^^^^^^^^^\n\
    \   |           |\n   |           help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `class_name` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpnjcigech.rs:27:5\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                        ----------\
    \ help: consider changing this to be mutable: `mut class_name`\n...\n27 |    \
    \ class_name.push_str(&best_extension);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min_strength = extensions[0].chars().filter(|c|\
    \ *c >= 'A').count() as i32;\n    let mut strongest_extension = String::from(\"\
    \");\n    for ext in extensions {\n        let mut s = ext.chars().filter(|c|\
    \ *c >= 'A').count() as i32;\n        if s < min_strength {\n            min_strength\
    \ = s;\n            strongest_extension = ext;\n        }\n    }\n    class_name.to_string()\
    \ + strongest_extension.to_string() + \".\"\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcwe0hgv2.rs:27:30\n   |\n\
    27 |     class_name.to_string() + strongest_extension.to_string() + \".\"\n  \
    \ |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |       \
    \                       |\n   |                              expected `&str`,\
    \ found struct `String`\n   |                              help: consider borrowing\
    \ here: `&strongest_extension.to_string()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result = String::from(\"\
    \");\n    let mut counter: usize = 0;\n\n    for ext: &str in extensions {\n \
    \       let mut i = ext.chars().filter(|&c| c >= 'A' && c <= 'Z').count();\n \
    \       i += ext.chars().filter(|&c| c >= 'a' && c <= 'z').count();\n        if\
    \ ext.chars().count() == i + 1 {\n            i += ext.chars().filter(|&c| c >=\
    \ '0' && c <= '9').count();\n            i += ext.chars().filter(|&c| c >= 'A'\
    \ && c <= 'Z').count();\n            i += ext.chars().filter(|&c| c >= 'a' &&\
    \ c <= 'z').count();\n        }\n        counter += i;\n        if counter > 1\
    \ {\n            let mut extension_name = class_name + ext.chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').collect::<Vec<String>>().join(\"\");\n            extension_name\
    \ = extension_name.to_string();\n            result = extension_name.to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmp_itwpw4w.rs:21:12\n  \
    \ |\n21 |     for ext: &str in extensions {\n   |            ^ help: try adding\
    \ `in` here\n\nerror: expected expression, found `:`\n  --> /tmp/tmp_itwpw4w.rs:21:12\n\
    \   |\n21 |     for ext: &str in extensions {\n   |            ^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut best_extension: Option<String> = None;\n    for extension in extensions\
    \ {\n        let mut cap: u32 = 0;\n        let mut sm: u32 = 0;\n        for\
    \ c in extension {\n            if c.is_uppercase() { cap += 1 }\n           \
    \ else if c.is_lowercase() { sm += 1 }\n        }\n        let strength_ext: u32\
    \ = (cap - sm) as u32;\n        if strength > strength_ext {\n            strength\
    \ = strength_ext;\n            best_extension = Some(extension.to_string());\n\
    \        }\n    }\n    if !best_extension.is_some() {\n        panic!(\"No extension\
    \ was found\")\n    } else {\n        format!(\"{}.{}\", class_name, best_extension.clone())\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpwsnxnu04.rs:23:18\n\
    \   |\n23 |         for c in extension {\n   |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the trait bound `u32: Neg` is not satisfied\n  --> /tmp/tmpwsnxnu04.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `u32`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: `Option<String>`\
    \ doesn't implement `std::fmt::Display`\n  --> /tmp/tmpwsnxnu04.rs:36:38\n   |\n\
    36 |         format!(\"{}.{}\", class_name, best_extension.clone())\n   |    \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^ `Option<String>` cannot\
    \ be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `Option<String>`\n   = note: in format strings you may\
    \ be able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error\
    \ originates in the macro `$crate::__export::format_args` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_str = String::from(\"\
    \");\n    let mut best_ext = 0;\n    for ext in &extensions {\n        if ext.chars().filter(|c|\
    \ c.is_uppercase()).count() > best_ext {\n            best_ext = ext.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            best_str = format!(\"{}.{}\", class_name,\
    \ ext);\n        }\n    }\n    best_str\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"__YESIMHERE.eMptY\"`,\n right: `\"__YESIMHERE.NuLl__\"`', /tmp/tmpqoswkl__.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_len = extensions[0].chars().map(|&c|c.to_uppercase().unwrap()).filter(|&c|c\
    \ != 'Z').count();\n    for (i, extension) in extensions.iter().enumerate() {\n\
    \        if extensions_len > i {\n            return &format!(\"{}.{}\", &class_name,\
    \ &extensions[extensions.len() - i + 1]);\n        }\n        extensions_len +=\
    \ extension.chars().map(|&c|c.to_lowercase().unwrap()).filter(|&c|c != 'z').count();\n\
    \    }\n    &format!(\"{}.{}\", &class_name, &extensions[0])\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp695nx8zs.rs:18:57\n   |\n\
    18 |     let mut extensions_len = extensions[0].chars().map(|&c|c.to_uppercase().unwrap()).filter(|&c|c\
    \ != 'Z').count();\n   |                                                     \
    \    ^--\n   |                                                         ||\n  \
    \ |                                                         |expected due to this\n\
    \   |                                                         expected `char`,\
    \ found reference\n   |                                                      \
    \   help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp695nx8zs.rs:21:20\n\
    \   |\n21 |             return &format!(\"{}.{}\", &class_name, &extensions[extensions.len()\
    \ - i + 1]);\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n21 -             return &format!(\"{}.{}\", &class_name, &extensions[extensions.len()\
    \ - i + 1]);\n21 +             return format!(\"{}.{}\", &class_name, &extensions[extensions.len()\
    \ - i + 1]);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp695nx8zs.rs:23:50\n\
    \   |\n23 |         extensions_len += extension.chars().map(|&c|c.to_lowercase().unwrap()).filter(|&c|c\
    \ != 'z').count();\n   |                                                  ^--\n\
    \   |                                                  ||\n   |              \
    \                                    |expected due to this\n   |             \
    \                                     expected `char`, found reference\n   | \
    \                                                 help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp695nx8zs.rs:25:5\n   |\n17 | fn\
    \ Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n\
    \   |                                                                        --"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extensions\
    \ = vec![];\n    for ext in extensions.iter() {\n        if ext.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() >= 2 {\n            strongest_extensions.push_back(ext);\n\
    \        }\n    }\n    \n    let mut strongest_extension = String::from(\"Nameless\"\
    );\n    strongest_extension.push_str(class_name);\n    \n    for str in strongest_extensions.iter()\
    \ {\n        let mut ext = String::from(\"Nameless\");\n        ext.push_str(str);\n\
    \        strongest_extension.push_str(ext);\n    }\n    \n    strongest_extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpntkz0fi4.rs:20:40\n   |\n\
    20 |         if ext.chars().filter(|c| c >= 'A' && c <= 'Z').count() >= 2 {\n\
    \   |                                        ^^^\n   |                       \
    \                 |\n   |                                        expected `&char`,\
    \ found `char`\n   |                                        help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpntkz0fi4.rs:20:52\n\
    \   |\n20 |         if ext.chars().filter(|c| c >= 'A' && c <= 'Z').count() >=\
    \ 2 {\n   |                                                    ^^^\n   |     \
    \                                               |\n   |                      \
    \                              expected `&char`, found `char`\n   |          \
    \                                          help: consider borrowing here: `&'Z'`\n\
    \nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmpntkz0fi4.rs:21:34\n   |\n21 |             strongest_extensions.push_back(ext);\n\
    \   |                                  ^^^^^^^^^ method not found in `Vec<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpntkz0fi4.rs:26:34\n   |\n26 |\
    \     strongest_extension.push_str(class_name);\n   |                        \
    \          ^^^^^^^^^^\n   |                                  |\n   |         \
    \                         expected `&str`, found struct `String`\n   |       \
    \                           help: consider borrowing here: `&class_name`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpntkz0fi4.rs:28:16\n   |\n28 |     for str in strongest_extensions.iter()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = help: the trait `Iterator` is implemented for `std::slice::Iter<'a, T>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `std::slice::Iter<'_, str>`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compil"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut exts = extensions.clone();\n\
    \    let mut max_strength = -1i8;\n    let mut current_strongest_ext = None;\n\
    \    for &ext in exts {\n        let c_len = ext.chars().filter(|&x| x.is_uppercase()).count()\
    \ as i32;\n        let s_len = ext.chars().filter(|&x| x.is_lowercase()).count()\
    \ as i32;\n        let strength = (c_len - s_len) as i8;\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            current_strongest_ext\
    \ = ext;\n        }\n    }\n    class_name.to_string() + current_strongest_ext.clone().unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe02n299s.rs:21:9\n   |\n\
    21 |     for &ext in exts {\n   |         ^^^^    ---- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `ext`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map: HashMap<String,\
    \ i32> = HashMap::new();\n    for i in 0..extensions.len() {\n        extensions_map.insert(extensions.to_string(i),\
    \ i);\n    }\n    extensions_map.entry(class_name.to_string()).or_insert(0)\n\
    \        .cmp(&extensions_map.iter().max().unwrap().1.to_string())\n        .unwrap()\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpdrl010a7.rs:18:29\n\
    \   |\n18 |     let mut extensions_map: HashMap<String, i32> = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpdrl010a7.rs:18:52\n   |\n18 |     let mut extensions_map: HashMap<String,\
    \ i32> = HashMap::new();\n   |                                               \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]: `Vec<String>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpdrl010a7.rs:20:42\n  \
    \  |\n20  |           extensions_map.insert(extensions.to_string(i), i);\n   \
    \ |                                            ^^^^^^^^^ `Vec<String>` cannot\
    \ be formatted with the default formatter\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<String>: std::fmt::Display`\n \
    \           which is required by `Vec<String>: ToString`\n            `[String]:\
    \ std::fmt::Display`\n            which is required by `[String]: ToString`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n    let\
    \ mut extensions = extensions.clone();\n    extensions = extensions.iter().collect();\n\
    \    let mut extension_map = HashMap::new();\n    for extension in extensions\
    \ {\n        let mut split = extension.split_ascii_lowercase();\n        let cap\
    \ = split.next().unwrap().len_ascii_lowercase();\n        let sm = split.next().unwrap().len_ascii_lowercase();\n\
    \        let strength = cap - sm;\n        let key = class_name.to_string() +\
    \ extension.to_string();\n        extension_map.insert(key, strength);\n    }\n\
    \    let mut sorted_extensions = extension_map.iter().sort();\n    let mut best_extension\
    \ = String::from(\"\");\n    let mut current_strength = 0;\n    for (_, v) in\
    \ sorted_extensions {\n        let strength = v.clone();\n        if strength\
    \ > current_strength {\n            current_strength = strength;\n           \
    \ best_extension = class_name.to_string() + v.to_string();\n        }\n    }\n\
    \    best_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpcztjpw6q.rs:21:29\n   |\n21 |     let mut extension_map = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpcztjpw6q.rs:20:36\n     |\n\
    20   |     extensions = extensions.iter().collect();\n     |                 \
    \                   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `split_ascii_lowercase`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpcztjpw6q.rs:23:35\n\
    \   |\n23 |         let mut split = extension.split_ascii_lowercase();\n   | \
    \                                  ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcztjpw6q.rs:27:44\n   |\n27 |         let key = class_name.to_string()\
    \ + extension.to_string();\n   |                                            ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                            |\n   |                     \
    \                       expected `&str`, found struct `String`\n   |         \
    \                                   help: consider borrowing here: `&extension.to_string()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::<String,\
    \ String>::new();\n    for (i, extension) in extensions.iter().enumerate() {\n\
    \        let (_, cap) = extension.split_ascii_upper();\n        let (lower, _)\
    \ = extension.split_ascii_lower();\n        let cap = (cap.len() as i32) - cap.count(|&x|\
    \ x.is_ascii_upper());\n        let lower = (lower.len() as i32) - lower.count(|&x|\
    \ x.is_ascii_lower());\n        extensions_map.insert(format!(\"{}.{}\", class_name,\
    \ extension), format!(\"{}\", (cap - lower).to_string()));\n    }\n    let mut\
    \ max: i32 = -1;\n    let mut strongest = String::from(\"\");\n    for (extension,\
    \ strength) in extensions_map.iter().filter(|(_, strength)| strength > 0).sorted(|(first,\
    \ _), (second, _)| *strength > 0).take(1) {\n        if *strength > max {\n  \
    \          max = *strength;\n            strongest = extension;\n        }\n \
    \   }\n    strongest\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpa8tyghqn.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::<String,\
    \ String>::new();\n   |                              ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `strength` in this scope\n  --> /tmp/tmpa8tyghqn.rs:28:127\n\
    \   |\n28 | ...)| strength > 0).sorted(|(first, _), (second, _)| *strength > 0).take(1)\
    \ {\n   |                                                       ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `split_ascii_upper` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmpa8tyghqn.rs:20:34\n\
    \   |\n20 |         let (_, cap) = extension.split_ascii_upper();\n   |      \
    \                            ^^^^^^^^^^^^^^^^^ method not found in `&String`\n\
    \nerror[E0599]: no method named `split_ascii_lower` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa8tyghqn.rs:21:36\n   |\n21 |         let\
    \ (lower, _) = extension.split_ascii_lower();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^ method not found in `&String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let (class_name, extensions_with_same_strength)\
    \ = extensions\n        .iter()\n        .enumerate()\n        .filter(|(_, e)|\
    \ e == class_name)\n        .map(|(i, e)| (e.to_lowercase(), i))\n        .collect::<Vec<_>>();\n\
    \n    let mut strongest_extension = vec![];\n    for (i, e) in extensions_with_same_strength.iter().enumerate()\
    \ {\n        if i == 0 {\n            strongest_extension.push(class_name);\n\
    \        }\n        strongest_extension.push(e);\n    }\n\n    let (class_name,\
    \ mut strongest_extension) = \n        strongest_extension\n        .iter()\n\
    \        .enumerate()\n        .filter_map(|(_, e)| {\n            if let Some(iter)\
    \ = strongest_extension.iter().cloned().find(|e| e.to_lowercase() == e) {\n  \
    \              Some(iter + 1)\n            } else {\n                None\n  \
    \          }\n        })\n        .next()\n        .unwrap();\n\n    strongest_extension.push(class_name);\n\
    \    class_name\n        .to_lowercase()\n        .join(strongest_extension)\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&String` with `String`\n  --> /tmp/tmp2j6vs31h.rs:21:28\n\
    \   |\n21 |         .filter(|(_, e)| e == class_name)\n   |                  \
    \          ^^ no implementation for `&&String == String`\n   |\n   = help: the\
    \ trait `PartialEq<String>` is not implemented for `&&String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2j6vs31h.rs:18:9\n   |\n18 |       let (class_name, extensions_with_same_strength)\
    \ = extensions\n   |  _________^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^___-\n\
    \   | |         |\n   | |         expected struct `Vec`, found tuple\n19 | | \
    \        .iter()\n20 | |         .enumerate()\n21 | |         .filter(|(_, e)|\
    \ e == class_name)\n22 | |         .map(|(i, e)| (e.to_lowercase(), i))\n23 |\
    \ |         .collect::<Vec<_>>();\n   | |____________________________- this expression\
    \ has type `Vec<(String, usize)>`\n   |\n   = note: expected struct `Vec<(String,\
    \ usize)>`\n               found tuple `(_, _)`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n\
    \    let mut max_extension = String::new();\n    let mut max_extension_strength\
    \ = -1;\n\n    for extension in extensions {\n        let extension_strength:\
    \ i32 = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        max_strength = if extension_strength\
    \ > max_extension_strength {\n            extension_strength\n        } else {\n\
    \            max_extension_strength\n        };\n        if extension_strength\
    \ == 0 {\n            return class_name;\n        }\n        if extension_strength\
    \ > max_extension_strength {\n            max_extension_strength = extension_strength;\n\
    \            max_extension = extension;\n        }\n    }\n\n    max_extension.clone()\
    \ + \".\" + max_extension_strength.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7lb5azwu.rs:23:73\n   |\n\
    23 | ...   let extension_strength: i32 = extension.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count() - extension.chars().filter(|c| c >= 'a' &&...\n   |   \
    \                                                                    ^^^\n   |\
    \                                                                       |\n  \
    \ |                                                                       expected\
    \ `&char`, found `char`\n   |                                                \
    \                       help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7lb5azwu.rs:23:85\n   |\n23 | ...   let extension_strength:\
    \ i32 = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c|\
    \ c >= 'a' &&...\n   |                                                       \
    \                            ^^^\n   |                                       \
    \                                            |\n   |                         \
    \                                                          expected `&char`, found\
    \ `char`\n   |                                                               \
    \                    help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7lb5azwu.rs:23:134\n   |\n23 | ...).count() - extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \           ^^^\n   |                                                  |\n   |\
    \                                                  expected `&char`, found `char`\n\
    \   |                                                  help: consider borrowing\
    \ here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7lb5azwu.rs:23:146\n\
    \   |\n23 | ...extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n \
    \  |                                                  ^^^\n   |              \
    \                                    |\n   |                                 \
    \                 expected `&char`, found `char`\n   |                       \
    \                "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_strength\
    \ = Vec::new();\n    for extension in extensions {\n        extension_strength.push((extension.chars().map(|c|\
    \ c.to_ascii_lowercase()).count() - extension.chars().map(|c| c.to_ascii_uppercase()).count())\n\
    \            .sqrt());\n    }\n    let strongest_extension = extension_strength.iter().min_by_key(|&i|\
    \ i).unwrap().to_string();\n    class_name.concat(\".\").concat(strongest_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sqrt` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpkthbpi7p.rs:21:14\n   |\n21 |             .sqrt());\n \
    \  |              ^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpkthbpi7p.rs:24:16\n\
    \   |\n24 |     class_name.concat(\".\").concat(strongest_extension);\n   |  \
    \              ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkthbpi7p.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut sm = String::new();\n\
    \    let mut cap = String::new();\n    let mut extensions_with_strength = Vec::new();\n\
    \n    for extension in extensions {\n        let splits = extension.splitn(2,\
    \ '.');\n\n        if splits[0] == extension {\n            sm = sm.to_owned()\
    \ + splits[1].to_owned();\n        } else if splits[1].to_lowercase() == extension\
    \ {\n            cap = cap.to_owned() + splits[0].to_owned();\n        } else\
    \ {\n            extensions_with_strength.push((extension, -1));\n        }\n\
    \    }\n\n    if extensions_with_strength.len() == 0 {\n        String::from(\"\
    \")\n    } else if extensions_with_strength.len() == 1 {\n        String::from(class_name\
    \ + \".\" + extensions_with_strength.iter().next().unwrap().0)\n    } else {\n\
    \        let mut min = extensions_with_strength.iter().min_by_key(|&(e, s)| s).0;\n\
    \        let mut max = extensions_with_strength.iter().max_by_key(|&(e, s)| s).0;\n\
    \n        if min == max {\n            String::from(class_name + \".\" + min.0)\n\
    \        } else {\n            String::from(class_name + \".\" + min.0 + \".\"\
    \ + max.0)\n        }\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `std::str::SplitN<'_, char>`\n\
    \  --> /tmp/tmps5t6kih9.rs:25:12\n   |\n25 |         if splits[0] == extension\
    \ {\n   |            ^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `std::str::SplitN<'_, char>`\n  --> /tmp/tmps5t6kih9.rs:26:34\n   |\n26 |  \
    \           sm = sm.to_owned() + splits[1].to_owned();\n   |                 \
    \                 ^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `std::str::SplitN<'_, char>`\n  --> /tmp/tmps5t6kih9.rs:27:19\n   |\n27 |  \
    \       } else if splits[1].to_lowercase() == extension {\n   |              \
    \     ^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `std::str::SplitN<'_,\
    \ char>`\n  --> /tmp/tmps5t6kih9.rs:28:36\n   |\n28 |             cap = cap.to_owned()\
    \ + splits[0].to_owned();\n   |                                    ^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps5t6kih9.rs:37:41\n   |\n37 |\
    \         String::from(class_name + \".\" + extensions_with_strength.iter().next().unwrap().0)\n\
    \   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                         |\n   |                        \
    \                 expected `&str`, found struct `String`\n   |               \
    \                          help: consider borrowing here: `&extensions_with_strength.iter().next().unwrap().0`\n\
    \nerror[E0609]: no field `0` on type `Option<&(String, {integer})>`\n  --> /tmp/tmps5t6kih9.rs:39:79\n\
    \   |\n39 |         let mut min = extensions_with_strength.iter().min_by_key(|&(e,\
    \ s)| s).0;\n   |                                                            \
    \                   ^\n\nerror[E0609]: no field `0` on type `Option<&(String,\
    \ {integer})>`\n  --> /tmp/tmps5t6kih9.rs:40:79\n   |\n40 |         let mut max\
    \ = extensions_with_strength.iter().max_by_key(|&(e, s)| s).0;\n   |         \
    \                                                                      ^\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608, E0609.\nFor more information about an er"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension: Vec<&str> = extensions.iter().map(String::from).collect();\n\
    \    while extension.len() > 1 {\n        let mut i: i32 = 0;\n        let mut\
    \ c: usize = 0;\n        for e in extension {\n            if i > c.cmp(&strength)\
    \ {\n                i = c.cmp(&strength);\n                c = e.len() as usize;\n\
    \            }\n        }\n        extension = extension.iter().filter(|&e| e.len()\
    \ == c).collect();\n    }\n    return class_name.to_string() + \".\" + extension[0].to_string();\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `String`\n    --> /tmp/tmpt65qo29b.rs:19:72\n     |\n\
    19   |     let mut extension: Vec<&str> = extensions.iter().map(String::from).collect();\n\
    \     |                                                                      \
    \  ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Vec<&str>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpt65qo29b.rs:24:26\n   |\n24 |             if i > c.cmp(&strength) {\n\
    \   |                          ^^^^^^^^^ expected `usize`, found `i32`\n   |\n\
    \   = note: expected reference `&usize`\n              found reference `&i32`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt65qo29b.rs:24:20\n   |\n24 |\
    \             if i > c.cmp(&strength) {\n   |                    ^^^^^^^^^^^^^^^^\
    \ expected `i32`, found enum `std::cmp::Ordering`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt65qo29b.rs:25:27\n   |\n25 |                 i = c.cmp(&strength);\n\
    \   |                           ^^^^^^^^^ expected `usize`, found `i32`\n   |\n\
    \   = note: expected reference `&usize`\n              found reference `&i32`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt65qo29b.rs:25:21\n   |\n21 |\
    \         let mut i: i32 = 0;\n   |                    --- expected due to this\
    \ type\n...\n25 |                 i = c.cmp(&strength);\n   |                \
    \     ^^^^^^^^^^^^^^^^ expected `i32`, found enum `std::cmp::Ordering`\n\nerror[E0277]:\
    \ a value of type `Vec<&str>` cannot be built from an iterator over elements of\
    \ type `&&str`\n    --> /tmp/tmpt65qo29b.rs:29:64\n     |\n29   |         extension\
    \ = extension.iter().filter(|&e| e.len() == c).collect();\n     |            \
    \                                                    ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=&&str>`\n     |\n     = help:\
    \ the trait `FromItera"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension:\
    \ String;\n    let mut strength: usize = 0;\n    for (extension, class) in extensions.iter().zip(extensions)\
    \ {\n        if class.to_ascii_lowercase().find(extension.to_ascii_lowercase())\
    \ == Some(0) {\n            strength = strength + 1;\n        }\n    }\n    if\
    \ strength > 0 {\n        strongest_extension = class_name + String::from(\".\"\
    ) + extensions.iter().take(strength).collect::<Vec<String>>().join();\n    } else\
    \ {\n        strongest_extension = class_name;\n    }\n    strongest_extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp6h9bc33q.rs:21:44\n     |\n21   |         if class.to_ascii_lowercase().find(extension.to_ascii_lowercase())\
    \ == Some(0) {\n     |                                       ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \                  |\n     |                                       required by\
    \ a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n21   |         if class.to_ascii_lowercase().find(&extension.to_ascii_lowercase())\
    \ == Some(0) {\n     |                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6h9bc33q.rs:26:44\n   |\n26 |         strongest_extension\
    \ = class_name + String::from(\".\") + extensions.iter().take(strength).collect::<Vec<String>>().join();\n\
    \   |                                            ^^^^^^^^^^^^^^^^^\n   |     \
    \                                       |\n   |                              \
    \              expected `&str`, found struct `String`\n   |                  \
    \                          help: consider borrowing here: `&String::from(\".\"\
    )`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmp6h9bc33q.rs:26:97\n     |\n\
    26   |         strongest_extension = class_name + String::from(\".\") + extensions.iter().take(strength).collect::<Vec<String>>().join();\n\
    \     |                                                                      \
    \                           ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&String>`\n     |\n     = help: the trait `FromIterator<&String>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bo"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_hashmap\
    \ = vec![];\n    for extension in extensions {\n        let mut extension_hashmap\
    \ = vec![];\n        let mut c = extension.chars();\n        for _ in 0..c.len()\
    \ {\n            extension_hashmap.push((c.next().unwrap(), 0));\n        }\n\
    \        for (key, value) in extension_hashmap {\n            extensions_hashmap.push((key,\
    \ value));\n        }\n    }\n    let mut max_strength = -1;\n    let mut min_strength\
    \ = std::cmp::min(*(extensions_hashmap.len() - 1).unwrap(), extensions_hashmap.len());\n\
    \    while let Some((extension_name, extension_strength)) = extensions_hashmap[min_strength].unwrap()\
    \ {\n        if extension_strength == max_strength {\n            max_strength\
    \ += 1;\n            min_strength = min_strength + 1;\n        } else {\n    \
    \        if extension_strength < max_strength {\n                max_strength\
    \ = extension_strength;\n            }\n        }\n    }\n    if min_strength\
    \ == extensions_hashmap.len() - 1 {\n        class_name + \".\" + extensions[min_strength].to_string()\n\
    \    } else {\n        class_name + \".\" + extensions[min_strength].to_string()\
    \ + extensions[(min_strength + 1)..(max_strength)].to_string()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpuli6r11r.rs:22:23\n   |\n22 |         for _ in 0..c.len()\
    \ {\n   |                       ^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpuli6r11r.rs:30:74\n   |\n30 |     let mut min_strength = std::cmp::min(*(extensions_hashmap.len()\
    \ - 1).unwrap(), extensions_hashmap.len());\n   |                            \
    \                                              ^^^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `unwrap` found for tuple `(char, {integer})` in\
    \ the current scope\n  --> /tmp/tmpuli6r11r.rs:31:93\n   |\n31 |     while let\
    \ Some((extension_name, extension_strength)) = extensions_hashmap[min_strength].unwrap()\
    \ {\n   |                                                                    \
    \                         ^^^^^^ method not found in `(char, {integer})`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuli6r11r.rs:42:28\n   |\n42 |         class_name\
    \ + \".\" + extensions[min_strength].to_string()\n   |                       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                            |\n\
    \   |                            expected `&str`, found struct `String`\n   |\
    \                            help: consider borrowing here: `&extensions[min_strength].to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuli6r11r.rs:44:28\n   |\n44 |\
    \         class_name + \".\" + extensions[min_strength].to_string() + extensions[(min_strength\
    \ + 1)..(max_strength)].to_string()\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&extensions[min_strength].to_string()`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpuli6r11r.rs:29:28\n   |\n29 | \
    \    let mut max_strength = -1;\n   |                            ^^ the trait\
    \ `Neg` is not implemented f"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min_strength = -1;\n\
    \    let mut max_class_name = class_name;\n    for (index, extension) in extensions.iter().enumerate()\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      if cap == 0 && sm == 0 {\n            return class_name;\n        }\n \
    \       if sm == 0 && cap == 0 {\n            return extension;\n        }\n \
    \       if cap > sm {\n            let strength = cap - sm;\n            if strength\
    \ >= min_strength {\n                min_strength = strength;\n              \
    \  max_class_name = extension;\n            }\n        } else {\n            let\
    \ strength = sm - cap;\n            if strength >= min_strength {\n          \
    \      min_strength = strength;\n                max_class_name = class_name;\n\
    \            }\n        }\n    }\n    format!(\"{}.{}\", class_name, max_class_name)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp24x9wauy.rs:27:20\n   |\n\
    27 |             return extension;\n   |                    ^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                    |\n   | \
    \                   expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp24x9wauy.rs:33:34\n   |\n19 |     let mut max_class_name\
    \ = class_name;\n   |                              ---------- expected due to\
    \ this value\n...\n33 |                 max_class_name = extension;\n   |    \
    \                              ^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                                  |\n   |              \
    \                    expected struct `String`, found `&String`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp24x9wauy.rs:18:28\n\
    \   |\n18 |     let mut min_strength = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut total_extensions =\
    \ extensions.len();\n    let mut total_cap = String::new();\n    let mut total_sm\
    \ = String::new();\n    for (i, e) in extensions.iter().enumerate() {\n      \
    \  let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm =\
    \ e.chars().filter(|c| c.is_lowercase()).count();\n        total_cap.push_str(&cap);\n\
    \        total_sm.push_str(&sm);\n        total_extensions = total_extensions\
    \ - 1;\n    }\n    let cap = total_cap.chars().filter(|c| c.is_uppercase()).count();\n\
    \    let sm = total_sm.chars().filter(|c| c.is_lowercase()).count();\n    let\
    \ strength = (cap - sm) / total_extensions; // fraction CAP - SM\n    let mut\
    \ best_extension = String::new();\n    let mut best_extension_cap = String::new();\n\
    \    let mut best_extension_sm = 0;\n    let mut best_extension_smcap = 0;\n \
    \   for (i, e) in extensions.iter().enumerate() {\n        let cap = e.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = e.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if (cap > best_extension_cap) {\n            best_extension_cap = cap;\n\
    \            best_extension = e;\n            best_extension_sm += sm;\n     \
    \       best_extension_smcap += cap;\n        }\n    }\n    String::from_str(&class_name\
    \ + &best_extension + &best_extension_cap)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6x6yrwgx.rs:38:12\n\
    \   |\n38 |         if (cap > best_extension_cap) {\n   |            ^       \
    \                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n38 -         if (cap > best_extension_cap)\
    \ {\n38 +         if cap > best_extension_cap {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6x6yrwgx.rs:24:28\n   |\n24 |         total_cap.push_str(&cap);\n\
    \   |                            ^^^^ expected `str`, found `usize`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6x6yrwgx.rs:25:27\n   |\n25 |  \
    \       total_sm.push_str(&sm);\n   |                           ^^^ expected `str`,\
    \ found `usize`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6x6yrwgx.rs:38:19\n\
    \   |\n38 |         if (cap > best_extension_cap) {\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6x6yrwgx.rs:39:34\n   |\n32 |     let mut best_extension_cap =\
    \ String::new();\n   |                                  ------------- expected\
    \ due to this value\n...\n39 |             best_extension_cap = cap;\n   |   \
    \                               ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |\n   |                               \
    \   expected struct `String`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6x6yrwgx.rs:40:30\n   |\n31 |     let mut best_extension = String::new();\n\
    \   |                              ------------- expected due to this value\n\
    ...\n40 |             best_extension = e;\n   |                              ^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \            |\n   |                              expected struct `String`, found\
    \ `&String`\n\nerror[E0599]: no function or associated item named `from_str` found\
    \ for struct `St"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_str = format!(\"\
    {}.\", class_name);\n    for ext in extensions {\n        let ext = String::from(ext);\n\
    \        let cap = ext.chars().filter(|c| *c == c.to_ascii_uppercase()).count();\n\
    \        let sm = ext.chars().filter(|c| *c == c.to_ascii_lowercase()).count();\n\
    \        extensions_str += format!(\"{}.{}\", class_name, (cap - sm).to_string());\n\
    \    }\n    extensions_str\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbo4y_m_2.rs:23:27\n   |\n\
    23 |         extensions_str += format!(\"{}.{}\", class_name, (cap - sm).to_string());\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let extensions_vec: Vec<&str>\
    \ = extensions.iter().map(|e| &**e).collect();\n    let strongest_extension_vec\
    \ : Vec<_> = extensions_vec.iter().filter_map(|e| e.is_lowercase()).collect();\n\
    \    let mut extensions_vec_vec: Vec<_> = extensions_vec.iter().cloned().collect();\n\
    \    let mut current_strongest_extension: &str = String::from(\"\");\n    let\
    \ mut current_strongest_extension_index: usize = 0;\n    let mut current_strength:\
    \ i8 = -1;\n    let mut current_strength_index: usize = 0;\n    for mut s in strongest_extension_vec\
    \ {\n        if s.is_uppercase() {\n            if current_strongest_extension_index\
    \ == 0 {\n                current_strongest_extension = s;\n                current_strongest_extension_index\
    \ = extensions_vec_vec.iter().position(|&x| x.is_uppercase()).unwrap();\n    \
    \            current_strength_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_lowercase()).unwrap();\n                current_strength = extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_uppercase()).count() - extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_lowercase()).count();\n            }\n            elseif current_strength\
    \ > extensions_vec_vec[current_strength_index].chars().filter(|&x| x.is_uppercase()).count()\
    \ - extensions_vec_vec[current_strength_index].chars().filter(|&x| x.is_lowercase()).count()\
    \ {\n                current_strength = extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_uppercase()).count() - extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_lowercase()).count();\n                current_strongest_extension = s;\n\
    \                current_strongest_extension_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_uppercase()).unwrap();\n                current_strength_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_lowercase()).unwrap();\n            }\n            else {\n           \
    \     current_strongest_extension = s;\n                current_strongest_extension_index\
    \ = extensions_vec_vec.iter().position(|&x| x.is_uppercase()).unwrap();\n    \
    \            current_strength_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_lowercase()).unwrap();\n                current_strength = extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_uppercase()).count() - extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_lowercase()).\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp61k_84ee.rs:57:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n25 |     for mut s in strongest_extension_vec\
    \ {\n   |                                          - unclosed delimiter\n26 |\
    \         if s.is_uppercase() {\n   |                             - unclosed delimiter\n\
    ...\n39 |             else {\n   |                  - this delimiter might not\
    \ be properly closed...\n...\n44 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n57 | }\n   |   ^\n\nerror: expected one of `!`,\
    \ `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `current_strength`\n  -->\
    \ /tmp/tmp61k_84ee.rs:17:79\n   |\n17 | fn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n   |                                 \
    \                                              ^ unclosed delimiter\n...\n33 |\
    \             elseif current_strength > extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_uppercase()).count() - extensio...\n   |                   -^^^^^^^^^^^^^^^^\
    \ expected one of 8 possible tokens\n   |                   |\n   |          \
    \         help: `}` may belong here\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for reference `&&str` in the current scope\n  --> /tmp/tmp61k_84ee.rs:19:83\n\
    \   |\n19 |     let strongest_extension_vec : Vec<_> = extensions_vec.iter().filter_map(|e|\
    \ e.is_lowercase()).collect();\n   |                                         \
    \                                          ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp61k_84ee.rs:21:49\n   |\n21 |     let mut current_strongest_extension:\
    \ &str = String::from(\"\");\n   |                                          ----\
    \   ^^^^^^^^^^^^^^^^\n   |                                          |      |\n\
    \   |                                          |      expected `&"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::from(\"\");\n    for extension in extensions {\n        let cap =\
    \ extension.chars().filter(|c| *c >= 'A'|| *c <= 'Z').count();\n        let sm\
    \ = extension.chars().filter(|c| *c >= 'a'|| *c <= 'z').count();\n        let\
    \ strength = cap - sm;\n        if strongest_extension.is_empty() || strength\
    \ >= 0 {\n            strongest_extension = extension.clone();\n        }\n  \
    \  }\n    class_name.to_string() + strongest_extension\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn341mo84.rs:27:30\n   |\n\
    27 |     class_name.to_string() + strongest_extension\n   |                  \
    \            ^^^^^^^^^^^^^^^^^^^\n   |                              |\n   |  \
    \                            expected `&str`, found struct `String`\n   |    \
    \                          help: consider borrowing here: `&strongest_extension`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n\
    \        return class_name\n    }\n    // sort extensions by strength first\n\
    \    let mut sorted_extensions = extensions\n        .iter()\n        .enumerate()\n\
    \        .filter_map(|(i, s)| {\n            if s.chars().all(|c| !c.is_uppercase())\
    \ { // if any character in the string is not uppercase \n                return\
    \ Some(None); // then keep this extension\n            } else if s.chars().all(|c|\
    \ c.is_uppercase()) { // if all characters are uppercase \n                //\
    \ find the one that comes first in the vector\n                let mut first_upper\
    \ = i;\n                for (j, e) in extensions.iter().enumerate() {\n      \
    \              if e.chars().all(|c| !c.is_uppercase()) {\n                   \
    \     first_upper = j;\n                        break;\n                    }\n\
    \                }\n                if first_upper == i {\n                  \
    \  Some(None) // if the two extensions have the same strongest strength then choose\
    \ the one that comes first in the vector \n                } else {\n        \
    \            Some(Some((first_upper + 1).to_digit() as u32)) // otherwise, return\
    \ the number of the extension with higher strongest strength\n               \
    \ }\n            }\n        })\n        .collect::<Vec<_>>();\n\n    let mut class_name\
    \ = class_name.to_ascii_lowercase();\n    // find the index of the first uppercase\
    \ letter\n    let mut first_upper = sorted_extensions.iter().position(|e| e.is_some());\n\
    \    // find the index of the first lowercase letter\n    let mut first_lower\
    \ = sorted_extensions.iter().position(|e| e.is_some());\n    // loop through the\
    \ sorted extensions\n    for i in sorted_extensions.iter().rev().skip(first_upper\
    \ as usize).rev().take(first_lower as usize) {\n        // if the next uppercase\
    \ letter is greater than the first lower letter\n        // then increment the\
    \ first lower letter\n        if i > first_lower\n            && (class_name.chars().nth(i\
    \ + 1).is_uppercase() || class_name.chars().nth(i + 1).is_lowercase()) {\n   \
    \         first_lower += 1;\n        } else {\n            // if the next lowercase\
    \ letter is greater than the first upper letter\n            // then increment\
    \ the first upper letter\n            if i > first_upper\n                && (class_name.chars().nth(i\
    \ + 1).is_uppercase() || class_name.chars().nth(i + 1).is_lowercase()) {\n   \
    \             first_upper += 1;\n            }\n            // if all the letters\
    \ are the same then just add an 'S'\n            if i > first_lower && i > first_upper\
    \ {\n                class_name.push(b'S');\n            }\n            break\n\
    \        }\n    }\n\n    class_name + String::from(String::from(\".\")) + sorted_extensions[first_upper\
    \ as usize].to_ascii_lowercase()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpfcped_q5.rs:40:49\n   |\n40 | ...   Some(Some((first_upper\
    \ + 1).to_digit() as u32)) // otherwise, return the number of the extension with\
    \ higher strongest strength\n   |                                   ^^^^^^^^ method\
    \ not found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcped_q5.rs:55:16\n\
    \   |\n55 |         if i > first_lower\n   |                ^^^^^^^^^^^\n   |\
    \                |\n   |                expected `&Option<_>`, found enum `Option`\n\
    \   |                help: consider borrowing here: `&first_lower`\n   |\n   =\
    \ note: expected reference `&Option<_>`\n                   found enum `Option<usize>`\n\
    \nerror[E0369]: cannot add `{integer}` to `&Option<_>`\n  --> /tmp/tmpfcped_q5.rs:56:42\n\
    \   |\n56 |             && (class_name.chars().nth(i + 1).is_uppercase() || class_name.chars().nth(i\
    \ + 1).is_lowercase()) {\n   |                                        - ^ - {integer}\n\
    \   |                                        |\n   |                         \
    \               &Option<_>\n\nerror[E0599]: no method named `is_uppercase` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpfcped_q5.rs:56:47\n  \
    \ |\n56 |             && (class_name.chars().nth(i + 1).is_uppercase() || class_name.chars().nth(i\
    \ + 1).is_lowercase()) {\n   |                                               ^^^^^^^^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0369]: cannot add `{integer}` to\
    \ `&Option<_>`\n  --> /tmp/tmpfcped_q5.rs:56:90\n   |\n56 |             && (class_name.chars().nth(i\
    \ + 1).is_uppercase() || class_name.chars().nth(i + 1).is_lowercase()) {\n   |\
    \                                                                            \
    \            - ^ - {integer}\n   |                                           \
    \                                             |\n   |                        \
    \                                                                &Option<_>\n\n\
    error[E0599]: no method named `is_lowercase` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpfc"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: Vec<(u8,\
    \ String)> = extensions.iter().cloned().map(|e| {\n        let c = e.chars().filter(|c|\
    \ *c == c).count();\n        (c.to_ascii_lowercase().as_digit(), e)\n    }).collect();\n\
    \    strength.sort();\n    let mut extensions_names: Vec<String> = extensions.iter().cloned().map(|e|\
    \ {\n        let c = e.chars().filter(|c| *c == c).count();\n        String::from_str(&format!(\"\
    {}{}\", c, e))\n    }).collect();\n    extensions_names.sort();\n    if extensions_names.len()\
    \ == 1 {\n        if strength[0].1 == -1 {\n            return String::from(&format!(\"\
    {}.{}\", class_name, extensions_names[0]));\n        } else {\n            return\
    \ String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[0], strength[0].0));\n\
    \        }\n    } else {\n        if strength[0].1 == -1 {\n            return\
    \ String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[0], strength[0].0));\n\
    \        } else {\n            if strength[0].1 < strength[0].0 {\n          \
    \      return String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[0],\
    \ strength[0].0));\n            } else if strength[0].1 < strength[1].0 {\n  \
    \              return String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[1],\
    \ strength[0].0));\n            } else {\n                return String::from(&format!(\"\
    {}.{}.{}.{}\", class_name, extensions_names[0], extensions_names[1], strength[0].0));\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwu10f4ov.rs:19:44\n   |\n\
    19 |         let c = e.chars().filter(|c| *c == c).count();\n   |            \
    \                                ^ expected `char`, found `&char`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |         let c = e.chars().filter(|c|\
    \ *c == *c).count();\n   |                                            +\n\nerror[E0599]:\
    \ no method named `to_ascii_lowercase` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpwu10f4ov.rs:20:12\n   |\n20 |         (c.to_ascii_lowercase().as_digit(),\
    \ e)\n   |            ^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwu10f4ov.rs:24:44\n   |\n24 |         let c\
    \ = e.chars().filter(|c| *c == c).count();\n   |                             \
    \               ^ expected `char`, found `&char`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |         let c = e.chars().filter(|c| *c == *c).count();\n\
    \   |                                            +\n\nerror[E0599]: no function\
    \ or associated item named `from_str` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpwu10f4ov.rs:25:17\n   |\n25 |         String::from_str(&format!(\"\
    {}{}\", c, e))\n   |                 ^^^^^^^^ function or associated item not\
    \ found in `String`\n   |\n   = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0277]:\
    \ can't compare `String` with `{integer}`\n  --> /tmp/tmpwu10f4ov.rs:29:26\n \
    \  |\n29 |         if strength[0].1 == -1 {\n   |                          ^^\
    \ no implementation for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_count =\
    \ extensions.len();\n    let mut extensions_name_map = Vec::new();\n    extensions_name_map.push(class_name);\n\
    \    for extension in extensions {\n        let mut extension_lowercase = extension.chars().collect::<String>().to_lowercase();\n\
    \        if extension_lowercase.chars().count() > extensions_count {\n       \
    \     extensions_count = extension_lowercase.chars().count();\n        }\n   \
    \     extensions_name_map.push(extension_lowercase);\n    }\n    let mut strongest_extension\
    \ = String::from(\"\");\n    let mut strength: i32 = -1;\n    extensions_name_map.sort_by_key(|x|\
    \ {\n        let mut s = x.chars().count() - x.chars().filter(|c| c.is_uppercase()).count();\n\
    \        if s > strength {\n            strength = s\n        }\n        x.chars().filter(|c|\
    \ c.is_lowercase()).count()\n    });\n    strongest_extension = extensions_name_map[0].to_string();\n\
    \    for extension_name in extensions_name_map {\n        if strongest_extension.chars().count()\
    \ < extension_name.chars().count() {\n            strongest_extension = extension_name\n\
    \        }\n    }\n    strongest_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw27h5tpi.rs:32:16\n   |\n\
    32 |         if s > strength {\n   |                ^^^^^^^^ expected `usize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n32 |         if s > strength.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw27h5tpi.rs:33:24\n   |\n29 |     let mut strength: i32\
    \ = -1;\n   |                       --- expected due to this type\n...\n33 | \
    \            strength = s\n   |                        ^ expected `i32`, found\
    \ `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let (classes, strength) =\
    \ classes.strength(extensions);\n    let max_strength = max_strength(strength);\n\
    \    match max_strength {\n        0 => format!(\"{}\", class_name),\n       \
    \ 1 => format!(\"{}.{}\", class_name, extensions[0]),\n        _ => format!(\"\
    {}.{}\", class_name, extensions[strength])\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `classes` in this scope\n  --> /tmp/tmp5y427rb8.rs:18:31\n\
    \   |\n18 |     let (classes, strength) = classes.strength(extensions);\n   |\
    \                               ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `max_strength` in this scope\n  --> /tmp/tmp5y427rb8.rs:19:24\n\
    \   |\n19 |     let max_strength = max_strength(strength);\n   |             \
    \           ^^^^^^^^^^^^ help: a local variable with a similar name exists: `strength`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n    extension_strength(class_name,\
    \ extensions).to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `extension_strength` in this scope\n\
    \  --> /tmp/tmpr_8yhgkx.rs:19:5\n   |\n19 |     extension_strength(class_name,\
    \ extensions).to_string()\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Get the number of uppercase\
    \ letters in the class name and the number of lowercase letters in the class name\n\
    \    let CAP = class_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \    let SM = class_name.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\n\
    \    // Calculate the strength of the extension\n    let strength = (CAP as f64\
    \ - SM as f64).recip();\n\n    // Return the extension that has the strongest\
    \ strength\n    extensions\n        .iter()\n        .enumerate()\n        .filter_map(|(i,\
    \ e)| if i == 0 { Some(e.len().saturating_sub(SM as f64).max(0) as i32, e) } else\
    \ { None })\n        .min()\n        .map(|(i, e)| class_name.split_at(i).join(e))\n\
    \        .unwrap_or_else(|_| \"\".to_owned())\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvaq_hb9m.rs:19:50\n   |\n\
    19 |     let CAP = class_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                  ^^^\n   |             \
    \                                     |\n   |                                \
    \                  expected `&char`, found `char`\n   |                      \
    \                            help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvaq_hb9m.rs:19:62\n   |\n19 |     let CAP =\
    \ class_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n   |         \
    \                                                     ^^^\n   |              \
    \                                                |\n   |                     \
    \                                         expected `&char`, found `char`\n   |\
    \                                                              help: consider\
    \ borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvaq_hb9m.rs:20:49\n\
    \   |\n20 |     let SM = class_name.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                 ^^^\n   |              \
    \                                   |\n   |                                  \
    \               expected `&char`, found `char`\n   |                         \
    \                        help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvaq_hb9m.rs:20:61\n   |\n20 |     let SM = class_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \                      ^^^\n   |                                             \
    \                |\n   |                                                     \
    \        expected `&char`, found `char`\n   |                                \
    \                             help: consider borrowing here: `&'z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvaq_hb9m.rs:29:70\n   |\n29 |         .filter_map(|(i,\
    \ e)| if i == 0 { Some(e.len().saturating_sub(SM as f64).max(0) as i32, e) } else\
    \ { None })\n   |          "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength_map = HashMap::new();\n\
    \    for (i, s) in extensions.iter().enumerate() {\n        let l = s.len();\n\
    \        let sc = (l.to_ascii_lowercase().len() as f64) / (l.to_ascii_lowercase().len()\
    \ as f64 - 1);\n        strength_map.insert(s, sc);\n    }\n    \n    let strength\
    \ = strength_map.iter().min(|a, b| a.1.cmp(&b.1).unwrap()).unwrap().1;\n    \n\
    \    let mut index = 0.0;\n    for i in strength_map.iter() {\n        if i.1\
    \ == strength {\n            index = i.0.len() as i32;\n        }\n    }\n   \
    \ \n    class_name[..index + 1] + &extensions[strength]\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpl72cy1zu.rs:18:28\n   |\n18 |     let mut strength_map = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `to_ascii_lowercase` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpl72cy1zu.rs:21:21\n   |\n21 |         let\
    \ sc = (l.to_ascii_lowercase().len() as f64) / (l.to_ascii_lowercase().len() as\
    \ f64 - 1);\n   |                     ^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `to_ascii_lowercase` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpl72cy1zu.rs:21:61\n   |\n21 |         let sc\
    \ = (l.to_ascii_lowercase().len() as f64) / (l.to_ascii_lowercase().len() as f64\
    \ - 1);\n   |                                                             ^^^^^^^^^^^^^^^^^^\
    \ method not found in `usize`\n\nerror[E0277]: cannot add an integer to a float\n\
    \  --> /tmp/tmpl72cy1zu.rs:34:24\n   |\n34 |     class_name[..index + 1] + &extensions[strength]\n\
    \   |                        ^ no implementation for `{float} + {integer}`\n \
    \  |\n   = help: the trait `Add<{integer}>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0369]:\
    \ cannot add `&_` to `str`\n  --> /tmp/tmpl72cy1zu.rs:34:29\n   |\n34 |     class_name[..index\
    \ + 1] + &extensions[strength]\n   |     ----------------------- ^ ---------------------\
    \ &_\n   |     |\n   |     str\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0369, E0433, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    let mut best_extension = String::from(\"\
    \");\n\n    for extension in extensions {\n        let mut char_counter = 0;\n\
    \        for char in class_name {\n            if char == extension {\n      \
    \          char_counter += 1;\n            }\n        }\n        if char_counter\
    \ == 0 {\n            strength = 0;\n            break;\n        }\n        if\
    \ char_counter > strength {\n            strength = char_counter;\n          \
    \  best_extension = extension;\n        }\n    }\n\n    format!(\"{}.{}\", class_name,\
    \ best_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpehbysybw.rs:24:21\n\
    \   |\n24 |         for char in class_name {\n   |                     ^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension:\
    \ usize = 0;\n\n    // iterate over all extension names and find the strongest\
    \ one\n    for (i, extension) in extensions.iter().enumerate() {\n        if extension.chars().filter(|c|\
    \ c.is_uppercase()).count() >= 1 {\n            // count the number of uppercase\
    \ letters in the extension's name\n            let cap = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            // count the number of lowercase letters\
    \ in the extension's name\n            let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \            // calculate the strength\n            let strength = (cap - sm)\
    \ as usize;\n            if strength > strongest_extension {\n               \
    \ strongest_extension = strength;\n            }\n        }\n    }\n\n    // return\
    \ the class name with the strongest extension\n    class_name.to_string() + \"\
    .\" +\n    extensions[strongest_extension].to_string()\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjsthfge4.rs:37:5\n   |\n\
    37 |     extensions[strongest_extension].to_string()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     expected `&str`, found struct `String`\n   |     help: consider\
    \ borrowing here: `&extensions[strongest_extension].to_string()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut classes: Vec<String>\
    \ = extensions.clone();\n    let mut num_upper = 0;\n    let mut num_lower = 0;\n\
    \    for (i, item) in classes.iter().enumerate() {\n        let c = item.to_lowercase();\n\
    \        if c.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() > num_upper {\n\
    \            num_upper = c.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \        }\n        if c.chars().filter(|c| *c >= 'a' && *c <= 'z').count() >\
    \ num_lower {\n            num_lower = c.chars().filter(|c| *c >= 'a' && *c <=\
    \ 'z').count();\n        }\n    }\n    if num_upper - num_lower == 0 {\n     \
    \   classes.remove(&class_name[class_name.len()..]);\n    }\n    format!(\"{}.{}\"\
    , class_name, classes.iter().filter(|&x| *x == class_name).min().unwrap_or(&class_name[class_name.len()..]))\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7f1j424_.rs:31:24\n   |\n\
    31 |         classes.remove(&class_name[class_name.len()..]);\n   |          \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7f1j424_.rs:33:95\n   |\n33 |\
    \     format!(\"{}.{}\", class_name, classes.iter().filter(|&x| *x == class_name).min().unwrap_or(&class_name[class_name.len()..]))\n\
    \   |                                                                        \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `str`\n   |\n   = note: expected reference `&String`\n              found\
    \ reference `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_extension: Option<String>\
    \ = None;\n    let mut strength: i32 = 0;\n    for extension in extensions {\n\
    \        let mut extension_strength: i32 = 0;\n        for c in extension.to_lowercase().chars()\
    \ {\n            if let Ok(c) = (c as u32).wrapping_sub(&(c as u32).wrapping_mul(10))\
    \ {\n                extension_strength += c;\n            }\n        }\n    \
    \    if extension_strength > strength {\n            best_extension = Some(extension.to_string());\n\
    \            strength = extension_strength;\n        }\n    }\n    match best_extension\
    \ {\n        Some(best_extension) => class_name.to_string() + \".\" + best_extension.clone(),\n\
    \        None => class_name.to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v0j6q1f.rs:23:52\n   |\n\
    23 |             if let Ok(c) = (c as u32).wrapping_sub(&(c as u32).wrapping_mul(10))\
    \ {\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found `&u32`\n   |\nhelp: consider removing the borrow\n   |\n\
    23 -             if let Ok(c) = (c as u32).wrapping_sub(&(c as u32).wrapping_mul(10))\
    \ {\n23 +             if let Ok(c) = (c as u32).wrapping_sub((c as u32).wrapping_mul(10))\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3v0j6q1f.rs:23:20\n\
    \   |\n23 |             if let Ok(c) = (c as u32).wrapping_sub(&(c as u32).wrapping_mul(10))\
    \ {\n   |                    ^^^^^   -----------------------------------------------------\
    \ this expression has type `u32`\n   |                    |\n   |            \
    \        expected `u32`, found enum `Result`\n   |\n   = note: expected type `u32`\n\
    \              found enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp3v0j6q1f.rs:33:64\n   |\n33 |         Some(best_extension) => class_name.to_string()\
    \ + \".\" + best_extension.clone(),\n   |                                    \
    \                            ^^^^^^^^^^^^^^^^^^^^^^\n   |                    \
    \                                            |\n   |                         \
    \                                       expected `&str`, found struct `String`\n\
    \   |                                                                help: consider\
    \ borrowing here: `&best_extension`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_extension: Option<String>\
    \ = None;\n    let mut strength = -1;\n    for ext in extensions {\n        let\
    \ cap = ext.to_ascii_lowercase().len_utf8();\n        let sm = ext.to_ascii_lowercase().len_utf8()\
    \ - cap;\n        let strength = if strength == -1 || cap > sm {\n           \
    \ cap - sm\n        } else {\n            strength\n        };\n        if strength\
    \ > best_extension.as_ref().unwrap().len_utf8() {\n            best_extension\
    \ = Some(ext);\n        }\n    }\n    match best_extension {\n        Some(ext)\
    \ => format!(\"{}.{}\", class_name, ext),\n        None => format!(\"{}\", class_name),\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len_utf8` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplbu1tome.rs:21:44\n   |\n21 |         let cap =\
    \ ext.to_ascii_lowercase().len_utf8();\n   |                                 \
    \           ^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `len_utf8` found for struct `String` in the current scope\n  --> /tmp/tmplbu1tome.rs:22:43\n\
    \   |\n22 |         let sm = ext.to_ascii_lowercase().len_utf8() - cap;\n   |\
    \                                           ^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `len_utf8` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmplbu1tome.rs:28:56\n   |\n28 |         if strength\
    \ > best_extension.as_ref().unwrap().len_utf8() {\n   |                      \
    \                                  ^^^^^^^^ method not found in `&String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_set: HashSet<String>\
    \ = extensions.iter().cloned().collect();\n    let mut strength: i64 = -1;\n\n\
    \    for x in extensions_set {\n        let cap = x.chars().filter(|c| *c >= 'A'\
    \ && *c <= 'Z').count() as i64;\n        let sm = x.chars().filter(|c| *c >= 'a'\
    \ && *c <= 'z').count() as i64;\n        if cap > sm {\n            strength =\
    \ cap - sm;\n            break;\n        }\n    }\n    let mut extensions_string\
    \ = class_name;\n    if strength == -1 {\n        extensions_string = extensions_string\n\
    \            + \".\"\n            + extensions[0]\n            + \".\"\n     \
    \       + extensions[extensions_set.len()-1]\n    }\n    else {\n        extensions_string\
    \ = extensions_string\n            + \".\"\n            + extensions[0]\n    \
    \        + \".\"\n            + extensions[extensions.len() - strength - 1]\n\
    \    }\n    extensions_string\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp91vayjp1.rs:18:29\n\
    \   |\n18 |     let mut extensions_set: HashSet<String> = extensions.iter().cloned().collect();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91vayjp1.rs:33:15\n   |\n\
    33 |             + extensions[0]\n   |               ^^^^^^^^^^^^^\n   |     \
    \          |\n   |               expected `&str`, found struct `String`\n   |\
    \               help: consider borrowing here: `&extensions[0]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp91vayjp1.rs:40:15\n   |\n40 |             +\
    \ extensions[0]\n   |               ^^^^^^^^^^^^^\n   |               |\n   |\
    \               expected `&str`, found struct `String`\n   |               help:\
    \ consider borrowing here: `&extensions[0]`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91vayjp1.rs:42:45\n   |\n42 |             + extensions[extensions.len()\
    \ - strength - 1]\n   |                                             ^^^^^^^^ expected\
    \ `usize`, found `i64`\n\nerror[E0277]: cannot subtract `i64` from `usize`\n \
    \ --> /tmp/tmp91vayjp1.rs:42:43\n   |\n42 |             + extensions[extensions.len()\
    \ - strength - 1]\n   |                                           ^ no implementation\
    \ for `usize - i64`\n   |\n   = help: the trait `Sub<i64>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91vayjp1.rs:42:15\n\
    \   |\n42 |             + extensions[extensions.len() - strength - 1]\n   |  \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |              \
    \ |\n   |               expected `&str`, fou"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n    let\
    \ mut counter: usize = 0;\n    for e in extensions {\n        if let Some(pos)\
    \ = e.find(|c| *c == c.to_ascii_uppercase().unwrap()) {\n            let n = pos\
    \ - counter;\n            if n > 0 {\n                counter += n\n         \
    \   } else {\n                counter += 1;\n            }\n        }\n    }\n\
    \    (class_name+\".\"+extensions[counter].to_ascii_lowercase().unwrap()).to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpncve8oey.rs:21:36\n\
    \   |\n21 |         if let Some(pos) = e.find(|c| *c == c.to_ascii_uppercase().unwrap())\
    \ {\n   |                                    ^ consider giving this closure parameter\
    \ a type\n   |\n   = note: type must be known at this point\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpncve8oey.rs:30:62\n   |\n30 |     (class_name+\".\"+extensions[counter].to_ascii_lowercase().unwrap()).to_string()\n\
    \   |                                                              ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0282, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min_strength: u32\
    \ = -1;\n\n    for e in extensions {\n        let cap = e.chars().filter(|c| c\
    \ >= 'A' && c <= 'Z').count();\n        let sm = e.chars().filter(|c| c >= 'a'\
    \ && c <= 'z').count();\n        min_strength = if cap - sm < 0 {\n          \
    \  min_strength\n        } else {\n            if cap - sm > min_strength {\n\
    \                min_strength\n            } else {\n                cap - sm\n\
    \            }\n        };\n    }\n\n    let mut max_extension = String::from(\"\
    \");\n    for e in extensions {\n        let cap = e.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count();\n        let sm = e.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count();\n        if cap >= min_strength {\n            if cap - sm > max_extension.len()\
    \ {\n                max_extension = e;\n            }\n        }\n    }\n\n \
    \   class_name.to_string() + \".\" + max_extension\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `u32`\n  --> /tmp/tmp_6dk4pp6.rs:18:33\n\
    \   |\n18 |     let mut min_strength: u32 = -1;\n   |                        \
    \         ^^\n   |                                 |\n   |                   \
    \              cannot apply unary operator `-`\n   |                         \
    \        help: you may have meant the maximum value of `u32`: `u32::MAX`\n   |\n\
    \   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_6dk4pp6.rs:21:45\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \      ^^^\n   |                                             |\n   |         \
    \                                    expected `&char`, found `char`\n   |    \
    \                                         help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_6dk4pp6.rs:21:57\n   |\n21 |\
    \         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n   |\
    \                                                         ^^^\n   |          \
    \                                               |\n   |                      \
    \                                   expected `&char`, found `char`\n   |     \
    \                                                    help: consider borrowing\
    \ here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_6dk4pp6.rs:22:44\n\
    \   |\n22 |         let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                            ^^^\n   |                   \
    \                         |\n   |                                            expected\
    \ `&char`, found `char`\n   |                                            help:\
    \ consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_6dk4pp6.rs:22:56\n\
    \   |\n22 |         let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                        ^^^\n   |       \
    \                                                 |\n   |                    \
    \                              "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut best_extension = -1;\n\
    \    for e in extensions {\n        if e == class_name {\n            continue;\n\
    \        }\n        let strength = e.chars().filter(|c| !c.is_upper()).count()\
    \ - e.chars().filter(|c| c.is_upper()).count();\n        if strength >= 0 {\n\
    \            if strength > best_extension {\n                best_extension =\
    \ strength;\n            }\n        }\n    }\n    class_name.to_string() + extensions[best_extension].to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpnufnphih.rs:23:48\n   |\n23 |         let strength\
    \ = e.chars().filter(|c| !c.is_upper()).count() - e.chars().filter(|c| c.is_upper()).count();\n\
    \   |                                                ^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_uppercase`\n\nerror[E0599]: no\
    \ method named `is_upper` found for reference `&char` in the current scope\n \
    \ --> /tmp/tmpnufnphih.rs:23:93\n   |\n23 |         let strength = e.chars().filter(|c|\
    \ !c.is_upper()).count() - e.chars().filter(|c| c.is_upper()).count();\n   | \
    \                                                                            \
    \                ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_uppercase`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpnufnphih.rs:18:30\n   |\n18 |     let mut best_extension = -1;\n\
    \   |                              ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnufnphih.rs:30:30\n\
    \   |\n30 |     class_name.to_string() + extensions[best_extension].to_string()\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  \
    \ |                              |\n   |                              expected\
    \ `&str`, found struct `String`\n   |                              help: consider\
    \ borrowing here: `&extensions[best_extension].to_string()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = -1i64;\n\
    \    let mut extension = String::from(\"\");\n    for extension_name in extensions\
    \ {\n        if extension_name.chars().count() > 0 {\n            let letters\
    \ = extension_name.chars().count();\n            let capitals = letters.cap_iter().count();\n\
    \            let smalls = letters.count() - capitals;\n            let extension_strength\
    \ = capitals - smalls;\n            if extension_strength > strength {\n     \
    \           strength = extension_strength;\n                extension = extension_name;\n\
    \            }\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `cap_iter` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp6prfeljm.rs:23:36\n   |\n23 |             let capitals\
    \ = letters.cap_iter().count();\n   |                                    ^^^^^^^^\
    \ method not found in `usize`\n\nerror[E0599]: `usize` is not an iterator\n  -->\
    \ /tmp/tmp6prfeljm.rs:24:34\n   |\n24 |             let smalls = letters.count()\
    \ - capitals;\n   |                                  ^^^^^ `usize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `usize:\
    \ Iterator`\n           which is required by `&mut usize: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 1;\n\
    \    let mut extension = String::from(\"NO_EXTENSION\");\n    let mut idx = 0;\n\
    \n    while idx < extension.len() {\n        let c = extension[idx].chars().next().unwrap();\n\
    \        let len = extension[idx].len();\n\n        if c.is_uppercase() {\n  \
    \          strength *= CAPITALS.len();\n            if CAPITALS.contains(&c.to_string().to_uppercase())\
    \ {\n                strength /= CAPITALS.len();\n            }\n        }\n \
    \       if c.is_lowercase() {\n            strength *= SMALLS.len();\n       \
    \     if SMALLS.contains(&c.to_string().to_lowercase()) {\n                strength\
    \ /= SMALLS.len();\n            }\n        }\n\n        idx += len;\n    }\n\n\
    \    let mut name = class_name;\n    name.push_str(\".\");\n    name.push_str(extension);\n\
    \n    name.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `CAPITALS` in this scope\n  --> /tmp/tmp4rvydbi5.rs:27:25\n\
    \   |\n27 |             strength *= CAPITALS.len();\n   |                    \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `CAPITALS`\
    \ in this scope\n  --> /tmp/tmp4rvydbi5.rs:28:16\n   |\n28 |             if CAPITALS.contains(&c.to_string().to_uppercase())\
    \ {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAPITALS` in this scope\n  --> /tmp/tmp4rvydbi5.rs:29:29\n   |\n\
    29 |                 strength /= CAPITALS.len();\n   |                       \
    \      ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `SMALLS`\
    \ in this scope\n  --> /tmp/tmp4rvydbi5.rs:33:25\n   |\n33 |             strength\
    \ *= SMALLS.len();\n   |                         ^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `SMALLS` in this scope\n  --> /tmp/tmp4rvydbi5.rs:34:16\n\
    \   |\n34 |             if SMALLS.contains(&c.to_string().to_lowercase()) {\n\
    \   |                ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `SMALLS` in this scope\n  --> /tmp/tmp4rvydbi5.rs:35:29\n   |\n35 |  \
    \               strength /= SMALLS.len();\n   |                             ^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp4rvydbi5.rs:23:17\n   |\n23 |         let c = extension[idx].chars().next().unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4rvydbi5.rs:24:19\n   "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min_extension = String::new();\n\
    \    for e in extensions {\n        if e.chars().filter(|x| x >= 'A' && x <= 'Z').count()\
    \ < e.chars().filter(|x| x >= 'a' && x <= 'z').count() {\n            min_extension.push_str(&e.to_string());\n\
    \        }\n    }\n    min_extension.push_str(&class_name.to_string());\n    min_extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmgpf6v6e.rs:20:38\n   |\n\
    20 |         if e.chars().filter(|x| x >= 'A' && x <= 'Z').count() < e.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count() {\n   |                                      ^^^\n\
    \   |                                      |\n   |                           \
    \           expected `&char`, found `char`\n   |                             \
    \         help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmgpf6v6e.rs:20:50\n   |\n20 |         if e.chars().filter(|x| x\
    \ >= 'A' && x <= 'Z').count() < e.chars().filter(|x| x >= 'a' && x <= 'z').count()\
    \ {\n   |                                                  ^^^\n   |         \
    \                                         |\n   |                            \
    \                      expected `&char`, found `char`\n   |                  \
    \                                help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmgpf6v6e.rs:20:91\n   |\n20 |         if e.chars().filter(|x|\
    \ x >= 'A' && x <= 'Z').count() < e.chars().filter(|x| x >= 'a' && x <= 'z').count()\
    \ {\n   |                                                                    \
    \                       ^^^\n   |                                            \
    \                                               |\n   |                      \
    \                                                                     expected\
    \ `&char`, found `char`\n   |                                                \
    \                                           help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmgpf6v6e.rs:20:103\n   |\n20 |\
    \         if e.chars().filter(|x| x >= 'A' && x <= 'Z').count() < e.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count() {\n   |                                      \
    \                                                                 ^^^\n   |  \
    \                                                                            \
    \                         |\n   |                                            \
    \                           "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut class_name = String::from(class_name);\n\
    \    let mut strength: i32 = -1;\n\n    for extension in extensions {\n      \
    \  let mut extension = String::from(extension);\n        \n        // find the\
    \ number of uppercase letters in extension\n        let mut num_caps = 0;\n  \
    \      for c in extension.chars() {\n            if c.is_uppercase() {\n     \
    \           num_caps += 1;\n            }\n        }\n\n        // find the number\
    \ of lowercase letters in extension\n        let mut num_lows = 0;\n        for\
    \ c in extension.chars() {\n            if c.is_lowercase() {\n              \
    \  num_lows += 1;\n            }\n        }\n\n        // get the number of uppercase\
    \ letters and lowercase letters in extension\n        let mut num_caps_lows =\
    \ num_caps + num_lows;\n\n        // get the percentage of uppercase letters and\
    \ lowercase letters in extension\n        let mut percent = 0.0;\n        if num_caps_lows\
    \ > 0 {\n            percent = (num_caps_lows.to_f() / extension.chars().len())\
    \ * 100.0;\n        }\n\n        // use the percentage to determine strength\n\
    \        match strength {\n            -1 => strength = percent,\n           \
    \ x if x > percent => strength = x,\n            _ => {}\n        }\n    }\n\n\
    \    let strength = match strength {\n        x if x > 0.0 => x.to_string(),\n\
    \        _ => \"UNKNOWN\".to_string(),\n    };\n    class_name.push_str(&format!(\"\
    {}.{}\", class_name, strength))\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmp1g6sfkxj.rs:46:38\n   |\n46 |             percent\
    \ = (num_caps_lows.to_f() / extension.chars().len()) * 100.0;\n   |          \
    \                            ^^^^ method not found in `{integer}`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp1g6sfkxj.rs:46:65\n\
    \   |\n46 |             percent = (num_caps_lows.to_f() / extension.chars().len())\
    \ * 100.0;\n   |                                                             \
    \    ^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1g6sfkxj.rs:51:30\n   |\n19 |     let mut strength: i32 = -1;\n\
    \   |                       --- expected due to this type\n...\n51 |         \
    \    -1 => strength = percent,\n   |                              ^^^^^^^ expected\
    \ `i32`, found floating-point number\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1g6sfkxj.rs:52:22\n   |\n52 |             x if x > percent => strength\
    \ = x,\n   |                      ^^^^^^^ expected `i32`, found floating-point\
    \ number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1g6sfkxj.rs:58:18\n\
    \   |\n58 |         x if x > 0.0 => x.to_string(),\n   |                  ^^^\
    \ expected `i32`, found floating-point number\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1g6sfkxj.rs:61:5\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                               ------ expected `String` because\
    \ of return type\n...\n61 |     class_name.push_str(&format!(\"{}.{}\", class_name,\
    \ strength))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmp1g6sfkxj.rs:61:16\n   |\n61 |     class_name.push_str(&format!(\"\
    {}.{}\", class_name, strength))\n   |     ---------- ^^^^^^^^ this call modifies\
    \ `class_name` in-place\n   |     |\n   |     you probably want to use this value\
    \ after calling the method"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: u32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    \n    for name in extensions\
    \ {\n        let cap = name.chars().filter(|c| c.is_uppercase()).count();\n  \
    \      let sml = name.chars().filter(|c| c.is_lowercase()).count();\n        \n\
    \        if cap - sml > strength {\n            strength = cap - sml;\n      \
    \      extension = name;\n        }\n    }\n    \n    class_name.to_string() +\
    \ \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `u32`\n  --> /tmp/tmppwk5so1o.rs:18:29\n\
    \   |\n18 |     let mut strength: u32 = -1;\n   |                            \
    \ ^^\n   |                             |\n   |                             cannot\
    \ apply unary operator `-`\n   |                             help: you may have\
    \ meant the maximum value of `u32`: `u32::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppwk5so1o.rs:25:24\n\
    \   |\n25 |         if cap - sml > strength {\n   |                        ^^^^^^^^\
    \ expected `usize`, found `u32`\n   |\nhelp: you can convert a `u32` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |         if cap - sml\
    \ > strength.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppwk5so1o.rs:26:24\n   |\n18 |\
    \     let mut strength: u32 = -1;\n   |                       --- expected due\
    \ to this type\n...\n26 |             strength = cap - sml;\n   |            \
    \            ^^^^^^^^^ expected `u32`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppwk5so1o.rs:31:36\n   |\n31 |     class_name.to_string()\
    \ + \".\" + extension.to_string()\n   |                                    ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&str`, found struct `String`\n   |                         \
    \           help: consider borrowing here: `&extension.to_string()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0600.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_score = -1;\n\
    \    let mut max_extension: Option<String> = None;\n    for extension in extensions\
    \ {\n        let mut score = (class_name.length() as f64 / extension.length()\
    \ as f64) - 1f64;\n        if score > max_score {\n            max_score = score;\n\
    \            max_extension = Some(extension);\n        }\n    }\n    max_extension.unwrap_or(class_name)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpxrmi1g2_.rs:21:37\n   |\n21 |         let mut score\
    \ = (class_name.length() as f64 / extension.length() as f64) - 1f64;\n   |   \
    \                                  ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `length` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpxrmi1g2_.rs:21:65\n   |\n\
    21 |         let mut score = (class_name.length() as f64 / extension.length()\
    \ as f64) - 1f64;\n   |                                                      \
    \           ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \n    for extension in extensions {\n        let CAP = extension.len();\n    \
    \    let SM = class_name.len();\n\n        if CAP - SM > strength {\n        \
    \    strength = CAP - SM;\n        }\n    }\n\n    format!(\"{}.{}\", class_name,\
    \ extensions.iter().filter_map(|e| e.to_lowercase()).max(&|a, b| a.cmp(b)).unwrap())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjevkr4w.rs:24:23\n   |\n\
    24 |         if CAP - SM > strength {\n   |                       ^^^^^^^^ expected\
    \ `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and\
    \ panic if the converted value doesn't fit\n   |\n24 |         if CAP - SM > strength.try_into().unwrap()\
    \ {\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqjevkr4w.rs:25:24\n   |\n18 |     let mut strength:\
    \ i32 = -1;\n   |                       --- expected due to this type\n...\n25\
    \ |             strength = CAP - SM;\n   |                        ^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqjevkr4w.rs:29:67\n\
    \   |\n29 |     format!(\"{}.{}\", class_name, extensions.iter().filter_map(|e|\
    \ e.to_lowercase()).max(&|a, b| a.cmp(b)).unwrap())\n   |                    \
    \                                               ^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found struct `String`\n   |\n   = note: expected enum `Option<_>`\n\
    \            found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |     format!(\"{}.{}\", class_name, extensions.iter().filter_map(|e|\
    \ Some(e.to_lowercase())).max(&|a, b| a.cmp(b)).unwrap())\n   |              \
    \                                                     +++++                +\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpqjevkr4w.rs:29:85\n     |\n29   |     format!(\"{}.{}\", class_name,\
    \ extensions.iter().filter_map(|e| e.to_lowercase()).max(&|a, b| a.cmp(b)).unwrap())\n\
    \     |                                                                      \
    \               ^^^ ---------------- supplied 1 argument\n     |             \
    \                                                                        |\n \
    \    |                                                                       \
    \              expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308.\nFo"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return class_name;\n    }\n    let mut max_extension_strength = -1;\n\
    \    let mut min_extension_strength = -1;\n    for i in 0..extensions.len() {\n\
    \        let extension = &extensions[i];\n        let class_name = String::from(class_name);\n\
    \        let extension_strength = extension.chars().filter(|c| *c >= 'A' && *c\
    \ <= 'Z').count() - extension.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n\
    \        if extension_strength > max_extension_strength {\n            max_extension_strength\
    \ = extension_strength;\n        }\n        if extension_strength < min_extension_strength\
    \ {\n            min_extension_strength = extension_strength;\n        }\n   \
    \ }\n    let strength = max_extension_strength - min_extension_strength;\n   \
    \ if strength != 0 {\n        return class_name.to_string() + extensions.iter().position(|e|\
    \ *e == class_name).unwrap().to_string() + String::from(\".\") + String::from(Strongest_Extension(class_name.to_string()\
    \ + extensions.iter().position(|e| *e == class_name).unwrap().to_string() + String::from(\"\
    .\" + extensions[extensions.iter().position(|e| *e == class_name).unwrap()]),\
    \ extensions)).to_string();\n    } else {\n        return class_name;\n    }\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp8__ncfaq.rs:21:38\n\
    \   |\n21 |     let mut max_extension_strength = -1;\n   |                   \
    \                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp8__ncfaq.rs:22:38\n\
    \   |\n22 |     let mut min_extension_strength = -1;\n   |                   \
    \                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8__ncfaq.rs:36:41\n   |\n36 |\
    \ ...class_name.to_string() + extensions.iter().position(|e| *e == class_name).unwrap().to_string()\
    \ + String::from(\".\") + String::from(Stro...\n   |                         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \
    \  |                             |\n   |                             expected\
    \ `&str`, found struct `String`\n   |                             help: consider\
    \ borrowing here: `&extensions.iter().position(|e| *e == class_name).unwrap().to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8__ncfaq.rs:36:113\n   |\n36 |\
    \ ...ss_name).unwrap().to_string() + String::from(\".\") + String::from(Strongest_Extension(class_name.to_string()\
    \ + extensions.iter().positi...\n   |                                    ^^^^^^^^^^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&str`, found struct `String`\n   |                         \
    \           help: consider borrowing here: `&String::from(\".\")`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8__ncfaq.rs:"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_iter =\
    \ extensions.iter();\n    let mut extensions_len = extensions.len();\n    let\
    \ mut strongest_extension = String::new();\n    let mut current_extension = String::new();\n\
    \    let mut current_strength = 0;\n    let mut current_class_name = class_name;\n\
    \    loop {\n        if extensions_iter.any(|e| {\n            e.chars().any(|c|\
    \ *c >= 'A' && *c <= 'Z') ||\n            e.chars().any(|c| *c >= 'a' && *c <=\
    \ 'z') ||\n            e.chars().any(|c| *c >= '0' && *c <= '9')\n        }) {\n\
    \            if current_strength > 0 {\n                return format!(\"{}.{}\"\
    , current_class_name, strongest_extension);\n            } else {\n          \
    \      return format!(\"{}.{}\", current_class_name, current_extension);\n   \
    \         }\n        }\n        if extensions_len > 0 {\n            if current_strength\
    \ > 0 {\n                current_extension = extensions_iter.next().unwrap();\n\
    \                current_strength = extensions_iter.any(|e| e.chars().any(|c|\
    \ *c >= 'A' && *c <= 'Z')).unwrap_or(false)\n                    ? extensions_len\n\
    \                    : -1;\n            } else {\n                current_extension\
    \ = extensions_iter.next().unwrap();\n                current_strength = extensions_iter.any(|e|\
    \ e.chars().any(|c| *c >= 'a' && *c <= 'z')).unwrap_or(false)\n              \
    \      ? extensions_len\n                    : -1;\n            }\n        }\n\
    \        extensions_len -= 1;\n        if extensions_len == 0 {\n            current_strength\
    \ = extensions_iter.any(|e| e.chars().any(|c| *c >= 'A' && *c <= 'Z')).unwrap_or(false)\n\
    \                ? extensions_len\n                : -1;\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `extensions_len`\n\
    \  --> /tmp/tmp6fqpbqrv.rs:40:23\n   |\n40 |                     ? extensions_len\n\
    \   |                       ^^^^^^^^^^^^^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `extensions_len`\n  --> /tmp/tmp6fqpbqrv.rs:45:23\n   |\n45 |        \
    \             ? extensions_len\n   |                       ^^^^^^^^^^^^^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`,\
    \ `?`, `}`, or an operator, found `extensions_len`\n  --> /tmp/tmp6fqpbqrv.rs:52:19\n\
    \   |\n52 |                 ? extensions_len\n   |                   ^^^^^^^^^^^^^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp6fqpbqrv.rs:26:31\n   |\n26 |        \
    \     e.chars().any(|c| *c >= 'A' && *c <= 'Z') ||\n   |                     \
    \          ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6fqpbqrv.rs:26:44\n\
    \   |\n26 |             e.chars().any(|c| *c >= 'A' && *c <= 'Z') ||\n   |   \
    \                                         ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp6fqpbqrv.rs:27:31\n   |\n27 |             e.chars().any(|c|\
    \ *c >= 'a' && *c <= 'z') ||\n   |                               ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp6fqpbqrv.rs:27:44\n   |\n\
    27 |             e.chars().any(|c| *c >= 'a' && *c <= 'z') ||\n   |          \
    \                                  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp6fqpbqrv.rs:28:31\n   |\n28 |             e.chars().any(|c| *c\
    \ >= '0' && *c <= '9')\n   |                               ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp6fqpbqrv.rs:28:44\n   |\n\
    28 |             e.chars().any(|c| *c >= '0' && *c <= '9')\n   |             \
    \                               ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6fqpbqrv.rs:38:37\n\
    \   |\n21 |     let mut current_extension = String::new();\n   |            "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Write your code in Rust\
    \ here.\n    let mut extensions_map = Vec::new();\n    extensions.iter().for_each(|e|\
    \ {\n        extensions_map.push(e.to_lowercase());\n    });\n    let mut strength\
    \ = -1;\n    for (i, e) in extensions_map.iter().enumerate() {\n        let cap\
    \ = e.chars().filter(|c| *c >= 'A').count();\n        let sm = e.chars().filter(|c|\
    \ *c <= 'Z').count();\n        strength = if cap > sm {\n            cap - sm\n\
    \        } else {\n            sm - cap\n        };\n        if strength > i {\n\
    \            return format!(\"{}.{}\", class_name, e);\n        }\n    }\n   \
    \ format!(\"{}.{}\", class_name, extensions[extensions_map.len()..extensions_map.len()\
    \ - 1].join());\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpn9in6avi.rs:23:24\n\
    \   |\n23 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpn9in6avi.rs:36:93\n\
    \    |\n36  |     format!(\"{}.{}\", class_name, extensions[extensions_map.len()..extensions_map.len()\
    \ - 1].join());\n    |                                                       \
    \                                      ^^^^- supplied 0 arguments\n    |     \
    \                                                                            \
    \            |\n    |                                                        \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9in6avi.rs:17:72\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n...\n\
    36 |     format!(\"{}.{}\", class_name, extensions[extensions_map.len()..extensions_map.len()\
    \ - 1].join());\n   |                                                        \
    \                                            - help: remove this semicolon\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_set: HashSet<&str>\
    \ = extensions.iter().map(|x| x.clone()).collect();\n    extensions_set.sort_unstable();\n\
    \    let mut best_extension: Vec<String> = Vec::new();\n    let mut best_extension_index:\
    \ usize = 0;\n    let mut best_strongest_extension: &str = \"\";\n    for (index,\
    \ extension) in extensions_set.iter().enumerate() {\n        let strongest_extension\
    \ = extension.clone();\n        let fraction = extension.chars().filter(|&x| x\
    \ >= 'A' && x <= 'Z').count() - extension.chars().filter(|&x| x >= 'a' && x <=\
    \ 'z').count();\n        let strength = if fraction < 0 {\n            -1.0\n\
    \        } else {\n            fraction\n        };\n        if strength > 0 {\n\
    \            if best_extension_index == index {\n                if strength >\
    \ best_strongest_extension.as_num() {\n                    best_strongest_extension\
    \ = strongest_extension;\n                    best_extension_index = index;\n\
    \                }\n            } else {\n                if strength < best_strongest_extension.as_num()\
    \ {\n                    best_strongest_extension = strongest_extension;\n   \
    \                 best_extension_index = index;\n                }\n         \
    \   }\n        }\n    }\n    class_name.get() + \"_\" + best_strongest_extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpgdh0t33f.rs:18:29\n\
    \   |\n18 |     let mut extensions_set: HashSet<&str> = extensions.iter().map(|x|\
    \ x.clone()).collect();\n   |                             ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: can't compare `{float}` with `{integer}`\n  --> /tmp/tmpgdh0t33f.rs:26:36\n\
    \   |\n26 |         let strength = if fraction < 0 {\n   |                   \
    \                 ^ no implementation for `{float} < {integer}` and `{float} >\
    \ {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `{float}` with `{integer}`\n\
    \  --> /tmp/tmpgdh0t33f.rs:31:21\n   |\n31 |         if strength > 0 {\n   | \
    \                    ^ no implementation for `{float} < {integer}` and `{float}\
    \ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgdh0t33f.rs:31:23\n\
    \   |\n31 |         if strength > 0 {\n   |                       ^ expected floating-point\
    \ number, found integer\n\nerror[E0599]: no method named `as_num` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpgdh0t33f.rs:33:56\n   |\n33 |   \
    \              if strength > best_strongest_extension.as_num() {\n   |       \
    \                                                 ^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `as_num` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpgdh0t33f.rs:38:56\n   |\n38 |      "
  stdout: ''
  timestamp: 1659976533
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions.iter().fold(class_name,\
    \ |class_name, extension| {\n        let (extension_str, _extension_str) =\n \
    \           extension.split_at(class_name.len());\n        let extension_strength:\
    \ i32 = extension_str\n            .chars()\n            .filter(|c| c.is_uppercase())\n\
    \            .count() as i32 - extension_str\n            .chars()\n         \
    \   .filter(|c| c.is_lowercase())\n            .count() as i32;\n        String::from(format!(\"\
    {}.{}\", class_name, extension))\n    })\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 7 is out of bounds of `tEN`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    for (extension, weight) in extensions.iter().zip(extensions.iter().rev())\
    \ {\n        let mut len = extension.len();\n        if let Ok(mut letter_count)\
    \ = get_letter_count(&extension[..len]) {\n            len = letter_count;\n \
    \       }\n        let strength = strength.min(len.saturating_sub(&weight));\n\
    \    }\n    String::from(format!(\"{}.{}\", class_name, extensions[strength -\
    \ 1]));\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_letter_count` in this scope\n \
    \ --> /tmp/tmprpfc0_ek.rs:21:39\n   |\n21 |         if let Ok(mut letter_count)\
    \ = get_letter_count(&extension[..len]) {\n   |                              \
    \         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprpfc0_ek.rs:24:56\n   |\n24 |         let strength = strength.min(len.saturating_sub(&weight));\n\
    \   |                                                        ^^^^^^^ expected\
    \ `usize`, found `&&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprpfc0_ek.rs:24:37\n\
    \   |\n24 |         let strength = strength.min(len.saturating_sub(&weight));\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `i64`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i64` and\
    \ panic if the converted value doesn't fit\n   |\n24 |         let strength =\
    \ strength.min(len.saturating_sub(&weight).try_into().unwrap());\n   |       \
    \                                                         ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `i64`\n  --> /tmp/tmprpfc0_ek.rs:26:47\n\
    \   |\n26 |     String::from(format!(\"{}.{}\", class_name, extensions[strength\
    \ - 1]));\n   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `i64`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<i64>` for `Vec<String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprpfc0_ek.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n26 |     String::from(format!(\"{}.{}\", class_name,\
    \ extensions[strength - 1]));\n   |                    "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    \n    let mut best_extension:\
    \ Option<String> = std::cmp::min(*extensions.iter().map(|e| e.len() as u32).sum(),\
    \ -1);\n    for (i, e) in extensions.iter().enumerate() {\n        let current_extension\
    \ = match e.len() {\n            1 => e,\n            2 => e.to_lowercase(),\n\
    \            _ => return String::from(class_name),\n        };\n        if best_extension.is_none()\
    \ || current_extension.cmp(*best_extension) != cmp::Ordering::Less {\n       \
    \     best_extension = Some(current_extension);\n        }\n    }\n    if best_extension.is_none()\
    \ {\n        return String::from(class_name);\n    }\n    String::from(&format!(\"\
    {}.{}\", class_name, best_extension.unwrap()))\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpguqh3gfd.rs:26:82\n   |\n26 |         if best_extension.is_none()\
    \ || current_extension.cmp(*best_extension) != cmp::Ordering::Less {\n   |   \
    \                                                                            \
    \   ^^^ use of undeclared crate or module `cmp`\n\nerror[E0282]: type annotations\
    \ needed\n  --> /tmp/tmpguqh3gfd.rs:19:103\n   |\n19 |     let mut best_extension:\
    \ Option<String> = std::cmp::min(*extensions.iter().map(|e| e.len() as u32).sum(),\
    \ -1);\n   |                                                                 \
    \                                      ^^^ cannot infer type for type parameter\
    \ `S` declared on the associated function `sum`\n   |\n   = note: type must be\
    \ known at this point\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n19 |     let mut best_extension: Option<String> = std::cmp::min(*extensions.iter().map(|e|\
    \ e.len() as u32).sum::<S>(), -1);\n   |                                     \
    \                                                                     +++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpguqh3gfd.rs:19:110\n   |\n19 | \
    \    let mut best_extension: Option<String> = std::cmp::min(*extensions.iter().map(|e|\
    \ e.len() as u32).sum(), -1);\n   |                                          \
    \                                                                    ^^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<String>`\n\
    \              found type `{integer}`\n\nerror[E0308]: `match` arms have incompatible\
    \ types\n  --> /tmp/tmpguqh3gfd.rs:23:18\n   |\n21 |           let current_extension\
    \ = match e.len() {\n   |  _________________________________-\n22 | |        \
    \     1 => e,\n   | |                  - this is found to be of type `&String`\n\
    23 | |             2 => e.to_lowercase(),\n   | |                  ^^^^^^^^^^^^^^^^\
    \ expected `&String`, found struct `String`\n24 | |             _ => return String::from(class_name),\n\
    25 | |         };\n   | |_________- `match` arms have incompatible t"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut current_class = \"\
    \";\n    let mut current_strength = -1;\n    for x in extensions {\n        if\
    \ x.to_lowercase() == class_name.to_lowercase() {\n            current_strength\
    \ = x.to_lowercase().chars().filter(|&c| *c == c).count() - x.to_lowercase().chars().filter(|&c|\
    \ *c == c).count();\n            current_class = x;\n        }\n    }\n\n    if\
    \ current_strength == -1 && extensions.get(0) != class_name {\n        return\
    \ class_name + \".\" + extensions.get(0).to_string();\n    } else if current_strength\
    \ != -1 {\n        let mut strength = current_strength;\n        extensions.iter().skip(1).for_each(|x|\
    \ {\n            strength += x.to_lowercase().chars().filter(|&c| *c == c).count()\
    \ - x.to_lowercase().chars().filter(|&c| *c == c).count();\n        });\n    \
    \    if strength < current_strength {\n            return class_name + \".\" +\
    \ extensions.get(0).to_string();\n        } else {\n            return class_name\
    \ + \".\" + extensions.get(strength).to_string();\n        }\n    } else {\n \
    \       return class_name + \".\" + extensions.get(0).to_string();\n    }\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp8fvnym21.rs:22:69\n\
    \   |\n22 | ...   current_strength = x.to_lowercase().chars().filter(|&c| *c ==\
    \ c).count() - x.to_lowercase().chars().filter(|&c| *c == c).count();\n   |  \
    \                                                             ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp8fvnym21.rs:22:125\n   |\n\
    22 | ...   current_strength = x.to_lowercase().chars().filter(|&c| *c == c).count()\
    \ - x.to_lowercase().chars().filter(|&c| *c == c).count();\n   |             \
    \                                                                            \
    \                              ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8fvnym21.rs:23:29\n\
    \   |\n18 |     let mut current_class = \"\";\n   |                          \
    \   -- expected due to this value\n...\n23 |             current_class = x;\n\
    \   |                             ^\n   |                             |\n   |\
    \                             expected `&str`, found struct `String`\n   |   \
    \                          help: consider borrowing here: `&x`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp8fvnym21.rs:19:32\n\
    \   |\n19 |     let mut current_strength = -1;\n   |                         \
    \       ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp8fvnym21.rs:27:28\n\
    \   |\n27 |     if current_strength == -1 && extensions.get(0) != class_name {\n\
    \   |                            ^^\n   |                            |\n   | \
    \                           cannot apply unary operator `-`\n   |            \
    \                help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8fvnym21.rs:27:5"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    assert!(extensions.len() >=\
    \ 2);\n    let mut max_strength: i32 = -1;\n    let mut strength: i32 = 0;\n \
    \   for extension in extensions {\n        if extension.chars().all(|c| c >= 'A'\
    \ && c <= 'Z') {\n            strength += 1;\n        }\n        if extension.chars().all(|c|\
    \ c >= 'a' && c <= 'z') {\n            strength += 1;\n        }\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n        }\n    }\n \
    \   if max_strength == 0 {\n        class_name\n    } else {\n        format!(\"\
    {}.{}\", class_name, extensions[max_strength])\n    }\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `i32`\n  --> /tmp/tmpoit6_vn0.rs:35:38\n\
    \   |\n35 |         format!(\"{}.{}\", class_name, extensions[max_strength])\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `i32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i32>` for `Vec<String>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n\
    \    let mut max_extension = String::new();\n    let mut i = 0;\n    loop {\n\
    \        let mut s = String::from(class_name);\n        for extension in &extensions\
    \ {\n            i += extension.len();\n            let mut j = i;\n         \
    \   let mut c = 1;\n            loop {\n                let (extension, extension_strength)\
    \ = Extension::from_name(extension);\n                if extension_strength >\
    \ 0 {\n                    s = &s[..j] + &extension[..j] + &s[j..];\n        \
    \            break;\n                }\n                j += 1;\n            \
    \    c += 1;\n            }\n            if max_strength < c {\n             \
    \   max_strength = c;\n                max_extension = extension;\n          \
    \  }\n        }\n        if i < class_name.len() {\n            i += 1;\n    \
    \    }\n        else {\n            break;\n        }\n    }\n    String::from(format!(\"\
    {}.{}\", class_name, max_extension))\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Extension`\n \
    \ --> /tmp/tmpp2zpz2d_.rs:28:55\n   |\n28 |                 let (extension, extension_strength)\
    \ = Extension::from_name(extension);\n   |                                   \
    \                    ^^^^^^^^^ use of undeclared type `Extension`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp2zpz2d_.rs:38:33\n   |\n19 |     let mut max_extension\
    \ = String::new();\n   |                             ------------- expected due\
    \ to this value\n...\n38 |                 max_extension = extension;\n   |  \
    \                               ^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                                 |\n   |               \
    \                  expected struct `String`, found `&String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut best_extension: String = String::from(\"\");\n    for extension in\
    \ extensions {\n        let extension_strength = extension.chars().map(|c| c.to_ascii_uppercase().count()\
    \ as i32).sum();\n        if extension_strength > strength {\n            strength\
    \ = extension_strength;\n            best_extension = extension;\n        }\n\
    \    }\n\n    format!(\"{}.{}\", class_name, best_extension)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmpljev1h99.rs:21:83\n\
    \   |\n21 |         let extension_strength = extension.chars().map(|c| c.to_ascii_uppercase().count()\
    \ as i32).sum();\n   |                                                       \
    \                            ^^^^^ `char` is not an iterator\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `char: Iterator`\n\
    \           which is required by `&mut char: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result: Vec<i16> =\
    \ Vec::new();\n    extensions.iter().for_each(|e| result.push((e.chars().count()\
    \ as i16) - (class_name.chars().count() as i16)));\n    let result = result.iter().enumerate().max(|a,\
    \ b| a.1.cmp(&b.1)).map(|(i, b)| b).unwrap_or(1);\n    format!(\"{}{}\", class_name,\
    \ result.to_string())\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpcm14x14t.rs:20:49\n\
    \   |\n20 |     let result = result.iter().enumerate().max(|a, b| a.1.cmp(&b.1)).map(|(i,\
    \ b)| b).unwrap_or(1);\n   |                                                 ^\
    \ consider giving this closure parameter a type\n   |\n   = note: type must be\
    \ known at this point\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n    --> /tmp/tmpcm14x14t.rs:20:44\n     |\n20   |     let result\
    \ = result.iter().enumerate().max(|a, b| a.1.cmp(&b.1)).map(|(i, b)| b).unwrap_or(1);\n\
    \     |                                            ^^^ -------------------- supplied\
    \ 1 argument\n     |                                            |\n     |    \
    \                                        expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcm14x14t.rs:20:96\n\
    \   |\n20 |     let result = result.iter().enumerate().max(|a, b| a.1.cmp(&b.1)).map(|(i,\
    \ b)| b).unwrap_or(1);\n   |                                                 \
    \                                               ^\n   |                      \
    \                                                                          |\n\
    \   |                                                                        \
    \                        expected `&i16`, found integer\n   |                \
    \                                                                            \
    \    help: consider borrowing here: `&1`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0282, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut classname: String = class_name;\n    while classname.chars().any(|c|\
    \ c.is_uppercase() && strength >= 0) {\n        strength += 1;\n        classname\
    \ = String::from(format!(\"{}.{}\", class_name, classname));\n    }\n    if extensions.iter().any(|e|\
    \ e == classname) {\n        String::from(format!(\"{}.{}\", class_name, classname))\n\
    \    } else {\n        String::from(format!(\"{}.{}\", classname, extensions.iter().min_by_key(|e|\
    \ {\n            e.chars().filter(|c| c.is_lowercase()).count() as i32\n     \
    \   }).unwrap()))\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmp26fqno03.rs:24:36\n\
    \   |\n24 |     if extensions.iter().any(|e| e == classname) {\n   |         \
    \                           ^^ no implementation for `&String == String`\n   |\n\
    \   = help: the trait `PartialEq<String>` is not implemented for `&String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions_with_strength(extensions).iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `extensions_with_strength` in this scope\n\
    \  --> /tmp/tmpo0l11q3z.rs:18:5\n   |\n18 |     extensions_with_strength(extensions).iter().max().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut min = extensions[0]\n\
    \    for extension in extensions {\n        let (strength, _) = Extension::strength(extension);\n\
    \        if strength < min.len() {\n            min = extension;\n        }\n\
    \    }\n    let (strength, class_name) = Extension::strength(class_name);\n  \
    \  if strength < min.len() {\n        min\n    } else {\n        class_name +\
    \ String::from(\".\") + extensions.iter().cloned().max_by_key(|s| Extension::strength(s).len()).unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpcb4qw070.rs:18:32\n\
    \   |\n18 |     let mut min = extensions[0]\n   |                            \
    \    ^ help: add `;` here\n19 |     for extension in extensions {\n   |     ---\
    \ unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `Extension`\n  --> /tmp/tmpcb4qw070.rs:20:29\n   |\n20 |         let (strength,\
    \ _) = Extension::strength(extension);\n   |                             ^^^^^^^^^\
    \ use of undeclared type `Extension`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Extension`\n  --> /tmp/tmpcb4qw070.rs:25:34\n   |\n25 |   \
    \  let (strength, class_name) = Extension::strength(class_name);\n   |       \
    \                           ^^^^^^^^^ use of undeclared type `Extension`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Extension`\n  --> /tmp/tmpcb4qw070.rs:29:84\n\
    \   |\n29 |         class_name + String::from(\".\") + extensions.iter().cloned().max_by_key(|s|\
    \ Extension::strength(s).len()).unwrap()\n   |                               \
    \                                                     ^^^^^^^^^ use of undeclared\
    \ type `Extension`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut res = String::from(\"\
    \");\n    \n    for s in extensions {\n        if !res.is_empty() {\n        \
    \    res.push_str(\".\")\n        }\n        res.push('.');\n        res.push(s);\n\
    \    }\n    res.push(class_name);\n\n    // If the input classes name has cap\
    \ letters in it, return the first \n    // extension with the highest strength.\n\
    \    if let Some(mut name) = name.split('.') {\n        for name in name.chars()\
    \ {\n            if !name.is_uppercase() {\n                break;\n         \
    \   }\n        }\n\n        name.truncate(name.len() - 1);\n\n        // Reverse\
    \ the extensions so they're in alphabetical order and return\n        // the first.\n\
    \        let mut extensions = extensions.iter().cloned().reverse();\n        let\
    \ mut strength = -1;\n        \n        for e in extensions {\n            let\
    \ cap = e.chars().filter(|c| c.is_uppercase()).count();\n            let sm =\
    \ e.chars().filter(|c| !c.is_uppercase()).count();\n            let strength =\
    \ cap - sm;\n            \n            if strength > 0 {\n                break;\n\
    \            }\n        }\n\n        res.push_str(&name.to_string() + \"_\" +\
    \ &extensions[extensions.len() - 1]);\n    }\n    else {\n        res.push_str(class_name\
    \ + \".\");\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmp0ntsrbll.rs:31:29\n\
    \   |\n31 |     if let Some(mut name) = name.split('.') {\n   |              \
    \               ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0ntsrbll.rs:25:18\n   |\n25 |         res.push(s);\n   |      \
    \            ^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0ntsrbll.rs:27:14\n   |\n27 |     res.push(class_name);\n\
    \   |              ^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `Cloned` in the current scope\n \
    \ --> /tmp/tmp0ntsrbll.rs:42:57\n   |\n42 |         let mut extensions = extensions.iter().cloned().reverse();\n\
    \   |                                                         ^^^^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, String>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0ntsrbll.rs:58:22\n   |\n58 |         res.push_str(class_name\
    \ + \".\");\n   |                      ^^^^^^^^^^^^^^^^\n   |                \
    \      |\n   |                      expected `&str`, found struct `String`\n \
    \  |                      help: consider borrowing here: `&(class_name + \".\"\
    )`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_counters\
    \ = HashMap::new();\n\n    for &extension in extensions {\n        let mut counter\
    \ = extension_counters.get(&extension);\n        counter.increment(1);\n     \
    \   extension_counters.insert(extension, counter);\n    }\n\n    let extension_counters_sorted_by_strength\
    \ = extension_counters.iter().enumerate().sorted();\n    let mut strength = -1;\n\
    \    let mut extension = String::from(\"\");\n\n    for (i, e) in extension_counters_sorted_by_strength\
    \ {\n        if i == 0 {\n            strength = e.unwrap();\n            extension\
    \ = e.unwrap();\n        } else {\n            if e.unwrap() == strength {\n \
    \               extension += String::from(\".\");\n            }\n           \
    \ strength = e.unwrap();\n            extension = e.unwrap();\n        }\n   \
    \ }\n\n    class_name + extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpdyjdf1b2.rs:18:34\n   |\n18 |     let mut extension_counters = HashMap::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyjdf1b2.rs:20:9\n   |\n\
    20 |     for &extension in extensions {\n   |         ^^^^^^^^^^    ----------\
    \ this expression has type `Option<String>`\n   |         |\n   |         expected\
    \ struct `String`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `extension`\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyjdf1b2.rs:36:30\n\
    \   |\n36 |                 extension += String::from(\".\");\n   |          \
    \                    ^^^^^^^^^^^^^^^^^\n   |                              |\n\
    \   |                              expected `&str`, found struct `String`\n  \
    \ |                              help: consider borrowing here: `&String::from(\"\
    .\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyjdf1b2.rs:43:18\n   |\n\
    43 |     class_name + extension\n   |                  ^^^^^^^^^\n   |       \
    \           |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&extension`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    extensions.iter().fold(class_name,\
    \ |a, &b| a.to_string() + b.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptzd_766u.rs:18:64\n   |\n\
    18 |     extensions.iter().fold(class_name, |a, &b| a.to_string() + b.to_string())\n\
    \   |                                                                ^^^^^^^^^^^^^\n\
    \   |                                                                |\n   | \
    \                                                               expected `&str`,\
    \ found struct `String`\n   |                                                \
    \                help: consider borrowing here: `&b.to_string()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Your code here\n    if\
    \ extensions.len() != class_name.chars().filter(|c| c.is_uppercase()).count()\
    \ - class_name.chars().filter(|c| c.is_lowercase()).count() {\n        return\
    \ String::from(\"\");\n    }\n    let mut counter = vec![0; extensions.len()];\n\
    \    for element in extensions {\n        counter[element.chars().filter(|c| c.is_uppercase()).count()]\
    \ += 1;\n        counter[element.chars().filter(|c| c.is_lowercase()).count()]\
    \ -= 1;\n    }\n    let min_count = counter.iter().min().unwrap_or(counter.len());\n\
    \    let strength = min_count - counter.iter().filter(|c| *c == min_count).count();\n\
    \    format!(\"{}.{}\", class_name, extensions[strength].to_string())\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo60me0ln.rs:27:52\n   |\n\
    27 |     let min_count = counter.iter().min().unwrap_or(counter.len());\n   |\
    \                                                    ^^^^^^^^^^^^^\n   |     \
    \                                               |\n   |                      \
    \                              expected `&{integer}`, found `usize`\n   |    \
    \                                                help: consider borrowing here:\
    \ `&counter.len()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.iter().any(|x|\
    \ x.contains(&class_name)) {\n        String::from(format!(\"{}.{}\", class_name,\
    \ extensions[0]))\n    } else {\n        let mut max = 0;\n        let mut max_index\
    \ = -1;\n        for (index, extension) in extensions.iter().enumerate() {\n \
    \           if extension.contains(&class_name) {\n                max = extension.chars().filter(|x|\
    \ x.is_uppercase() == true).count() as i32;\n                if max > max {\n\
    \                    max = index;\n                }\n            }\n        }\n\
    \        String::from(format!(\"{}.{}\", class_name, extensions[max]))\n    }\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpas526kn8.rs:27:27\n   |\n\
    21 |         let mut max = 0;\n   |                       - expected due to this\
    \ value\n...\n27 |                     max = index;\n   |                    \
    \       ^^^^^ expected `i32`, found `usize`\n\nerror[E0277]: the type `[String]`\
    \ cannot be indexed by `i32`\n  --> /tmp/tmpas526kn8.rs:31:51\n   |\n31 |    \
    \     String::from(format!(\"{}.{}\", class_name, extensions[max]))\n   |    \
    \                                               ^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `i32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i32>` for `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n\
    \        return class_name\n    }\n    let mut best_extension: String;\n    let\
    \ mut best_strength: usize;\n    for extension in extensions {\n        let mut\
    \ current_strength: usize = 0;\n        let mut current_class: String = class_name;\n\
    \        for c in extension {\n            if c.is_uppercase() {\n           \
    \     current_strength += 1;\n                current_class += c;\n          \
    \  } else if c.is_lowercase() {\n                current_strength += 2;\n    \
    \            current_class += c;\n            } else {\n                break;\n\
    \            }\n        }\n        if current_strength > best_strength {\n   \
    \         best_strength = current_strength;\n            best_extension = extension;\n\
    \        }\n    }\n    return best_extension;\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp1t8mtgek.rs:26:18\n\
    \   |\n26 |         for c in extension {\n   |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_components = extension.split(\"\
    .\");\n        let mut extension_component_length = extension_components.len();\n\
    \        \n        // if an extension has lower characters or has more then one\
    \ dots it's too bad\n        if extension_component_length > 1 {\n           \
    \ extension_component_length -= 1;\n        }\n        \n        // if extension\
    \ is empty (no class) it's too bad\n        if extension_component_length == 0\
    \ {\n            extension_component_length = 1;\n        }\n        \n      \
    \  let mut extension_component_iter: Vec<String> = extension_components.iter().map(String::from).collect();\n\
    \        let mut extension_component_length = extension_component_iter.len();\n\
    \        \n        // if component has a lower character (all uppercase) it's\
    \ too bad \n        if extension_component_length < CAP {\n            extension_component_length\
    \ += CAP - SM;\n        }\n        \n        // if component has lower characters\
    \ it's too bad \n        if extension_component_length < SM {\n            extension_component_length\
    \ += SM;\n        }\n        \n        extension_map.insert(extension_component_iter.last().to_lowercase(),\
    \ extension_component_iter);\n    }\n    \n    let mut result = class_name.clone();\n\
    \    let mut strongest_extension = String::from(\"NA\");\n    \n    for component\
    \ in extension_map.keys().cloned() {\n        if extension_map.get(component).len()\
    \ > extension_map.get(strongest_extension).len() {\n            strongest_extension\
    \ = component;\n        }\n    }\n    \n    result += \".\" + strongest_extension;\n\
    \    result\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpy2bng3v8.rs:18:29\n   |\n18 |     let mut extension_map = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `CAP` in this scope\n  --> /tmp/tmpy2bng3v8.rs:37:41\n\
    \   |\n37 |         if extension_component_length < CAP {\n   |              \
    \                           ^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAP` in this scope\n  --> /tmp/tmpy2bng3v8.rs:38:43\n   |\n38 |\
    \             extension_component_length += CAP - SM;\n   |                  \
    \                         ^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `SM` in this scope\n  --> /tmp/tmpy2bng3v8.rs:38:49\n   |\n38 | \
    \            extension_component_length += CAP - SM;\n   |                   \
    \                              ^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `SM` in this scope\n  --> /tmp/tmpy2bng3v8.rs:42:41\n   |\n42 | \
    \        if extension_component_length < SM {\n   |                          \
    \               ^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `SM` in this scope\n  --> /tmp/tmpy2bng3v8.rs:43:43\n   |\n43 |            \
    \ extension_component_length += SM;\n   |                                    \
    \       ^^ not found in this scope\n\nerror[E0599]: no method named `len` found\
    \ for struct `std::str::Split` in the current scope\n  --> /tmp/tmpy2bng3v8.rs:21:67\n\
    \   |\n21 |         let mut extension_component_length = extension_components.len();\n\
    \   |                                                                   ^^^ method\
    \ not found in `std::str::Split<'_, &str>`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `std::str::Split` in the current scope\n  --> /tmp/tmpy2bng3v8.rs:33:78\n\
    \   |\n33 |         let mut extension_component_iter: Vec<String> = extension_components.iter().map(String::from).collect();\n\
    \   |                                                                        "
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_extension = 0;\n\
    \    let mut current_max_extension = 0;\n    let mut current_extension = String::new();\n\
    \n    for e in extensions {\n        if e.chars().filter(|c| c == '_').count()\
    \ > 0 {\n            println!(\"Error: You should not use an underscore in an\
    \ extension name!\");\n        }\n\n        let c = e.chars().filter(|c| !c.is_ascii()).count();\n\
    \        let s = e.chars().filter(|c| c.is_ascii()).count();\n        current_extension\
    \ = String::from(\"{}.{}\", class_name, e);\n        current_max_extension = max(c,\
    \ s, current_max_extension);\n\n        if c > max_extension { max_extension =\
    \ c; }\n    }\n\n    if current_max_extension == 0 {\n        println!(\"Error:\
    \ No extension with strongest extension was found!\");\n        return String::new();\n\
    \    }\n\n    return String::from(\"{}.{}\", class_name, extensions[extensions.len()\
    \ - max_extension]);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpwmndmlyo.rs:30:33\n\
    \   |\n30 |         current_max_extension = max(c, s, current_max_extension);\n\
    \   |                                 ^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpwmndmlyo.rs:23:35\n   |\n23\
    \ |         if e.chars().filter(|c| c == '_').count() > 0 {\n   |            \
    \                       ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0061]: this function takes 1\
    \ argument but 3 arguments were supplied\n   --> /tmp/tmpwmndmlyo.rs:29:29\n \
    \   |\n29  |         current_extension = String::from(\"{}.{}\", class_name, e);\n\
    \    |                             ^^^^^^^^^^^^ -------  ----------  - supplied\
    \ 3 arguments\n    |                             |\n    |                    \
    \         expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \   --> /tmp/tmpwmndmlyo.rs:40:12\n    |\n40  |     return String::from(\"{}.{}\"\
    , class_name, extensions[extensions.len() - max_extension]);\n    |          \
    \  ^^^^^^^^^^^^ -------  ----------  --------------------------------------------\
    \ supplied 3 arguments\n    |            |\n    |            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = String::new();\n\
    \n    for i in extensions.iter().cloned().filter(|&x| x.chars().count(|c| *c >=\
    \ 'A') || *c <= 'Z').sorted() {\n        let count = (i[0..].chars().count(|c|\
    \ *c >= 'A') || *c <= 'Z').to_string();\n        if count.len() > strength.len()\
    \ {\n            strength = i.to_string();\n        }\n    }\n\n    format!(\"\
    {}.{}\", class_name, strength)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpgbpt7uif.rs:20:88\n\
    \   |\n20 |     for i in extensions.iter().cloned().filter(|&x| x.chars().count(|c|\
    \ *c >= 'A') || *c <= 'Z').sorted() {\n   |                                  \
    \                                                      ^ help: a local variable\
    \ with a similar name exists: `x`\n\nerror[E0425]: cannot find value `c` in this\
    \ scope\n  --> /tmp/tmpgbpt7uif.rs:21:62\n   |\n21 |         let count = (i[0..].chars().count(|c|\
    \ *c >= 'A') || *c <= 'Z').to_string();\n   |                                \
    \                              ^ help: a local variable with a similar name exists:\
    \ `i`\n\nerror[E0282]: type annotations needed\n  --> /tmp/tmpgbpt7uif.rs:20:70\n\
    \   |\n20 |     for i in extensions.iter().cloned().filter(|&x| x.chars().count(|c|\
    \ *c >= 'A') || *c <= 'Z').sorted() {\n   |                                  \
    \                                    ^ consider giving this closure parameter\
    \ a type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpgbpt7uif.rs:20:63\n\
    \    |\n20  |     for i in extensions.iter().cloned().filter(|&x| x.chars().count(|c|\
    \ *c >= 'A') || *c <= 'Z').sorted() {\n    |                                 \
    \                              ^^^^^ ------------- supplied 1 argument\n    |\
    \                                                               |\n    |     \
    \                                                          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgbpt7uif.rs:20:53\n   |\n20 |     for i in extensions.iter().cloned().filter(|&x|\
    \ x.chars().count(|c| *c >= 'A') || *c <= 'Z').sorted() {\n   |              \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found `usize`\n\nerror[E0599]: no method named `sorted` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmpgbpt7uif.rs:20:98\n   |\n20 | \
    \    for i in extensions.iter().cloned().filter(|&x| x.chars().count(|"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    // Find the strongest extension\
    \ based on number of uppercase letters\n    // and number of lowercase letters\n\
    \    let mut strongest_extensions = Vec::new();\n    strongest_extensions.sort_by(|a,\
    \ b| {\n        match a.chars().filter(|c| c.is_uppercase()).count() - b.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n            0 => 1,\n            _ => -1,\n   \
    \     }\n    });\n    \n    if extensions.iter().any(|ext| strongest_extensions.contains(ext))\
    \ {\n        // The found extension has already had its strength chosen\n    \
    \    return class_name;\n    }\n    \n    // Iterate over the list of extensions\
    \ and find the strongest one\n    for (i, ext) in extensions.iter().enumerate()\
    \ {\n        if ext.chars().filter(|c| c.is_lowercase()).count() > strongest_extensions[i].chars().filter(|c|\
    \ c.is_uppercase()).count() {\n            strongest_extensions[i] = ext;\n  \
    \      }\n    }\n    \n    // Return the class name with the strongest extension\n\
    \    format!(\"{}.{}\", class_name, strongest_extensions.iter().next()) // Use\
    \ .next() here because we don't care about the order of the extensions list\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpnzypdz_8.rs:21:35\n\
    \   |\n21 |     strongest_extensions.sort_by(|a, b| {\n   |                  \
    \                 ^ consider giving this closure parameter the explicit type `&T`,\
    \ where the type parameter `T` is specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnzypdz_8.rs:23:18\n\
    \   |\n23 |             0 => 1,\n   |                  ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0282, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut classname = class_name;\n\
    \    let mut extensions = extensions;\n    let mut extensions_copy = extensions;\n\
    \    loop {\n        if extensions.is_empty() {\n            break;\n        }\n\
    \        let (extension, extension_strength) = extensions.iter().cloned().max_by(|a,\
    \ b| a.cmp(b));\n        classname.push_str(extension);\n        extensions.remove(&extension);\n\
    \        extensions_copy = extensions;\n    }\n    classname.push_str(extensions_copy.iter().min().unwrap());\n\
    \    classname\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n \
    \   assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpasvzx1vn.rs:25:13\n   |\n\
    25 |         let (extension, extension_strength) = extensions.iter().cloned().max_by(|a,\
    \ b| a.cmp(b));\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   --------------------------------------------------\
    \ this expression has type `Option<String>`\n   |             |\n   |        \
    \     expected enum `Option`, found tuple\n   |\n   = note: expected enum `Option<String>`\n\
    \             found tuple `(_, _)`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n\
    \        return class_name;\n    }\n    let mut current_strength = -1;\n    let\
    \ mut best_extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let (classname, extension) = extension.split('.');\n        let cap_ext\
    \ = extension.chars().filter(|x| x.is_uppercase()).count();\n        let sml_ext\
    \ = extension.chars().filter(|x| x.is_lowercase()).count();\n        let strength\
    \ = cap_ext.saturating_sub(sml_ext);\n        if strength > current_strength {\n\
    \            current_strength = strength;\n            best_extension = extension;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, best_extension)\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwovavicu.rs:24:13\n   |\n\
    24 |         let (classname, extension) = extension.split('.');\n   |        \
    \     ^^^^^^^^^^^^^^^^^^^^^^   -------------------- this expression has type `std::str::Split<'_,\
    \ char>`\n   |             |\n   |             expected struct `std::str::Split`,\
    \ found tuple\n   |\n   = note: expected struct `std::str::Split<'_, char>`\n\
    \               found tuple `(_, _)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = Vec::<String>::new();\n    let mut strength: i64 = 0;\n    let mut i = 0;\n\
    \    for extension in extensions {\n        if extension.to_lowercase() == class_name.to_lowercase()\
    \ {\n            strength += 1;\n        } else {\n            strength -= 1;\n\
    \        }\n        if i == 0 {\n            strongest_extension.push(extension);\n\
    \        }\n        i += 1;\n    }\n    // If there are no extensions then return\
    \ the first one \n    strongest_extension.iter().find(|&s| s == class_name).unwrap().to_lowercase()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpo_tcrh1i.rs:33:44\n\
    \   |\n33 |     strongest_extension.iter().find(|&s| s == class_name).unwrap().to_lowercase()\n\
    \   |                                            ^^ no implementation for `&String\
    \ == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions = extensions.clone();\n\
    \    let mut class_name = class_name.to_ascii_lowercase();\n    let mut counter\
    \ = 0;\n    let mut counter2 = 0;\n    loop {\n        if counter > extensions.len()\
    \ {\n            return class_name + String::from(\".\") + &extensions[counter2];\n\
    \        }\n        if counter2 > extensions.len() {\n            return class_name\
    \ + String::from(\".\") + &extensions[counter];\n        }\n        if counter2\
    \ == 0 {\n            let mut counter3 = (counter + counter2) / 2;\n         \
    \   while counter3 > 0 && extensions.len() > counter3 {\n                if extensions[counter3]\
    \ >= &extensions[counter] {\n                    counter = counter3;\n       \
    \             break;\n                } else {\n                    counter3 -=\
    \ 1;\n                }\n            }\n        }\n        if counter2 == 0 {\n\
    \            let mut counter3 = (counter + counter2) / 2;\n            while counter3\
    \ > 0 && extensions.len() > counter3 {\n                if extensions[counter3]\
    \ >= &extensions[counter2] {\n                    counter = counter3;\n      \
    \              break;\n                } else {\n                    counter3\
    \ -= 1;\n                }\n            }\n        }\n        counter3 -= 1;\n\
    \        counter2 += 1;\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `counter3` in this scope\n  --> /tmp/tmptzxtw4de.rs:51:9\n\
    \   |\n51 |         counter3 -= 1;\n   |         ^^^^^^^^ help: a local variable\
    \ with a similar name exists: `counter`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptzxtw4de.rs:24:33\n   |\n24 |             return class_name + String::from(\"\
    .\") + &extensions[counter2];\n   |                                 ^^^^^^^^^^^^^^^^^\n\
    \   |                                 |\n   |                                \
    \ expected `&str`, found struct `String`\n   |                               \
    \  help: consider borrowing here: `&String::from(\".\")`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptzxtw4de.rs:27:33\n   |\n27 |             return class_name\
    \ + String::from(\".\") + &extensions[counter];\n   |                        \
    \         ^^^^^^^^^^^^^^^^^\n   |                                 |\n   |    \
    \                             expected `&str`, found struct `String`\n   |   \
    \                              help: consider borrowing here: `&String::from(\"\
    .\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptzxtw4de.rs:32:44\n   |\n\
    32 |                 if extensions[counter3] >= &extensions[counter] {\n   | \
    \                                           ^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\nhelp: consider removing the borrow\n   |\n\
    32 -                 if extensions[counter3] >= &extensions[counter] {\n32 + \
    \                if extensions[counter3] >= extensions[counter] {\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptzxtw4de.rs:43:44\n   |\n43 |              \
    \   if extensions[counter3] >= &extensions[counter2] {\n   |                 \
    \                           ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&String`\n   |\nhelp: consider removing the borrow\n   |\n43 -            \
    \     if extensions[counter3] >= &extensions[counter2] {\n43 +               \
    \  if extensions[counter3] >= extensions[counter2] {\n   | \n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    match extensions.iter().enumerate().max_by_key(|_,\
    \ i| {\n        // To find the strength of the extension, we count the number\
    \ of \n        // upper case letters in our extension's name.\n        let cap\
    \ = String::from(extensions[i].chars().filter(|c| match c.to_ascii_lowercase().as_ref()\
    \ {\n            Some(el) => true,\n            None => false\n        }).count());\n\
    \n        // To find the strength of the extension, we count the number of \n\
    \        // lower case letters in our extension's name.\n        let sm = String::from(extensions[i].chars().filter(|c|\
    \ match c.to_ascii_lowercase().as_ref() {\n            Some(el) => true,\n   \
    \         None => false\n        }).count());\n        // Return the difference\
    \ between the capital letters and lowercase letters\n        // divided by the\
    \ total number of letters in the extension's name.\n        (cap - sm).unwrap()\
    \ / extensions.len()\n    }) {\n        // We found the strongest extension.\n\
    \        Some(e) => {\n            format!(\"{}.{}\", class_name, e)\n       \
    \ }\n        // We didn't find the strongest extension.\n        None => String::from(\"\
    NO_EXTENSION\")\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 1 argument, but it takes 2 arguments\n\
    \  --> /tmp/tmpe_1hq845.rs:18:41\n   |\n18 |     match extensions.iter().enumerate().max_by_key(|_,\
    \ i| {\n   |                                         ^^^^^^^^^^ ------ takes 2\
    \ arguments\n   |                                         |\n   |            \
    \                             expected closure that takes 1 argument\n\nerror[E0369]:\
    \ cannot subtract `String` from `String`\n  --> /tmp/tmpe_1hq845.rs:34:14\n  \
    \ |\n34 |         (cap - sm).unwrap() / extensions.len()\n   |          --- ^\
    \ -- String\n   |          |\n   |          String\n\nerror[E0277]: `(usize, &String)`\
    \ doesn't implement `std::fmt::Display`\n  --> /tmp/tmpe_1hq845.rs:38:42\n   |\n\
    38 |             format!(\"{}.{}\", class_name, e)\n   |                     \
    \                     ^ `(usize, &String)` cannot be formatted with the default\
    \ formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented\
    \ for `(usize, &String)`\n   = note: in format strings you may be able to use\
    \ `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates\
    \ in the macro `$crate::__export::format_args` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369, E0593.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut result: String = \"\
    .\".to_owned();\n    for (i, e) in extensions.iter().enumerate() {\n        if\
    \ i == 0 {\n            continue;\n        }\n        let mut s = e;\n       \
    \ if i > 0 {\n            let mut k = i;\n            let mut c = e;\n       \
    \     while k > 0 {\n                let mut j = k;\n                let mut d\
    \ = e;\n                while j > 0 {\n                    s = s.to_owned() +\
    \ c.to_owned();\n                    j -= 1;\n                }\n            \
    \    k = j;\n                c = d;\n            }\n        }\n        result\
    \ = s.to_owned() + result.to_owned();\n    }\n    result + class_name\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp26y4r9e4.rs:31:40\n   |\n\
    31 |                     s = s.to_owned() + c.to_owned();\n   |              \
    \                          ^^^^^^^^^^^^\n   |                                \
    \        |\n   |                                        expected `&str`, found\
    \ struct `String`\n   |                                        help: consider\
    \ borrowing here: `&c.to_owned()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp26y4r9e4.rs:31:25\n\
    \   |\n23 |         let mut s = e;\n   |                     - expected due to\
    \ this value\n...\n31 |                     s = s.to_owned() + c.to_owned();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |              \
    \           |\n   |                         expected `&String`, found struct `String`\n\
    \   |                         help: consider borrowing here: `&(s.to_owned() +\
    \ c.to_owned())`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp26y4r9e4.rs:38:33\n\
    \   |\n38 |         result = s.to_owned() + result.to_owned();\n   |         \
    \                        ^^^^^^^^^^^^^^^^^\n   |                             \
    \    |\n   |                                 expected `&str`, found struct `String`\n\
    \   |                                 help: consider borrowing here: `&result.to_owned()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp26y4r9e4.rs:40:14\n   |\n40 |\
    \     result + class_name\n   |              ^^^^^^^^^^\n   |              |\n\
    \   |              expected `&str`, found struct `String`\n   |              help:\
    \ consider borrowing here: `&class_name`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_exts = vec![];\n\
    \    for ext in extensions {\n        let cap_extension = ext.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as i32 - ext.chars().filter(|c| c >= 'a' && c\
    \ <= 'z').count() as i32;\n        let sm_extension = ext.chars().filter(|c| c\
    \ >= 'a' && c <= 'z').count() as i32;\n        let strength = cap_extension -\
    \ sm_extension;\n        if strength > 0 {\n            strongest_exts.push(String::from(ext.to_string()\
    \ + f\".{ext.to_string().chars().filter(|c| c >= 'a' && c <= 'z').count().to_string()}\"\
    ));\n        }\n    }\n    strongest_exts.sort_unstable_by_key(|s| s.len());\n\
    \    strongest_exts.last().unwrap().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `\".{ext.to_string().chars().filter(|c| c >= 'a' && c <= 'z').count().to_string()}\"\
    `\n  --> /tmp/tmpz_k9zfzj.rs:24:65\n   |\n24 | ...ing() + f\".{ext.to_string().chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count().to_string()}\"));\n   |             -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             expected one of 8 possible tokens\n   |\
    \             help: missing `,`\n\nerror[E0425]: cannot find value `f` in this\
    \ scope\n  --> /tmp/tmpz_k9zfzj.rs:24:64\n   |\n24 | ...   strongest_exts.push(String::from(ext.to_string()\
    \ + f\".{ext.to_string().chars().filter(|c| c >= 'a' && c <= 'z').count().to_string()...\n\
    \   |                                                          ^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_k9zfzj.rs:20:57\n\
    \   |\n20 | ...   let cap_extension = ext.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count() as i32 - ext.chars().filter(|c| c >= 'a' && c <= 'z').coun...\n\
    \   |                                                       ^^^\n   |        \
    \                                               |\n   |                      \
    \                                 expected `&char`, found `char`\n   |       \
    \                                                help: consider borrowing here:\
    \ `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_k9zfzj.rs:20:69\n\
    \   |\n20 | ...   let cap_extension = ext.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count() as i32 - ext.chars().filter(|c| c >= 'a' && c <= 'z').coun...\n\
    \   |                                                                   ^^^\n\
    \   |                                                                   |\n  \
    \ |                                                                   expected\
    \ `&char`, found `char`\n   |                                                \
    \                   help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz_k9zfzj.rs:20:119\n   |\n20 | ....count() as i32 - ext.chars().filter(|c|"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_counter\
    \ = vec![];\n    for e in extensions {\n        let mut counter = 0;\n       \
    \ for c in &e {\n            counter += match c {\n                'A' => {\n\
    \                    1\n                }\n                'B' => {\n        \
    \            2\n                }\n                'C' => {\n                \
    \    3\n                }\n                'D' => {\n                    4\n \
    \               }\n                'E' => {\n                    5\n         \
    \       }\n                'F' => {\n                    6\n                }\n\
    \                'G' => {\n                    7\n                }\n        \
    \        'H' => {\n                    8\n                }\n                'I'\
    \ => {\n                    9\n                }\n                'J' => {\n \
    \                   10\n                }\n                'K' => {\n        \
    \            11\n                }\n                'L' => {\n               \
    \     12\n                }\n                'M' => {\n                    13\n\
    \                }\n                'N' => {\n                    14\n       \
    \         }\n                'O' => {\n                    15\n              \
    \  }\n                'P' => {\n                    16\n                }\n  \
    \              'Q' => {\n                    17\n                }\n         \
    \       'R' => {\n                    18\n                }\n                'S'\
    \ => {\n                    19\n                }\n                'T' => {\n\
    \                    20\n                }\n                'U' => {\n       \
    \             21\n                }\n                'V' => {\n              \
    \      22\n                }\n                'W' => {\n                    23\n\
    \                }\n                'X' => {\n                    24\n       \
    \         }\n                'Y' => {\n                    25\n              \
    \  }\n                'Z' => {\n                    26\n                }\n  \
    \              _ => {\n                    0\n                }\n            };\n\
    \        }\n        extension_counter.push(counter);\n    }\n    \n    // Sort\
    \ extensions by strength\n    extension_counter.sort_by_key(|x| *x);\n\n    //\
    \ Iterate through the sorted extensions and choose the one with the lowest strength\n\
    \    let mut counter = 0;\n    for (i, e) in extension_counter.iter().enumerate()\
    \ {\n        if i == 0 {\n            return String::from(&class_name.to_string().to_string())\
    \ + &e.to_string();\n        }\n        \n        // If two extensions have the\
    \ same strength we choose the one that comes first\n        if *e == *extension_counter[i\
    \ + 1] {\n            return String::from(&class_name.to_string().to_string())\
    \ + &extensions[i - 1].to_string();\n        }\n        counter += 1;\n    }\n\
    \    return String::from(&class_name.to_string().to_string()) + &extensions[counter].to_string();\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp12nzzcqg.rs:21:18\n\
    \   |\n21 |         for c in &e {\n   |                  ^^ `&String` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n   -->\
    \ /tmp/tmp12nzzcqg.rs:120:18\n    |\n120 |         if *e == *extension_counter[i\
    \ + 1] {\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    let mut class_name = String::from(class_name);\n\
    \    for extension in extensions {\n        let mut extension_len = extension.len();\n\
    \        let mut class_len = 0;\n        while class_len < extension_len {\n \
    \           let cap_diff = class_len.saturating_sub(extension_len);\n        \
    \    let cap = extension.chars().filter(|c| c.is_uppercase())\n              \
    \  .filter(|c| c <= 'Z').count() as usize - 1;\n            let sm_diff = class_len.saturating_sub(extension_len);\n\
    \            let sm = extension.chars().filter(|c| c.is_lowercase())\n       \
    \         .filter(|c| c <= 'z').count() as usize - 1;\n            let strength_diff\
    \ = cap - sm;\n            let strength = strength_diff;\n            if strength\
    \ > 0 {\n                if strength < strength_diff {\n                    extension\
    \ = extension.to_string();\n                    break;\n                }\n  \
    \          }\n            extension = extension.clone();\n            class_len\
    \ += 1;\n        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3muaio1.rs:27:34\n   |\n\
    27 |                 .filter(|c| c <= 'Z').count() as usize - 1;\n   |       \
    \                           ^^^\n   |                                  |\n   |\
    \                                  expected `&char`, found `char`\n   |      \
    \                            help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph3muaio1.rs:30:34\n   |\n30 |              \
    \   .filter(|c| c <= 'z').count() as usize - 1;\n   |                        \
    \          ^^^\n   |                                  |\n   |                \
    \                  expected `&char`, found `char`\n   |                      \
    \            help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph3muaio1.rs:43:36\n   |\n43 |     class_name.to_string()\
    \ + \".\" + extension.to_string()\n   |                                    ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&str`, found struct `String`\n   |                         \
    \           help: consider borrowing here: `&extension.to_string()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.len() <= 2 {\n\
    \        return format!(\"{}.{}\", class_name, extensions.last());\n    }\n\n\
    \    // count the number of upper case letters\n    let cap_num = String::from(\"\
    \").chars().filter(|c| c.is_upper()).count();\n    // count the number of lower\
    \ case letters\n    let sm_num = String::from(\"\").chars().filter(|c| c.is_lower()).count();\n\
    \n    if cap_num >= sm_num {\n        return format!(\"{}.{}\", class_name, extensions.last());\n\
    \    }\n\n    // calculate the strength of the extension\n    let strength = cap_num\
    \ - sm_num;\n\n    // sort the extensions by strength\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<String>>().sort();\n    extensions_sorted.pop();\n\
    \    extensions_sorted.pop();\n\n    // pick the strongest extension\n    if extensions_sorted.len()\
    \ == 1 {\n        return format!(\"{}.{}\", class_name, extensions_sorted[0]);\n\
    \    }\n\n    // find the first extension with equal strength\n    let mut chosen_extensions\
    \ = extensions_sorted.iter().cloned().collect::<Vec<String>>();\n    for (i, &name)\
    \ in chosen_extensions.iter().enumerate() {\n        if i == 0 {\n           \
    \ continue;\n        }\n        if name == extensions_sorted[i - 1] {\n      \
    \      chosen_extensions.swap(0, i);\n        }\n    }\n\n    // return the extension\n\
    \    format!(\"{}.{}\", class_name, chosen_extensions[0])\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `Option<&String>` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmpm997pkwc.rs:19:45\n   |\n19 |         return format!(\"{}.{}\"\
    , class_name, extensions.last());\n   |                                      \
    \       ^^^^^^^^^^^^^^^^^ `Option<&String>` cannot be formatted with the default\
    \ formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented\
    \ for `Option<&String>`\n   = note: in format strings you may be able to use `{:?}`\
    \ (or {:#?} for pretty-print) instead\n   = note: this error originates in the\
    \ macro `$crate::__export::format_args` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0599]: no method named `is_upper` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpm997pkwc.rs:23:57\n   |\n23 |  \
    \   let cap_num = String::from(\"\").chars().filter(|c| c.is_upper()).count();\n\
    \   |                                                         ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]:\
    \ no method named `is_lower` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmpm997pkwc.rs:25:56\n   |\n25 |     let sm_num = String::from(\"\"\
    ).chars().filter(|c| c.is_lower()).count();\n   |                            \
    \                            ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_lowercase`\n\nerror[E0277]: `Option<&String>` doesn't implement\
    \ `std::fmt::Display`\n  --> /tmp/tmpm997pkwc.rs:28:45\n   |\n28 |         return\
    \ format!(\"{}.{}\", class_name, extensions.last());\n   |                   \
    \                          ^^^^^^^^^^^^^^^^^ `Option<&String>` cannot be formatted\
    \ with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is\
    \ not implemented for `Option<&String>`\n   = note: in format strings you may\
    \ be able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error\
    \ originates in the macro `$crate::__export::format_args` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `pop` found for unit type `()` in the current sc"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n\
    \    for ext in extensions {\n        if ext.chars().filter(|&c| c == 'A'..'Z').count()\
    \ > strength {\n            strength = ext.chars().filter(|&c| c == 'A'..'Z').count();\n\
    \        }\n    }\n    let strength = match strength {\n        x if x > 0 else\
    \ 0 => 0,\n        x => 1,\n    };\n    class_name.chars().filter( |&c| c.is_upper()\
    \ ).collect().join(\"\") + &class_name.chars().filter( |&c| !c.is_upper() ).collect().join(\"\
    \").chars().filter(|&c| c == '_' || c == '.').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ c == 'A'..'Z').collect().join(\"\") + &class_name.chars().filter(|&c| c == 'a'..'z').collect().join(\"\
    \") + &class_name.chars().filter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c\
    \ == '.').collect().join(\"\") + &class_name.chars().filter(|&c| !c == '_' &&\
    \ !c == '.').collect().join(\"\") + &class_name.chars().filter(|&c| c == 'A'..'Z'\
    \ || c == 'a'..'z' || c == '_'||c == '.' || c == '_').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ !c == '_' && !c == '.' && c == '_').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.' || c == '_').collect().join(\"\
    \") + &class_name.chars().filter(|&c| !c == '_' && !c == '.' && c == '_').collect().join(\"\
    \") + &class_name.chars().filter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c\
    \ == '.' || c == '_').collect().join(\"\") + &class_name.chars().filter(|&c| !c\
    \ == '_' && !c == '.' && c == '_').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.' || c == '_').collect().join(\"\
    \") + &class_\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `=>`, `?`, or an operator, found keyword `else`\n\
    \  --> /tmp/tmptt9so8ko.rs:25:20\n   |\n25 |         x if x > 0 else 0 => 0,\n\
    \   |                    ^^^^ expected one of `.`, `=>`, `?`, or an operator\n\
    \nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmptt9so8ko.rs:28:406\n\
    \   |\n28 | ...chars().filter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c\
    \ == '.').collect().join(\"\") + &class_name.chars().filter(|&c| !c == '...\n\
    \   |                                                          ^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmptt9so8ko.rs:28:416\n\
    \   |\n28 | ...lter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.').collect().join(\"\
    \") + &class_name.chars().filter(|&c| !c == '_' && !c =...\n   |             \
    \                                             ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmptt9so8ko.rs:28:590\n   |\n\
    28 | ...chars().filter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.'\
    \ || c == '_').collect().join(\"\") + &class_name.chars().filter(...\n   |   \
    \                                                       ^ not found in this scope\n\
    \nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmptt9so8ko.rs:28:600\n\
    \   |\n28 | ...lter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.'\
    \ || c == '_').collect().join(\"\") + &class_name.chars().filter(|&c| !c ==...\n\
    \   |                                                          ^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmptt9so8ko.rs:28:612\n\
    \   |\n28 | ...== 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.' || c == '_').collect().join(\"\
    \") + &class_name.chars().filter(|&c| !c == '_' && !c =...\n   |             \
    \                                             ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmptt9so8ko.rs:28:798\n   |\n\
    28 | ...chars().filter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.'\
    \ || c == '_').collect().join(\"\") + &cl"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut len = class_name\n\
    \        .chars()\n        .map(|x| x.to_ascii_lowercase().unwrap())\n       \
    \ .filter(|&x| x == x)\n        .count();\n    \n    for ext in extensions {\n\
    \        let mut len = ext.chars().map(|x| x.to_ascii_lowercase().unwrap()).filter(|&x|\
    \ x == x).count();\n        if len >= len {\n            len = len;\n        }\n\
    \    }\n    class_name\n        .get_str()\n        .to_string()\n        .to_uppercase()\n\
    \        + &extensions[extensions.iter().max_by_key(|&x| x.len()).unwrap()]\n\
    \        .get_str()\n        .to_string()\n        .to_uppercase()\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpmcd0w3dl.rs:20:41\n   |\n20 |         .map(|x| x.to_ascii_lowercase().unwrap())\n\
    \   |                                         ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpmcd0w3dl.rs:25:66\n   |\n25 |         let mut len = ext.chars().map(|x|\
    \ x.to_ascii_lowercase().unwrap()).filter(|&x| x == x).count();\n   |        \
    \                                                          ^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `get_str` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpmcd0w3dl.rs:31:10\n   |\n31 |         .get_str()\n\
    \   |          ^^^^^^^ method not found in `String`\n\nerror[E0277]: the type\
    \ `[String]` cannot be indexed by `&String`\n  --> /tmp/tmpmcd0w3dl.rs:34:12\n\
    \   |\n34 |         + &extensions[extensions.iter().max_by_key(|&x| x.len()).unwrap()]\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `&String`\n   = note: required\
    \ because of the requirements on the impl of `Index<&String>` for `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n\
    \        return class_name;\n    }\n\n    let mut classname = class_name;\n  \
    \  let mut strength = 1;\n    let mut counter = 0;\n    while let Some(mut extension)\
    \ = extensions.iter().find(|x| x.to_lowercase().contains(classname.to_lowercase()))\
    \ {\n        strength += 1;\n        if counter > 0 {\n            return format!(\"\
    {}.{}\", classname, extension);\n        }\n        counter += 1;\n    }\n\n \
    \   format!(\"{}.{}\", classname, extensions[0])\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpb0whyvyu.rs:25:90\n     |\n25   |     while let Some(mut extension)\
    \ = extensions.iter().find(|x| x.to_lowercase().contains(classname.to_lowercase()))\
    \ {\n     |                                                                  \
    \               -------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                                                      \
    \                           |\n     |                                        \
    \                                         required by a bound introduced by this\
    \ call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider borrowing here\n     |\n25   |     while let Some(mut extension)\
    \ = extensions.iter().find(|x| x.to_lowercase().contains(&classname.to_lowercase()))\
    \ {\n     |                                                                  \
    \                        +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    for (index, extension) in extensions.iter().enumerate() {\n        let cap\
    \ = extension.chars().filter(|c| *c >= 'A').count() as i32;\n        let sm =\
    \ extension.chars().filter(|c| *c <= 'Z').count() as i32;\n        strength =\
    \ cap - sm;\n        if strength < 0 {\n            strength = -1;\n        }\n\
    \    }\n    if strength == 0 {\n        class_name\n    } else {\n        class_name.to_string()\
    \ + format!(\"{}.{}\", Strongest_Extension_name(strength), Strongest_Extension_name(strength))\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strongest_Extension_name`\
    \ in this scope\n  --> /tmp/tmpgll2npzp.rs:30:51\n   |\n30 |         class_name.to_string()\
    \ + format!(\"{}.{}\", Strongest_Extension_name(strength), Strongest_Extension_name(strength))\n\
    \   |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct\
    \ or tuple variant `Strongest_Extension_name` in this scope\n  --> /tmp/tmpgll2npzp.rs:30:87\n\
    \   |\n30 |         class_name.to_string() + format!(\"{}.{}\", Strongest_Extension_name(strength),\
    \ Strongest_Extension_name(strength))\n   |                                  \
    \                                                     ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgll2npzp.rs:30:34\n\
    \   |\n30 |         class_name.to_string() + format!(\"{}.{}\", Strongest_Extension_name(strength),\
    \ Strongest_Extension_name(strength))\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extension_hash: HashMap<String,\
    \ u32> = HashMap::new();\n    extensions.iter().for_each(|ext| {\n        let\
    \ ext = ext.to_lowercase().chars().collect();\n        let mut c: u32 = 1;\n \
    \       for ch in ext.iter() {\n            if *ch >= 'a' && *ch <= 'z' {\n  \
    \              *c += 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        extension_hash.insert(String::from(ext), c);\n  \
    \  });\n    let mut extension_order: Vec<(u32, String)> = extensions.iter().cloned().collect();\n\
    \    extension_order.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut best_extension:\
    \ Vec<(u32, String)> = extension_order.iter().cloned().collect();\n    let mut\
    \ strength: usize = 0;\n    for e in &mut extension_order {\n        if best_extension.iter().all(|x|\
    \ x.1.cmp(&e.1) == 0) {\n            strength = e.0;\n            break;\n   \
    \     }\n    }\n    if best_extension.len() < extensions.len() {\n        if strength\
    \ > 0 {\n            let (extension, new_strength) = best_extension[0];\n    \
    \        best_extension.sort_by(|a, b| a.1.cmp(&b.1));\n            best_extension.dedup();\n\
    \            let mut new_extensions: Vec<String> = best_extension.iter().cloned().collect();\n\
    \            new_extensions.push(\"_\".to_owned());\n            new_extensions.push(extension);\n\
    \            new_extensions.push(\"_\".to_owned());\n            Strongest_Extension(String::from(&class_name)[..],\
    \ new_extensions)\n        } else {\n            Strongest_Extension(String::from(&class_name)[..],\
    \ extensions)\n        }\n    } else {\n        Strongest_Extension(String::from(&class_name)[..],\
    \ extensions)\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmphpyoxlqc.rs:18:29\n\
    \   |\n18 |     let mut extension_hash: HashMap<String, u32> = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmphpyoxlqc.rs:18:52\n   |\n18 |     let mut extension_hash: HashMap<String,\
    \ u32> = HashMap::new();\n   |                                               \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0614]: type `u32` cannot\
    \ be dereferenced\n  --> /tmp/tmphpyoxlqc.rs:24:17\n   |\n24 |               \
    \  *c += 1;\n   |                 ^^\n\nerror[E0277]: a value of type `Vec<(u32,\
    \ String)>` cannot be built from an iterator over elements of type `String`\n\
    \    --> /tmp/tmphpyoxlqc.rs:31:78\n     |\n31   |     let mut extension_order:\
    \ Vec<(u32, String)> = extensions.iter().cloned().collect();\n     |         \
    \                                                                     ^^^^^^^\
    \ value of type `Vec<(u32, String)>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Vec<(u32, String)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphpyoxlqc.rs:36:59\n   |\n36 |         if best_extension.iter().all(|x|\
    \ x.1.cmp(&e.1) == 0) {\n   |                                                \
    \           ^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphpyoxlqc.rs:37:24\n   |\n34 |     let mut strength:\
    \ usize = 0;\n   |                       ----- expected due to this type\n...\n\
    37 |             strength = e.0;\n   |                        ^^^ expected `usize`,\
    \ found `u32`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from\
    \ an iterator over"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ -1;\n    let mut index = 0;\n    while index < extensions.len() {\n        let\
    \ current_extension = extensions[index];\n        let current_extension_upper\
    \ = current_extension.chars().map(|c| *c).collect::<String>();\n        let current_extension_lower\
    \ = current_extension.chars().map(|c| *c).collect::<String>();\n        let cap\
    \ = current_extension_upper.chars().map(|c| *c).collect::<String>();\n       \
    \ let sm = current_extension_lower.chars().map(|c| *c).collect::<String>();\n\
    \        strength += cap.to_string().chars().filter(|c| *c == c.to_lowercase()).count()\
    \ - sm.to_lowercase().chars().filter(|c| *c == c.to_lowercase()).count();\n  \
    \      index = index + 1;\n    }\n    \n    let strength_str = format!(\"{}.{}\"\
    , class_name, extensions[strength].to_string());\n    strength_str.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpkgibkwoc.rs:18:31\n\
    \   |\n18 |     let mut strength: usize = -1;\n   |                          \
    \     ^^\n   |                               |\n   |                         \
    \      cannot apply unary operator `-`\n   |                               help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpkgibkwoc.rs:22:73\n   |\n22 |         let current_extension_upper\
    \ = current_extension.chars().map(|c| *c).collect::<String>();\n   |         \
    \                                                                ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpkgibkwoc.rs:23:73\n   |\n\
    23 |         let current_extension_lower = current_extension.chars().map(|c| *c).collect::<String>();\n\
    \   |                                                                        \
    \ ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpkgibkwoc.rs:24:59\n\
    \   |\n24 |         let cap = current_extension_upper.chars().map(|c| *c).collect::<String>();\n\
    \   |                                                           ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpkgibkwoc.rs:25:58\n   |\n\
    25 |         let sm = current_extension_lower.chars().map(|c| *c).collect::<String>();\n\
    \   |                                                          ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkgibkwoc.rs:26:62\n   |\n26 | ...   strength\
    \ += cap.to_string().chars().filter(|c| *c == c.to_lowercase()).count() - sm.to_lowercase().chars().filter(|c|\
    \ *c == c.to_lo...\n   |                                                     \
    \       ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkgibkwoc.rs:26:133\n   |\n26 | ...lowercase().chars().filter(|c|\
    \ *c == c.to_lowercase()).count();\n   |                                     \
    \    ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\nerror: a"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n\
    \    let mut max_extension = String::from(\"\");\n    for (index, ext) in extensions.iter().enumerate()\
    \ {\n        let (ext, strength) = ext.splitn(2, \".\").map(|x| x.parse().unwrap());\n\
    \        let (class_name, _) = class_name.splitn(2, \".\").map(|x| x.parse().unwrap());\n\
    \        if strength > max_strength {\n            max_strength = strength;\n\
    \            max_extension = ext;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ max_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgn04pesp.rs:21:13\n   |\n\
    21 |         let (ext, strength) = ext.splitn(2, \".\").map(|x| x.parse().unwrap());\n\
    \   |             ^^^^^^^^^^^^^^^   ----------------------------------------------\n\
    \   |             |                 |                      |\n   |           \
    \  |                 |                      the expected closure\n   |       \
    \      |                 this expression has type `Map<std::str::SplitN<'_, &str>,\
    \ [closure@/tmp/tmpgn04pesp.rs:21:54: 21:76]>`\n   |             expected struct\
    \ `Map`, found tuple\n   |\n   = note: expected struct `Map<std::str::SplitN<'_,\
    \ &str>, [closure@/tmp/tmpgn04pesp.rs:21:54: 21:76]>`\n               found tuple\
    \ `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgn04pesp.rs:22:13\n\
    \   |\n22 |         let (class_name, _) = class_name.splitn(2, \".\").map(|x|\
    \ x.parse().unwrap());\n   |             ^^^^^^^^^^^^^^^   -----------------------------------------------------\n\
    \   |             |                 |                             |\n   |    \
    \         |                 |                             the expected closure\n\
    \   |             |                 this expression has type `Map<std::str::SplitN<'_,\
    \ &str>, [closure@/tmp/tmpgn04pesp.rs:22:61: 22:83]>`\n   |             expected\
    \ struct `Map`, found tuple\n   |\n   = note: expected struct `Map<std::str::SplitN<'_,\
    \ &str>, [closure@/tmp/tmpgn04pesp.rs:22:61: 22:83]>`\n               found tuple\
    \ `(_, _)`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976533
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions;\n    extensions_sorted.sort();\n    let strength = extensions_sorted.iter().fold(0,\
    \ |s, e| {\n        let cap = e.chars().filter(|c| c >= 'A').count() + 1;\n  \
    \      let sm = e.chars().filter(|c| c < 'A').count() + 1;\n        (s.saturating_sub(s)\
    \ + cap - sm) as i32\n    });\n    class_name\n        + String::from(\".\") +\
    \ extensions_sorted[strength].to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwtssdysu.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A').count() + 1;\n   |     \
    \                                        ^^^\n   |                           \
    \                  |\n   |                                             expected\
    \ `&char`, found `char`\n   |                                             help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwtssdysu.rs:22:43\n\
    \   |\n22 |         let sm = e.chars().filter(|c| c < 'A').count() + 1;\n   |\
    \                                           ^^^\n   |                        \
    \                   |\n   |                                           expected\
    \ `&char`, found `char`\n   |                                           help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0689]: can't call method `saturating_sub`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpwtssdysu.rs:23:12\n   |\n\
    20 |     let strength = extensions_sorted.iter().fold(0, |s, e| {\n   |      \
    \                                                - you must specify a type for\
    \ this binding, like `i32`\n...\n23 |         (s.saturating_sub(s) + cap - sm)\
    \ as i32\n   |            ^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpwtssdysu.rs:26:11\n   |\n26 |         + String::from(\".\") + extensions_sorted[strength].to_string()\n\
    \   |           ^^^^^^^^^^^^^^^^^\n   |           |\n   |           expected `&str`,\
    \ found struct `String`\n   |           help: consider borrowing here: `&String::from(\"\
    .\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwtssdysu.rs:26:31\n   |\n\
    26 |         + String::from(\".\") + extensions_sorted[strength].to_string()\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                               |\n   |                               expected\
    \ `&str`, found struct `String`\n   |                               help: consider\
    \ borrowing here: `&extensions_sorted[strength].to_string()`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0689.\n\
    Fo"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -100;\n\
    \    extensions.iter().for_each(|extension| {\n        let mut cap_extension:\
    \ String;\n        let mut sm_extension: String;\n        let mut first_extension:\
    \ Vec<String> = Vec::new();\n        for char in extension {\n            if char\
    \ == char.downcase() {\n                cap_extension += char.to_string();\n \
    \           } else {\n                sm_extension += char.to_string();\n    \
    \        }\n        }\n        if cap_extension.len() > sm_extension.len() {\n\
    \            if cap_extension > sm_extension {\n                first_extension.push(cap_extension);\n\
    \            } else {\n                first_extension.push(sm_extension);\n \
    \           }\n        }\n    });\n    first_extension.iter().for_each(|extension|\
    \ {\n        let mut extension_strength = -1;\n        if extension == extension.to_ascii_lowercase()\
    \ {\n            extension_strength = 0;\n        } else if extension == extension.to_ascii_uppercase()\
    \ {\n            extension_strength = 1;\n        } else {\n            extension_strength\
    \ = 2;\n        }\n        if extension_strength > strength {\n            strength\
    \ = extension_strength;\n        }\n    });\n    String::from(format!(\"{}.{}\"\
    , class_name, extensions[strength]))\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `first_extension` in this scope\n  -->\
    \ /tmp/tmpn_xae05y.rs:38:5\n   |\n38 |     first_extension.iter().for_each(|extension|\
    \ {\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: `&String`\
    \ is not an iterator\n  --> /tmp/tmpn_xae05y.rs:23:21\n   |\n23 |         for\
    \ char in extension {\n   |                     ^^^^^^^^^ `&String` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpn_xae05y.rs:18:24\n   |\n18 |     let mut strength = -100;\n  \
    \ |                        ^^^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpn_xae05y.rs:39:38\n   |\n39 |         let mut extension_strength\
    \ = -1;\n   |                                      ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = extensions[0];\n\n    for extension in extensions {\n        if extension.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() > 3 || \n            extension.chars().filter(|&c|\
    \ *c >= 'a' && *c <= 'z').count() > 3 {\n            continue;\n        }\n\n\
    \        let cap = extension.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count();\n\
    \        let sm = extension.chars().filter(|&c| *c >= 'a' && *c <= 'z').count();\n\
    \        let strength = (cap - sm) as f64;\n        if strength > 0 {\n      \
    \      strongest_extension = extension;\n        }\n    }\n\n    return class_name\
    \ + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:21:42\n\
    \   |\n21 |         if extension.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count()\
    \ > 3 || \n   |                                          ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:21:55\n   |\n21 | \
    \        if extension.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count() > 3\
    \ || \n   |                                                       ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:22:43\n   |\n\
    22 |             extension.chars().filter(|&c| *c >= 'a' && *c <= 'z').count()\
    \ > 3 {\n   |                                           ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:22:56\n   |\n22 | \
    \            extension.chars().filter(|&c| *c >= 'a' && *c <= 'z').count() > 3\
    \ {\n   |                                                        ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:26:49\n   |\n\
    26 |         let cap = extension.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count();\n\
    \   |                                                 ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:26:62\n   |\n26 | \
    \        let cap = extension.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count();\n\
    \   |                                                              ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:27:48\n   |\n\
    27 |         let sm = extension.chars().filter(|&c| *c >= 'a' && *c <= 'z').count();\n\
    \   |                                                ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmphu8426w_.rs:27:61\n   |\n27 | \
    \        let sm = extension.chars().filter(|&c| *c >= 'a' && *c <= 'z').count();\n\
    \   |                                                             ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphu8426w_.rs:29:23\n   |\n29 |         if strength\
    \ > 0 {\n   |                       ^\n   |                       |\n   |    \
    \                   expected `f6"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    if extensions.iter().any(|x|\
    \ x.chars().count::<u32>() <\n        (class_name.chars().count::<u32>() as u32\
    \ / extension_strength_limit) as u32)\n    {\n        return String::from(class_name\
    \ + \"_\" + extensions[0].to_string());\n    }\n\n    let mut best_extension:\
    \ Option<String> = None;\n    let mut best_strength = std::u32::MAX;\n    for\
    \ (i, x) in extensions.iter().enumerate() {\n        if x.chars().count::<u32>()\
    \ < (\n            class_name.chars().count::<u32>() /\n                (extension_strength_limit\
    \ as u32 - extension_strength_limit as u32))\n        {\n            continue;\n\
    \        }\n\n        let strength = x.chars().count::<u32>() / (class_name.chars().count::<u32>()\
    \ as u32);\n        if strength > best_strength {\n            best_strength =\
    \ strength;\n            best_extension = Some(x.to_string());\n        }\n  \
    \  }\n\n    if let Some(extension) = best_extension {\n        return String::from(class_name\
    \ + extension);\n    }\n\n    String::from(class_name)\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `extension_strength_limit` in this scope\n\
    \  --> /tmp/tmptb6zv9vx.rs:19:53\n   |\n19 |         (class_name.chars().count::<u32>()\
    \ as u32 / extension_strength_limit) as u32)\n   |                           \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `extension_strength_limit` in this scope\n  -->\
    \ /tmp/tmptb6zv9vx.rs:29:18\n   |\n29 |                 (extension_strength_limit\
    \ as u32 - extension_strength_limit as u32))\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `extension_strength_limit`\
    \ in this scope\n  --> /tmp/tmptb6zv9vx.rs:29:52\n   |\n29 |                 (extension_strength_limit\
    \ as u32 - extension_strength_limit as u32))\n   |                           \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0107]: this associated function takes 0 generic arguments but 1 generic\
    \ argument was supplied\n  --> /tmp/tmptb6zv9vx.rs:18:44\n   |\n18 |     if extensions.iter().any(|x|\
    \ x.chars().count::<u32>() <\n   |                                           \
    \ ^^^^^------- help: remove these generics\n   |                             \
    \               |\n   |                                            expected 0\
    \ generic arguments\n\nerror[E0107]: this associated function takes 0 generic\
    \ arguments but 1 generic argument was supplied\n  --> /tmp/tmptb6zv9vx.rs:19:29\n\
    \   |\n19 |         (class_name.chars().count::<u32>() as u32 / extension_strength_limit)\
    \ as u32)\n   |                             ^^^^^------- help: remove these generics\n\
    \   |                             |\n   |                             expected\
    \ 0 generic arguments\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptb6zv9vx.rs:19:9\n\
    \   |\n19 |         (class_name.chars().count::<u32>() as u32 / extension_strength_limit)\
    \ as u32)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `u32`\n   |\nhelp: you can convert a `u32` to a `usize`\
    \ and panic if th"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_counter:\
    \ Vec<(String, u32)> = extensions.iter().cloned().map(|s| {\n        (s, 1)\n\
    \    }).collect();\n    let mut extensions_counter: Vec<(String, u32)> = extensions.iter().cloned().map(|s|\
    \ {\n        (s, 1)\n    }).collect();\n    let mut strongest_extension: Vec<String>\
    \ = Vec::new();\n    let mut total_extensions_counter = extensions.iter().cloned().map(|s|\
    \ {\n        (s, 1)\n    }).sum();\n\n    for i in 0..extensions.len() {\n   \
    \     for j in 0..extensions.len() {\n            let mut strongest_counter: Vec<(String,\
    \ u32)> = extensions.iter().cloned().map(|s| {\n                (s, 1)\n     \
    \       }).collect();\n            let mut strongest_counter: Vec<(String, u32)>\
    \ = extensions.iter().cloned().map(|s| {\n                (s, 1)\n           \
    \ }).collect();\n            strongest_extension.clear();\n            for z in\
    \ 0..extensions.len() {\n                let mut max_extension_strength: u32 =\
    \ i32::MAX;\n                for (k, s) in strongest_counter {\n             \
    \       let mut total_strength: u32 = i32::MAX;\n                    for (l, _)\
    \ in extensions_counter {\n                        if z == l {\n             \
    \               total_strength += s;\n                        }\n            \
    \        }\n                    if total_strength > max_extension_strength {\n\
    \                        max_extension_strength = total_strength;\n          \
    \          }\n                }\n                if max_extension_strength ==\
    \ i32::MAX {\n                    break;\n                }\n                let\
    \ strength = i32::MAX - max_extension_strength;\n                strongest_extension.push(i.to_string()\
    \ + j.to_string() + z.to_string() + \"(\" + extensions[z].to_string() + \")\"\
    .to_string());\n                strongest_counter.push((extensions[z], strength));\n\
    \            }\n            if strongest_counter.len() > total_extensions_counter\
    \ {\n                extensions_counter = strongest_counter;\n               \
    \ total_extensions_counter = strongest_counter.len();\n            }\n       \
    \ }\n    }\n    extensions_counter.iter().cloned().for_each(|(extension, strength)|\
    \ {\n        let mut current_strongest_extensions: Vec<String> = vec![String::from(\"\
    \".to_string())];\n        for strongest in strongest_extension {\n          \
    \  let mut current_strongest_extension: String = String::from(\"\".to_\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp576vjkjt.rs:81:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n64 |     extensions_counter.iter().cloned().for_each(|(extension,\
    \ strength)| {\n   |                                                - unclosed\
    \ delimiter     - unclosed delimiter\n65 |         let mut current_strongest_extensions:\
    \ Vec<String> = vec![String::from(\"\".to_string())];\n66 |         for strongest\
    \ in strongest_extension {\n   |                                             \
    \ - this delimiter might not be properly closed...\n67 |             let mut current_strongest_extension:\
    \ String = String::from(\"\".to_\n68 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n81 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmp576vjkjt.rs:67:71\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                                      - closing delimiter possibly\
    \ meant for this\n...\n67 |             let mut current_strongest_extension: String\
    \ = String::from(\"\".to_\n   |                                              \
    \                         ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found\
    \ `}`\n  --> /tmp/tmp576vjkjt.rs:68:1\n   |\n68 | }\n   | ^ expected one of `.`,\
    \ `;`, `?`, `else`, or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp576vjkjt.rs:39:55\n\
    \   |\n39 |                 let mut max_extension_strength: u32 = i32::MAX;\n\
    \   |                                                 ---   ^^^^^^^^ expected\
    \ `u32`, found `i32`\n   |                                                 |\n\
    \   |                                                 expected due to this\n \
    \  |\nhelp: you can convert an `i32` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n39 |            "
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut total_class_strength\
    \ = Vec::new();\n\n    for e in extensions {\n        total_class_strength.push(e.chars().filter(|c|\
    \ c >= 'A').count() - e.chars().filter(|c| c >= 'a').count());\n    }\n\n    //\
    \ The class name will always have 2 capital letters and the other\n    // extensions\
    \ will have 1 capital letter\n    let mut total_extensions_strength = total_class_strength.clone();\n\
    \    total_extensions_strength.sort();\n\n    if total_extensions_strength.len()\
    \ > 0 {\n        let mut total_strength = total_extensions_strength[0];\n    \
    \    for s in &total_extensions_strength {\n            if s > total_strength\
    \ {\n                total_strength = s;\n            }\n        }\n        let\
    \ mut class_strength = total_strength;\n        let mut best_extension = &extensions[0];\n\
    \        for &s in &total_extensions_strength {\n            if s == total_strength\
    \ {\n                let mut extension = &extensions[0];\n                while\
    \ extension.len() > 0 {\n                    if extension.chars().filter(|c| c\
    \ >= 'A').count() >= 2 && \n                        extension.chars().filter(|c|\
    \ c >= 'a').count() >= 2 &&\n                        extension.chars().filter(|c|\
    \ c >= 'A').count() <= 3 &&\n                        extension.chars().filter(|c|\
    \ c >= 'a').count() <= 3 {\n                        extension = &extension.split_off(1).collect::<Vec<String>>().unwrap()[0];\n\
    \                    } else {\n                        extension = &extension.split_off(1).collect::<Vec<String>>().unwrap()[1..];\n\
    \                    }\n                }\n                best_extension = extension.clone();\n\
    \                total_strength = s;\n            } else {\n                total_strength\
    \ = s;\n            }\n        }\n        format!(\"{}.{}\", class_name, best_extension)\n\
    \    } else {\n        format!(\"{}\", class_name)\n    }\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb7ndcjfe.rs:21:61\n   |\n\
    21 |         total_class_strength.push(e.chars().filter(|c| c >= 'A').count()\
    \ - e.chars().filter(|c| c >= 'a').count());\n   |                           \
    \                                  ^^^\n   |                                 \
    \                            |\n   |                                         \
    \                    expected `&char`, found `char`\n   |                    \
    \                                         help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb7ndcjfe.rs:21:102\n   |\n21 |\
    \         total_class_strength.push(e.chars().filter(|c| c >= 'A').count() - e.chars().filter(|c|\
    \ c >= 'a').count());\n   |                                                  \
    \                                                    ^^^\n   |               \
    \                                                                            \
    \           |\n   |                                                          \
    \                                            expected `&char`, found `char`\n\
    \   |                                                                        \
    \                              help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb7ndcjfe.rs:32:20\n   |\n32 |             if\
    \ s > total_strength {\n   |                    ^^^^^^^^^^^^^^\n   |         \
    \           |\n   |                    expected `&usize`, found `usize`\n   |\
    \                    help: consider borrowing here: `&total_strength`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb7ndcjfe.rs:33:34\n   |\n30 |         let mut\
    \ total_strength = total_extensions_strength[0];\n   |                       \
    \           ---------------------------- expected due to this value\n...\n33 |\
    \                 total_strength = s;\n   |                                  ^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n33 |                 total_strength = *s;\n   |                       \
    \           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb7"
  stdout: ''
  timestamp: 1659976534
