name: HumanEval_49_modp
language: rs
prompt: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
  \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
  \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
  \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
  }\n"
completions: ['    (n % p + p) % p', "    let mut i = p;\n    while i >= n {\n   \
    \     i -= n;\n    }\n    i", "    let mut m = p * (p - 1) * (p - 2) / 6;\n  \
    \  for _ in 0..n {\n        m = ((m + p) % p);\n    }\n    m", '    (p - 1) %
    n + 1', "    let mut x = n;\n    let mut y = p;\n    while x > y {\n        y\
    \ -= x;\n        x &= y - 1;\n    }\n    y", '    (p - 1) % n + (n % p)', "  \
    \  let mut n1 = n % p;\n    while n1 < 0 {\n        n1 += p;\n    }\n    let mut\
    \ n2 = n / p;\n    while n2 > 1 {\n        n2 -= p;\n    }\n    n1 * n2", "  \
    \  let mut n = n;\n    let mut res = p;\n    while n > 0 && !(res % n == 0) {\n\
    \        res /= n;\n    }\n    res + 1", '    if n < p { n } else { p }', "  \
    \  let mut n2 = n * 2;\n    while n2 > p + 1 {\n        n2 -= p + 1;\n    }\n\
    \    n2 % p", "    if n >= p {\n        n - p\n    } else {\n        (p + (n -\
    \ p)) % p\n    }", "    let mut a = p;\n    let mut b = p;\n    while n > 0 {\n\
    \        let t = a % b;\n        a = b;\n        b = t;\n        n -= 1;\n   \
    \ }\n    a", "    if p < 0 {\n        p = 0\n    }\n    p as isize * pow(2, n\
    \ - 1)", "    debug_assert!(n::mod_mul(p) == 0);\n    n::mod_mul(p)", '    (p
    % n) as usize % p', "    assert!(n >= 0);\n    assert!(p);\n    let mut res =\
    \ 1;\n    for _ in 0..n {\n        res *= p;\n        res %= p;\n    }\n    res",
  "    mod {\n        fn modp(mut n: isize, mut p: isize) -> isize {\n           \
    \ n = n + (p - 1) / p;\n            if n % p == 0 {\n                n -= p +\
    \ 1;\n            }\n            n\n        }\n    }\n    modp(n, p)", "    let\
    \ mut n2 = pow2n(n);\n    let mut p2 = pow2n(p);\n    let mut res = n2;\n    while\
    \ p2 > 0 {\n        if n2 % p2 > 0 {\n            n2 -= p2;\n            res -=\
    \ p2;\n        } else {\n            n2 -= p2;\n        }\n        p2 /= 2;\n\
    \    }\n    res", "    let d = n%p;\n    if d == 0 {\n        d\n    } else {\n\
    \        p + d\n    }", "    fn gcd(mut n: isize, mut p: isize) -> isize {\n \
    \       if n == 0 {\n            p\n        } else {\n            gcd(n % p, p)\n\
    \        }\n    }\n\n    fn div_rec(mut n: isize, mut p: isize, mut r: isize)\
    \ -> isize {\n        if n == 0 {\n            return r\n        }\n        div_rec(n,\
    \ (n % p), r)\n    }\n\n    if p != 1 {\n        if p == 2 {\n            return\
    \ 1;\n        }\n        return gcd(n, p) * div_rec(n, p * 2, 1)\n    }\n\n  \
    \  if n == 0 {\n        return 1\n    }\n\n    gcd(n, p)", '    (n as usize) %
    p', "    mod {\n        use num_bigint::{BigInt, Sign};\n        use std::cmp::Ordering;\n\
    \        use std::ops::{Add, Sub};\n\n        let n = n as usize;\n        let\
    \ p = p as usize;\n\n        // n is >= p, thus modular inverses are unique\n\
    \        if n == 0 {\n            1\n        } else if n > p {\n            n\
    \ & !p\n        } else if n < p {\n            n | !p\n        } else {\n    \
    \        let m = if n < p { p } else { p };\n\n            // m is odd, m has\
    \ at most n factors\n            if m % 2 == 1 {\n                n / 2\n    \
    \        } else {\n                let mut m = m / 2;\n                while m\
    \ % 2 == 0 {\n                    m /= 2;\n                }\n               \
    \ m + 1\n            }\n        }\n    }", "    if n > p {\n        n - p\n  \
    \  } else {\n        p\n    }", "    let s = n;\n    while s > 0 && (s & 1) !=\
    \ 0 {\n        s /= 2;\n    }\n    return s * p % n;", '    (n * p % p).ceil()
    as isize', '    (p - 1) & n as isize', "    match n {\n        0 => 1,\n     \
    \   _ => n,\n    }\n    n & ((p - 1) << 1)", '    (n + p - 1) % p', '    (p -
    1) * (2 * n + 1) + (2 * n - 1)', "    if n < 0 {\n        p + 1 - n\n    } else\
    \ {\n        n % p\n    }", "    if n < 1 {\n        1\n    }\n    else if n ==\
    \ 1 {\n        0\n    }\n    else if n == p {\n        n\n    }\n    else {\n\
    \        n\n    }", "    let rem = n % p;\n    n - rem", "    if n < 0 {\n   \
    \     n + (p as isize)\n    } else {\n        n % p\n    }", '    n & (p - 1)',
  "    if n == 0 { return 1; }\n    n - (n % p) % p", '    n & (p - 1)', '    (p *
    n + n) % p as isize', "    let mut n = n as isize;\n    n %= p;\n    if n == 0\
    \ {\n        n = 1\n    }\n    n", "    assert!(n > 0);\n    assert!(p > 0);\n\
    \    assert!(p < modq(n));\n    if n < 2 {\n        return n;\n    }\n    if n\
    \ == 1 {\n        return p;\n    }\n    if n == 2 {\n        return n + (p - 1)\
    \ / p;\n    }\n    if n % 2 == 0 {\n        if n % p == 0 {\n            return\
    \ n;\n        }\n        if p % n == 0 {\n            return n + (p - 1) / p;\n\
    \        }\n    }\n    if p % n == 0 {\n        return n - p / n;\n    }\n   \
    \ n + (p - 1)", '    (n % p) as isize', "    if n % p == 0 {\n        n\n    }\
    \ else {\n        n + p - n % p\n    }", "    let a = n / p;\n    let b = n %\
    \ p;\n    if b < 0 {\n        b - p\n    } else {\n        b\n    }", "    if\
    \ n == 0 || (n & (n - 1)) == 0 {\n        return 1;\n    }\n    if p > n {\n \
    \       return 0;\n    }\n    let mut t = p + (p - 1) * (p - 1) / 2;\n    while\
    \ t < n {\n        if t % p == 0 {\n            return 0;\n        }\n       \
    \ t += p;\n    }\n    return 1;", "    debug_assert!(n % p == 0);\n    (n / p).floor()\
    \ as isize", "    let mut mod = 0;\n    let mut result = 1;\n    while n > 0 {\n\
    \        mod += n % p;\n        n /= p;\n    }\n    if n == 1 {\n        mod -=\
    \ 1;\n    }\n    mod += 1;\n    if mod < 2 {\n        mod += p;\n    }\n    if\
    \ mod > p {\n        mod -= p;\n    }\n    result", '    mod_lt(p, n).unwrap_or(p)',
  '    n as usize % (p as usize)', "    match n {\n        0 => 1,\n        1 => p,\n\
    \        n => n % p\n    }", "    n %= p;\n    if n < 0 {\n        n += p;\n \
    \   }\n    n", "    if n < 0 {\n        p *= -1;\n        n *= -1;\n    }\n  \
    \  if p < 2 {\n        return n;\n    }\n\n    if n & (n - 1) == 0 {\n       \
    \ // x is power of two\n        if p == 1 {\n            return n;\n        }\n\
    \        // n is power of two\n        if n == 1 {\n            return p;\n  \
    \      }\n\n        // n is odd and p is even\n        if ((n >> 1) & p == 1)\
    \ {\n            return n + (n - 1) * (n - 1) / 2;\n        }\n        // n is\
    \ even and p is odd\n        if ((n >> 1) & p == 0) {\n            return n -\
    \ 1 - (n - 1) / 2;\n        }\n\n        // n is odd and p is odd\n        if\
    \ ((n >> 1) & p == 1) {\n            return n + (n - 1) * (n - 1) / 2;\n     \
    \   }\n        // n is even and p is even\n        if ((n >> 1) & p == 0) {\n\
    \            return n - 1 - (n - 1) / 2;\n        }\n\n        // n is odd and\
    \ p is even and x is power of two\n        if ((n >> 1) & p == 1) {\n        \
    \    return n + (n - 1) * (n - 1) / 2;\n        }\n        // n is even and p\
    \ is odd and x is power of two\n        if ((n >> 1) & p == 0) {\n           \
    \ return n - 1 - (n - 1) / 2;\n        }\n\n        // n is even and p is even\
    \ and x is power of two and y is power of two\n        if ((n >> 1) & p == 1)\
    \ {\n            return n + (n - 1) * (n - 1) / 2;\n        }\n        // n is\
    \ even and p is even and x is power of two and y is odd.\n        if ((n >> 1)\
    \ & p == 0) {\n            return n - 1 - (n - 1) / 2;\n        }\n\n        //\
    \ n is even and p is even and x is power of two and y is even and y is power of\
    \ two.\n        if ((n >> 1) & p == 1) {\n            return n + (n - 1) * (n\
    \ - 1) / 2;\n        }\n        // n is even and p is even and x is power of two\
    \ and y is even and y is odd.\n        if ((n >> 1) & p == 0) {\n            return\
    \ n - 1 - (n - 1) / 2;\n        }\n    }\n\n    // n is odd and p is odd\n   \
    \ if n == 1 {\n        return p;\n    }\n\n    // n is odd and p is even\n   \
    \ if n == 0 {\n        return n;\n    }\n\n    // n is even and p is odd\n   \
    \ if p == 1 {\n        return n - (n >> 1);\n    }\n\n    // n is even and p is\
    \ even\n    if p == 0 {\n        return n - 1;\n    }\n\n", "    assert!(p ==\
    \ p || p < 2);\n    n + p - 1", "    if n < 0 {\n        n - (p - 1)\n    } else\
    \ {\n        p - (n - 1)\n    }", "    debug_assert!(n * p <= ::std::i128::MAX);\n\
    \    let mut n = (n as i128) % p;\n    if n == 0 {\n        n = p - 1;\n    }\n\
    \    n", '    n - ((p - 1) & (n - 1))', "    // This could be sped up a bit by\
    \ using a lookup table instead\n    // of division repeatedly.\n    let mut mod\
    \ = p;\n    let mut nn = n as isize;\n    while nn != 0 {\n        mod -= 1;\n\
    \        mod |= mod >> 1;\n        mod |= mod >> 2;\n        mod |= mod >> 4;\n\
    \        mod |= mod >> 8;\n        mod |= mod >> 16;\n        mod |= mod >> 32;\n\
    \        mod &= (mod - 1) as isize;\n        nn >>= 1;\n    }\n    mod", '    (n
    % p) as usize', "    let mut result = n;\n    if n % p != 0 {\n        result\
    \ = n - p;\n    }\n    result", "    let mut n_inv = pow2n(n);\n    let mut result\
    \ = 0;\n    while ((n_inv % p) != 0) {\n        result += 1;\n        n_inv /=\
    \ p;\n    }\n    if n_inv.is_zero() {\n        1\n    } else {\n        result\
    \ + n_inv\n    }", "    if n == 0 {\n        return 0;\n    }\n    let mut a =\
    \ p % n;\n    if a < 0 {\n        a += n;\n    }\n    a", "    let mut ndiv: isize\
    \ = n; // TODO: remove this ugly cast\n    while ndiv > 0 {\n        if ndiv %\
    \ p == 0 {\n            ndiv -= p;\n        } else {\n            break;\n   \
    \     }\n    }\n    ndiv", '    (n % p) as usize', "    let mut result = 0;\n\
    \    while n >= p {\n        n -= p;\n        result += 1\n    }\n    result",
  '    (p * n) % p', '    (n - p) % (p + 1) + (p + 1) % (p + 1) // mod p', "    if\
    \ n > p { return n }\n    if p == 0 { return 0 }\n    if n == p { return 1 }\n\
    \    if n >= p { return modp(n - p, p) }\n    let mut n2 = n;\n    let mut n1\
    \ = n - p;\n    let mut r = n1;\n    while n1 % p == 0 && n1 != 0 {\n        n1\
    \ /= p;\n        n2 /= p;\n        r += 1;\n    }\n    r", "    if n % p != 0\
    \ {\n        n - n - p\n    } else {\n        n\n    }", "    if n <= 0 {\n  \
    \      return 0;\n    }\n    if p <= 0 {\n        return 1;\n    }\n    // We\
    \ need to use |p - n| to make sure that p - n >= 0 for positive integers.\n  \
    \  let mut i = p - 1;\n    // We use |i & (p - 1)| instead of |p| since |p| is\
    \ guaranteed to be positive.\n    while i < n {\n        i = (i << 1) + 1;\n \
    \   }\n    i & (p - 1)", "    let mut result = 1;\n    while n >= 2 {\n      \
    \  result %= p;\n        result *= 2;\n        n -= 1;\n    }\n    n % 2 != 0\
    \ ? result % p : result", "    // return 0 if n < 0\n    if n < 0 {\n        return\
    \ 0;\n    }\n\n    if n < p {\n        return n;\n    }\n\n    let mut result\
    \ = 1;\n    let mut p = p;\n\n    while n > p {\n        result *= p;\n      \
    \  p /= 2;\n    }\n\n    result % p", '    n & (p + 1)', "    debug_assert!(n\
    \ != 0);\n    debug_assert!(p != 0);\n    if n % p == 0 {\n        n - p\n   \
    \ } else {\n        n\n    }", "    if n == 0 {\n        return 1\n    }\n   \
    \ if p < 0 {\n        p *= -1\n    }\n    if p > n*n+n {\n        p %= n*n+n\n\
    \    }\n    let mut q = p - 1;\n    let mut r = n % p;\n    while q > 0 {\n  \
    \      if r >= n {\n            q %= r\n        } else {\n            r %= q\n\
    \        }\n    }\n    return r", '    (n + (p - 1)) % (p + 1)', "    let mut\
    \ res = p;\n    let mut mod = p;\n    while n > 0 {\n        mod += 1;\n     \
    \   res %= mod;\n        n -= 1;\n    }\n    res", '    (p - 1) * (n % p + p)
    % p', '    n & (p - 1) as isize', "    // We start by computing floor(log2(p)).\
    \ If p is even, we use n and\n    // modpow(2, n, p) to get the final result.\
    \ Otherwise, we can use p and\n    // modpow(2, p, n) to get the final result.\n\
    \    let log2_ = p::isize::log2();\n    let log2 = if p & 1 != 0 {\n        p\
    \ >> 1\n    } else {\n        p\n    };\n\n    let mut result = n;\n    let (log2,\
    \ newp) = (log2, p >> 1);\n\n    // Do binary search:\n    while log2 < log2_\
    \ {\n        // Compute the midpoint of our range (2**(log2-log2)):\n        let\
    \ mut mid = result + (result >> 1);\n        // And check whether it's less than\
    \ p\n        if p > mid {\n            result = mid;\n            (log2, newp)\
    \ = (log2, p >> 1);\n        } else {\n            result = mid;\n           \
    \ (log2, newp) = (log2, newp << 1);\n        }\n    }\n\n    result", '    (n
    + (p - 1)) as isize', "    debug_assert!(n >= p);\n    let mut n2 = n;\n    n2\
    \ %= p;\n    while n2 == 0 {\n        n2 += p;\n    }\n    if n2 > p {\n     \
    \   n2 -= p;\n    }\n    n2", "    let mut n1 = n * n / p;\n    let mut n2 = n\
    \ - n1;\n    n1 += n2 % p;\n    n2 -= n2 % p;\n    n1 += n2 % p;\n    n2 -= n2\
    \ % p;\n    n1 += n2 % p;\n    n2 -= n2 % p;\n    n1 %= p;\n    n2 %= p;\n   \
    \ n1 + n2", "    if n & (n - 1) as isize == 0 {\n        return n - p;\n    }\n\
    \    n & (n - 1) as isize + (p - 1) + (n - 1) & (p - 1)", '    (n + p + 1) % p',
  "    if n < 0 {\n        modp(n - p, p)\n    } else {\n        n % (p + 1)\n   \
    \ }", "    if n >= p {\n        n\n    } else {\n        n - p\n    }", '    n
    - p * n', "    let mut i = n;\n    while i > 0 {\n        if n % p == 0 {\n  \
    \          return i;\n        }\n        i -= 1;\n    }\n    1", "    match p\
    \ {\n        0 => 1,\n        1 => n,\n        2 => n % p,\n        _ => {\n \
    \           assert!(n != 0);\n            p % n\n        }\n    }", '    (p -
    1) + (((n / p) & !p) as isize)', "    match p.checked_mul(n as usize) {\n    \
    \    Some(x) => x.checked_mod(p as usize),\n        None => n,\n    }", "    let\
    \ mut res = 0;\n    while n > 0 {\n        res |= (n & 1) << (n % 32);\n     \
    \   n >>= 1;\n    }\n    res ^= p;\n    res %= p;\n    if res < 0 {\n        res\
    \ += p;\n    }\n    res >>= 1;\n    return res;", "    if n == 0 {\n        return\
    \ 1;\n    }\n    n %= p;\n    if n < 0 {\n        n += p;\n    }\n    n", "  \
    \  assert!((p >= 1) && (p <= 100));\n    let mut npow = p;\n    let mut nn = n;\n\
    \    while (nn > 1) {\n        npow = npow % p;\n        nn = nn * p % p;\n  \
    \  }\n    npow", "    if n < 0 {\n        n as isize % (p as isize)\n    } else\
    \ {\n        n as isize % (p as isize) + p as isize\n    }", "    let mut n0 =\
    \ n;\n    while n0 % p == 0 {\n        n0 /= p;\n    }\n    n0", "    assert!(n\
    \ == 0 || p != 0);\n    n & (p - 1)", "    assert!(n > 0);\n    assert!(p > 0);\n\
    \    let mut n: isize = n;\n    let mut remainder: isize = p;\n    let mut ret\
    \ = 1;\n    while n > 0 {\n        remainder, rem = divmod(n - 1, p);\n      \
    \  ret = res * res + rem;\n        n -= 1;\n    }\n    ret * remainder", "   \
    \ // TODO: assert p is coprime\n    let mut q = p;\n    loop {\n        if n %\
    \ q == 0 {\n            return q;\n        }\n        q *= 2;\n    }", '    (p
    - 1)*n + (n % p)', '    n & (p - 1)', "    // we cannot use the much faster bit_xor()\
    \ because that would also fail for n < p.\n    if n < p && p % n == 0 {\n    \
    \    n - (p % n)\n    } else {\n        n\n    }", "    let mut n = n;\n    loop\
    \ {\n        if n < p { break; }\n        n -= p;\n    }\n    n", "    let mut\
    \ r = p % n;\n    if r > 0 {\n        r += n;\n    }\n    r", '    pow(p, n)',
  "    if n <= p {\n        n\n    } else {\n        (p - 1) * (n / p)\n    }", " \
    \   if n == 0 {\n        return 1;\n    }\n    if n < p {\n        return modp(n\
    \ - p, p);\n    }\n    if n < p {\n        return 1;\n    }\n    if n == p {\n\
    \        return n;\n    }\n    if n < p {\n        return modp(n - p, p);\n  \
    \  }\n    let mut dp = p;\n    while n >= dp {\n        dp *= p;\n        n -=\
    \ dp;\n    }\n    n %= p;\n    dp *= p;\n    while n > 0 {\n        dp *= p;\n\
    \        n -= dp;\n    }\n    dp %= p;\n    dp", '    modpow_base(p, n)', "  \
    \  assert!(n == 0 || n == 1);\n    (n + p - 1) % p", '    n - p % n', '    n &
    (p - 1)', "    let mut m = p % n;\n    if m == 0 {\n        m += n;\n    }\n \
    \   m", "    if n >= 0 {\n        (p - 1) % n\n    } else {\n        (n - 1) %\
    \ p\n    }", "    use std::cmp::Ordering;\n    let mut r = n;\n    let mut nn\
    \ = r as isize;\n    let mut rp = rp as isize;\n    while rp >= p {\n        if\
    \ rp < p {\n            nn = nn - 1;\n        }\n        r = r - 1;\n        if\
    \ r < 0 {\n            break;\n        }\n        rp = rp as isize;\n    }\n \
    \   let mut r = r;\n    let mut rpp = rp as isize;\n    while rp >= p {\n    \
    \    if rp < p {\n            nn = nn + 1;\n        }\n        r = r + 1;\n  \
    \      if r > p {\n            break;\n        }\n        rp = rp as isize;\n\
    \    }\n    r", "    let mut s = p;\n    s.checked_mul(n as usize).unwrap();\n\
    \    s", '    (n as isize) % (p as isize)', "    debug_assert!(n <= p);\n    n\
    \ - p.powi(p.bits() - n.bits())", "    let mut rem: isize = 0;\n    while n >=\
    \ p {\n        rem += 1;\n        n -= p;\n    }\n    rem", "    if n < p {\n\
    \        let mut a = n;\n        let mut b = p;\n        while a % b != 0 {\n\
    \            a += b;\n            b += p;\n        }\n        b %= p;\n      \
    \  a\n    } else {\n        p\n    }", "    if n == 0 {\n        return 0;\n \
    \   }\n    if p == 0 {\n        return 1;\n    }\n    let m = p * p % n;\n   \
    \ if m < p && n < m {\n        return m;\n    }\n    if n < p && m % n == 0 {\n\
    \        return n;\n    }\n    if n < m {\n        return n;\n    }\n    return\
    \ m;", "    debug_assert_eq!(n, p % 2, \"Argument must be positive\");\n    n\
    \ / 2 % p", "    match n % p {\n        0 => n - p,\n        1 => n,\n       \
    \ _ => p + (n - p) % p,\n    }", "    if n < 0 || p == 0 {\n        0\n    } else\
    \ {\n        n % (p as usize)\n    }", "    let mut n = n as isize;\n    let mut\
    \ p = p as isize;\n    let mut result = 1;\n    while n >= p && result > 0 {\n\
    \        result = result % p;\n        n /= p;\n    }\n    result", "    let mut\
    \ nn = n;\n    let mut np = p;\n    while nn >= 10 {\n        nn = (nn - n % 10)\
    \ as isize;\n        np = (np - n % 10) as isize;\n    }\n    (nn % p) as isize",
  "    let mut result = p;\n    loop {\n        if n % result < 0 {\n            result\
    \ -= 1;\n        } else {\n            return result + p;\n        }\n    }",
  "    debug_assert!(n > 1);\n    if n == 1 {\n        p - 1\n    } else {\n     \
    \   let mut r = p % n;\n        if r == 0 {\n            r - p / n\n        }\
    \ else {\n            r\n        }\n    }", "    if n == 0 {\n        return 1\n\
    \    }\n    if n <= p {\n        return n\n    }\n    return n % p", "    match\
    \ n {\n        0 => p,\n        _ => n % p,\n    }", "    let mut m = p;\n   \
    \ while m > 1 && n >= pow2(m - 1) {\n        m -= 1;\n    }\n    m", "    let\
    \ r = p % n;\n    if r == 0 {\n        return 1;\n    }\n    return r;", "   \
    \ debug_assert!(n >= 0 && p >= 0);\n    let mut t = n;\n    t %= p;\n    if t\
    \ == 0 {\n        1\n    } else {\n        t * (p + (t & -p))\n    }", '    n
    % (p as u64)', '    if n <= p { n } else { p }', '    n ^ (n >> usize::from(p))',
  "    // use bigint to avoid numeric overflow\n    (1u64 << n).wrapping_add(p.wrapping_mul(1u64\
    \ << n))", "    match n % p {\n        0 => 0,\n        n => n - n % p + p,\n\
    \    }", "    if n == 0 {\n        return 1\n    }\n    n & (n - 1) + (p - 1)\
    \ & p", "    assert!(n > 0);\n    assert!(p > 0);\n    let mut result = p;\n \
    \   for _ in 0..n {\n        result *= 2;\n    }\n    result % p", '    p % n',
  "    let mut result: isize = 1;\n    while result <= n {\n        result *= p;\n\
    \        p /= 2;\n    }\n    result", "    if p <= 1 { return 0 }\n    if n <\
    \ 0 { return 1 }\n    if p < 2 { panic!(\"p should be greater than 1\") }\n  \
    \  if n <= p { return 1 }\n    if n == p { return n }\n    let mut r = 1;\n  \
    \  while n > p { r <<= 1; n -= p }\n    r", "    assert!(p.is_positive());\n\n\
    \    let mut ns: isize = n;\n    while ns < p {\n        ns <<= 1;\n    }\n  \
    \  ns", "    // `p` can't be zero because\n    // `n % p != 0` will fail if `p\
    \ == 0`\n    if p == 0 {\n        p = 1\n    }\n\n    n % p", "    debug_assert!(p\
    \ > 0);\n    let mut n = n as isize;\n    if p == 0 {\n        return 1;\n   \
    \ }\n    while n > p {\n        n -= p;\n    }\n    return n;", '    n % (p +
    p / 2)', "    if p < 2 {\n        return 0;\n    }\n    if p > n {\n        return\
    \ p % n;\n    }\n    p %= n;\n    if p < 2 {\n        return 0;\n    }\n    p\
    \ -= 2;\n    if p < 2 {\n        return p;\n    }\n    p %= n;\n    if p < 3 {\n\
    \        return p;\n    }\n    p -= 3;\n    if p < 3 {\n        return p;\n  \
    \  }\n    p %= n;\n    if p < 5 {\n        return p;\n    }\n    p -= 5;\n   \
    \ if p < 5 {\n        return p;\n    }\n    p %= n;\n    if p < 7 {\n        return\
    \ p;\n    }\n    p -= 7;\n    if p < 7 {\n        return p;\n    }\n    p %= n;\n\
    \    if p < 9 {\n        return p;\n    }\n    p -= 9;\n    if p < 9 {\n     \
    \   return p;\n    }\n    p %= n;\n    if p < 11 {\n        return p;\n    }\n\
    \    p -= 11;\n    if p < 11 {\n        return p;\n    }\n    p %= n;\n    if\
    \ p < 13 {\n        return p;\n    }\n    p -= 13;\n    if p < 13 {\n        return\
    \ p;\n    }\n    p %= n;\n    if p < 15 {\n        return p;\n    }\n    p -=\
    \ 15;\n    if p < 15 {\n        return p;\n    }\n    p %= n;\n    if p < 17 {\n\
    \        return p;\n    }\n    p -= 17;\n    if p < 17 {\n        return p;\n\
    \    }\n    p %= n;\n    if p < 19 {\n        return p;\n    }\n    p -= 19;\n\
    \    if p < 19 {\n        return p;\n    }\n    p %= n;\n    if p < 21 {\n   \
    \     return p;\n    }\n    p -= 21;\n    if p < 21 {\n        return p;\n   \
    \ }\n    p %= n;\n    if p < 23 {\n        return p;\n    }\n    p -= 23;\n  \
    \  if p < 23 {\n        return p;\n    }\n    p %= n;\n    if p < 25 {\n     \
    \   return p;\n    }\n    p -= 25;\n    if p < 25 {\n        return p;\n    }\n\
    \    p %= n;\n    if p < 27 {\n        return p;\n    }\n    p -= 27;\n    if\
    \ p < 27 {\n        return p;\n    }\n    p %= n;\n    if p < 29 {\n        return\
    \ p;\n    }\n    p -= 29;\n    if p < 29 {\n        return p;\n    }\n    p %=\
    \ n;\n    if p ", "    let mut result = n;\n    if result % p != 0 {\n       \
    \ result = result % p;\n    }\n    result", "    if n < p {\n        n + (p -\
    \ n) % p\n    } else {\n        (n - (n mod p)) % p\n    }", "    let mut q =\
    \ p;\n    let mut r = 0x1f;\n    loop {\n        let mut c = 0;\n        while\
    \ r != 0 {\n            if n % r == 0 {\n                c += 1;\n           \
    \ }\n            r = (r - n % r) / 2;\n        }\n        if c == 2n {\n     \
    \       return q;\n        }\n        q -= 1;\n    }", "    let mut res = 0;\n\
    \    while p > 0 {\n        if n & 1 == 1 {\n            res += p;\n         \
    \   n >>= 1;\n        }\n        p >>= 1;\n    }\n    res % p", "    debug_assert_eq!(n,\
    \ 0);\n    debug_assert_eq!(p, 0);\n    1", "    debug_assert!(n > 0);\n    if\
    \ n == 0 {\n        1\n    } else {\n        ((p % n) * n) / n\n    }", '    n.checked_mul(p.clone()).unwrap()',
  '    (p + n - 1) & !(p - 1)', "    mod n\n    mod p\n    mod p", "    if n < p {\
    \ return n }\n    let mut nn = n;\n    for _ in 0..p + 2 {\n        if n % p ==\
    \ 0 {\n            nn /= p;\n        } else {\n            nn %= p;\n        }\n\
    \    }\n    nn", "    if n == 0 {\n        return 0;\n    }\n    if n < 0 {\n\
    \        let mut n = -n;\n        let mut p = -p;\n        let mut res = 1;\n\
    \        while n > 0 {\n            let q = p / n;\n            res *= q;\n  \
    \          n -= q;\n            p = p;\n        }\n        res %= p;\n       \
    \ return res;\n    }\n    let mut res = 1;\n    while n > 0 {\n        let q =\
    \ p / n;\n        res *= q;\n        n -= q;\n    }\n    res %= p;\n    res",
  "    let mut nr = p / 2;\n    let mut d = n - nr;\n    if d > p {\n        d = p;\n\
    \        nr /= 2;\n    }\n    d - nr", "    assert!(n >= 0, \"modulus can't be\
    \ negative number\");\n    if n == 0 {\n        1\n    } else if n == 1 {\n  \
    \      p\n    } else {\n        modp(n >> 1, p)\n            * (p - 1)\n     \
    \       + (n % p)\n            * (modp(n & -n, p))\n    }", "    if n < 0 {\n\
    \        return modp(n - 1, p) * p;\n    }\n    if p == 0 {\n        return 1;\n\
    \    }\n    let mut res = 1;\n    while n > 0 {\n        let r = n % p;\n    \
    \    n /= p;\n        res = (res * r) % p;\n    }\n    res", "    debug_assert!((n\
    \ >> p) == 0);\n    let mut result = n >> p;\n    while (n > 1) {\n        n >>=\
    \ 1;\n        result |= n & p;\n    }\n    result", '    (((n % p) + p) % p)',
  "    if n == 0 {\n        return p;\n    }\n    if n == 1 {\n        return 1;\n\
    \    }\n    if p < n {\n        let mut q: usize = n - p;\n        while q > 0\
    \ {\n            q = q >> 1;\n        }\n        return q;\n    }\n    let mut\
    \ q = p - 1;\n    while q > 0 {\n        q = q >> 1;\n    }\n    q", "    if n\
    \ < 0 {\n        p\n    } else {\n        n - p\n    }", '    n % p', "    let\
    \ mut ret = 1;\n    let mut q: isize = p;\n    while q > 0 {\n        if n % q\
    \ == 0 {\n            ret *= q;\n            n /= q;\n        } else {\n     \
    \       q *= q;\n        }\n    }\n    ret % p", "    if n >= p {\n        n -\
    \ p\n    } else {\n        mod (n, p)\n    }", '    n < p || (n % p) + (n - n
    % p) % p', '    (n - 1) % p + 1', "    let mut result = n;\n    if p % 2 == 0\
    \ {\n        result = result - 1;\n    }\n    result % p", "    // Use division\
    \ to avoid truncating towards zero\n    // or overflow if n is very large.\n \
    \   (n as i64) / p as isize", '    (n & (p - 1)) - (p & (n - 1))', "    let mut\
    \ result = n;\n    while result > p {\n        result -= p;\n    }\n    result",
  "    if n < p {\n        if n < 0 {\n            n - p\n        } else {\n     \
    \       n + p\n        }\n    } else {\n        n - p\n    }", "    let mut a\
    \ = p;\n    if a < n {\n        a = a;\n    }\n    n -= a;\n    a %= p;\n    if\
    \ a < 0 {\n        a += p;\n    }\n    a", "    assert!(n >= 0);\n    assert!(p\
    \ == 0 || p % n == 0);\n    if n == 0 {\n        return 1;\n    }\n    if n ==\
    \ 1 {\n        return 0;\n    }\n    let m = p / n;\n    let t = p - m * n;\n\
    \    if t == m {\n        return m;\n    }\n    if t == 0 {\n        return m;\n\
    \    }\n    return m;", "    match p {\n        0 => 1,\n        1 => n,\n   \
    \     _ => {\n            assert!(n > p);\n            let mut result = n;\n \
    \           while n > p && result % p != 0 {\n                result /= p;\n \
    \           }\n            result\n        }\n    }", "    let mut npow = pow(p,\
    \ n);\n    while npow % p != 0 {\n        npow = pow(npow, p);\n    }\n    npow",
  "    assert!(p.is_even());\n    n + ((n + 1) & (p - 1))", '    (n as isize) % (p
    as isize) as isize', '    (p + n) % p', '    (n % p) as isize', "    assert_eq!(n,\
    \ p.bit_len());\n    n & !(p-1)", '    (((n as usize) * p + 0x1f642) % (p - 0x1f642))
    as isize', '    (1<<(n)) % ((1<<p)) - 1 - (n & p)', "    assert!(n > 0 && p >\
    \ 0);\n    if n < p { n } else { p }", "    if n < 0 {\n        std::ipow(p, n)\n\
    \    } else {\n        n / p\n    }", '    n & -p | n', "    debug_assert!(n >\
    \ 0);\n    debug_assert!(p > 0);\n    debug_assert!(n % p != 0);\n    debug_assert!(p\
    \ <= 64);\n    debug_assert!(p >= -64);\n\n    let mut r = n / p;\n    let mut\
    \ q = 0;\n    while q * p < n {\n        q <<= 1;\n    }\n    while r > 0 {\n\
    \        debug_assert!(p < 64);\n        debug_assert!(r < 64);\n        debug_assert!(q\
    \ >= 0);\n        debug_assert!(q < 64);\n        debug_assert!(p <= 64);\n  \
    \      debug_assert!(p > -64);\n        debug_assert!(q * p >= n);\n        debug_assert!(r\
    \ * p >= n);\n\n        let mask = (p + q) << (64 - p);\n        let mut tmp =\
    \ mask & r ^ mask;\n        r = (r - tmp) % p;\n        q = (q - tmp) / p;\n \
    \   }\n    if r < 0 {\n        r += p;\n    }\n    r", '    mod n { n % p }',
  "    debug_assert!(n > 1);\n    if p == 0 {\n        return 1;\n    }\n    if n\
    \ <= p {\n        return n;\n    }\n    debug_assert!(p > 0);\n    if n <= (p\
    \ / 2) {\n        n - (p / 2)\n    } else {\n        n + (p / 2)\n    }", "  \
    \  if p < 2 {\n        return 0;\n    }\n\n    if n > p {\n        let tmp = n;\n\
    \        n = p;\n        p = tmp;\n    }\n\n    let mut res = p % n;\n    while\
    \ (res < 0) {\n        res += p;\n    }\n    res", "    let mut i = p;\n    while\
    \ i > 1 {\n        i /= 2;\n    }\n    if i <= 0 {\n        i\n    } else {\n\
    \        n % i\n    }", "    let mut ret = n;\n    let mut p2 = p;\n    while\
    \ ret > p2 {\n        ret -= p2;\n        p2 += p;\n    }\n    ret", "    let\
    \ mut res = 0;\n    let mut i = 1u64;\n    while i <= n {\n        let mut rem\
    \ = i % p;\n        if rem == 0 {\n            res += i;\n        }\n        i\
    \ += 1;\n    }\n    res", "    let rem = n % p;\n    if rem == 0 {\n        return\
    \ n\n    } else {\n        return n - rem\n    }", "    let mut t = p % n;\n \
    \   if t < 0 {\n        t += n;\n    }\n    t", "    let mut result = 1;\n   \
    \ while n != 0 {\n        if n % p == 0 {\n            result *= p;\n        \
    \    n /= p;\n        }\n        p /= 2;\n    }\n    result", "    assert!(n ==\
    \ 0 || (n & (n - 1)) == 0);\n    assert!(p != 0 && p != 1);\n\n    let mut n =\
    \ n as isize;\n    let mut p = p as isize;\n\n    while n != 1 {\n        n >>=\
    \ 1;\n        p += 1;\n    }\n\n    n >>= 1;\n    p", '    n & (p - 1)', "   \
    \ assert_eq!(n, p.into());\n\n    if n < 0 {\n        n = -p;\n    }\n\n    (n\
    \ - p.into()) % (p.into())"]
stop_tokens:
- "\n}"
