language: rs
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // Algorithm below is an adaptation of http://codereview.stackexchange.com/questions/98432/palindrome-detection-using-knuth-morris-pratte-algorithm\n\
    \n    let max_palindrome_length: usize = string.chars().max_by_key(|c| *c).unwrap();\n\
    \n    // The longest palindrome that starts with string is just the\n    // reversed\
    \ original string\n    let prefix: String = string[..max_palindrome_length];\n\
    \n    // Find the longest palindrome that starts with prefix\n    let suffix:\
    \ String = string\n        .chars()\n        .filter_map(|c| if *c == *max_palindrome_length\
    \ { None } else { Some(c) })\n        .collect::<Vec<_>>()\n        .reverse()\n\
    \        .to_string() + prefix;\n\n    suffix.to_owned()\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6ve_up0.rs:14:40\n   |\n\
    14 |     let max_palindrome_length: usize = string.chars().max_by_key(|c| *c).unwrap();\n\
    \   |                                -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `char`\n   |                                |\n   |\
    \                                expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn6ve_up0.rs:18:26\n   |\n18 |     let prefix: String =\
    \ string[..max_palindrome_length];\n   |                 ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                 |\
    \        |\n   |                 |        expected struct `String`, found `str`\n\
    \   |                 expected due to this\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmpn6ve_up0.rs:23:28\n   |\n23 |         .filter_map(|c|\
    \ if *c == *max_palindrome_length { None } else { Some(c) })\n   |           \
    \                 ^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n  -->\
    \ /tmp/tmpn6ve_up0.rs:23:34\n   |\n23 |         .filter_map(|c| if *c == *max_palindrome_length\
    \ { None } else { Some(c) })\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpn6ve_up0.rs:26:10\n\
    \   |\n26 |         .to_string() + prefix;\n   |          ^^^^^^^^^ `()` cannot\
    \ be formatted with the default formatter\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(): std::fmt::Display`\n           which\
    \ is required by `(): ToString`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string.as_str();\n    let len = string.len();\n    let mut\
    \ palindrome = String::with_capacity(len + 2);\n    let mut last_is_palindrome\
    \ = true;\n    let mut last_is_prefix = false;\n    for pos in 0..len - 1 {\n\
    \        if last_is_palindrome {\n            string = &string[..pos];\n     \
    \       last_is_prefix = false;\n        }\n        let c = &string[pos];\n  \
    \      if c != reverse c {\n            last_is_palindrome = false;\n        }\n\
    \        if !last_is_prefix {\n            palindrome.push(c);\n        }\n  \
    \      last_is_prefix = true;\n    }\n    palindrome.append(&string[..pos]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpvwfhydib.rs:24:32\n   |\n\
    24 |             last_is_palindrome = false;\n   |                           \
    \    -^\n   |                               |\n   |                          \
    \     help: replace equals symbol with a colon: `:`\n\nerror: expected one of\
    \ `,`, `.`, `?`, `}`, or an operator, found `;`\n  --> /tmp/tmpvwfhydib.rs:24:39\n\
    \   |\n23 |         if c != reverse c {\n   |                         - while\
    \ parsing this struct\n24 |             last_is_palindrome = false;\n   |    \
    \                                   ^ expected one of `,`, `.`, `?`, `}`, or an\
    \ operator\n\nerror: expected `{`, found `c`\n  --> /tmp/tmpvwfhydib.rs:23:25\n\
    \   |\n23 |         if c != reverse c {\n   |         --              ^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n   |\nhelp: try placing this code inside a block\n   |\n23 ~     \
    \    if c != reverse { c {\n24 |             last_is_palindrome = false;\n25 ~\
    \         } }\n   |\n\nerror[E0425]: cannot find value `pos` in this scope\n \
    \ --> /tmp/tmpvwfhydib.rs:31:33\n   |\n31 |     palindrome.append(&string[..pos]);\n\
    \   |                                 ^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpvwfhydib.rs:22:18\n\
    \   |\n22 |         let c = &string[pos];\n   |                  ^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpvwfhydib.rs:31:16\n   |\n\
    31 |     palindrome.append(&string[..pos]);\n   |                ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string[..].to_lowercase();\n    let mut palindrome = String::new();\n\
    \n    // Find the longest postfix of supplied string that is a palindrome\n  \
    \  // by comparing longest prefix with longest suffix.\n    while !string.is_empty()\
    \ {\n        if string.len() > palindrome.len() {\n            palindrome = string;\n\
    \        }\n        let mut i = string.rfind('a');\n        while i != String::npos\
    \ && i >= 0 {\n            string = string.to_owned();\n            i -= 1;\n\
    \            let mut j = string.rfind('a');\n            while (j != String::npos\
    \ && j < i) {\n                string = string[j..].to_owned();\n            \
    \    j += 1;\n            }\n            if string.eq_p(&string[..]) {\n     \
    \           string = string[i..].to_owned();\n            }\n        }\n    }\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpuk2z7zsu.rs:26:19\n\
    \   |\n26 |             while (j != String::npos && j < i) {\n   |           \
    \        ^                          ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n26 -             while\
    \ (j != String::npos && j < i) {\n26 +             while j != String::npos &&\
    \ j < i {\n   | \n\nerror[E0599]: no function or associated item named `npos`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpuk2z7zsu.rs:22:28\n\
    \   |\n22 |         while i != String::npos && i >= 0 {\n   |                \
    \            ^^^^ function or associated item not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuk2z7zsu.rs:22:41\n   |\n22 |         while\
    \ i != String::npos && i >= 0 {\n   |                                        \
    \ ^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |         while i != String::npos && i >= Some(0) {\n   |          \
    \                               +++++ +\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmpuk2z7zsu.rs:24:13\n\
    \   |\n24 |             i -= 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `-=` on type `Option<usize>`\n\nerror[E0599]: no\
    \ function or associated item named `npos` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpuk2z7zsu.rs:26:33\n   |\n26 |             while (j != String::npos\
    \ && j < i) {\n   |                                 ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `RangeFrom<Option<usize>>`\n  --> /tmp/tmpuk2z7zsu.rs:27:26\n   |\n27 | \
    \                string = string[j..].to_owned();\n   |                      \
    \    ^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  \
    \ |\n   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the fol"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        return string;\n    }\n    let (prefix_palindrom,\
    \ suffix_palindrome) = split_palindrome(string);\n    let mut string = string;\n\
    \    string.push_str(&suffix_palindrome[..prefix_palindrome.len()]);\n    string.push_str(&prefix_palindrome[..suffix_palindrome.len()]);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `split_palindrome` in this scope\n \
    \ --> /tmp/tmp0lm24krf.rs:15:49\n   |\n15 |     let (prefix_palindrom, suffix_palindrome)\
    \ = split_palindrome(string);\n   |                                          \
    \       ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `prefix_palindrome` in this scope\n  --> /tmp/tmp0lm24krf.rs:17:42\n \
    \  |\n17 |     string.push_str(&suffix_palindrome[..prefix_palindrome.len()]);\n\
    \   |                                          ^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `prefix_palindrom`\n\nerror[E0425]: cannot\
    \ find value `prefix_palindrome` in this scope\n  --> /tmp/tmp0lm24krf.rs:18:22\n\
    \   |\n18 |     string.push_str(&prefix_palindrome[..suffix_palindrome.len()]);\n\
    \   |                      ^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `prefix_palindrom`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = string;\n    let mut prefix = string;\n    let mut index\
    \ = 0;\n    let mut reverse_index = 0;\n    let mut current_char = 0;\n    let\
    \ mut is_prefix = false;\n\n    while index < suffix.len() {\n        let char\
    \ = suffix[index];\n        current_char = char.to_ascii_lowercase().as_bytes().last().unwrap();\n\
    \        is_prefix = char == current_char;\n        match suffix[index..].iter().rev()\
    \ {\n            None => break,\n            Some(suffix) => current_char = suffix[reverse_index..].iter().rev().next().unwrap().to_ascii_lowercase().as_bytes().last().unwrap(),\n\
    \        };\n\n        if is_prefix {\n            reverse_index += 1;\n     \
    \       prefix += &suffix[index..index].iter().rev().collect::<String>();\n  \
    \      }\n        index += 1;\n    }\n\n    if reverse_index != suffix.len() -\
    \ 2 {\n        reverse_index += 2;\n        prefix += &suffix[reverse_index..].iter().rev().collect::<String>();\n\
    \    }\n    prefix.reverse();\n    String::from(prefix)\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2czi7_q7.rs:20:20\n\
    \   |\n20 |         let char = suffix[index];\n   |                    ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `iter` found for type `str` in the\
    \ current scope\n  --> /tmp/tmp2czi7_q7.rs:23:31\n   |\n23 |         match suffix[index..].iter().rev()\
    \ {\n   |                               ^^^^ method not found in `str`\n\nerror[E0599]:\
    \ no method named `iter` found for type `str` in the current scope\n  --> /tmp/tmp2czi7_q7.rs:30:45\n\
    \   |\n30 |             prefix += &suffix[index..index].iter().rev().collect::<String>();\n\
    \   |                                             ^^^^ method not found in `str`\n\
    \nerror[E0599]: no method named `iter` found for type `str` in the current scope\n\
    \  --> /tmp/tmp2czi7_q7.rs:37:44\n   |\n37 |         prefix += &suffix[reverse_index..].iter().rev().collect::<String>();\n\
    \   |                                            ^^^^ method not found in `str`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp2czi7_q7.rs:39:12\n   |\n39 |     prefix.reverse();\n \
    \  |            ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n\n    for _ in 0..(string.len() / 2) {\n  \
    \      let mut left = &palindrome[..];\n        let mut right = &palindrome[..];\n\
    \n        if left.len() > right.len() {\n            left = &left[..];\n     \
    \   }\n\n        if right.len() > left.len() {\n            right = &right[..];\n\
    \        }\n\n        let mut reversed_left = &left[..];\n        reversed_left.reverse();\n\
    \        reversed_left.push_str(right);\n\n        palindrome = String::from(reversed_left);\n\
    \    }\n\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpr_0lx8yw.rs:27:23\n   |\n27 |         reversed_left.reverse();\n\
    \   |                       ^^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpr_0lx8yw.rs:28:23\n   |\n28 |         reversed_left.push_str(right);\n\
    \   |                       ^^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut max_length = 0;\n    let mut result = \"\";\n    let mut start =\
    \ String::from(\"\");\n    for character in string.chars() {\n        if character\
    \ == start[0] {\n            start = start.clone();\n        } else {\n      \
    \      max_length = character.len_utf8();\n            start = String::from(&character[..max_length]);\n\
    \            result = start.clone().into_reverse() + result;\n            start\
    \ = String::from(&character[max_length..]);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpbb7xj3t1.rs:16:25\n   |\n16 |         if character == start[0] {\n \
    \  |                         ^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpbb7xj3t1.rs:20:35\n\
    \   |\n20 |             start = String::from(&character[..max_length]);\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no\
    \ method named `into_reverse` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpbb7xj3t1.rs:21:36\n   |\n21 |             result = start.clone().into_reverse()\
    \ + result;\n   |                                    ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `into_bytes`\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpbb7xj3t1.rs:22:35\n\
    \   |\n22 |             start = String::from(&character[max_length..]);\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbb7xj3t1.rs:25:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n25 |     result\n   |     ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599, E0608.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = \"a\".to_string();\n    let mut index = string.len();\n\n\
    \    while index > 0 {\n        if index == 1 {\n            break;\n        }\n\
    \n        let c = &string[index..index - 1];\n\n        if c != c.rev() {\n  \
    \          break;\n        }\n\n        index = index - 1;\n        suffix = suffix\
    \ + c;\n    }\n\n    string.push_str(&suffix);\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&str` is not an iterator\n  --> /tmp/tmpb4oxvpz6.rs:22:19\n\
    \   |\n22 |         if c != c.rev() {\n   |                   ^^^ `&str` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `&str: Iterator`\n           which\
    \ is required by `&mut &str: Iterator`\n           `str: Iterator`\n         \
    \  which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debug!(\"make_palindrome(\\\"{}\\\", {:?})\", string, string);\n    // Find\
    \ longest postfix of string\n    let mut string_prefix = string;\n    let mut\
    \ string_suffix = string;\n    let mut max_length = 0;\n    let mut max_length_suffix\
    \ = 1;\n    while !string_prefix.is_empty() {\n        max_length = max_length.max(string_prefix.len()\
    \ as usize);\n        if max_length_suffix > max_length {\n            max_length_suffix\
    \ = 1;\n        }\n        if string_prefix[string_prefix.len() - max_length_suffix..].chars().count()\
    \ != max_length {\n            break;\n        }\n        string_prefix = string_prefix[string_prefix.len()\
    \ - max_length_suffix..];\n    }\n    // If prefix is too long, just append suffix\n\
    \    if max_length_suffix > max_length {\n        string_suffix = &string_suffix[..max_length_suffix];\n\
    \    } else {\n        string_suffix = &string_suffix[..];\n    }\n    debug!(\"\
    make_palindrome(\\\"{}\\\", {:?}) -> {:?}\", string, string_suffix, string);\n\
    \    string_suffix.reverse()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmpxvm3i25b.rs:12:5\n\
    \   |\n12 |     debug!(\"make_palindrome(\\\"{}\\\", {:?})\", string, string);\n\
    \   |     ^^^^^\n\nerror: cannot find macro `debug` in this scope\n  --> /tmp/tmpxvm3i25b.rs:34:5\n\
    \   |\n34 |     debug!(\"make_palindrome(\\\"{}\\\", {:?}) -> {:?}\", string,\
    \ string_suffix, string);\n   |     ^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxvm3i25b.rs:26:25\n   |\n14 |     let mut string_prefix = string;\n\
    \   |                             ------ expected due to this value\n...\n26 |\
    \         string_prefix = string_prefix[string_prefix.len() - max_length_suffix..];\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \       |\n   |                         expected struct `String`, found `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxvm3i25b.rs:30:25\n   |\n15 |\
    \     let mut string_suffix = string;\n   |                             ------\
    \ expected due to this value\n...\n30 |         string_suffix = &string_suffix[..max_length_suffix];\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n30\
    \ |         string_suffix = (&string_suffix[..max_length_suffix]).to_string();\n\
    \   |                         +                                   +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxvm3i25b.rs:32:25\n   |\n15 |\
    \     let mut string_suffix = string;\n   |                             ------\
    \ expected due to this value\n...\n32 |         string_suffix = &string_suffix[..];\n\
    \   |                         ^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n32 |         string_suffix\
    \ = (&string_suffix[..]).to_string();\n   |                         +        \
    \          +++++++++++++\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpxvm3i25b.rs:35:19\n   |\n\
    35 |     string_suffix"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut s = string;\n\
    \    let mut rs = s.chars().collect::<Vec<_>>();\n    rs.reverse();\n    s = s.chars().collect::<String>();\n\
    \    let mut r = String::new();\n    for i in rs {\n        if s.ends_with(&i)\
    \ {\n            r += &s[i];\n        } else {\n            r += i;\n        }\n\
    \    }\n    r\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp1ucadses.rs:21:24\n\
    \   |\n21 |         if s.ends_with(&i) {\n   |              --------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n   |              |\n   |          \
    \    required by a bound introduced by this call\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\nhelp: consider dereferencing\
    \ here\n   |\n21 |         if s.ends_with(*&i) {\n   |                       \
    \ +\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp1ucadses.rs:22:19\n\
    \   |\n22 |             r += &s[i];\n   |                   ^^^^ `String` cannot\
    \ be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1ucadses.rs:24:18\n\
    \   |\n24 |             r += i;\n   |                  ^ expected `&str`, found\
    \ `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut postfix = string;\n    let mut reversed_suffix;\n\n    // First find\
    \ the longest postfix that is a palindrome\n    while let Some(suffix) = postfix\n\
    \        .rsplitn(2, |&b| b == b[..string.reverse().len()])\n        .last()\n\
    \    {\n        reversed_suffix = suffix;\n        if postfix == &*suffix {\n\
    \            break;\n        }\n\n        postfix = &*suffix;\n    }\n\n    //\
    \ The longest postfix which can be reversed\n    let reversed_postfix = &*reversed_suffix;\n\
    \n    // Now lets append reverse of string prefix before the longest postfix.\n\
    \    let mut reversed_prefix = string;\n    while let Some(prefix) = reversed_prefix.split_prefix(&reversed_postfix).last()\
    \ {\n        if !prefix.is_empty() {\n            reversed_prefix += &*prefix;\n\
    \        }\n    }\n\n    reversed_prefix\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpxp1sa6nl.rs:17:42\n   |\n17 |         .rsplitn(2,\
    \ |&b| b == b[..string.reverse().len()])\n   |                               \
    \           ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxp1sa6nl.rs:25:19\n\
    \   |\n12 |     let mut postfix = string;\n   |                       ------ expected\
    \ due to this value\n...\n25 |         postfix = &*suffix;\n   |             \
    \      ^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n25 |         postfix = (&*suffix).to_string();\n\
    \   |                   +        +++++++++++++\n\nerror[E0599]: no method named\
    \ `split_prefix` found for struct `String` in the current scope\n  --> /tmp/tmpxp1sa6nl.rs:33:46\n\
    \   |\n33 |     while let Some(prefix) = reversed_prefix.split_prefix(&reversed_postfix).last()\
    \ {\n   |                                              ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `strip_prefix`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = string;\n    let mut suffix_start_index\
    \ = string.len();\n\n    while suffix_start_index > 0 {\n        let mut suffix_end_index\
    \ = 0;\n\n        for _ in 0..string.len() - suffix_start_index {\n          \
    \  suffix_end_index = suffix_start_index + 1;\n        }\n\n        let mut suffix_prefix\
    \ = &mut suffix[..suffix_start_index];\n\n        let mut suffix_reverse = suffix_prefix.clone();\n\
    \n        suffix_reverse.reverse();\n\n        if suffix_prefix != suffix_reverse\
    \ {\n            suffix_start_index = suffix_end_index;\n        } else {\n  \
    \          break;\n        }\n    }\n\n    string.append(&suffix[..suffix_start_index]);\n\
    \n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `clone` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmp1kwn07d0.rs:25:48\n   |\n25 |     \
    \    let mut suffix_reverse = suffix_prefix.clone();\n   |                   \
    \                             ^^^^^ method not found in `&mut str`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp1kwn07d0.rs:36:12\n   |\n36 |     string.append(&suffix[..suffix_start_index]);\n\
    \   |            ^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut length = 1;\n    let mut suffix = string;\n    while suffix.len()\
    \ > 1 {\n        if suffix.chars().next().unwrap() == suffix.chars().next().unwrap()\
    \ {\n            length += 1\n        } else {\n            break;\n        }\n\
    \    }\n    suffix += &String::from(string[..length]);\n    suffix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp20qzrrwo.rs:21:29\n    |\n21  |     suffix += &String::from(string[..length]);\n\
    \    |                ------------ ^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n    |                |\n    |                required by a\
    \ bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `from`\n\nerror[E0277]: the trait bound\
    \ `String: From<str>` is not satisfied\n  --> /tmp/tmp20qzrrwo.rs:21:16\n   |\n\
    21 |     suffix += &String::from(string[..length]);\n   |                ^^^^^^^^^^^^\
    \ the trait `From<str>` is not implemented for `String`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() <= 1 {\n        return string;\n    }\n\n    let mut postfix\
    \ = String;\n    let mut reverse = String;\n    for s in string.split(\" \").filter(|&s|\
    \ s != \"\") {\n        postfix += s;\n        reverse += String::from(s);\n \
    \   }\n\n    let mut postfix_reversed = String::from(postfix);\n    postfix_reversed.reverse();\n\
    \    let postfix_reversed_prefix = postfix_reversed.split_off(1);\n    reverse\n\
    \        + postfix_reversed_prefix.join().to_string()\n        + String::from(reverse.split_off(1).collect::<String>().reverse().to_string())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found struct `String`\n   --> /tmp/tmpw7adwp8j.rs:16:23\n\
    \    |\n16  |       let mut postfix = String;\n    |                         ^^^^^^\n\
    \    |\nhelp: use struct literal syntax instead\n    |\n16  |     let mut postfix\
    \ = String { vec: val };\n    |                       ~~~~~~~~~~~~~~~~~~~\nhelp:\
    \ a local variable with a similar name exists\n    |\n16  |     let mut postfix\
    \ = string;\n    |                       ~~~~~~\n\nerror[E0423]: expected value,\
    \ found struct `String`\n   --> /tmp/tmpw7adwp8j.rs:17:23\n    |\n17  |      \
    \ let mut reverse = String;\n    |                         ^^^^^^\n    |\nhelp:\
    \ use struct literal syntax instead\n    |\n17  |     let mut reverse = String\
    \ { vec: val };\n    |                       ~~~~~~~~~~~~~~~~~~~\nhelp: a local\
    \ variable with a similar name exists\n    |\n17  |     let mut reverse = string;\n\
    \    |                       ~~~~~~\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpw7adwp8j.rs:24:22\n\
    \   |\n24 |     postfix_reversed.reverse();\n   |                      ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror[E0599]:\
    \ no method named `join` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpw7adwp8j.rs:27:35\n   |\n27 |         + postfix_reversed_prefix.join().to_string()\n\
    \   |                                   ^^^^ method not found in `String`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string\n        .split_ascii_lowercase()\n        .filter_map(|p| p.chars().collect::<Vec<char>>())\n\
    \        .filter_map(|p| {\n            if p == p.rev() {\n                Some(p)\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .max_by_key(|s| s.len())\n        .unwrap_or(string)\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_ascii_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmph2m5t6gt.rs:13:10\n   |\n13 | \
    \        .split_ascii_lowercase()\n   |          ^^^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut rev_string = string;\n    let mut postfix = string.clone();\n   \
    \ while !postfix.is_empty() {\n        let last_letter = postfix.chars().last().unwrap();\n\
    \        if last_letter == last_letter.to_ascii_lowercase().rev().last() {\n \
    \           postfix.pop();\n        } else {\n            break;\n        }\n\
    \    }\n    let mut first_letter = postfix.chars().first().unwrap();\n    rev_string.insert(0,\
    \ &first_letter);\n    rev_string.append(&last_letter);\n    rev_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `last_letter` in this scope\n  --> /tmp/tmpkg1qfv5y.rs:24:24\n\
    \   |\n24 |     rev_string.append(&last_letter);\n   |                       \
    \ ^^^^^^^^^^^ help: a local variable with a similar name exists: `first_letter`\n\
    \nerror[E0599]: `char` is not an iterator\n  --> /tmp/tmpkg1qfv5y.rs:16:60\n \
    \  |\n16 |         if last_letter == last_letter.to_ascii_lowercase().rev().last()\
    \ {\n   |                                                            ^^^ `char`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `char: Iterator`\n           which is required by `&mut char: Iterator`\n\
    \nerror[E0599]: no method named `first` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpkg1qfv5y.rs:22:44\n   |\n22 |     let mut first_letter\
    \ = postfix.chars().first().unwrap();\n   |                                  \
    \          ^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkg1qfv5y.rs:23:26\n   |\n23 |     rev_string.insert(0, &first_letter);\n\
    \   |                          ^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\nhelp:\
    \ consider removing the borrow\n   |\n23 -     rev_string.insert(0, &first_letter);\n\
    23 +     rev_string.insert(0, first_letter);\n   | \n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmpkg1qfv5y.rs:24:16\n\
    \   |\n24 |     rev_string.append(&last_letter);\n   |                ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // Create stack to store palindrome postfix, reverse, postfix, reverse, postfix,\
    \ reverse\n    let mut stack = Vec::new();\n    // Add first postfix to the stack\n\
    \    stack.push(string.to_owned());\n\n    while let Some(postfix) = stack.pop()\
    \ {\n        // Add reverse of the last postfix\n        stack.push((&postfix\
    \ as &str).rev());\n\n        // Add postfix to the end of the stack\n       \
    \ stack.push(postfix);\n    }\n\n    // Take first element from stack\n    let\
    \ postfix = stack.pop().unwrap();\n\n    // Add reverse of the postfix to the\
    \ end of the string\n    string += (&postfix as &str).rev();\n\n    string\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&str` is not an iterator\n  --> /tmp/tmpslf_6ciw.rs:19:39\n\
    \   |\n19 |         stack.push((&postfix as &str).rev());\n   |              \
    \                         ^^^ `&str` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `&str: Iterator`\n           which is required by `&mut &str: Iterator`\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `&str` is not an iterator\n  --> /tmp/tmpslf_6ciw.rs:29:34\n \
    \  |\n29 |     string += (&postfix as &str).rev();\n   |                     \
    \             ^^^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `&str:\
    \ Iterator`\n           which is required by `&mut &str: Iterator`\n         \
    \  `str: Iterator`\n           which is required by `&mut str: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string;\n    let mut suffix_length = 0;\n    for (i, ch)\
    \ in string.chars().enumerate() {\n        if i == 0 || string[i - 1] != ch {\n\
    \            suffix_length = i;\n        }\n    }\n    if suffix_length == 0 {\n\
    \        return result;\n    }\n    let mut suffix_start = suffix_length - (string[suffix_length].len()\
    \ + 1);\n    while suffix_start >= 0 {\n        result = result.push_str(&string[suffix_start\
    \ as usize..suffix_length]);\n        suffix_start -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkl9m3q32.rs:15:22\n\
    \   |\n15 |         if i == 0 || string[i - 1] != ch {\n   |                 \
    \     ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkl9m3q32.rs:22:45\n   |\n22 |     let mut suffix_start = suffix_length\
    \ - (string[suffix_length].len() + 1);\n   |                                 \
    \            ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkl9m3q32.rs:24:18\n   |\n12 |     let mut result\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    24 |         result = result.push_str(&string[suffix_start as usize..suffix_length]);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpkl9m3q32.rs:24:25\n   |\n24 |         result\
    \ = result.push_str(&string[suffix_start as usize..suffix_length]);\n   |    \
    \              -----"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    while string.is_palindrom() {\n        string\
    \ = string.to_string();\n        string.push_front(&string[string.len() - 1]);\n\
    \    }\n    return string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindrom` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmps27u12y2.rs:13:18\n   |\n13 |     while\
    \ string.is_palindrom() {\n   |                  ^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `push_front` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmps27u12y2.rs:15:16\n   |\n15 |         string.push_front(&string[string.len()\
    \ - 1]);\n   |                ^^^^^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps27u12y2.rs:15:28\n\
    \   |\n15 |         string.push_front(&string[string.len() - 1]);\n   |      \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    fn reverse(mut s: String) -> String {\n        s.reverse();\n        s\n\
    \    }\n\n    let mut postfix = string;\n    let mut reversed = \"\";\n    let\
    \ mut found = false;\n\n    while !found {\n        postfix = reverse(postfix);\n\
    \        reversed = reverse + postfix;\n        found = postfix == reversed;\n\
    \    }\n\n    String::from(postfix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `String` to `fn(String) -> String {reverse}`\n\
    \  --> /tmp/tmpxtz89gq2.rs:23:28\n   |\n23 |         reversed = reverse + postfix;\n\
    \   |                    ------- ^ ------- String\n   |                    |\n\
    \   |                    fn(String) -> String {reverse}\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpxtz89gq2.rs:13:11\n\
    \   |\n13 |         s.reverse();\n   |           ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut string_palindrome\
    \ = string;\n    let mut i = string.len();\n    let mut j = string.len();\n  \
    \  let mut palindrome_suffix = &string[..];\n    let mut palindrome_prefix = &string[..];\n\
    \    loop {\n        if j >= i {\n            break;\n        }\n        let mut\
    \ char = string[j];\n        if char == string[i - j] {\n            j = j - 1;\n\
    \            palindrome_suffix += char;\n        } else {\n            i = i -\
    \ 1;\n            palindrome_prefix += char;\n        }\n    }\n    if palindrome_prefix\
    \ != string {\n        string_palindrome.push(palindrome_prefix);\n    }\n   \
    \ if palindrome_suffix != string {\n        string_palindrome.push(palindrome_suffix);\n\
    \    }\n    return string_palindrome;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp17mn92np.rs:24:24\n\
    \   |\n24 |         let mut char = string[j];\n   |                        ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp17mn92np.rs:25:20\n   |\n25 |         if char == string[i - j]\
    \ {\n   |                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp17mn92np.rs:27:13\n   |\n27 |             palindrome_suffix\
    \ += char;\n   |             -----------------^^^^^^^^\n   |             |\n \
    \  |             cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp17mn92np.rs:30:13\n\
    \   |\n30 |             palindrome_prefix += char;\n   |             -----------------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp17mn92np.rs:34:32\n   |\n34 |         string_palindrome.push(palindrome_prefix);\n\
    \   "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    while string.len() > 0 {\n        let index\
    \ = string[string.len() - 1];\n        let mut prefix_string = string.clone();\n\
    \        let mut prefix_index = -1;\n        while prefix_index >= 0 {\n     \
    \       if prefix_string[prefix_index] != string[index] {\n                break;\n\
    \            }\n            prefix_index += 1;\n        }\n        prefix_string\
    \ = prefix_string.clone();\n        if prefix_index >= 0 {\n            prefix_string[prefix_index]\
    \ = &string[index];\n            string = prefix_string.to_string();\n       \
    \ }\n    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpymwqmq66.rs:14:21\n\
    \   |\n14 |         let index = string[string.len() - 1];\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpymwqmq66.rs:18:16\n\
    \   |\n18 |             if prefix_string[prefix_index] != string[index] {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpymwqmq66.rs:25:13\n   |\n25 |             prefix_string[prefix_index]\
    \ = &string[index];\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n          "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        return string;\n    }\n\n    let mut prefix\
    \ = string.clone();\n    let mut suffix = string.clone();\n\n    let mut reversed_prefix:\
    \ String = String::new();\n    let mut reversed_suffix: String = String::new();\n\
    \n    while let Some(letter) = prefix.chars().next().unwrap().to_string().chars().last().unwrap()\
    \ {\n        reversed_prefix.push_front(letter);\n    }\n    while let Some(letter)\
    \ = suffix.chars().next().unwrap().to_string().chars().last().unwrap() {\n   \
    \     reversed_suffix.push(letter);\n    }\n\n    let longest = if let Some(letter)\
    \ = reversed_prefix.chars().next().unwrap().to_string().chars().last().unwrap()\
    \ {\n        String::from(&letter)\n    } else {\n        String::from(\"\")\n\
    \    };\n    let prefix = &*longest;\n    let reversed_prefix = &reversed_prefix;\n\
    \    let suffix = &*reversed_suffix;\n    let reversed_suffix = &reversed_suffix;\n\
    \n    let reversed_prefix_and_suffix: &String = String::from(reversed_prefix +\
    \ prefix + suffix);\n\n    let reversed_prefix_and_suffix_len = reversed_prefix_and_suffix.len();\n\
    \n    // We now know length of the longest palindromic prefix and suffix.\n  \
    \  // The remainder (without prefix/suffix) is now the palindrome.\n\n    if reversed_prefix_and_suffix_len\
    \ > string.len() {\n        return string;\n    }\n\n    let mut reversed_remainder\
    \ = String::new();\n    let mut remainder = string.clone();\n\n    for i in 0..(string.len()\
    \ - 1) {\n        let letter = remainder.chars().next().unwrap().to_string();\n\
    \        remainder.push_front(letter);\n    }\n\n    for i in 0..(string.len()\
    \ - 1) {\n        let letter = remainder.chars().next().unwrap().to_string();\n\
    \        remainder.push(letter);\n    }\n\n    let palindrome = &*remainder;\n\
    \n    reversed_remainder.clear();\n    remainder.clear();\n\n    for i in 0..(palindrome.len()\
    \ - 1) {\n        let letter = &palindrome[i];\n        reversed_remainder.push_front(letter);\n\
    \    }\n\n    for i in 0..(palindrome.len() - 1) {\n        let letter = &palindrome[i];\n\
    \        remainder.push(letter);\n    }\n\n    String::from(reversed_remainder\
    \ + palindrome + reversed_remainder)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdbp4gydw.rs:22:15\n   |\n\
    22 |     while let Some(letter) = prefix.chars().next().unwrap().to_string().chars().last().unwrap()\
    \ {\n   |               ^^^^^^^^^^^^   ------------------------------------------------------------------\
    \ this expression has type `char`\n   |               |\n   |               expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<_>`\n\nerror[E0599]: no method named `push_front` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpdbp4gydw.rs:23:25\n\
    \   |\n23 |         reversed_prefix.push_front(letter);\n   |                \
    \         ^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdbp4gydw.rs:25:15\n   |\n25 |     while let Some(letter)\
    \ = suffix.chars().next().unwrap().to_string().chars().last().unwrap() {\n   |\
    \               ^^^^^^^^^^^^   ------------------------------------------------------------------\
    \ this expression has type `char`\n   |               |\n   |               expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbp4gydw.rs:29:26\n\
    \   |\n29 |     let longest = if let Some(letter) = reversed_prefix.chars().next().unwrap().to_string().chars().last().unwrap()\
    \ {\n   |                          ^^^^^^^^^^^^   ---------------------------------------------------------------------------\
    \ this expression has type `char`\n   |                          |\n   |     \
    \                     expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0369]: cannot add\
    \ `&str` to `&String`\n  --> /tmp/tmpdbp4gydw.rs:39:76\n   |\n39 |     let reversed_prefix_and_suffix:\
    \ &String = String::from(reversed_prefix + prefix + suffix);\n   |           \
    \                                                 --------------- ^ ------ &str\n\
    \   |                                                            |           \
    \    |\n   |          "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix = string;\n    let mut longest = prefix.chars().max_by_key(|c|\
    \ c.len());\n    if longest == prefix.chars().max_by_key(|c| c.len()) {\n    \
    \    return string;\n    }\n    let mut suffix_to_prepend = longest.clone() +\
    \ &longest[prefix.chars().count() - longest.len()];\n    suffix_to_prepend = suffix_to_prepend.clone();\n\
    \    prefix.chars().rev().take_while(|&c| c != longest && !suffix_to_prepend.contains(c)).cloned()\n\
    \        .extend(reverse(suffix_to_prepend.clone()));\n    prefix + suffix_to_prepend\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmp9xbwrp5u.rs:20:17\n\
    \   |\n20 |         .extend(reverse(suffix_to_prepend.clone()));\n   |       \
    \          ^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `len`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmp9xbwrp5u.rs:13:55\n\
    \   |\n13 |     let mut longest = prefix.chars().max_by_key(|c| c.len());\n  \
    \ |                                                       ^^^ method not found\
    \ in `&char`\n\nerror[E0599]: no method named `len` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9xbwrp5u.rs:14:51\n   |\n14 |     if longest\
    \ == prefix.chars().max_by_key(|c| c.len()) {\n   |                          \
    \                         ^^^ method not found in `&char`\n\nerror[E0599]: no\
    \ method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmp9xbwrp5u.rs:17:93\n\
    \   |\n17 |     let mut suffix_to_prepend = longest.clone() + &longest[prefix.chars().count()\
    \ - longest.len()];\n   |                                                    \
    \                                         ^^^ method not found in `Option<char>`\n\
    \nerror[E0608]: cannot index into a value of type `Option<char>`\n  --> /tmp/tmp9xbwrp5u.rs:17:52\n\
    \   |\n17 |     let mut suffix_to_prepend = longest.clone() + &longest[prefix.chars().count()\
    \ - longest.len()];\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9xbwrp5u.rs:19:47\n   |\n19 |\
    \     prefix.chars().rev().take_while(|&c| c != longest && !suffix_to_prepend.contains(c)).cloned()\n\
    \   |                                               ^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<char>`\n\nerror[E0271]: type mismatch resolving `<TakeWhile<Rev<Chars<'_>>,\
    \ [closure@/tmp/tmp9xbwrp5u.rs:19:37: 19:88]> as Iterator>::Item == &_`\n    -->\
    \ /tmp/tmp9xbwrp5u.rs:19:90\n     |\n19   |     prefix.chars().rev().take_while(|&c|\
    \ c != longest && !suffix_to_prepend.contains(c"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if let Some(suffix) = string.rsplit_iter(|c| c == char::reverse && c != '\\\
    0') {\n        suffix\n            .iter()\n            .map(|c| String::from(c))\n\
    \            .fold(\"\", |mut acc, x| {\n                acc.push(x.to_string());\n\
    \                acc.reverse();\n                acc\n            })\n    } else\
    \ {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rsplit_iter` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpm7nj0zt9.rs:12:34\n   |\n12 |     if let Some(suffix)\
    \ = string.rsplit_iter(|c| c == char::reverse && c != '\\0') {\n   |         \
    \                         ^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `rsplit`\n\nerror[E0599]: no function or associated item named\
    \ `reverse` found for type `char` in the current scope\n  --> /tmp/tmpm7nj0zt9.rs:12:61\n\
    \   |\n12 |     if let Some(suffix) = string.rsplit_iter(|c| c == char::reverse\
    \ && c != '\\0') {\n   |                                                     \
    \        ^^^^^^^ function or associated item not found in `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    reverse.reverse();\n\n    let mut prefix:\
    \ String = string;\n    prefix.truncate(prefix.len() - 1);\n\n    let mut suffix\
    \ = reverse;\n    suffix.truncate(suffix.len() - 1);\n\n    prefix.append(&suffix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpi17yzva8.rs:13:13\n   |\n13 |     reverse.reverse();\n\
    \   |             ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpi17yzva8.rs:21:12\n   |\n21 |     prefix.append(&suffix)\n\
    \   |            ^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        return string;\n    }\n\n    let mut suffix\
    \ = \"ab\";\n    let mut i = 1; // start from 1\n    let mut i_s2 = 1; // start\
    \ from 1, because we reverse first string from suffix\n    let mut s0 = String::from(string);\n\
    \    let mut p0 = String::from(\"\");\n    let mut p1 = String::from(\"\");\n\n\
    \    while i <= string.len() {\n        p0 = p0.as_str().append(&string[i - s0.len()]);\n\
    \n        let mut is_palindrome = true;\n        let mut j = 1;\n        let mut\
    \ j_s2 = 1;\n\n        while j <= string.len() {\n            p1 = p1.as_str().append(&string[j_s2\
    \ - j]);\n\n            if p0.len() > p1.len() {\n                break;\n   \
    \         }\n\n            if p0 == p1 {\n                is_palindrome = true;\n\
    \                break;\n            }\n\n            if p0.len() < p1.len() {\n\
    \                is_palindrome = false;\n                break;\n            }\n\
    \n            j = j + 2;\n            j_s2 = j_s2 + 2;\n        }\n\n        if\
    \ is_palindrome {\n            return s0;\n        }\n\n        i = i + 1;\n \
    \       s0 = s0.clone();\n    }\n\n    p0\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpzgrdt8mg.rs:24:26\n   |\n24 |         p0 = p0.as_str().append(&string[i\
    \ - s0.len()]);\n   |                          ^^^^^^ method not found in `&str`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzgrdt8mg.rs:24:34\n\
    \   |\n24 |         p0 = p0.as_str().append(&string[i - s0.len()]);\n   |    \
    \                              ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `append` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpzgrdt8mg.rs:31:30\n   |\n31 |          \
    \   p1 = p1.as_str().append(&string[j_s2 - j]);\n   |                        \
    \      ^^^^^^ method not found in `&str`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpzgrdt8mg.rs:31:38\n   |\n31 |         \
    \    p1 = p1.as_str().append(&string[j_s2 - j]);\n   |                       \
    \               ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations: "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string\n        .rsplit_at(string.len())\n        .map(|word| {\n       \
    \     if !word.starts_with(word) {\n                return word;\n           \
    \ }\n            word\n                .rsplit('a', 2)\n                .next()\n\
    \                .to_string()\n                .rsplit('a', 2)\n             \
    \   .next()\n                .to_string()\n        })\n        .filter_map(|x|\
    \ x.ok())\n        .fold(\"\", |s, w| s + &w[..]);\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rsplit_at` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpjrdfdjxh.rs:13:10\n   |\n13 |         .rsplit_at(string.len())\n\
    \   |          ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `rsplit`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjrdfdjxh.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let len = string.len();\n    let mut suffix_reverse = \"\";\n    let mut\
    \ suffix_postfix = \"\";\n    let mut suffix_reverse_index = 0;\n    let mut prefix_postfix\
    \ = \"\";\n    let mut prefix_reverse_index = 0;\n\n    // Find longest postfix\
    \ of string that is a palindrome\n    let mut longest_postfix = String::from(\"\
    \");\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = 0;\n    for j in (0..len).rev() {\n        if j > longest_postfix_end {\n\
    \            longest_postfix_start = j;\n            longest_postfix_end = 0;\n\
    \        }\n\n        if string[j] != string[len - 1 - j] {\n            longest_postfix_end\
    \ += 1;\n            if longest_postfix_end > longest_postfix_start {\n      \
    \          longest_postfix = string[j..j + longest_postfix_end];\n           \
    \ }\n        }\n    }\n\n    // Prefix string that comes before the longest postfix\n\
    \    let mut prefix_postfix_start = -1;\n    let mut prefix_postfix_end = 0;\n\
    \    for j in (0..len).rev() {\n        if j > prefix_postfix_end {\n        \
    \    prefix_postfix_start = j;\n            prefix_postfix_end = 0;\n        }\n\
    \n        if string[j] != string[len - 1 - j] {\n            prefix_postfix_end\
    \ += 1;\n            if prefix_postfix_end > prefix_postfix_start {\n        \
    \        prefix_postfix = string[prefix_postfix_start..prefix_postfix_end];\n\
    \            }\n        }\n    }\n\n    // Append longest postfix to the beginning\
    \ of the string\n    suffix_reverse += longest_postfix;\n    // Append reverse\
    \ of the string prefix to the end of the string\n    suffix_reverse += string[prefix_postfix_start..prefix_postfix_end].chars().collect::<String>().rev().collect::<String>();\n\
    \n    suffix_postfix += longest_postfix.chars().collect::<String>().rev();\n \
    \   suffix_postfix += string[prefix_postfix_start..prefix_postfix_end].chars().collect::<String>().rev();\n\
    \n    suffix_reverse = suffix_reverse.into();\n    suffix_postfix = suffix_postfix.into();\n\
    \n    // Return longest postfix that is a palindrome\n    String::from(suffix_reverse)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp9x7iypi3.rs:21:37\n\
    \   |\n21 |     let mut longest_postfix_start = -1;\n   |                    \
    \                 ^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9x7iypi3.rs:29:12\n\
    \   |\n29 |         if string[j] != string[len - 1 - j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9x7iypi3.rs:29:25\n   |\n29 |         if string[j] != string[len\
    \ - 1 - j] {\n   |                         ^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9x7iypi3.rs:32:35\n\
    \   |\n20 |     let mut longest_postfix = String::from(\"\");\n   |          \
    \                     ---------------- expecte"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let (longest_palindromic_part, rest_of_string) = string.rsplit(|c| !c.is_alphanumeric());\n\
    \    let (longest_palindromic, rest_of_string) = longest_palindromic_part.split_off(1);\n\
    \    let (longest_palindromic, rest_of_string) = longest_palindromic.split_off(0);\n\
    \    longest_palindromic + &*longest_palindromic &*rest_of_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpxg3rbpia.rs:12:69\n\
    \   |\n12 |     let (longest_palindromic_part, rest_of_string) = string.rsplit(|c|\
    \ !c.is_alphanumeric());\n   |                                               \
    \                      ^ consider giving this closure parameter a type\n   |\n\
    \   = note: type must be known at this point\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxg3rbpia.rs:12:9\n   |\n12 |     let (longest_palindromic_part,\
    \ rest_of_string) = string.rsplit(|c| !c.is_alphanumeric());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \   --------------------------------------- this expression has type `std::str::RSplit<'_,\
    \ _>`\n   |         |\n   |         expected struct `std::str::RSplit`, found\
    \ tuple\n   |\n   = note: expected struct `std::str::RSplit<'_, _>`\n        \
    \       found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0282, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string\n        .chars()\n        .flat_map(|c| {\n            match c.to_ascii_lowercase()\
    \ {\n                \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"\
    h\" | \"i\" | \"j\" | \"k\" => {\n                    if c.to_ascii_lowercase()\
    \ == c.to_ascii_lowercase()[..] {\n                        let reversed = c[..].to_ascii_lowercase().rev().collect::<String>();\n\
    \                        if reversed == c {\n                            Some(c)\n\
    \                        } else {\n                            None\n        \
    \                }\n                    } else {\n                        None\n\
    \                    }\n                }\n                _ => None\n       \
    \     }\n        })\n        .filter(|c| c != None)\n        .collect::<String>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqbsv4cnl.rs:16:17\n   |\n\
    15 |             match c.to_ascii_lowercase() {\n   |                   ----------------------\
    \ this expression has type `char`\n16 |                 \"a\" | \"b\" | \"c\"\
    \ | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" => {\n   | \
    \                ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqbsv4cnl.rs:16:23\n   |\n15 |             match c.to_ascii_lowercase()\
    \ {\n   |                   ---------------------- this expression has type `char`\n\
    16 |                 \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"\
    h\" | \"i\" | \"j\" | \"k\" => {\n   |                       ^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqbsv4cnl.rs:16:29\n\
    \   |\n15 |             match c.to_ascii_lowercase() {\n   |                 \
    \  ---------------------- this expression has type `char`\n16 |              \
    \   \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"\
    j\" | \"k\" => {\n   |                             ^^^ expected `char`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqbsv4cnl.rs:16:35\n\
    \   |\n15 |             match c.to_ascii_lowercase() {\n   |                 \
    \  ---------------------- this expression has type `char`\n16 |              \
    \   \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"\
    j\" | \"k\" => {\n   |                                   ^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqbsv4cnl.rs:16:41\n\
    \   |\n15 |             match c.to_ascii_lowercase() {\n   |                 \
    \  ---------------------- this expression has type `char`\n16 |              \
    \   \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"\
    j\" | \"k\" => {\n   |                                         ^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqbsv4cnl.rs:16:47\n\
    \   |\n15 |             match c.to_ascii_lowercase() {\n   |                 \
    \  ---------------------- this expression has type `char`\n16 |              \
    \   \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"\
    j\" | \"k\" => {\n   |"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debug_assert_eq!(string.length(), 1, \"input must be of size 1\");\n    let\
    \ mut result = string;\n    for ch in string.chars().rev() {\n        if ch !=\
    \ ch {\n            result = &result.to_ascii_lowercase()[..] + &ch;\n       \
    \     break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp41rls4uy.rs:12:29\n   |\n12 |     debug_assert_eq!(string.length(),\
    \ 1, \"input must be of size 1\");\n   |                             ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0369]:\
    \ cannot add `&char` to `&str`\n  --> /tmp/tmp41rls4uy.rs:16:55\n   |\n16 |  \
    \           result = &result.to_ascii_lowercase()[..] + &ch;\n   |           \
    \           -------------------------------- ^ --- &char\n   |               \
    \       |\n   |                      &str\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let string = &string.to_string();\n    let mut postfix_iter = string.char_indices().rev();\n\
    \    let mut reversed_prefix_str = \"\";\n    for postfix_pos in postfix_iter\
    \ {\n        let reverse_suffix = (*postfix_pos).reverse();\n        reversed_prefix_str.push(reverse_suffix);\n\
    \    }\n\n    let mut reverse_suffix_str = reversed_prefix_str[..];\n    &reverse_suffix_str\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmpaz9t_ues.rs:16:30\n\
    \   |\n16 |         let reverse_suffix = (*postfix_pos).reverse();\n   |     \
    \                         ^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpaz9t_ues.rs:17:29\n\
    \   |\n17 |         reversed_prefix_str.push(reverse_suffix);\n   |          \
    \                   ^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaz9t_ues.rs:21:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n21 |     &reverse_suffix_str\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n21 |     (&reverse_suffix_str).to_string()\n\
    \   |     +                   +++++++++++++\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpaz9t_ues.rs:20:9\n\
    \   |\n20 |     let mut reverse_suffix_str = reversed_prefix_str[..];\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n20 |     let mut\
    \ reverse_suffix_str = &reversed_prefix_str[..];\n   |                       \
    \           +\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    reversed_string.rev();\n    reversed_string.push(reversed_string.clone().iter().rev().take());\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpy2p0mp7d.rs:13:21\n\
    \    |\n13  |       reversed_string.rev();\n    |                       ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: no method\
    \ named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpy2p0mp7d.rs:14:50\n\
    \   |\n14 |     reversed_string.push(reversed_string.clone().iter().rev().take());\n\
    \   |                                                  ^^^^ method not found in\
    \ `String`\n   |\nhelp: because of the in-memory representation of `&str`, to\
    \ obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n14\
    \ |     reversed_string.push(reversed_string.clone().chars().rev().take());\n\
    \   |                                                  ~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debug_assert!(string.len() >= 2);\n\n    let mut palindrome = string;\n \
    \   let mut i = 1;\n    while i < string.len() {\n        let j = string.len()\
    \ - i;\n        if palindrome[j..].iter().zip(&palindrome[i..j]).all(|&(l, r)|\
    \ l == r) {\n            palindrome += \"_\";\n            i += 1;\n        }\
    \ else {\n            break;\n        }\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n  --> /tmp/tmp02ee2fhj.rs:18:28\n   |\n18 |         if palindrome[j..].iter().zip(&palindrome[i..j]).all(|&(l,\
    \ r)| l == r) {\n   |                            ^^^^ method not found in `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut suffixes = vec![];\n    for suffix\
    \ in string.split_first_by_char() {\n        suffixes.push(suffix);\n        let\
    \ longest_postfix = suffixes.iter().map(|s| s.chars().max().unwrap()).sum();\n\
    \        palindrome = &palindrome[..longest_postfix];\n    }\n    palindrome.push(&palindrome[..string.length()]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_first_by_char` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpgl5sv7sb.rs:14:26\n   |\n14 |     for suffix\
    \ in string.split_first_by_char() {\n   |                          ^^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgl5sv7sb.rs:17:22\n\
    \   |\n12 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n17 |         palindrome = &palindrome[..longest_postfix];\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n17 |        \
    \ palindrome = (&palindrome[..longest_postfix]).to_string();\n   |           \
    \           +                              +++++++++++++\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpgl5sv7sb.rs:19:42\n\
    \   |\n19 |     palindrome.push(&palindrome[..string.length()]);\n   |       \
    \                                   ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgl5sv7sb.rs:19:21\n\
    \   |\n19 |     palindrome.push(&palindrome[..string.length()]);\n   |       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string\n        .rsplitn(string.len(), string[..string.len() - 2])\n    \
    \    .iter()\n        .take_while(|&s| s.chars().all(|c| c.is_ascii_lowercase()))\n\
    \        .chain(\n            string\n                .chars()\n             \
    \   .take_while(|&c| !c.is_ascii_lowercase())\n                .chain(\n     \
    \               string\n                        .chars()\n                   \
    \     .take_while(|&c| !c.is_ascii_lowercase())\n                        .chain(\n\
    \                            string\n                                .chars()\n\
    \                                .take_while(|&c| !c.is_ascii_lowercase())\n \
    \                               .chain(\n                                    string\n\
    \                                        .chars()\n                          \
    \              .take_while(|&c| !c.is_ascii_lowercase())\n                   \
    \                     .chain(\n                                            string\n\
    \                                                .chars()\n                  \
    \                              .take_while(|&c| !c.is_ascii_lowercase())\n   \
    \                                             .chain(\n                      \
    \                              string\n                                      \
    \                  .chars()\n                                                \
    \        .take_while(|&c| !c.is_ascii_lowercase())\n                         \
    \                               .chain(\n                                    \
    \                        string\n                                            \
    \                    .chars()\n                                              \
    \                  .take_while(|&c| !c.is_ascii_lowercase())\n               \
    \                                                 .chain(\n                  \
    \                                                  string\n                  \
    \                                                      .chars()\n            \
    \                                                            .take_while(|&c|\
    \ !c.is_ascii_lowercase())\n                                                 \
    \                       .chain(\n                                            \
    \                                string\n                                    \
    \                                            .chars()\n                      \
    \                                                          .take_while(|&c| !c.is_ascii_lowercase())\n\
    \                                                                            \
    \    .chain(\n                                                               \
    \                     string\n                                               \
    \                                         .chars()\n                         \
    \                                                               .take_while(|&c|\
    \ !c.is_ascii_lowercase())\n                                                 \
    \                                       .chain(\n                            \
    \                                                                string\n    \
    \                                                                            \
    \                .chars()\n                                                  \
    \                                              .take_while(|&c| !c.is_ascii_lowercase())\n\
    \                                                                            \
    \                    .chain(\n                                               \
    \                                                     string\n               \
    \                                                                            \
    \             .chars()\n                                                     \
    \                                                   .take_while(|&c| !c.is_ascii_lowercase())\n\
    \                                                                            \
    \                            .chain(\n                                       \
    \                                                                     string\n\
    \                                                                            \
    \                                    .chars()\n                              \
    \                                                                            \
    \      .take_while(|&c| !c.is_ascii_lowercase())\n                           \
    \                                                                            \
    \         .chain(\n                                                          \
    \                                                          string\n          \
    \                                                                            \
    \                                  .chars()\n                                \
    \                                                                            \
    \            .take_while(|&c| !c.is_ascii_lowercase())\n                     \
    \                                                                            \
    \                       .chain(\n                                            \
    \                                                                            \
    \    string\n                                                                \
    \                                                                .chars()\n  \
    \                                                                            \
    \                                                  .take_while(|&c| !c.is_ascii_lowercase())\n\
    \                                                                            \
    \                                                    .chain(\n               \
    \                                                                            \
    \                                         string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpacdexr8u.rs:76:135\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n76 |                                                                    \
    \                                                             .chain(\n   |  \
    \                                                                            \
    \                                                         ^ unclosed delimiter\n\
    77 |                                                                         \
    \                                                            string\n78 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n    --> /tmp/tmpacdexr8u.rs:13:32\n\
    \     |\n13   |         .rsplitn(string.len(), string[..string.len() - 2])\n \
    \    |          -------               ^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have\
    \ a size known at compile-time\n     |          |\n     |          required by\
    \ a bound introduced by this call\n     |\n     = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `core::str::<impl str>::rsplitn`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `str`\n  --> /tmp/tmpacdexr8u.rs:13:32\n\
    \   |\n13 |         .rsplitn(string.len(), string[..string.len() - 2])\n   | \
    \         -------               ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n   |          |\n   |          required by a bound introduced\
    \ by this call\n   |\n   = note: the trait bound `str: Pattern<'_>` is not satisfied\n\
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `str`\nhelp: consider borrowing here\n   |\n13 |         .rsplitn(string.len(),\
    \ &string[..string.len() - 2])\n   |                                +\n\nerror[E0599]:\
    \ no method named `iter` found for struct `std::str::RSplitN` in the current scope\n\
    \  --> /tmp/tmpacdexr8u.rs:14:10\n   |\n14 |         .iter()\n   |          ^^^^\
    \ method not"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // TODO(pdg): Use optimized code?\n    let mut string_to_reverse = string;\n\
    \    for _ in 0..string.len() {\n        string_to_reverse.push(palindrome(&string_to_reverse[..]));\n\
    \    }\n    string_to_reverse.reverse()\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `palindrome` in this scope\n  --> /tmp/tmpv1cg8oip.rs:15:32\n\
    \   |\n15 |         string_to_reverse.push(palindrome(&string_to_reverse[..]));\n\
    \   |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpv1cg8oip.rs:17:23\n   |\n17 |     string_to_reverse.reverse()\n\
    \   |                       ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let len = string.len();\n    if len == 0 {\n        return string;\n    }\n\
    \    let mut result = string.clone();\n    let start = result.split_first_char_if_mut(&mut\
    \ |c| c.is_alphanumeric()).unwrap();\n    let mut suffix = String::from(\"\");\n\
    \    let mut suffix_start = start.split_last_char_if_mut(&mut |c| c.is_alphanumeric()).unwrap();\n\
    \    while suffix_start.len() > 0 {\n        let rev_suffix_start = suffix_start.rev();\n\
    \        if rev_suffix_start == suffix_start {\n            suffix += suffix_start;\n\
    \            suffix_start = \"\";\n        } else {\n            suffix += rev_suffix_start;\n\
    \            suffix_start = rev_suffix_start;\n        }\n    }\n    result +=\
    \ suffix;\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_first_char_if_mut` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpdi0759rr.rs:17:24\n   |\n17 | \
    \    let start = result.split_first_char_if_mut(&mut |c| c.is_alphanumeric()).unwrap();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at_mut`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdi0759rr.rs:30:15\n   |\n30 |     result += suffix;\n   |     \
    \          ^^^^^^\n   |               |\n   |               expected `&str`, found\
    \ struct `String`\n   |               help: consider borrowing here: `&suffix`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = String::new();\n    let mut postfix = String::from(string);\n\
    \    let mut reverse = String::from(\"\");\n    let mut max_length = 0;\n\n  \
    \  while !postfix.is_empty() {\n        let first = postfix.chars().nth(0).unwrap();\n\
    \        reversed.push((first as char).to_string());\n        reversed.push(reverse.clone());\n\
    \        max_length = std::cmp::max(max_length, reversed.len());\n        postfix.pop();\n\
    \        reverse.pop();\n    }\n\n    reversed.push_str(&reverse);\n    reversed\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi6ubq5wl.rs:19:23\n   |\n\
    19 |         reversed.push((first as char).to_string());\n   |               \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpi6ubq5wl.rs:20:23\n   |\n20 |  \
    \       reversed.push(reverse.clone());\n   |                       ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        return string;\n    }\n    let mut left =\
    \ 0;\n    let mut right = string.len() - 1;\n    while left < right {\n      \
    \  if string.chars().skip(left).collect::<Vec<_>>()\n            .iter()\n   \
    \         .chain(string.chars().skip(right).collect::<Vec<_>>())\n           \
    \ .find(|&c| c != c)\n            .is_some()\n        {\n            break;\n\
    \        }\n        left += 1;\n        right -= 1;\n    }\n    let (left, right)\
    \ = if left >= right { (-1, -1) } else { (left, right + 1) };\n    let middle\
    \ = string.len().checked_sub(left).unwrap();\n    string\n        .into_iter()\n\
    \        .chain(string.chars().skip(middle).collect::<Vec<_>>())\n        .chain(string.chars().skip(right).collect::<Vec<_>>())\n\
    \        .cloned()\n        .collect::<String>()\n        .join(\"\")\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Vec<char> as IntoIterator>::Item\
    \ == &char`\n   --> /tmp/tmpw99modci.rs:20:14\n    |\n20  |             .chain(string.chars().skip(right).collect::<Vec<_>>())\n\
    \    |              ^^^^^ expected `&char`, found `char`\n    |\nnote: required\
    \ by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]: the method `find`\
    \ exists for struct `std::iter::Chain<std::slice::Iter<'_, char>, std::vec::IntoIter<char>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpw99modci.rs:21:14\n \
    \  |\n21 |                .find(|&c| c != c)\n   |                 ^^^^ method\
    \ cannot be called on `std::iter::Chain<std::slice::Iter<'_, char>, std::vec::IntoIter<char>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<char> as Iterator>::Item\
    \ = &char`\n           which is required by `std::iter::Chain<std::slice::Iter<'_,\
    \ char>, std::vec::IntoIter<char>>: Iterator`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpw99modci.rs:29:45\n   |\n29 | \
    \    let (left, right) = if left >= right { (-1, -1) } else { (left, right + 1)\
    \ };\n   |                                             ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpw99modci.rs:29:49\n   |\n29 |     let (left,\
    \ right) = if left >= right { (-1, -1) } else { (left, right + 1) };\n   |   \
    \                                              ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0599]: the method `into_iter` exists for"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = string;\n    let mut palindrome = string;\n    while palindrome.len()\
    \ > 1 {\n        let mut longest_postfix_suffix = 0;\n        for length in (0..=palindrome.len()).rev()\
    \ {\n            longest_postfix_suffix = if palindrome[length] == suffix[length]\
    \ {\n                longest_postfix_suffix + 1\n            } else {\n      \
    \          longest_postfix_suffix\n            };\n        }\n        palindrome\
    \ = suffix\n            .rev()\n            .rev()\n            .join(String::from(\"\
    0\"))\n            .join(palindrome);\n        suffix = String::from(\n      \
    \      longest_postfix_suffix.to_string()\n                .to_string()\n    \
    \            .rev()\n                .to_string()\n        );\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmhpc64wk.rs:17:41\n\
    \   |\n17 |             longest_postfix_suffix = if palindrome[length] == suffix[length]\
    \ {\n   |                                         ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmhpc64wk.rs:17:63\n   |\n17 |             longest_postfix_suffix\
    \ = if palindrome[length] == suffix[length] {\n   |                          \
    \                                     ^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpmhpc64wk.rs:24:14\n\
    \    |\n24  |               .rev()\n    |                ^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmpmhpc64wk.rs:31:18\n  "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n\n    let (prefix,\
    \ suffix) = string.split_first_not_of(String::from(\"a\"));\n\n    // 1. Find\
    \ the longest postfix of supplied string that is a palindrome.\n    let mut suffix_end\
    \ = suffix.len() - 1;\n    let mut suffix_palindrome = suffix.clone();\n    while\
    \ suffix_end >= 0 && suffix.chars().nth(suffix_end).unwrap() != String::from(\"\
    a\").chars().nth(suffix_end).unwrap() {\n        suffix_palindrome = suffix.clone();\n\
    \        suffix_end--;\n    }\n    // longest palindrome is suffix + reverse of\
    \ suffix before it.\n    let longest_palindrome = suffix\n        .clone()\n \
    \       + suffix_palindrome\n        .chars()\n        .iter()\n        .rev()\n\
    \        .map(|c| {\n            c.to_string() + String::from(\"a\")\n       \
    \ })\n        .collect::<String>()\n        .join();\n\n    // 2. Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    // To ensure that we do not insert duplicates and to make the algorithm\
    \ efficient, we reverse the whole string,\n    // reverse the prefix and then\
    \ reverse the whole string again.\n    let mut suffix_reversed = suffix.chars().collect::<String>().rev().collect::<String>();\n\
    \    // reverse the whole string\n    let mut suffix_reversed_reversed = suffix_reversed.clone();\n\
    \    while suffix_end >= 0 {\n        if suffix.chars().nth(suffix_end).unwrap()\
    \ == String::from(\"a\").chars().nth(suffix_end).unwrap() {\n            break;\n\
    \        }\n        suffix_reversed_reversed = suffix_reversed.clone();\n    \
    \    suffix_end--;\n    }\n    let mut suffix_reversed_reversed_reversed = suffix_reversed_reversed.clone();\n\
    \    // reverse the prefix to get the suffix\n    while suffix_end >= 0 {\n  \
    \      suffix_reversed_reversed_reversed += suffix_palindrome.clone();\n     \
    \   suffix_end--;\n    }\n    let mut suffix_reversed_reversed_reversed_reversed\
    \ = suffix_reversed_reversed_reversed.clone();\n    // reverse the whole string\
    \ again\n    while suffix_end >= 0 {\n        suffix_reversed_reversed_reversed_reversed\
    \ += suffix_reversed_reversed.clone();\n        suffix_end--;\n    }\n    // concatenate\
    \ reversed strings\n    let mut palindrome = longest_palin\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpm5wrugl7.rs:23:21\n\
    \   |\n23 |         suffix_end--;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmpm5wrugl7.rs:49:21\n   |\n\
    49 |         suffix_end--;\n   |                     ^ expected expression\n\n\
    error: expected expression, found `;`\n  --> /tmp/tmpm5wrugl7.rs:55:21\n   |\n\
    55 |         suffix_end--;\n   |                     ^ expected expression\n\n\
    error: expected expression, found `;`\n  --> /tmp/tmpm5wrugl7.rs:61:21\n   |\n\
    61 |         suffix_end--;\n   |                     ^ expected expression\n\n\
    error: expected `;`, found `}`\n  --> /tmp/tmpm5wrugl7.rs:64:39\n   |\n64 |  \
    \   let mut palindrome = longest_palin\n   |                                 \
    \      ^ help: add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `longest_palin` in this scope\n  --> /tmp/tmpm5wrugl7.rs:64:26\n\
    \   |\n64 |     let mut palindrome = longest_palin\n   |                     \
    \     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `split_first_not_of`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpm5wrugl7.rs:16:35\n\
    \   |\n16 |     let (prefix, suffix) = string.split_first_not_of(String::from(\"\
    a\"));\n   |                                   ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `split_at_mut`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm5wrugl7.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 8 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        String::from(\"\")\n    } else {\n      \
    \  let mut reversed_string = string[..];\n        reversed_string.chars().rev().for_each(|c|\
    \ {\n            if *c != *reversed_string[..] {\n                reversed_string.push(*c);\n\
    \            }\n        });\n        String::from(string.to_owned() + &reversed_string)\n\
    \    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpgtd5vwgw.rs:15:13\n   |\n15 |         let mut reversed_string\
    \ = string[..];\n   |             ^^^^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n15 |         let mut reversed_string = &string[..];\n   |             \
    \                      +\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpgtd5vwgw.rs:17:16\n   |\n17 |             if *c != *reversed_string[..]\
    \ {\n   |                ^^\n\nerror[E0614]: type `str` cannot be dereferenced\n\
    \  --> /tmp/tmpgtd5vwgw.rs:17:22\n   |\n17 |             if *c != *reversed_string[..]\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method\
    \ named `push` found for type `str` in the current scope\n  --> /tmp/tmpgtd5vwgw.rs:18:33\n\
    \   |\n18 |                 reversed_string.push(*c);\n   |                  \
    \               ^^^^ method not found in `str`\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmpgtd5vwgw.rs:18:38\n   |\n18 |               \
    \  reversed_string.push(*c);\n   |                                      ^^\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() - 1 {\n        if string[i] == string[string.len()\
    \ - 1 - i] {\n            i += 1;\n        } else {\n            break;\n    \
    \    }\n    }\n    while i > 0 {\n        reverse += string[--i];\n    }\n   \
    \ string\n        + &reverse\n        + &string[i..string.len()]\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi2qibvm1.rs:16:12\n\
    \   |\n16 |         if string[i] == string[string.len() - 1 - i] {\n   |     \
    \       ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpi2qibvm1.rs:16:25\n   |\n16 |         if string[i] == string[string.len()\
    \ - 1 - i] {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpi2qibvm1.rs:23:28\n   |\n23 |         reverse += string[--i];\n\
    \   |                            ^^ cannot apply unary operator `-`\n   |\n  \
    \ = note: unsigned values cannot be negated\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpi2qibvm1.rs:23:27\n   |\n23 |  \
    \       reverse += string[--i];\n   |                           ^^^ cannot apply\
    \ unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi2qibvm1.rs:23:20\n\
    \   |\n23 |         rev"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let (longest_palindrome, last_index) = longest_palindrome(string);\n    string\n\
    \        .replace(&last_index, \"x\")\n        .replace(&longest_palindrome, \"\
    \")\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindrome` in this scope\n\
    \  --> /tmp/tmp_qnjijf5.rs:12:44\n   |\n12 |     let (longest_palindrome, last_index)\
    \ = longest_palindrome(string);\n   |                                        \
    \    ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string;\n    let mut max_len = string.chars().count();\n\
    \    let mut prefix_len = 0;\n    while prefix_len < max_len {\n        let mut\
    \ found_palindrome = false;\n        for &s in &string.chars() {\n           \
    \ if s == &result[prefix_len] {\n                if !found_palindrome {\n    \
    \                found_palindrome = true;\n                    let mut suffix_len\
    \ = prefix_len;\n                    while suffix_len < max_len {\n          \
    \              result[suffix_len] = &result[suffix_len + 1];\n               \
    \         suffix_len += 1;\n                    }\n                }\n       \
    \     } else {\n                found_palindrome = false;\n            }\n   \
    \     }\n        if !found_palindrome {\n            max_len += 1;\n        }\n\
    \        prefix_len += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmphcnhyxu0.rs:17:19\n\
    \   |\n17 |         for &s in &string.chars() {\n   |                   -^^^^^^^^^^^^^^\n\
    \   |                   |\n   |                   `&Chars<'_>` is not an iterator\n\
    \   |                   help: consider removing the leading `&`-reference\n  \
    \ |\n   = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n   =\
    \ note: `Iterator` is implemented for `&mut std::str::Chars<'_>`, but not for\
    \ `&std::str::Chars<'_>`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `&Chars<'_>`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmphcnhyxu0.rs:18:22\n   |\n18 |         \
    \    if s == &result[prefix_len] {\n   |                      ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphcnhyxu0.rs:23:25\n   |\n23 |                         result[suffix_len]\
    \ = &result[suffix_len + 1];\n   |                         ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome_start = 0\n    let mut palindrome_end = 0\n\n    for c\
    \ in string.chars() {\n        if let Some(palindrome_start) = palindrome_end\
    \ {\n            if *c != *palindrome_start {\n                let len = palindrome_end\
    \ - palindrome_start + 1;\n                let mut palindrome = string.to_owned();\n\
    \                palindrome.truncate(palindrome_start + len);\n              \
    \  palindrome.push(*c);\n                palindrome.reverse();\n             \
    \   return palindrome\n            }\n        }\n\n        let len = c.len_utf8();\n\
    \        if len > 0 {\n            palindrome_start = len;\n            palindrome_end\
    \ = 0;\n        }\n        if len < 0 {\n            palindrome_start = len;\n\
    \            palindrome_end = 0;\n        }\n        palindrome_end += len;\n\
    \    }\n\n    if let Some(palindrome_end) = palindrome_end {\n        let len\
    \ = palindrome_end - palindrome_start + 1;\n        let mut palindrome = string.to_owned();\n\
    \        palindrome.truncate(palindrome_start + len);\n        palindrome.push(*palindrome_start);\n\
    \        palindrome.reverse();\n        return palindrome\n    } else {\n    \
    \    \"\".to_owned()\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpqv714uil.rs:12:33\n\
    \   |\n12 |     let mut palindrome_start = 0\n   |                           \
    \      ^ help: add `;` here\n13 |     let mut palindrome_end = 0\n   |     ---\
    \ unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpqv714uil.rs:13:31\n\
    \   |\n13 |     let mut palindrome_end = 0\n   |                             \
    \  ^ help: add `;` here\n14 | \n15 |     for c in string.chars() {\n   |     ---\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqv714uil.rs:16:16\n\
    \   |\n16 |         if let Some(palindrome_start) = palindrome_end {\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^   -------------- this expression has type\
    \ `{integer}`\n   |                |\n   |                expected integer, found\
    \ enum `Option`\n   |\n   = note: expected type `{integer}`\n              found\
    \ enum `Option<_>`\n\nerror[E0614]: type `char` cannot be dereferenced\n  -->\
    \ /tmp/tmpqv714uil.rs:17:16\n   |\n17 |             if *c != *palindrome_start\
    \ {\n   |                ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpqv714uil.rs:21:33\n   |\n21 |                 palindrome.push(*c);\n\
    \   |                                 ^^\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpqv714uil.rs:22:28\n\
    \   |\n22 |                 palindrome.reverse();\n   |                      \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqv714uil.rs:39:12\n   |\n39 |\
    \     if let Some(palindrome_end) = palindrome_end {\n   |            ^^^^^^^^^^^^^^^^^^^^\
    \   -------------- this expression has type `usize`\n   |            |\n   | \
    \           expected `usize`, found enum `Option`\n   |\n   = note: expected type\
    \ `usize`\n              found enum `Option<_>`\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmpqv714uil.rs:43:25\n   |\n43 |        \
    \ palindrome.push(*palindrome_start);\n   |                         ^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `re"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        return string;\n    }\n\n    let mut suffix\
    \ = String::from(string.chars());\n    let mut prefix = String::from(string.chars());\n\
    \    let mut max_length = 1;\n\n    while prefix.is_empty() {\n        max_length\
    \ = max_length.max(1);\n        suffix.pop();\n    }\n\n    for _ in 0..max_length\
    \ {\n        prefix.pop();\n    }\n\n    while suffix.is_empty() {\n        prefix.push(b'_');\n\
    \        max_length = max_length.max(1);\n        suffix.pop();\n    }\n\n   \
    \ while suffix.is_empty() {\n        max_length = max_length.max(1);\n       \
    \ suffix.push(b'_');\n    }\n\n    prefix.append(suffix.chars().clone());\n\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<Chars<'_>>` is not satisfied\n\
    \  --> /tmp/tmp_t1xy6d_.rs:16:22\n   |\n16 |     let mut suffix = String::from(string.chars());\n\
    \   |                      ^^^^^^^^^^^^ the trait `From<Chars<'_>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<Chars<'_>>` is not satisfied\n \
    \ --> /tmp/tmp_t1xy6d_.rs:17:22\n   |\n17 |     let mut prefix = String::from(string.chars());\n\
    \   |                      ^^^^^^^^^^^^ the trait `From<Chars<'_>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_t1xy6d_.rs:30:21\n   |\n30 |\
    \         prefix.push(b'_');\n   |                     ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_t1xy6d_.rs:37:21\n  \
    \ |\n37 |         suffix.push(b'_');\n   |                     ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp_t1xy6d_.rs:40:12\n   |\n40 |     prefix.append(suffix.chars().clone());\n\
    \   |            ^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let string = string.to_lowercase().trim_left();\n    let mut string_to_add\
    \ = string;\n    let mut is_palindrome = true;\n    let mut current_string_to_check\
    \ = string;\n\n    while is_palindrome {\n        is_palindrome = false;\n\n \
    \       for mut index = 0; index < string.len(); index += 1 {\n            //\
    \ Check if string prefix is a palindrome\n            let current_substring =\
    \ &current_string_to_check[..index];\n            if !string_to_add.contains(current_substring)\
    \ {\n                is_palindrome = true;\n                break;\n         \
    \   }\n\n            // Append to suffix\n            let current_substring =\
    \ &current_string_to_check[..index];\n            let substring_to_add = &string_to_add[..index];\n\
    \            current_string_to_check = current_string_to_check[..index];\n   \
    \         string_to_add += &substring_to_add;\n        }\n    }\n\n    return\
    \ string_to_add;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpww2awnb0.rs:20:22\n  \
    \ |\n20 |         for mut index = 0; index < string.len(); index += 1 {\n   |\
    \                      ^ help: try adding `in` here\n\nerror: expected expression,\
    \ found `=`\n  --> /tmp/tmpww2awnb0.rs:20:23\n   |\n20 |         for mut index\
    \ = 0; index < string.len(); index += 1 {\n   |                       ^ expected\
    \ expression\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_left`: superseded by `trim_start`\n  --> /tmp/tmpww2awnb0.rs:12:40\n\
    \   |\n12 |     let string = string.to_lowercase().trim_left();\n   |        \
    \                                ^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_start`\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpww2awnb0.rs:36:12\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    36 |     return string_to_add;\n   |            ^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |            |\n   |            expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffixes = Vec::new();\n    for c in string.chars().rev() {\n   \
    \     if c.is_alphanumeric() {\n            suffixes.push(c);\n        } else\
    \ {\n            suffixes.push(c.to_lowercase());\n        }\n    }\n    let mut\
    \ suffix_end = suffixes.clone();\n    suffix_end.pop();\n    suffix_end.push(char::FromInt(0));\n\
    \    let mut suffix_start_end = String::new();\n    suffix_start_end.push(suffixes[0]);\n\
    \    for &suffix in suffixes.iter().rev() {\n        if suffix_start_end.len()\
    \ > suffix_end.len() {\n            break;\n        }\n        if suffix != suffix_end[suffix_end.len()\
    \ - 1] {\n            break;\n        }\n        suffix_end_end.pop();\n     \
    \   suffix_end_end.push(suffix);\n    }\n    if suffix_start_end.len() <= suffix_end.len()\
    \ {\n        let mut suffix_start = suffix_start_end.clone();\n        suffix_start.push(suffixes[0]);\n\
    \        suffix_start.pop();\n        return suffix_start;\n    }\n    return\
    \ suffix_end\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `suffix_end_end` in this scope\n  --> /tmp/tmpdcop_uto.rs:32:9\n\
    \   |\n32 |         suffix_end_end.pop();\n   |         ^^^^^^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `suffix_end`\n\nerror[E0425]: cannot\
    \ find value `suffix_end_end` in this scope\n  --> /tmp/tmpdcop_uto.rs:33:9\n\
    \   |\n33 |         suffix_end_end.push(suffix);\n   |         ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `suffix_end`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdcop_uto.rs:17:27\n   |\n17 |             suffixes.push(c.to_lowercase());\n\
    \   |                           ^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `ToLowercase`\n\nerror[E0599]: no associated item named `FromInt` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpdcop_uto.rs:22:27\n   |\n22\
    \ |     suffix_end.push(char::FromInt(0));\n   |                           ^^^^^^^\
    \ associated item not found in `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdcop_uto.rs:41:12\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n41 |     return suffix_end\n   |            ^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<char>`\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut last_letter = String::from(\"\");\n    let mut is_reversed = false;\n\
    \    while !reversed_string.is_empty() {\n        let c = reversed_string[reversed_string.len()\
    \ - 1];\n        // Ignore letters other than the end of the string.\n       \
    \ if !c.is_ascii() {\n            break;\n        }\n        if c == last_letter\
    \ && !is_reversed {\n            palindrome = &reversed_string[..reversed_string.len()\
    \ - 1];\n            last_letter = String::from(\"\");\n            reversed_string\
    \ = &reversed_string[...reversed_string.len() - 1..];\n            is_reversed\
    \ = false;\n        } else {\n            palindrome += &reversed_string[...reversed_string.len()\
    \ - 1];\n            palindrome += &last_letter;\n            last_letter = c;\n\
    \            is_reversed = false;\n        }\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmp39s6q7g3.rs:25:48\n   |\n\
    25 |             reversed_string = &reversed_string[...reversed_string.len() -\
    \ 1..];\n   |                                                ^^^\n   |\nhelp:\
    \ use `..` for an exclusive range\n   |\n25 |             reversed_string = &reversed_string[..reversed_string.len()\
    \ - 1..];\n   |                                                ~~\nhelp: or `..=`\
    \ for an inclusive range\n   |\n25 |             reversed_string = &reversed_string[..=reversed_string.len()\
    \ - 1..];\n   |                                                ~~~\n\nerror: expected\
    \ one of `.`, `?`, `]`, or an operator, found `..`\n  --> /tmp/tmp39s6q7g3.rs:25:76\n\
    \   |\n25 |             reversed_string = &reversed_string[...reversed_string.len()\
    \ - 1..];\n   |                                                              \
    \              ^^ expected one of `.`, `?`, `]`, or an operator\n\nerror: unexpected\
    \ token: `...`\n  --> /tmp/tmp39s6q7g3.rs:28:44\n   |\n28 |             palindrome\
    \ += &reversed_string[...reversed_string.len() - 1];\n   |                   \
    \                         ^^^\n   |\nhelp: use `..` for an exclusive range\n \
    \  |\n28 |             palindrome += &reversed_string[..reversed_string.len()\
    \ - 1];\n   |                                            ~~\nhelp: or `..=` for\
    \ an inclusive range\n   |\n28 |             palindrome += &reversed_string[..=reversed_string.len()\
    \ - 1];\n   |                                            ~~~\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp39s6q7g3.rs:17:17\n\
    \   |\n17 |         let c = reversed_string[reversed_string.len() - 1];\n   |\
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n  "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = 0;\n    let mut index = 0;\n    let mut reversed_string\
    \ = String::new();\n    while let Some(item) = string.chars().nth(index) {\n \
    \       match item {\n            c if c != ' ' => {\n                reversed_string\
    \ += &item;\n                index += 1;\n            }\n            _ => {\n\
    \                let postfix_len = string.len();\n                let is_palindrome\
    \ = (&string[index..postfix_len]).chars()\n                    .cloned()\n   \
    \                 .zip(&string[postfix_len..])\n                    .all(|t| t\
    \ == (t[0] as char));\n                if is_palindrome {\n                  \
    \  index += 1;\n                }\n                suffix = postfix_len;\n   \
    \         }\n        }\n    }\n    String::from(&reversed_string + &string[..suffix])\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpreabmct2.rs:18:36\n   |\n\
    18 |                 reversed_string += &item;\n   |                         \
    \           ^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpreabmct2.rs:24:22\n\
    \     |\n24   |                     .cloned()\n     |                      ^^^^^^\
    \ expected reference, found `char`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `zip` exists for struct `Cloned<Chars<'_>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpreabmct2.rs:25:22\n   |\n25 |\
    \                       .zip(&string[postfix_len..])\n   |                   \
    \     ^^^ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Chars<'_> as Iterator>::Item = &_`\n           which is required by\
    \ `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n  \
    \         which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0369]:\
    \ cannot add `&str` to `&String`\n  --> /tmp/tmpreabmct2.rs:34:35\n   |\n34 |\
    \     String::from(&reversed_string + &string[..suffix])\n   |               \
    \   ---------------- ^ ----------------- &str\n   |                  |       \
    \         |\n   |                  |                `+` cannot be used to concatenate\
    \ two `&str` strings\n   |                  &String\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: remove the borrow to obtain an\
    \ owned `String`\n   |\n34 -     String::from(&reversed_string + &string[..suffix])\n\
    34 +     String::from(reversed_string + &string[..suffix])\n   | \n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n\n    if string.is_empty() {\n        return string;\n\
    \    }\n\n    // Step 1: Find the longest postfix of a palindrome that begins\
    \ with the supplied\n    // string. Here we assume that the longest prefix is\
    \ a palindrome. Since we\n    // are looking for prefixes we could also look for\
    \ suffixes.\n    let mut current_start = string.len();\n    let mut longest_prefix\
    \ = \"\";\n\n    while current_start >= 2 {\n        // Step 2: Append to the\
    \ end of the longest prefix that comes before the\n        // longest postfix\
    \ that begins with the supplied string.\n        let mut current_start = longest_prefix.len();\n\
    \        longest_prefix.push(*string);\n        string.as_str() = &*string.as_str()[..current_start];\n\
    \n        // Step 3: Find the longest prefix that follows the longest postfix.\n\
    \        while current_start >= 2 {\n            let mut current_start = longest_prefix.len();\n\
    \            longest_prefix.push(*string);\n            string.as_str() = &*string.as_str()[..current_start];\n\
    \n            if longest_prefix.len() == 2 {\n                break;\n       \
    \     }\n        }\n\n        // Step 4: Reverse the longest prefix.\n       \
    \ longest_prefix.reverse();\n    }\n\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmprp827y9w.rs:28:24\n   |\n28 |         longest_prefix.push(*string);\n\
    \   |                        ^^^^ method not found in `&str`\n\nerror[E0070]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmprp827y9w.rs:29:25\n   |\n\
    29 |         string.as_str() = &*string.as_str()[..current_start];\n   |     \
    \    --------------- ^\n   |         |\n   |         cannot assign to this expression\n\
    \nerror[E0614]: type `str` cannot be dereferenced\n  --> /tmp/tmprp827y9w.rs:29:28\n\
    \   |\n29 |         string.as_str() = &*string.as_str()[..current_start];\n  \
    \ |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmprp827y9w.rs:34:28\n   |\n34 |             longest_prefix.push(*string);\n\
    \   |                            ^^^^ method not found in `&str`\n\nerror[E0070]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmprp827y9w.rs:35:29\n   |\n\
    35 |             string.as_str() = &*string.as_str()[..current_start];\n   | \
    \            --------------- ^\n   |             |\n   |             cannot assign\
    \ to this expression\n\nerror[E0614]: type `str` cannot be dereferenced\n  -->\
    \ /tmp/tmprp827y9w.rs:35:32\n   |\n35 |             string.as_str() = &*string.as_str()[..current_start];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmprp827y9w.rs:43:24\n   |\n43 |         longest_prefix.reverse();\n\
    \   |                        ^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0070, E0599,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0070`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut len = string.len();\n    let mut res = string;\n    let mut suffix:\
    \ String = string.to_string();\n    let mut i = len - 1;\n\n    while i != -1\
    \ {\n        if string[i] != string[len - i - 1] {\n            suffix += &string[len\
    \ - i - 1];\n        } else {\n            res.insert(0, &suffix);\n         \
    \   suffix = \"\";\n            i -= 1;\n        }\n    }\n    res.insert(0, &suffix);\n\
    \    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmph2abx783.rs:17:16\n\
    \   |\n17 |     while i != -1 {\n   |                ^^\n   |                |\n\
    \   |                cannot apply unary operator `-`\n   |                help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmph2abx783.rs:18:12\n   |\n18 |         if\
    \ string[i] != string[len - i - 1] {\n   |            ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph2abx783.rs:18:25\n   |\n18 |         if string[i] != string[len\
    \ - i - 1] {\n   |                         ^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph2abx783.rs:19:24\n   |\n19 |             suffix += &string[len\
    \ - i - 1];\n   |                        ^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemen"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = String::from(\"\");\n    let mut last_palindrome\
    \ = String::from(\"\");\n    let mut first_palindrome = String::from(\"\");\n\
    \    let mut first_half = String::from(\"\");\n    for ch in string.chars() {\n\
    \        if !first_palindrome.chars().any(|c| c == ch) {\n            first_half\
    \ += &ch;\n        } else {\n            if first_palindrome.len() > first_half.len()\
    \ {\n                first_palindrome = first_half;\n            }\n         \
    \   first_palindrome += &ch;\n            last_palindrome += &ch;\n        }\n\
    \    }\n\n    if first_palindrome.len() > first_half.len() {\n        first_palindrome\
    \ = first_half;\n    }\n    if first_palindrome.len() <= first_half.len() {\n\
    \        String::from(\"\")\n    } else {\n        last_palindrome += &first_palindrome[first_palindrome.len()\
    \ - first_half.len()];\n        String::from(&first_palindrome + &last_palindrome)\n\
    \    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7uu6o2ki.rs:18:27\n   |\n\
    18 |             first_half += &ch;\n   |                           ^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7uu6o2ki.rs:23:33\n\
    \   |\n23 |             first_palindrome += &ch;\n   |                       \
    \          ^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7uu6o2ki.rs:24:32\n   |\n24 |             last_palindrome += &ch;\n\
    \   |                                ^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7uu6o2ki.rs:34:29\n\
    \   |\n34 |         last_palindrome += &first_palindrome[first_palindrome.len()\
    \ - first_half.len()];\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `&String` to `&String`\n  --> /tmp/tmp7uu6o2ki.rs:35:40\n\
    \   |\n35 |         String::from(&first_palindrome + &last_palindrome)\n   | \
    \                     ----------------- ^ ---------------- &String\n   |     \
    \                 |                 |\n   |                      |           \
    \      `+` cannot be used to concatenate two `&str` strings\n   |            \
    \          &String\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\nhelp: re"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string; // copy string because we'll reuse it.\n    let\
    \ mut palindrome = string; // set palindrome to start the same as the given string.\n\
    \    let mut last_char = String::new(); // set last_char to start at the start\
    \ of the string.\n    while !string.is_empty() {\n        last_char = String::from(&string[string.len()\
    \ - 1]);\n        palindrome = string.chars().filter(|c| *c == c).cloned().rev().collect::<String>();\n\
    \        string = String::from(&string[..string.len() - palindrome.len()]);\n\
    \        if palindrome == last_char {\n            break;\n        }\n    }\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvwuf7gq9.rs:16:35\n\
    \   |\n16 |         last_char = String::from(&string[string.len() - 1]);\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvwuf7gq9.rs:17:54\n\
    \   |\n17 |         palindrome = string.chars().filter(|c| *c == c).cloned().rev().collect::<String>();\n\
    \   |                                                      ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |   \
    \      palindrome = string.chars().filter(|c| *c == *c).cloned().rev().collect::<String>();\n\
    \   |                                                      +\n\nerror[E0271]:\
    \ type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpvwuf7gq9.rs:17:44:\
    \ 17:55]> as Iterator>::Item == &_`\n    --> /tmp/tmpvwuf7gq9.rs:17:57\n     |\n\
    17   |         palindrome = string.chars().filter(|c| *c == c).cloned().rev().collect::<String>();\n\
    \     |                                                         ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `rev` exists for struct `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpvwuf7gq9.rs:17:44:\
    \ 17:55]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpvwuf7gq9.rs:17:66\n\
    \   |\n17 |            palindrome = string.chars().filter(|c| *c == c).cloned().rev().collect::<String>();\n\
    \   |                                              "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut new_string = string;\n    let mut last_index = 0;\n\n    let mut\
    \ max_suffix = 0;\n    while max_suffix < string.len() {\n        let mut current_suffix\
    \ = 1;\n        let mut last_suffix = 0;\n\n        while last_suffix < string.len()\
    \ && current_suffix < max_suffix {\n            if string[last_suffix] != string[current_suffix]\
    \ {\n                break;\n            }\n\n            last_suffix += 1;\n\
    \            current_suffix += 1;\n        }\n\n        if current_suffix > max_suffix\
    \ {\n            max_suffix = current_suffix;\n            last_index = current_suffix;\n\
    \        }\n    }\n\n    new_string.push_str(&string[..last_index].iter().cloned().collect());\n\
    \n    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo3c4gu8s.rs:21:16\n\
    \   |\n21 |             if string[last_suffix] != string[current_suffix] {\n \
    \  |                ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo3c4gu8s.rs:21:39\n   |\n21 |             if string[last_suffix]\
    \ != string[current_suffix] {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `iter` found for type `str` in the\
    \ current scope\n  --> /tmp/tmpo3c4gu8s.rs:35:47\n   |\n35 |     new_string.push_str(&string[..last_index].iter().cloned().collect());\n\
    \   |                                               ^^^^ method not found in `str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut new_string = string;\n    let mut reverse_suffix;\n    let mut longest_postfix;\n\
    \n    // Find longest postfix that is a palindrome.\n    longest_postfix =\n \
    \       if new_string.is_empty() || new_string.is_back() {\n            new_string\n\
    \        } else {\n            let mut prefix_len = new_string.len() - 1;\n  \
    \          let mut prefix = new_string.clone();\n\n            // Check from left\
    \ and see if it is a palindrome.\n            while prefix >= &new_string {\n\
    \                let reverse_pos = prefix.rfind(&prefix[prefix_len..]);\n    \
    \            if reverse_pos < 0 {\n                    return new_string;\n  \
    \              }\n                reverse_suffix = &prefix[prefix_len..(reverse_pos\
    \ + prefix_len)];\n                if *reverse_suffix != &prefix[reverse_pos {\n\
    \                    prefix_len = reverse_pos;\n                    prefix -=\
    \ 1;\n                } else {\n                    break;\n                }\n\
    \            }\n            new_string += &prefix[prefix_len..];\n           \
    \ longest_postfix = prefix;\n        };\n\n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    new_string\
    \ += &reverse_suffix;\n\n    longest_postfix\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp8avvrssy.rs:32:32\n   |\n\
    32 |                     prefix_len = reverse_pos;\n   |                     \
    \          -^\n   |                               |\n   |                    \
    \           help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `!`, `,`, `.`, `::`, `?`, `{`, `}`, or an operator, found `;`\n  --> /tmp/tmp8avvrssy.rs:32:45\n\
    \   |\n31 |                 if *reverse_suffix != &prefix[reverse_pos {\n   |\
    \                                               ----------- while parsing this\
    \ struct\n32 |                     prefix_len = reverse_pos;\n   |           \
    \                                  ^ expected one of 8 possible tokens\n\nerror:\
    \ expected one of `.`, `?`, `]`, or an operator, found keyword `else`\n  --> /tmp/tmp8avvrssy.rs:31:46\n\
    \   |\n31 |                 if *reverse_suffix != &prefix[reverse_pos {\n   |\
    \                                              ^ unclosed delimiter\n...\n34 |\
    \                 } else {\n   |                  -^^^^\n   |                \
    \  |\n   |                  help: `]` may belong here\n\nerror: missing condition\
    \ for `if` expression\n  --> /tmp/tmp8avvrssy.rs:31:19\n   |\n31 |           \
    \      if *reverse_suffix != &prefix[reverse_pos {\n   |                   ^ expected\
    \ if condition here\n\nerror: expected expression, found `]`\n  --> /tmp/tmp8avvrssy.rs:37:13\n\
    \   |\n37 |             }\n   |             ^ expected expression\n\nerror[E0574]:\
    \ expected struct, variant or union type, found local variable `reverse_pos`\n\
    \  --> /tmp/tmp8avvrssy.rs:31:47\n   |\n31 |                 if *reverse_suffix\
    \ != &prefix[reverse_pos {\n   |                                             \
    \  ^^^^^^^^^^^ not a struct, variant or union type\n\nerror[E0599]: no method\
    \ named `is_back` found for struct `String` in the current scope\n  --> /tmp/tmp8avvrssy.rs:18:48\n\
    \   |\n18 |         if new_string.is_empty() || new_string.is_back() {\n   | \
    \                                               ^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8avvrssy.rs:25:29\n   |\n25 | "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let reversed_string = string\n        .chars()\n        .rev()\n        .collect::<String>();\n\
    \    let postfix_length = string\n        .chars()\n        .chain(reversed_string.chars())\n\
    \        .filter(|&c| !c.is_alphanumeric())\n        .count();\n    let mut postfix_string\
    \ = string.to_owned();\n    postfix_string.reserve(postfix_length + reversed_string.len());\n\
    \    postfix_string.push(reversed_string.to_owned());\n    postfix_string\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprnmc2ilm.rs:23:25\n   |\n\
    23 |     postfix_string.push(reversed_string.to_owned());\n   |              \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string;\n    let mut last = 0;\n    while last != result.len()\
    \ - 1 {\n        let last = string.len();\n        result = result + &string[last..last].reverse();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpci0wz7km.rs:16:47\n   |\n16 |         result = result +\
    \ &string[last..last].reverse();\n   |                                       \
    \        ^^^^^^^ method not found in `str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    fn make_palindrome(\n        suffix: &str,\n        prefix_length: usize,\n\
    \    ) -> String {\n        let mut prefix = suffix.chars().nth(prefix_length);\n\
    \        let mut reversed_prefix: String;\n        let mut palindrome: String;\n\
    \        loop {\n            let new_prefix: String = prefix.to_owned().reverse();\n\
    \            let new_reversed_prefix: String = new_prefix.chars().take(prefix_length).collect();\n\
    \            palindrome += new_reversed_prefix.to_string();\n            reversed_prefix\
    \ += new_prefix.to_string();\n            if prefix == suffix {\n            \
    \    return palindrome;\n            }\n            prefix = &suffix[prefix_length..];\n\
    \        }\n    }\n\n    let mut max_length = 0;\n    let mut max_length_palindrome\
    \ = 0;\n    let mut max_length_prefix = 0;\n    let mut prefix_length = 0;\n\n\
    \    while string.len() > max_length {\n        let last_postfix_length = string.rfind('b',\
    \ 0, max_length);\n        let last_postfix_palindrome = make_palindrome(string[..last_postfix_length]);\n\
    \        let last_postfix_prefix = &string[last_postfix_length..];\n        if\
    \ last_postfix_palindrome < last_postfix_prefix {\n            max_length_palindrome\
    \ = last_postfix_length;\n            max_length_prefix = prefix_length;\n   \
    \         max_length = max_length_palindrome;\n        }\n        prefix_length\
    \ += 1;\n    }\n    make_palindrome(string[..max_length_prefix])\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \    --> /tmp/tmposhisgbp.rs:37:42\n     |\n37   |         let last_postfix_length\
    \ = string.rfind('b', 0, max_length);\n     |                                \
    \          ^^^^^ ---  -  ---------- supplied 3 arguments\n     |             \
    \                             |\n     |                                      \
    \    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmposhisgbp.rs:38:55\n\
    \   |\n38 |         let last_postfix_palindrome = make_palindrome(string[..last_postfix_length]);\n\
    \   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeTo<Option<usize>>`\n   |\n   = help: the\
    \ trait `Index<RangeTo<Option<usize>>>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 1 argument was\
    \ supplied\n  --> /tmp/tmposhisgbp.rs:38:39\n   |\n38 |         let last_postfix_palindrome\
    \ = make_palindrome(string[..last_postfix_length]);\n   |                    \
    \                   ^^^^^^^^^^^^^^^ ----------------------------- supplied 1 argument\n\
    \   |                                       |\n   |                          \
    \             expected 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmposhisgbp.rs:12:8\n\
    \   |\n12 |     fn make_palindrome(\n   |        ^^^^^^^^^^^^^^^\n13 |       \
    \  suffix: &str,\n   |         ------------\n14 |         prefix_length: usize,\n\
    \   |         --------------------\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n  --> /"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut start = String::from(\"\");\n    let mut end = string;\n    let mut\
    \ reverse = String::from(\"\");\n    let mut longest_postfix = String::from(\"\
    \");\n    while !start.is_empty() {\n        let mut current = end;\n        longest_postfix\
    \ = longest(longest_postfix, current);\n        current = reverse(reverse, current);\n\
    \        start = reverse(start, current);\n    }\n    longest_postfix\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest` in this scope\n  --> /tmp/tmppoygdxlc.rs:18:27\n\
    \   |\n18 |         longest_postfix = longest(longest_postfix, current);\n   |\
    \                           ^^^^^^^ not found in this scope\n\nerror[E0618]: expected\
    \ function, found `String`\n  --> /tmp/tmppoygdxlc.rs:19:19\n   |\n14 |     let\
    \ mut reverse = String::from(\"\");\n   |         ----------- `reverse` has type\
    \ `String`\n...\n19 |         current = reverse(reverse, current);\n   |     \
    \              ^^^^^^^------------------\n   |                   |\n   |     \
    \              call expression requires function\n\nerror[E0618]: expected function,\
    \ found `String`\n  --> /tmp/tmppoygdxlc.rs:20:17\n   |\n14 |     let mut reverse\
    \ = String::from(\"\");\n   |         ----------- `reverse` has type `String`\n\
    ...\n20 |         start = reverse(start, current);\n   |                 ^^^^^^^----------------\n\
    \   |                 |\n   |                 call expression requires function\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0618.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = String::from(string.chars().rev().take(string.len()).collect());\n\
    \    for c in &*suffix {\n        suffix = suffix.to_string().append(&c.to_string());\n\
    \    }\n    suffix.to_owned()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmpvo_im57x.rs:13:14\n\
    \   |\n13 |     for c in &*suffix {\n   |              ^^^^^^^^ `&str` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&str`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmpvo_im57x.rs:14:37\n\
    \   |\n14 |         suffix = suffix.to_string().append(&c.to_string());\n   |\
    \                                     ^^^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string + \"a\".rev().to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&'static str` is not an iterator\n  --> /tmp/tmpq14cqloj.rs:12:18\n\
    \   |\n12 |     string + \"a\".rev().to_string()\n   |                  ^^^ `&'static\
    \ str` is not an iterator\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `&'static str: Iterator`\n           which is required\
    \ by `&mut &'static str: Iterator`\n           `str: Iterator`\n           which\
    \ is required by `&mut str: Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: -1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n\n    let max_len\
    \ = string.len();\n    let mut s = string;\n    for i in 0..max_len {\n      \
    \  loop {\n            let len = (max_len - i) + 1;\n            let start = s.chars().take(len).collect::<String>();\n\
    \            let end = s.chars().skip(len).collect::<String>();\n            if\
    \ start == end {\n                s = String::from(&s[..(i + 1)]);\n         \
    \       break;\n            }\n        }\n    }\n\n    s\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976844
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = \"a\"; // to reverse the prefix\n    let mut prefix = string;\n\
    \    while let Some(p) = palindrome_length(prefix.as_str()) {\n        prefix\
    \ = prefix.remove(p);\n        suffix = suffix.append()\n    };\n    String::from(prefix\
    \ + suffix).reverse()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `palindrome_length` in this scope\n\
    \  --> /tmp/tmp73xw7vyr.rs:14:25\n   |\n14 |     while let Some(p) = palindrome_length(prefix.as_str())\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp73xw7vyr.rs:15:18\n   |\n13 |  \
    \   let mut prefix = string;\n   |                      ------ expected due to\
    \ this value\n14 |     while let Some(p) = palindrome_length(prefix.as_str())\
    \ {\n15 |         prefix = prefix.remove(p);\n   |                  ^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\n\
    \   |                  expected struct `String`, found `char`\n\nerror[E0599]:\
    \ no method named `append` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmp73xw7vyr.rs:16:25\n   |\n16 |         suffix = suffix.append()\n\
    \   |                         ^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp73xw7vyr.rs:18:35\n   |\n18 |     String::from(prefix + suffix).reverse()\n\
    \   |                                   ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse_string = string.chars().map(|c| c.to_string()).collect::<Vec<String>>();\n\
    \    reverse_string.push(reverse_string.last());\n    let new_string = string.chars().map(|c|\
    \ c.to_string()).collect::<Vec<String>>();\n    new_string.push(reverse_string);\n\
    \    new_string.join()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq4ivqvlx.rs:13:25\n   |\n\
    13 |     reverse_string.push(reverse_string.last());\n   |                   \
    \      ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n \
    \  |\n   = note: expected struct `String`\n                found enum `Option<&String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq4ivqvlx.rs:15:21\n   |\n15 |\
    \     new_string.push(reverse_string);\n   |                     ^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<String>`\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpq4ivqvlx.rs:16:16\n\
    \    |\n16  |     new_string.join()\n    |                ^^^^- supplied 0 arguments\n\
    \    |                |\n    |                expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string\n        .chars()\n        .filter_map(|c| if c.is_alphanumeric()\
    \ { c.to_ascii_lowercase() } else { None })\n        .filter(|c| !c.is_alphanumeric())\n\
    \        .map(|c| if c.is_lowercase() { c.to_ascii_uppercase() } else { c })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv6k2ypzk.rs:14:50\n   |\n\
    14 |         .filter_map(|c| if c.is_alphanumeric() { c.to_ascii_lowercase() }\
    \ else { None })\n   |                                                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |         .filter_map(|c| if c.is_alphanumeric() { Some(c.to_ascii_lowercase())\
    \ } else { None })\n   |                                                  +++++\
    \                      +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string.chars().filter_map(|c| {\n        if c.is_whitespace() {\n       \
    \     None\n        } else {\n            Some(c.to_string())\n        }\n   \
    \ }).take_while(|c| c.is_ascii()).chain(\n        string.chars().filter_map(|c|\
    \ {\n            if c.is_whitespace() {\n                None\n            } else\
    \ if c == c.to_string() + 'a' {\n                Some(c.to_string())\n       \
    \     } else if c != c.to_string() + 'a' {\n                None\n           \
    \ } else {\n                Some(c.to_string() + c.to_string() + 'a')\n      \
    \      }\n        }).take_while(|c| c.is_ascii()).rev()\n    ).chain(string.chars().filter_map(|c|\
    \ {\n        if c.is_whitespace() {\n            None\n        } else if c !=\
    \ c.to_string() + 'a' && c != c.to_string() + 'a' {\n            None\n      \
    \  } else {\n            Some(c.to_string())\n        }\n    }).take_while(|c|\
    \ c.is_ascii()).rev()).collect()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5d7fqm01.rs:22:44\n   |\n\
    22 |             } else if c == c.to_string() + 'a' {\n   |                  \
    \                          ^^^ expected `&str`, found `char`\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n22 |             }\
    \ else if c == c.to_string() + \"a\" {\n   |                                 \
    \           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5d7fqm01.rs:22:28\n\
    \   |\n22 |             } else if c == c.to_string() + 'a' {\n   |           \
    \                 ^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5d7fqm01.rs:24:44\n   |\n24 |\
    \             } else if c != c.to_string() + 'a' {\n   |                     \
    \                       ^^^ expected `&str`, found `char`\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n24 |             }\
    \ else if c != c.to_string() + \"a\" {\n   |                                 \
    \           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5d7fqm01.rs:24:28\n\
    \   |\n24 |             } else if c != c.to_string() + 'a' {\n   |           \
    \                 ^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5d7fqm01.rs:27:38\n   |\n27 |\
    \                 Some(c.to_string() + c.to_string() + 'a')\n   |            \
    \                          ^^^^^^^^^^^^^\n   |                               \
    \       |\n   |                                      expected `&str`, found struct\
    \ `String`\n   |                                      help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5d7fqm01.rs:27:54\n\
    \   |\n27 |                 Some(c.to_string() + c.to_string() + 'a')\n   |  \
    \                                                    ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n27 |                 Some(c.to_string() + c.to_string() + \"a\")\n   |\
    \                                                      ~~~\n\nerror[E0277]: the\
    \ trait bou"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = (0..string.len()).rev().collect::<Vec<_>>();\n    let mut\
    \ suffix2 = string.split_last().unwrap().to_owned();\n    suffix2.reverse();\n\
    \    let mut result = \"\";\n    for (i, c) in suffix.into_iter().zip(suffix2.into_iter())\
    \ {\n        result += c;\n        if i == 0 || (i + 1) * 2 == string.len() {\n\
    \            result += c;\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_last` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmplo0tymre.rs:13:30\n   |\n13 |     let mut suffix2\
    \ = string.split_last().unwrap().to_owned();\n   |                           \
    \   ^^^^^^^^^^ help: there is an associated function with a similar name: `split`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmplo0tymre.rs:17:9\n   |\n17 |         result += c;\n   |       \
    \  ------^^^^^\n   |         |\n   |         cannot use `+=` on type `&str`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmplo0tymre.rs:19:13\n   |\n19 |             result += c;\n   |  \
    \           ------^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplo0tymre.rs:22:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    22 |     result\n   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.length() <= 1 {\n        return string;\n    }\n\n    let mut s\
    \ = string;\n    let mut l = string.length();\n\n    // find the longest postfix\
    \ that is a palindrome.\n    for p in s.rev() {\n        if p == string[l - 2]\
    \ {\n            l -= 2;\n        } else {\n            break;\n        }\n  \
    \  }\n\n    // reverse that postfix and put it at the end of the string.\n   \
    \ let reversed = string\n        .split_at_mut(l - 2)\n        .map(|x| x.chars().rev().collect::<String>().reverse())\n\
    \        .collect::<Vec<_>>();\n\n    let result = reversed\n        .iter()\n\
    \        .cloned()\n        .chain(s.chars().rev())\n        .collect::<Vec<_>>();\n\
    \n    result.append(&s);\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpw50ayhu0.rs:12:15\n   |\n12 |     if string.length()\
    \ <= 1 {\n   |               ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpw50ayhu0.rs:17:24\n   |\n17 | \
    \    let mut l = string.length();\n   |                        ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmpw50ayhu0.rs:20:16\n    |\n20  |       for\
    \ p in s.rev() {\n    |                  ^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror[E0599]: `(&mut str, &mut str)` is\
    \ not an iterator\n  --> /tmp/tmpw50ayhu0.rs:31:10\n   |\n31 |         .map(|x|\
    \ x.chars().rev().collect::<String>().reverse())\n   |          ^^^ `(&mut str,\
    \ &mut str)` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `(&mut str, &mut str): Iterator`\n           which\
    \ is required by `&mut (&mut str, &mut str): Iterator`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut last_char = String::from(\"\");\n\
    \n    while !palindrome.is_empty() {\n        let mut next_char = String::from(\"\
    \");\n        loop {\n            next_char = if palindrome.len() == 1 {\n   \
    \             palindrome.chars().nth(0).unwrap()\n            } else {\n     \
    \           if palindrome.chars().nth(1).unwrap() == palindrome.chars().nth(0).unwrap()\
    \ {\n                    palindrome.chars().nth(0).unwrap()\n                }\
    \ else {\n                    last_char\n                }\n            };\n\n\
    \            palindrome.clear();\n\n            if !next_char.contains(&last_char)\
    \ {\n                palindrome.push(*next_char);\n                break;\n  \
    \          }\n\n            last_char = next_char;\n        }\n    }\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp48w1tof3.rs:19:17\n   |\n\
    19 |                 palindrome.chars().nth(0).unwrap()\n   |                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                 |\n   |                 expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp48w1tof3.rs:22:21\n\
    \   |\n22 |                     palindrome.chars().nth(0).unwrap()\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                     |\n   |                   \
    \  expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp48w1tof3.rs:31:33\n   |\n31 |                 palindrome.push(*next_char);\n\
    \   |                                 ^^^^^^^^^^ expected `char`, found `str`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // Start with the longest postfix that is a palindrome\n    let mut longest_palindromic\
    \ = string;\n    while !longest_palindromic.ends_with(string[..]) {\n        longest_palindromic\
    \ += \"*\";\n    }\n    // Append the reverse of the postfix of the prefix that\
    \ comes before that postfix.\n    longest_palindromic += string[..string.rfind(&longest_palindromic)].chars().collect::<String>().reverse().collect();\n\
    \    longest_palindromic\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmp7c0z9j8l.rs:14:42\n     |\n14   |     while !longest_palindromic.ends_with(string[..])\
    \ {\n     |                                --------- ^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n     |                                |\n     |\
    \                                required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `core::str::<impl str>::ends_with`\n\nerror[E0277]: expected a\
    \ `FnMut<(char,)>` closure, found `str`\n  --> /tmp/tmp7c0z9j8l.rs:14:42\n   |\n\
    14 |     while !longest_palindromic.ends_with(string[..]) {\n   |            \
    \                    --------- ^^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \   |                                |\n   |                                required\
    \ by a bound introduced by this call\n   |\n   = note: the trait bound `str: Pattern<'_>`\
    \ is not satisfied\n   = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `str`\nhelp: consider borrowing here\n   |\n14 |     while\
    \ !longest_palindromic.ends_with(&string[..]) {\n   |                        \
    \                  +\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \  --> /tmp/tmp7c0z9j8l.rs:18:28\n   |\n18 |     longest_palindromic += string[..string.rfind(&longest_palindromic)].chars().collect::<String>().reverse().collect();\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeTo<Option<usize>>`\n   |\n   = help: the\
    \ trait `Index<RangeTo<Option<usize>>>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = string;\n    let mut prefix: String;\n    let mut longest_suffix\
    \ = 0;\n    let mut longest_prefix = 0;\n\n    while !suffix.is_empty() {\n  \
    \      let mut i = suffix.rfind('c', longest_suffix - 1);\n        if i == -1\
    \ {\n            suffix = suffix[..];\n        } else {\n            let mut j\
    \ = longest_suffix - i;\n            if j > longest_prefix {\n               \
    \ longest_suffix = j;\n                longest_prefix = i;\n            }\n  \
    \      }\n    }\n    longest_prefix += longest_suffix + 1;\n    longest_prefix\
    \ += 1;\n\n    if longest_suffix > 1 {\n        longest_suffix -= 1;\n       \
    \ longest_suffix += 1;\n    } else {\n        longest_suffix -= 1;\n    }\n\n\
    \    prefix = string[..longest_suffix];\n    let mut reverse = String::from(\"\
    a\");\n    while !prefix.is_empty() {\n        reverse.push(prefix[0]);\n    \
    \    prefix.remove(0);\n    }\n    reverse.reverse();\n    reverse.push_str(suffix);\n\
    \n    format!(\"{}{}\", string, reverse)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpf6ytied2.rs:18:28\n     |\n18   |         let mut i = suffix.rfind('c',\
    \ longest_suffix - 1);\n     |                            ^^^^^ ---  ------------------\
    \ supplied 2 arguments\n     |                            |\n     |          \
    \                  expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf6ytied2.rs:19:17\n  \
    \ |\n19 |         if i == -1 {\n   |                 ^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    19 |         if i == Some(-1) {\n   |                 +++++  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf6ytied2.rs:20:22\n   |\n12 |     let mut suffix\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    20 |             suffix = suffix[..];\n   |                      ^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                      |\n\
    \   |                      expected struct `String`, found `str`\n\nerror[E0277]:\
    \ cannot subtract `Option<usize>` from `{integer}`\n  --> /tmp/tmpf6ytied2.rs:22:40\n\
    \   |\n22 |             let mut j = longest_suffix - i;\n   |                \
    \                        ^ no implementation for `{integer} - Option<usize>`\n\
    \   |\n   = help: the trait `Sub<Option<usize>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf6ytied2.rs:25:34\n   |\n15 |     let mut longest_prefix\
    \ = 0;\n   |                              - expected due to this value\n...\n\
    25 |                 longest_pre"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let reverse = String::from(&string[..].reverse());\n\
    \    palindrome.push_str(reverse);\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `str` in the current\
    \ scope\n  --> /tmp/tmp1ejleruu.rs:13:44\n   |\n13 |     let reverse = String::from(&string[..].reverse());\n\
    \   |                                            ^^^^^^^ method not found in `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1ejleruu.rs:14:25\n   |\n14 |\
    \     palindrome.push_str(reverse);\n   |                         ^^^^^^^\n  \
    \ |                         |\n   |                         expected `&str`, found\
    \ struct `String`\n   |                         help: consider borrowing here:\
    \ `&reverse`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debug_assert!(string.len() <= 4);\n    let mut prefix_reverse = string.clone();\n\
    \    let mut suffix_postfix = string.clone();\n    let mut prefix_reverse_palindrome\
    \ = false;\n    let mut suffix_postfix_palindrome = false;\n    for pos in string.rchars().rpos()\
    \ {\n        let mut suffix_postfix_chars = suffix_postfix.chars();\n        let\
    \ mut suffix_postfix_palindrome = false;\n        for suffix_postfix_pos in suffix_postfix.rchars().rpos()\
    \ {\n            let suffix_postfix_char = suffix_postfix.chars().nth(suffix_postfix_pos);\n\
    \            if suffix_postfix_char == &suffix_postfix_chars[0] {\n          \
    \      suffix_postfix_palindrome = true;\n                suffix_postfix_chars\
    \ = suffix_postfix.chars().skip(suffix_postfix_pos).take(1).collect();\n     \
    \       } else {\n                break;\n            }\n        }\n        if\
    \ suffix_postfix_palindrome {\n            suffix_postfix_palindrome = false;\n\
    \            for suffix_postfix_pos in suffix_postfix.rchars().rpos() {\n    \
    \            let suffix_postfix_char = suffix_postfix.chars().nth(suffix_postfix_pos);\n\
    \                if suffix_postfix_char == &suffix_postfix_chars[0] {\n      \
    \              suffix_postfix_palindrome = true;\n                    suffix_postfix\
    \ = suffix_postfix.chars().skip(suffix_postfix_pos).collect();\n             \
    \       break;\n                }\n            }\n        }\n        if suffix_postfix_palindrome\
    \ {\n            suffix_postfix_palindrome = false;\n            for suffix_postfix_pos\
    \ in suffix_postfix.rchars().rpos() {\n                let suffix_postfix_char\
    \ = suffix_postfix.chars().nth(suffix_postfix_pos);\n                if suffix_postfix_char\
    \ == &suffix_postfix_chars[0] {\n                    suffix_postfix_palindrome\
    \ = true;\n                    suffix_postfix = suffix_postfix.chars().skip(suffix_postfix_pos).collect();\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if suffix_postfix_palindrome {\n            suffix_postfix_palindrome =\
    \ false;\n            for suffix_postfix_pos in suffix_postfix.rchars().rpos()\
    \ {\n                let suffix_postfix_char = suffix_postfix.chars().nth(suffix_postfix_pos);\n\
    \                if suffix_post\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9h9pfgvh.rs:65:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n17 |     for pos\
    \ in string.rchars().rpos() {\n   |                                       - unclosed\
    \ delimiter\n...\n51 |         if suffix_postfix_palindrome {\n   |          \
    \                            - unclosed delimiter\n52 |             suffix_postfix_palindrome\
    \ = false;\n53 |             for suffix_postfix_pos in suffix_postfix.rchars().rpos()\
    \ {\n   |                                                                    \
    \  - this delimiter might not be properly closed...\n...\n56 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n65 | }\n   |   ^\n\n\
    error: expected `{`, found `}`\n  --> /tmp/tmp9h9pfgvh.rs:56:1\n   |\n55 |   \
    \              if suffix_post\n   |                 -- this `if` expression has\
    \ a condition, but no block\n56 | }\n   | ^ expected `{`\n\nerror[E0599]: no method\
    \ named `rchars` found for struct `String` in the current scope\n  --> /tmp/tmp9h9pfgvh.rs:17:23\n\
    \   |\n17 |     for pos in string.rchars().rpos() {\n   |                    \
    \   ^^^^^^ help: there is an associated function with a similar name: `chars`\n\
    \nerror[E0599]: no method named `rchars` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp9h9pfgvh.rs:20:50\n   |\n20 |         for suffix_postfix_pos\
    \ in suffix_postfix.rchars().rpos() {\n   |                                  \
    \                ^^^^^^ help: there is an associated function with a similar name:\
    \ `chars`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  -->\
    \ /tmp/tmp9h9pfgvh.rs:22:40\n   |\n22 |             if suffix_postfix_char ==\
    \ &suffix_postfix_chars[0] {\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: a value of type `Chars<'_>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp9h9pfgvh.rs:24:96\n     |\n24   | \
    \                suffix_postfix_chars = suffix_postfix.chars().skip(suffix_postfix_po"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string;\n    let mut i = 0;\n    let mut j = 0;\n\n    while\
    \ i < result.len() && j < result.len() {\n        if result[j] != result[i] {\n\
    \            break;\n        }\n\n        i += 1;\n        j += 1;\n    }\n\n\
    \    if i == result.len() {\n        result\n    } else {\n        result.chars()\n\
    \            .rev()\n            .take(i)\n            .chain(string.chars())\n\
    \            .take(j)\n            .collect::<String>()\n            .join(\"\"\
    )\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4132xl9x.rs:17:12\n\
    \   |\n17 |         if result[j] != result[i] {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4132xl9x.rs:17:25\n   |\n17 |         if result[j] != result[i]\
    \ {\n   |                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `join` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp4132xl9x.rs:34:14\n   |\n34 |          \
    \   .join(\"\")\n   |              ^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.length() == 0 {\n        return string;\n    }\n\n    let mut suffix\
    \ = String::from(\"\");\n    let mut string = string.clone();\n    let mut i =\
    \ 0;\n    let mut j = 0;\n\n    while i < string.length() {\n        if i + 1\
    \ < string.length() {\n            suffix.push_str(&string[j..]);\n          \
    \  i += 1;\n        }\n\n        if suffix.is_palendrome() {\n            string\
    \ = suffix.clone() + &string[i..];\n            i += 1;\n        }\n\n       \
    \ i += 1;\n    }\n\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6b4632wg.rs:12:15\n   |\n12 |     if string.length()\
    \ == 0 {\n   |               ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp6b4632wg.rs:21:22\n   |\n21 | \
    \    while i < string.length() {\n   |                      ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmp6b4632wg.rs:22:27\n\
    \   |\n22 |         if i + 1 < string.length() {\n   |                       \
    \    ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `is_palendrome` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6b4632wg.rs:27:19\n   |\n27 |         if suffix.is_palendrome()\
    \ {\n   |                   ^^^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut longest = 0;\n    let mut prefix: String = string;\n    let mut suffix:\
    \ String = string;\n\n    let mut i = prefix.len();\n    while i {\n        if\
    \ i < suffix.len() {\n            if prefix[i..].iter().cloned().any(|c| c !=\
    \ suffix[i..][..]) {\n                longest = prefix.len();\n              \
    \  break;\n            }\n            i += 1;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n\n    longest\n        .try_clone()\n        .map(|p|\
    \ {\n            prefix.extend(&suffix[..p])\n        })\n        .or_else(|_|\
    \ panic!(\"Unable to make a palindrome from {}\", string))\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdremvq27.rs:17:11\n   |\n\
    17 |     while i {\n   |           ^ expected `bool`, found `usize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `str` in the current scope\n  --> /tmp/tmpdremvq27.rs:19:28\n\
    \   |\n19 |             if prefix[i..].iter().cloned().any(|c| c != suffix[i..][..])\
    \ {\n   |                            ^^^^ method not found in `str`\n\nerror[E0599]:\
    \ no method named `try_clone` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpdremvq27.rs:30:10\n   |\n30 |         .try_clone()\n   |          ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_le`\n\nerror[E0277]:\
    \ `&str` is not an iterator\n   --> /tmp/tmpdremvq27.rs:32:27\n    |\n32  |  \
    \           prefix.extend(&suffix[..p])\n    |                    ------ ^^^^^^^^^^^^\
    \ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n    |     \
    \               |\n    |                    required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Iterator` is not implemented for `&str`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\nnote: required by a bound in `extend`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string.to_string();\n    let mut start = 0..string.len()\
    \ - 1;\n    let mut end = -1;\n\n    while end < string.len() {\n        let (prefix,\
    \ suffix) = string.split_at(end);\n        let reversed = &prefix[start..];\n\
    \        if reversed == suffix {\n            start = end;\n        }\n      \
    \  else {\n            end = string.len();\n            string += &suffix[..end];\n\
    \        }\n    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2n_g15xm.rs:14:19\n\
    \   |\n14 |     let mut end = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `RangeFrom<std::ops::Range<usize>>`\n  --> /tmp/tmp2n_g15xm.rs:18:25\n\
    \   |\n18 |         let reversed = &prefix[start..];\n   |                   \
    \      ^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `RangeFrom<std::ops::Range<usize>>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <RangeFrom<usize> as SliceIndex<[T]>>\n             <RangeFrom<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<RangeFrom<std::ops::Range<usize>>>` for `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2n_g15xm.rs:20:21\n   |\n13 |     let mut start\
    \ = 0..string.len() - 1;\n   |                     ------------------- expected\
    \ due to this value\n...\n20 |             start = end;\n   |                \
    \     ^^^ expected struct `std::ops::Range`, found `usize`\n   |\n   = note: expected\
    \ struct `std::ops::Range<usize>`\n                found type `usize`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut pos = 0;\n    let mut palindrome = string;\n    while !is_palindrome(&palindrome[..])\
    \ {\n        pos = 0;\n        while !is_palindrome(&palindrome[..pos]) {\n  \
    \          pos = pos + 1;\n        }\n        palindrome.push(palindrome[..pos]);\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0v055rs1.rs:14:12\n   |\n14 |     while !is_palindrome(&palindrome[..])\
    \ {\n   |            ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror[E0425]: cannot find function `is_palindrome` in\
    \ this scope\n  --> /tmp/tmp0v055rs1.rs:16:16\n   |\n16 |         while !is_palindrome(&palindrome[..pos])\
    \ {\n   |                ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0v055rs1.rs:19:25\n\
    \   |\n19 |         palindrome.push(palindrome[..pos]);\n   |                \
    \         ^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut prefix\
    \ = string;\n    let mut suffix = string;\n    let mut longest_palindrome = string;\n\
    \    for c in string.chars() {\n        match longest_palindrome.as_mut() {\n\
    \            None => panic!(\"Palindrome must have at least one character\"),\n\
    \            Some(p) => p.chars().next().unwrap(),\n        }\n        longest_palindrome\
    \ = &c[..].reverse().to_string();\n        if longest_palindrome == &prefix[..]\
    \ {\n            prefix = &c[..];\n        } else {\n            suffix = &c[..];\n\
    \            longest_palindrome = &c[..].reverse().to_string();\n        }\n \
    \   }\n    longest_palindrome = prefix.to_string() + longest_palindrome + suffix;\n\
    \    longest_palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi0o3a6ae.rs:20:13\n   |\n\
    19 |         match longest_palindrome.as_mut() {\n   |               ---------------------------\
    \ this expression has type `&mut str`\n20 |             None => panic!(\"Palindrome\
    \ must have at least one character\"),\n   |             ^^^^ expected `str`,\
    \ found enum `Option`\n   |\n   = note: expected type `str`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi0o3a6ae.rs:21:13\n\
    \   |\n19 |         match longest_palindrome.as_mut() {\n   |               ---------------------------\
    \ this expression has type `&mut str`\n20 |             None => panic!(\"Palindrome\
    \ must have at least one character\"),\n21 |             Some(p) => p.chars().next().unwrap(),\n\
    \   |             ^^^^^^^ expected `str`, found enum `Option`\n   |\n   = note:\
    \ expected type `str`\n              found enum `Option<_>`\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpi0o3a6ae.rs:23:31\n   |\n23\
    \ |         longest_palindrome = &c[..].reverse().to_string();\n   |         \
    \                      ^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `char`\n  --> /tmp/tmpi0o3a6ae.rs:25:23\n   |\n25 |             prefix = &c[..];\n\
    \   |                       ^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `char`\n  --> /tmp/tmpi0o3a6ae.rs:27:23\n   |\n27 |             suffix\
    \ = &c[..];\n   |                       ^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `char`\n  --> /tmp/tmpi0o3a6ae.rs:28:35\n   |\n28 |        \
    \     longest_palindrome = &c[..].reverse().to_string();\n   |               \
    \                    ^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi0o3a6ae.rs:31:47\n\
    \   |\n31 |     longest_palindrome = prefix.to_string() + longest_palindrome +\
    \ suffix;\n   |                                               ^^^^^^^^^^^^^^^^^^\n\
    \   |                                               |\n   |                  \
    \                             expected `&str`, found struct `String`\n   |   \
    \                                            help: consider borrowing here:"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string.chars()\n        .flat_map(|c| {\n            let mut s = c.to_string();\n\
    \            s.push_str(&s.chars().rev().collect::<String>());\n            s.to_string()\n\
    \        })\n        .chain(string.chars())\n        .take_while(|c| !c.is_whitespace())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n    --> /tmp/tmptf51q_7g.rs:13:19\n\
    \     |\n13   |           .flat_map(|c| {\n     |  __________--------_^\n    \
    \ | |          |\n     | |          required by a bound introduced by this call\n\
    14   | |             let mut s = c.to_string();\n15   | |             s.push_str(&s.chars().rev().collect::<String>());\n\
    16   | |             s.to_string()\n17   | |         })\n     | |_________^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n     |\n     = help:\
    \ the trait `Iterator` is not implemented for `String`\n     = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\nnote:\
    \ required by a bound in `flat_map`\n\nerror[E0599]: the method `chain` exists\
    \ for struct `FlatMap<Chars<'_>, String, [closure@/tmp/tmptf51q_7g.rs:13:19: 17:10]>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmptf51q_7g.rs:18:10\n\
    \    |\n18  |           .chain(string.chars())\n    |            ^^^^^ method\
    \ cannot be called on `FlatMap<Chars<'_>, String, [closure@/tmp/tmptf51q_7g.rs:13:19:\
    \ 17:10]>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: IntoIterator`\n           \
    \ which is required by `FlatMap<Chars<'_>, String, [closure@/tmp/tmptf51q_7g.rs:13:19:\
    \ 17:10]>: Iterator`\n            `FlatMap<Chars<'_>, String, [closure@/tmp/tmptf51q_7g.rs:13:19:\
    \ 17:10]>: Iterator`\n            which is required by `&mut FlatMap<Chars<'_>,\
    \ String, [closure@/tmp/tmptf51q_7g.rs:13:19: 17:10]>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = [String::from('')].into_iter().collect();\n    suffix.extend(string.chars().take(string.len()\
    \ / 2).collect::<Vec<_>>());\n    suffix.extend(&[String::from('')].into_iter().collect());\n\
    \    let mut prefix = suffix.clone();\n    let mut reversed_suffix = suffix.clone();\n\
    \    let mut reversed_prefix = prefix.clone();\n    reversed_suffix.reverse();\n\
    \    reversed_prefix.reverse();\n    prefix.append(reversed_prefix);\n    prefix.append(reversed_suffix);\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmpujtz47me.rs:12:37\n   |\n\
    12 |     let mut suffix = [String::from('')].into_iter().collect();\n   |    \
    \                                 ^ empty character literal\n\nerror: empty character\
    \ literal\n  --> /tmp/tmpujtz47me.rs:14:35\n   |\n14 |     suffix.extend(&[String::from('')].into_iter().collect());\n\
    \   |                                   ^ empty character literal\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut postfix = string;\n    let mut reverse = string;\n\n    while postfix.ends_with(&reverse)\
    \ {\n        postfix = postfix.chars().collect::<String>().rev().collect();\n\
    \        reverse = reverse.chars().collect::<String>().rev().collect();\n    }\n\
    \n    string.push_str(&reverse);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp5rlzdbai.rs:16:55\n\
    \    |\n16  |           postfix = postfix.chars().collect::<String>().rev().collect();\n\
    \    |                                                         ^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmp5rlzdbai.rs:17:55\n    |\n17  |         \
    \  reverse = reverse.chars().collect::<String>().rev().collect();\n    |     \
    \                                                    ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let len = string.len();\n    let mut max_len = len - 1;\n    let mut start\
    \ = String::from(string.chars().skip(max_len).collect::<Vec<_>>());\n    let mut\
    \ last = String::from(string.chars().skip(max_len).collect::<Vec<_>>());\n   \
    \ let mut found = false;\n\n    while !found {\n        for c in string.chars().take(max_len)\
    \ {\n            match char::from_u32(c.to_u32()) {\n                Ok(c) =>\
    \ last.push(c),\n                Err(_) => {}\n            }\n        }\n    \
    \    last.push((char::from_u32(last.last().unwrap()).unwrap()));\n        found\
    \ = String::from(last) == start;\n        if max_len > 0 {\n            max_len\
    \ -= 1;\n        } else {\n            break;\n        }\n    }\n    start + String::from(last)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpd8kodl1b.rs:25:19\n\
    \   |\n25 |         last.push((char::from_u32(last.last().unwrap()).unwrap()));\n\
    \   |                   ^                                             ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n25 -         last.push((char::from_u32(last.last().unwrap()).unwrap()));\n\
    25 +         last.push(char::from_u32(last.last().unwrap()).unwrap());\n   | \n\
    \nerror[E0277]: the trait bound `String: From<Vec<char>>` is not satisfied\n \
    \ --> /tmp/tmpd8kodl1b.rs:14:21\n   |\n14 |     let mut start = String::from(string.chars().skip(max_len).collect::<Vec<_>>());\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<Vec<char>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<Vec<char>>` is not satisfied\n \
    \ --> /tmp/tmpd8kodl1b.rs:15:20\n   |\n15 |     let mut last = String::from(string.chars().skip(max_len).collect::<Vec<_>>());\n\
    \   |                    ^^^^^^^^^^^^ the trait `From<Vec<char>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0599]: no method named `to_u32` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpd8kodl1b.rs:20:36\n   |\n20 |             match char::from_u32(c.to_u32())\
    \ {\n   |                                    ^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd8kodl1b.rs:21:17\n   |\n20 |\
    \             match char::from_u32(c.to_u32()) {\n "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string: String = string;\n    let mut rev_string: String = string;\n\
    \n    let longest_prefix_palindrome: usize = get_longest_prefix_palindrome(string);\n\
    \    let longest_prefix_rev_palindrome: usize = get_longest_prefix_rev_palindrome(string);\n\
    \    let prefix_length = longest_prefix_palindrome - longest_prefix_rev_palindrome\
    \ + 1;\n\n    rev_string.resize_to(longest_prefix_rev_palindrome + 1);\n\n   \
    \ for pos in 1..prefix_length {\n        rev_string.push(rev_string[longest_prefix_rev_palindrome\
    \ + pos - 1]);\n    }\n\n    string.push_str(rev_string);\n\n    string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_longest_prefix_palindrome` in this\
    \ scope\n  --> /tmp/tmp9jr7onc8.rs:15:44\n   |\n15 |     let longest_prefix_palindrome:\
    \ usize = get_longest_prefix_palindrome(string);\n   |                       \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `get_longest_prefix_rev_palindrome` in this\
    \ scope\n  --> /tmp/tmp9jr7onc8.rs:16:48\n   |\n16 |     let longest_prefix_rev_palindrome:\
    \ usize = get_longest_prefix_rev_palindrome(string);\n   |                   \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `longest_prefix_palindrome`\n\nerror[E0599]:\
    \ no method named `resize_to` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp9jr7onc8.rs:19:16\n   |\n19 |     rev_string.resize_to(longest_prefix_rev_palindrome\
    \ + 1);\n   |                ^^^^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9jr7onc8.rs:22:25\n\
    \   |\n22 |         rev_string.push(rev_string[longest_prefix_rev_palindrome +\
    \ pos - 1]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9jr7onc8.rs:25:21\n\
    \   |\n25 |     string.push_str(rev_string);\n   |                     ^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&rev_string`\n\
    \nerror: aborting due to 5 p"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n\n    while !string.is_empty() {\n        let mut\
    \ longest_prefix_string = \"\";\n        let mut longest_prefix_string_index =\
    \ 0;\n\n        let mut longest_suffix_string = \"\";\n        let mut longest_suffix_string_index\
    \ = 0;\n\n        while !string.is_empty() && longest_prefix_string_index < longest_prefix_string.len()\
    \ {\n            let index1 = string.len() - longest_prefix_string.len() + longest_prefix_string_index;\n\
    \            let index2 = string.len() - longest_suffix_string.len() + longest_suffix_string_index;\n\
    \n            if index1 > index2 {\n                longest_suffix_string[..longest_suffix_string.len()\
    \ - longest_prefix_string.len()] = longest_prefix_string;\n                longest_prefix_string\
    \ = \"\";\n                longest_prefix_string_index = 0;\n            } else\
    \ if index2 > index1 {\n                longest_prefix_string[..longest_prefix_string.len()]\
    \ = longest_suffix_string;\n                longest_suffix_string = \"\";\n  \
    \              longest_suffix_string_index = 0;\n            } else {\n      \
    \          longest_prefix_string += &string[index1];\n                longest_suffix_string\
    \ += &string[index2];\n            }\n            string += &string[index1];\n\
    \            string += &string[index2];\n        }\n\n        if longest_suffix_string.is_empty()\
    \ {\n            return String::from(\"\");\n        }\n\n        string += &longest_suffix_string[..longest_suffix_string.len()\
    \ - longest_prefix_string.len()];\n\n        longest_prefix_string += &longest_suffix_string[..longest_suffix_string.len()\
    \ - longest_prefix_string.len()];\n\n        longest_suffix_string_index += longest_suffix_string.len()\
    \ - longest_prefix_string.len();\n\n        longest_suffix_string = longest_suffix_string[..longest_suffix_string.len()/2];\n\
    \n        longest_prefix_string_index += longest_prefix_string.len() - longest_suffix_string.len();\n\
    \n        longest_prefix_string = longest_prefix_string[..longest_prefix_string.len()/2];\n\
    \    }\n\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvot_u8xe.rs:26:102\n   |\n\
    26 |                 longest_suffix_string[..longest_suffix_string.len() - longest_prefix_string.len()]\
    \ = longest_prefix_string;\n   |                 ----------------------------------------------------------------------------------\
    \   ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `&str`\n   |                 |\n\
    \   |                 expected due to the type of this binding\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpvot_u8xe.rs:26:17\n   |\n26 |                 longest_suffix_string[..longest_suffix_string.len()\
    \ - longest_prefix_string.len()] = longest_prefix_string;\n   |              \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: the left-hand-side of an assignment\
    \ must have a statically known size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvot_u8xe.rs:30:72\n\
    \   |\n30 |                 longest_prefix_string[..longest_prefix_string.len()]\
    \ = longest_suffix_string;\n   |                 ----------------------------------------------------\
    \   ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `&str`\n   |                 |\n\
    \   |                 expected due to the type of this binding\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpvot_u8xe.rs:30:17\n   |\n30 |                 longest_prefix_string[..longest_prefix_string.len()]\
    \ = longest_suffix_string;\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: the left-hand-side of an assignment\
    \ must have a statically known size\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpvot_u8xe.rs:34:43\n   |\n34 |         \
    \        longest_prefix_string += &string[index1];\n   |                     \
    \                   "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut len = 0;\n    let mut max_len = string.length();\n    let mut start\
    \ = -1;\n    let mut end = -1;\n    let mut pal_str = string;\n    let mut char_index\
    \ = -1;\n    let mut reverse_str = String::new();\n    let mut reversed_char =\
    \ String::new();\n\n    while true {\n        let mut cur = string.chars();\n\
    \        cur.next(); // Get next character and advance cursor to next\n      \
    \  cur.next(); // Get next character\n        cur.next(); // Get next character\n\
    \n        if string[len] != string[(len + 1) - 1] {\n            pal_str = pal_str.chars().collect();\n\
    \            pal_str = String::from(pal_str.iter().rev().collect());\n       \
    \     end = len - 1;\n            break;\n        }\n\n        len = len + 1;\n\
    \    }\n\n    while max_len > len {\n        start = len - 1;\n        let mut\
    \ cur = string.chars();\n        cur.next(); // Get next character and advance\
    \ cursor to next\n        cur.next(); // Get next character\n        cur.next();\
    \ // Get next character\n\n        if string[start] != string[(start + 1) - 1]\
    \ {\n            pal_str = pal_str.chars().collect();\n            pal_str = String::from(pal_str.iter().rev().collect());\n\
    \            end = len - 1;\n            break;\n        }\n\n        start =\
    \ start - 1;\n        len = len - 1;\n    }\n\n    pal_str = pal_str.chars().collect();\n\
    \    pal_str = String::from(pal_str.iter().rev().collect());\n\n    while pal_str\
    \ != string {\n        let mut cur = string.chars();\n        cur.next(); // Get\
    \ next character and advance cursor to next\n        cur.next(); // Get next character\n\
    \        cur.next(); // Get next character\n        char_index = char_index +\
    \ 1;\n\n        if string[char_index] != string[(char_index + 1) - 1] {\n    \
    \        pal_str = pal_str.chars().collect();\n            pal_str = String::from(pal_str.iter().rev().collect());\n\
    \            end = char_index - 1;\n            break;\n        }\n\n        char_index\
    \ = char_index - 1;\n    }\n\n    reverse_str = string.chars().collect();\n  \
    \  reverse_str = String::from(reverse_str.iter().rev().collect());\n\n    reversed_char\
    \ = reverse_str.chars().collect();\n    reversed_char = String::from(reversed_char.iter().rev().collect());\n\
    \n    string = pal_str + reversed_char + string;\n\n    return string;\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpih_w7jg0.rs:21:5\n\
    \   |\n21 |     while true {\n   |     ^^^^^^^^^^ help: use `loop`\n   |\n   =\
    \ note: `#[warn(while_true)]` on by default\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpih_w7jg0.rs:13:30\n\
    \   |\n13 |     let mut max_len = string.length();\n   |                     \
    \         ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpih_w7jg0.rs:27:12\n\
    \   |\n27 |         if string[len] != string[(len + 1) - 1] {\n   |          \
    \  ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpih_w7jg0.rs:27:27\n   |\n27 |         if string[len] != string[(len\
    \ + 1) - 1] {\n   |                           ^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpih_w7jg0.rs:29:44\n   |\n29 |          \
    \   "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // TODO: find and use better algorithm to find palindrome prefix.\n    let\
    \ mut reverse = \"\";\n    for &c in string {\n        reverse.push(c); // append\
    \ the current character\n    }\n\n    if reverse.len() == string.len() {\n   \
    \     reverse\n    } else {\n        let mut palindrome = String::from(reverse);\n\
    \        for &c in string {\n            palindrome.push(c);\n            if palindrome\
    \ == string {\n                return palindrome;\n            }\n           \
    \ palindrome.push(c); // append the character\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp1gg368sx.rs:14:15\n\
    \   |\n14 |     for &c in string {\n   |               ^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `push` found for reference `&str` in the current scope\n  --> /tmp/tmp1gg368sx.rs:15:17\n\
    \   |\n15 |         reverse.push(c); // append the current character\n   |   \
    \              ^^^^ method not found in `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1gg368sx.rs:19:9\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n19 |         reverse\n   |         ^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |         |\n   |        \
    \ expected struct `String`, found `&str`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmp1gg368sx.rs:22:19\n   |\n22 |         for &c in string {\n   |\
    \                   ^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1gg368sx.rs:22:9\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n22 | /         for &c in string {\n23 | |             palindrome.push(c);\n\
    24 | |             if palindrome == string {\n25 | |                 return palindrome;\n\
    26 | |             }\n27 | |             palindrome.push(c); // append the character\n\
    28 | |         }\n   | |_________^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        String::from(\"\")\n    } else {\n       \
    \ let (left_rest, right_rest) = string.split_at(2);\n        let (left_rest, right_rest)\
    \ = if left_rest.len() < right_rest.len() {\n            (left_rest, right_rest)\n\
    \        } else {\n            (right_rest, left_rest)\n        };\n        let\
    \ left_reversed = reverse(left_rest);\n        let right_reversed = reverse(right_rest);\n\
    \        let mut result = left_reversed;\n        result.push(reverse(left_rest));\n\
    \        result.push(right_reversed);\n        result\n    }\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpgt2yymhy.rs:21:29\n\
    \   |\n21 |         let left_reversed = reverse(left_rest);\n   |            \
    \                 ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `reverse` in this scope\n  --> /tmp/tmpgt2yymhy.rs:22:30\n   |\n22\
    \ |         let right_reversed = reverse(right_rest);\n   |                  \
    \            ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `reverse` in this scope\n  --> /tmp/tmpgt2yymhy.rs:24:21\n   |\n24 |       \
    \  result.push(reverse(left_rest));\n   |                     ^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string\n        .chars()\n        .chain(string.chars().rev())\n        .take_while(|c|\
    \ !c.is_digit())\n        .map(|c| String::from(c))\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpebytudiz.rs:15:28\n    |\n15  |         .take_while(|c| !c.is_digit())\n\
    \    |                            ^^^^^^^^- supplied 0 arguments\n    |      \
    \                      |\n    |                            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut i = 1;\n    let mut rev = string;\n    while i < string.len() {\n\
    \        let mut j = i + 1;\n        let mut is_rev = false;\n        while j\
    \ < string.len() {\n            if string[j] != string[i] {\n                break;\n\
    \            }\n            is_rev = !is_rev;\n            j += 1;\n        }\n\
    \        if is_rev {\n            let mut j = i;\n            while j + 1 < string.len()\
    \ {\n                let next = string[j + 1];\n                string[j] = string[i];\n\
    \                string[i] = next;\n                j += 1;\n            }\n \
    \           rev = string.clone();\n        }\n        i += 1;\n    }\n    rev\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1lv_w3os.rs:18:16\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1lv_w3os.rs:18:29\n   |\n18 |             if string[j] != string[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1lv_w3os.rs:27:28\n   |\n27 |                 let next = string[j\
    \ + 1];\n   |                            ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut last_index = 0;\n    for index\
    \ in string.chars().skip(1).rev() {\n        if index == string[last_index] {\n\
    \            last_index = index;\n        } else {\n            palindrome = &palindrome[..last_index].reverse()\
    \ + &string[..index];\n            last_index = index;\n        }\n    }\n   \
    \ palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpbxfqm1zg.rs:14:41\n     |\n14   |     for index in string.chars().skip(1).rev()\
    \ {\n     |                                         ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Skip<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]: the\
    \ trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpbxfqm1zg.rs:14:18\n\
    \   |\n14 |     for index in string.chars().skip(1).rev() {\n   |            \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n             &mut I\n             Args\n             ArgsOs\n\
    \             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_, T, N>\n \
    \            ArrayWindows<'_, T, N>\n             Box<I, A>\n             Chunks<'_,\
    \ T>\n           and 109 others\n   = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Skip<Chars<'_>>`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `Rev<Skip<Chars<'_>>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Rev<Skip<Chars<'_>>>`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpbxfqm1zg.rs:15:21\n   |\n15 |         if index\
    \ == string[last_index] {\n   |                     ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types i"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debug_assert!(\n        !string.is_empty(),\n        \"Empty string is impossible.\
    \ Nothing to reverse.\"\n    );\n    let mut rev = \"\";\n\n    let mut longest_prefix\
    \ = prefix.iter().cloned().rev();\n\n    while let Some(prefix) = get_prefix_longest_palindrome(longest_prefix,\
    \ string) {\n        rev.insert(0, prefix);\n        longest_prefix = prefix.iter().cloned().rev();\n\
    \    }\n\n    rev\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `prefix` in this scope\n  --> /tmp/tmpxc71u69m.rs:18:30\n\
    \   |\n18 |     let mut longest_prefix = prefix.iter().cloned().rev();\n   | \
    \                             ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_prefix_longest_palindrome` in this scope\n  --> /tmp/tmpxc71u69m.rs:20:30\n\
    \   |\n20 |     while let Some(prefix) = get_prefix_longest_palindrome(longest_prefix,\
    \ string) {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `insert` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpxc71u69m.rs:21:13\n   |\n21 |   \
    \      rev.insert(0, prefix);\n   |             ^^^^^^ method not found in `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxc71u69m.rs:25:5\n   |\n11 | fn\
    \ make_palindrome(string: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n25 |     rev\n\
    \   |     ^^^- help: try using a conversion method: `.to_string()`\n   |     |\n\
    \   |     expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // The length of the longest postfix of string that is a palindrome.\n  \
    \  let mut len = 0;\n    for c in string.chars() {\n        let mut suffix: String\
    \ = c.to_string();\n        suffix.reverse();\n        if let Some(&Some(suffix))\
    \ = suffix.chars() {\n            if suffix.chars().rev().all() == &suffix[..]\
    \ {\n                len = std::cmp::min(len, suffix.len());\n            }\n\
    \        }\n    }\n\n    let mut result = \"?\".to_string();\n    result += &string[..len];\n\
    \n    let mut i = 0;\n    while i < len - 1 {\n        let c = &string[i..i +\
    \ 2];\n        let v = c.chars().rev().next();\n        result += &v[..2];\n \
    \       i += 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmptmf8lfu8.rs:16:16\n   |\n16 |         suffix.reverse();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptmf8lfu8.rs:17:16\n\
    \   |\n17 |         if let Some(&Some(suffix)) = suffix.chars() {\n   |      \
    \          ^^^^^^^^^^^^^^^^^^^   -------------- this expression has type `Chars<'_>`\n\
    \   |                |\n   |                expected struct `Chars`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Chars<'_>`\n                found\
    \ enum `Option<_>`\n\nerror[E0608]: cannot index into a value of type `Option<char>`\n\
    \  --> /tmp/tmptmf8lfu8.rs:31:20\n   |\n31 |         result += &v[..2];\n   |\
    \                    ^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut max = string.len();\n    while max\
    \ > 0 {\n        let mut suffix = string;\n        suffix.reverse();\n       \
    \ if &suffix == &string {\n            max = max - 1;\n        }\n        string\
    \ = suffix.clone();\n    }\n    string.clone()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdoacfupp.rs:16:16\n   |\n16 |         suffix.reverse();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix_index = string.length() - 1;\n    let mut suffix_value = string[suffix_index];\n\
    \    let mut string_value = string.to_string();\n    let mut index = 0;\n    loop\
    \ {\n        let mut prefix = string_value.clone();\n        prefix.truncate(index);\n\
    \        let suffix_index = string.length() - suffix_index - 1;\n        let suffix_value\
    \ = string[suffix_index];\n        let mut suffix;\n        if suffix_value ==\
    \ suffix_value {\n            suffix.truncate(index);\n        } else {\n    \
    \        suffix.resize(string_value.len(), 0);\n            suffix.copy(&string_value[..suffix_index]);\n\
    \            suffix.append(&mut [suffix_value]);\n            suffix.reverse();\n\
    \        }\n        let prefix = prefix.reverse();\n        let mut palindrome\
    \ = prefix.clone();\n        palindrome.extend(suffix);\n        if !palindrome.starts_with(string)\
    \ {\n            break;\n        }\n        suffix_index += 1;\n        index\
    \ = suffix_index;\n        suffix_value = string[suffix_index];\n    }\n    string.truncate(index);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `palindrome` in this scope\n  --> /tmp/tmp4g4ym6xw.rs:41:5\n\
    \   |\n41 |     palindrome\n   |     ^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp4g4ym6xw.rs:12:35\n   |\n12 |     let mut suffix_index = string.length()\
    \ - 1;\n   |                                   ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp4g4ym6xw.rs:19:35\n\
    \   |\n19 |         let suffix_index = string.length() - suffix_index - 1;\n \
    \  |                                   ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp4g4ym6xw.rs:20:28\n   |\n20 |         let suffix_value\
    \ = string[suffix_index];\n   |                            ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp4g4ym6xw.rs:30:29\n   |\n30 |         let\
    \ prefix = prefix.reverse();\n   |                             ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4g4ym6xw.rs:38:24\n\
    \   |\n38 |         suffix_value = string[suffix_index];\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = \"\";\n    let mut suffix = string;\n    let mut\
    \ prefix_len = 0;\n    let mut palindrome = string;\n    while !suffix.is_empty()\
    \ {\n        let mut prefix_start = prefix_len.len();\n        let mut prefix\
    \ = suffix;\n        let mut suffix_start = suffix.len();\n        while !prefix.is_empty()\
    \ {\n            if prefix.as_bytes()[prefix_start] == suffix.as_bytes()[suffix_start]\
    \ {\n                prefix_start += 1;\n                suffix_start += 1;\n\
    \            }\n            else {\n                break;\n            }\n  \
    \          prefix = prefix.prefix();\n        }\n        reversed_string += prefix.to_string();\n\
    \        suffix = suffix.suffix();\n        prefix_len = prefix_start.max(prefix_len);\n\
    \        palindrome = palindrome.insert(prefix_len, reversed_string);\n    }\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpj8vhsbva.rs:17:43\n   |\n17 |         let mut prefix_start = prefix_len.len();\n\
    \   |                                           ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n14 |     let mut prefix_len: i32\
    \ = 0;\n   |         ~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `prefix`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpj8vhsbva.rs:28:29\n\
    \   |\n28 |             prefix = prefix.prefix();\n   |                      \
    \       ^^^^^^ help: there is an associated function with a similar name: `strip_prefix`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpj8vhsbva.rs:30:9\n   |\n30 |         reversed_string += prefix.to_string();\n\
    \   |         ---------------^--^^^^^^^^^^^^^^^^^^^\n   |         |          \
    \     |\n   |         |               `+` cannot be used to concatenate a `&str`\
    \ with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n   = note:\
    \ string concatenation requires an owned `String` on the left\n\nerror[E0599]:\
    \ no method named `suffix` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpj8vhsbva.rs:31:25\n   |\n31 |         suffix = suffix.suffix();\n  \
    \ |                         ^^^^^^ help: there is an associated function with\
    \ a similar name: `strip_suffix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj8vhsbva.rs:33:52\n\
    \   |\n33 |         palindrome = palindrome.insert(prefix_len, reversed_string);\n\
    \   |                                                    ^^^^^^^^^^^^^^^ expected\
    \ `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj8vhsbva.rs:33:22\n\
    \   |\n15 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n33 |         palindrome = palindrome.insert(prefix_len,\
    \ reversed_string);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpj"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string.clone();\n\
    \    reversed_string.rev();\n    let mut prefix = string;\n    let mut suffix\
    \ = reversed_string;\n    let mut postfix = prefix.clone();\n    let mut new_string\
    \ = prefix.clone();\n    while new_string.is_prefix(&suffix) {\n        postfix.rev();\n\
    \        new_string = postfix.clone();\n    }\n    new_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpjohkuj_q.rs:14:21\n\
    \    |\n14  |       reversed_string.rev();\n    |                       ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: no method\
    \ named `is_prefix` found for struct `String` in the current scope\n  --> /tmp/tmpjohkuj_q.rs:19:22\n\
    \   |\n19 |     while new_string.is_prefix(&suffix) {\n   |                  \
    \    ^^^^^^^^^ help: there is an associated function with a similar name: `strip_prefix`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpjohkuj_q.rs:20:17\n\
    \    |\n20  |           postfix.rev();\n    |                   ^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut new_string = string;\n    let mut last_char = new_string.chars().last();\n\
    \    loop {\n        if last_char == String::new().chars().last() {\n        \
    \    return new_string;\n        }\n        let last_char = new_string.chars().last().unwrap();\n\
    \        new_string = new_string.to_owned() + last_char.to_string();\n    }\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoq1nodqi.rs:19:46\n   |\n\
    19 |         new_string = new_string.to_owned() + last_char.to_string();\n   |\
    \                                              ^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \                                           |\n   |                          \
    \                    expected `&str`, found struct `String`\n   |            \
    \                                  help: consider borrowing here: `&last_char.to_string()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string.chars();\n    let mut reversed_string = String::new();\n\
    \    let mut start = 0;\n    let mut end = 0;\n    loop {\n        match string.next()\
    \ {\n            Some('c') -> {\n                reversed_string.push((&string.as_str()[end].unwrap()).to_lowercase());\n\
    \                end = end + 1;\n            }\n            Some('a') -> {\n \
    \               reversed_string.push((&string.as_str()[start].unwrap()).to_lowercase());\n\
    \                start = start + 1;\n            }\n            Some('t') -> {\n\
    \                reversed_string.push((&string.as_str()[end].unwrap()).to_lowercase());\n\
    \                end = end + 1;\n            }\n            Some('g') -> {\n \
    \               reversed_string.push((&string.as_str()[start].unwrap()).to_lowercase());\n\
    \                start = start + 1;\n            }\n            Some('n') -> break,\n\
    \            _ => {\n                reversed_string.push((&string.as_str()[start].unwrap()).to_lowercase());\n\
    \                start = start + 1;\n            }\n        }\n    }\n    String::from_str(&reversed_string)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmporcp6e9m.rs:18:23\n\
    \   |\n18 |             Some('c') -> {\n   |                       ^^\n   |  \
    \                     |\n   |                       expected one of `=>`, `if`,\
    \ or `|`\n   |                       help: try using a fat arrow here: `=>`\n\n\
    error: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmporcp6e9m.rs:22:23\n\
    \   |\n22 |             Some('a') -> {\n   |                       ^^\n   |  \
    \                     |\n   |                       expected one of `=>`, `if`,\
    \ or `|`\n   |                       help: try using a fat arrow here: `=>`\n\n\
    error: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmporcp6e9m.rs:26:23\n\
    \   |\n26 |             Some('t') -> {\n   |                       ^^\n   |  \
    \                     |\n   |                       expected one of `=>`, `if`,\
    \ or `|`\n   |                       help: try using a fat arrow here: `=>`\n\n\
    error: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmporcp6e9m.rs:30:23\n\
    \   |\n30 |             Some('g') -> {\n   |                       ^^\n   |  \
    \                     |\n   |                       expected one of `=>`, `if`,\
    \ or `|`\n   |                       help: try using a fat arrow here: `=>`\n\n\
    error: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmporcp6e9m.rs:34:23\n\
    \   |\n34 |             Some('n') -> break,\n   |                       ^^\n \
    \  |                       |\n   |                       expected one of `=>`,\
    \ `if`, or `|`\n   |                       help: try using a fat arrow here: `=>`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmporcp6e9m.rs:19:40\n\
    \   |\n19 |                 reversed_string.push((&string.as_str()[end].unwrap()).to_lowercase());\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Bo"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut pos = 0;\n    let mut prefix = String::from(\"\");\n    let mut suffix\
    \ = String::from(\"\");\n    let mut longest_palindromic_suffix = String::from(\"\
    \");\n\n    while pos < string.len() {\n        if string[pos] == string[string.len()\
    \ - pos - 1] {\n            longest_palindromic_suffix += string[pos];\n     \
    \       prefix += string[pos];\n            suffix += &string[string.len() - pos\
    \ - 1];\n            pos += 1;\n        } else {\n            break;\n       \
    \ }\n    }\n\n    if suffix == &string[string.len() - 1] {\n        longest_palindromic_suffix\
    \ += &string[pos];\n        prefix += &string[pos];\n    }\n\n    prefix + longest_palindromic_suffix\
    \ + suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0kshtp21.rs:18:12\n\
    \   |\n18 |         if string[pos] == string[string.len() - pos - 1] {\n   | \
    \           ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0kshtp21.rs:18:27\n   |\n18 |         if string[pos] == string[string.len()\
    \ - pos - 1] {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0kshtp21.rs:19:43\n   |\n19 |             longest_palindromic_suffix\
    \ += string[pos];\n   |                                           ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut last_palindrome = String::from(\"\");\n    let mut prefix = String::from(\"\
    \");\n    let mut suffix = String::from(\"\");\n\n    for c in string.chars()\
    \ {\n        match c {\n            'a' => {\n                suffix = suffix.reverse();\n\
    \                last_palindrome = suffix.iter().cloned().collect();\n       \
    \     }\n            'a' | 'b' => {\n                last_palindrome = suffix.iter().cloned().collect();\n\
    \                last_palindrome = last_palindrome.join(c.to_string());\n    \
    \        }\n            'c' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'd' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'e' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'f' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'g' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'h' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'i' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'j' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'k' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'l' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'm' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'n' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'o' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'p' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'q' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            'r' => {\n                last_palindrome = last_palindrome.join(c.to_string());\n\
    \            }\n            's' => {\n                last_palindrome = \n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjzncrrcs.rs:85:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     for c in\
    \ string.chars() {\n   |                             - unclosed delimiter\n17\
    \ |         match c {\n   |                 - unclosed delimiter\n...\n74 |  \
    \           's' => {\n   |                    - this delimiter might not be properly\
    \ closed...\n75 |                 last_palindrome = \n76 | }\n   | - ...as it\
    \ matches this but it has different indentation\n...\n85 | }\n   |   ^\n\nerror:\
    \ expected expression, found `}`\n  --> /tmp/tmpjzncrrcs.rs:76:1\n   |\n76 | }\n\
    \   | ^ expected expression\n\nerror: expected identifier, found keyword `fn`\n\
    \  --> /tmp/tmpjzncrrcs.rs:78:1\n   |\n78 | fn main() {\n   | ^^ expected identifier,\
    \ found keyword\n\nerror: expected one of `=>`, `@`, `if`, or `|`, found `main`\n\
    \  --> /tmp/tmpjzncrrcs.rs:78:4\n   |\n78 | fn main() {\n   |    ^^^^ expected\
    \ one of `=>`, `@`, `if`, or `|`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpjzncrrcs.rs:19:33\n\
    \   |\n19 |                 suffix = suffix.reverse();\n   |                 \
    \                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpjzncrrcs.rs:20:42\n   |\n20 |          \
    \       last_palindrome = suffix.iter().cloned().collect();\n   |            \
    \                              ^^^^ method not found in `String`\n   |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n   |\n20 |                 last_palindrome\
    \ = suffix.chars().cloned().collect();\n   |                                 \
    \         ~~~~~\n\nerror[E0599]: no method named `iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpjzncrrcs.rs:23:42\n   |\n23 |          \
    \       last_palindrome = suffix.iter().cloned().collect();\n   |      "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // We have special case of single character string\n    if string.len() ==\
    \ 1 {\n        return string;\n    }\n\n    let mut reverse = String::from(\"\"\
    );\n    let mut postfix = String::from(\"\");\n    let mut suffix = String::from(\"\
    \");\n    let mut prefix_pos = 0;\n    let mut suffix = String::from(\"\");\n\
    \    let mut suffix_pos = 0;\n    let mut start = String::from(\"\");\n    let\
    \ mut end = String::from(\"\");\n\n    // Find the longest postfix of supplied\
    \ string that is a palindrome.\n    postfix = suffix;\n    let mut postfix_len\
    \ = string.len();\n    while postfix_len >= 1 {\n        postfix = &string[postfix_len..postfix_len\
    \ - postfix_len];\n        postfix_len = postfix.len();\n    }\n\n    // Find\
    \ longest prefix that comes before the postfix as a suffix of the string.\n  \
    \  suffix = &string[postfix_len..];\n    suffix_len = suffix.len();\n\n    //\
    \ Find longest suffix that comes after the postfix as a prefix of the string.\n\
    \    prefix = &string[..suffix_len];\n    prefix_len = prefix.len();\n\n    //\
    \ Find suffix position in the string.\n    while suffix.len() > 0 {\n        start\
    \ = &string[prefix_pos..suffix_pos];\n        end = &string[start..];\n      \
    \  suffix_pos = end;\n        prefix_pos += start.len();\n        suffix = &string[start..];\n\
    \        suffix_len = suffix.len();\n    }\n\n    // Add reverse of postfix to\
    \ the original string.\n    reverse += &string[prefix_pos...suffix_pos];\n\n \
    \   // Add reverse of the postfix to the original string.\n    reverse += &string[start..suffix_pos];\n\
    \n    // Add reverse of the postfix to the original string.\n    reverse += &string[suffix_pos+1..suffix_len];\n\
    \n    return reverse;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmpjio487oc.rs:53:34\n   |\n\
    53 |     reverse += &string[prefix_pos...suffix_pos];\n   |                  \
    \                ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n53 |\
    \     reverse += &string[prefix_pos..suffix_pos];\n   |                      \
    \            ~~\nhelp: or `..=` for an inclusive range\n   |\n53 |     reverse\
    \ += &string[prefix_pos..=suffix_pos];\n   |                                 \
    \ ~~~\n\nerror[E0425]: cannot find value `suffix_len` in this scope\n  --> /tmp/tmpjio487oc.rs:36:5\n\
    \   |\n36 |     suffix_len = suffix.len();\n   |     ^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `suffix_pos`\n\nerror[E0425]: cannot find\
    \ value `prefix` in this scope\n  --> /tmp/tmpjio487oc.rs:39:5\n   |\n39 |   \
    \  prefix = &string[..suffix_len];\n   |     ^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `suffix_len` in this scope\n  --> /tmp/tmpjio487oc.rs:39:24\n\
    \   |\n39 |     prefix = &string[..suffix_len];\n   |                        ^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `suffix_pos`\n\nerror[E0425]:\
    \ cannot find value `prefix_len` in this scope\n  --> /tmp/tmpjio487oc.rs:40:5\n\
    \   |\n40 |     prefix_len = prefix.len();\n   |     ^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `postfix_len`\n\nerror[E0425]: cannot find\
    \ value `prefix` in this scope\n  --> /tmp/tmpjio487oc.rs:40:18\n   |\n40 |  \
    \   prefix_len = prefix.len();\n   |                  ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `suffix_len` in this scope\n  --> /tmp/tmpjio487oc.rs:49:9\n\
    \   |\n49 |         suffix_len = suffix.len();\n   |         ^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `suffix_pos`\n\nerror[E0425]: cannot\
    \ find value `suffix_len` in this scope\n  --> /tmp/tmpjio487oc.rs:59:38\n   |\n\
    59 |     reverse += &string[suffix_pos+1..suffix_len];\n   |                 \
    \                     ^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `suffix_pos`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjio487oc.rs:30:19\n\
    \   |\n18 |     let"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        return string;\n    }\n\n    let mut rev1\
    \ = String::from([0; string.len()]);\n    let mut rev2 = String::from([0; string.len()]);\n\
    \    let mut postfix = String::from([0; string.len()]);\n\n    let mut i = 0;\
    \ // starting index of string\n\n    while i <= string.len() - 1 {\n        postfix[i]\
    \ = string[i];\n        i += 1;\n    }\n\n    let mut k = 0; // index on end of\
    \ string\n\n    while k <= postfix.len() - 1 {\n        rev2[k] = postfix[k];\n\
    \        k += 1;\n    }\n\n    rev1.append(rev2.reverse());\n    rev1\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpgud7dk99.rs:16:37\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |                    ------ this would need to be a `const`\n...\n\
    16 |     let mut rev1 = String::from([0; string.len()]);\n   |               \
    \                      ^^^^^^\n\nerror[E0435]: attempt to use a non-constant value\
    \ in a constant\n  --> /tmp/tmpgud7dk99.rs:17:37\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                    ------ this would need to be a\
    \ `const`\n...\n17 |     let mut rev2 = String::from([0; string.len()]);\n   |\
    \                                     ^^^^^^\n\nerror[E0435]: attempt to use a\
    \ non-constant value in a constant\n  --> /tmp/tmpgud7dk99.rs:18:40\n   |\n11\
    \ | fn make_palindrome(string: String) -> String {\n   |                    ------\
    \ this would need to be a `const`\n...\n18 |     let mut postfix = String::from([0;\
    \ string.len()]);\n   |                                        ^^^^^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgud7dk99.rs:23:9\n\
    \   |\n23 |         postfix[i] = string[i];\n   |         ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgud7dk99.rs:23:22\n   |\n23 |         postfix[i] = string[i];\n\
    \   |                      ^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usiz"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n\n    let (min_length,\
    \ max_length) = shortest_palindrome_prefix_len(&string);\n\n    if min_length\
    \ == max_length {\n        return string;\n    }\n\n    let mut new_string = string;\n\
    \    new_string.push_pback(String::from_str(&reverse(&string[..min_length])));\n\
    \    new_string.push_pback(String::from_str(&reverse(&string[min_length..])));\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shortest_palindrome_prefix_len` in\
    \ this scope\n  --> /tmp/tmpwhgj2mkb.rs:16:36\n   |\n16 |     let (min_length,\
    \ max_length) = shortest_palindrome_prefix_len(&string);\n   |               \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpwhgj2mkb.rs:23:45\n\
    \   |\n23 |     new_string.push_pback(String::from_str(&reverse(&string[..min_length])));\n\
    \   |                                             ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpwhgj2mkb.rs:24:45\n\
    \   |\n24 |     new_string.push_pback(String::from_str(&reverse(&string[min_length..])));\n\
    \   |                                             ^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `push_pback` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpwhgj2mkb.rs:23:16\n   |\n23 |     new_string.push_pback(String::from_str(&reverse(&string[..min_length])));\n\
    \   |                ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no function or associated item named `from_str` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpwhgj2mkb.rs:23:35\n   |\n23 |     new_string.push_pback(String::from_str(&reverse(&string[..min_length])));\n\
    \   |                                   ^^^^^^^^ function or associated item not\
    \ found in `String`\n   |\n   = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]:\
    \ no method named `push_pback` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpwhgj2mkb.rs:24:16\n   |\n24 |     new_string.push_pback(String::from_str(&reverse(&string[min_length..])));\n\
    \   |                ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no function or associated item named `from_str` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpwhgj2mkb.rs:24:35\n   |\n24 |     new_"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let len = string.len();\n    let mut start = 0;\n    let mut end = len -\
    \ 1;\n\n    if len == 1 {\n        return string;\n    }\n\n    while start <\
    \ end {\n        let mid = start..end;\n        let sub = string[mid..].iter().cloned().collect::<Vec<String>>();\n\
    \        let sub = sub.iter().cloned().collect();\n        let sub = sub.rev().cloned().collect();\n\
    \        let mut sub_m = 0;\n\n        for i in 0..sub.len() {\n            sub_m\
    \ += sub[i].len_utf8();\n        }\n\n        if sub_m == (sub_m..).max_by(|a,\
    \ b| a.len_utf8() < b.len_utf8()).len_utf8() {\n            return string[start..end];\n\
    \        }\n\n        start += 1;\n        end -= 1;\n    }\n\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeFrom<std::ops::Range<usize>>`\n\
    \  --> /tmp/tmp0c4wkeg0.rs:22:19\n   |\n22 |         let sub = string[mid..].iter().cloned().collect::<Vec<String>>();\n\
    \   |                   ^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<std::ops::Range<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<std::ops::Range<usize>>>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `len_utf8` found for reference `&{integer}`\
    \ in the current scope\n  --> /tmp/tmp0c4wkeg0.rs:31:47\n   |\n31 |         if\
    \ sub_m == (sub_m..).max_by(|a, b| a.len_utf8() < b.len_utf8()).len_utf8() {\n\
    \   |                                               ^^^^^^^^ method not found\
    \ in `&{integer}`\n\nerror[E0599]: no method named `len_utf8` found for reference\
    \ `&{integer}` in the current scope\n  --> /tmp/tmp0c4wkeg0.rs:31:62\n   |\n31\
    \ |         if sub_m == (sub_m..).max_by(|a, b| a.len_utf8() < b.len_utf8()).len_utf8()\
    \ {\n   |                                                              ^^^^^^^^\
    \ method not found in `&{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0c4wkeg0.rs:31:45\n\
    \   |\n31 |         if sub_m == (sub_m..).max_by(|a, b| a.len_utf8() < b.len_utf8()).len_utf8()\
    \ {\n   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0599]: no method\
    \ named `len_utf8` found for enum `Option` in the current scope\n  --> /tmp/tmp0c4wkeg0.rs:31:74\n\
    \   |\n31 |         if sub_m == (sub_m..).max_by(|a, b| a.len_utf8() < b.len_utf8()).len_utf8()\
    \ {\n   |                                                                    \
    \      ^^^^^^^^ m"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n\n    let mut reversed\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\n\
    \    // This loop searches for the longest palindromic suffix that starts at a\
    \ position after this prefix\n    // e.g. for the string \"cat\" the longest palindromic\
    \ suffix is \"tac\"\n    while !reversed.is_empty() {\n        suffix_length =\
    \ prefix_length + reversed.len();\n\n        // If this suffix-start position\
    \ doesn't exist the string isn't a palindrome\n        if reversed.iter().position(|c|\
    \ !c.is_ascii_alphanumeric()).is_none() {\n            break;\n        }\n\n \
    \       // Get the palindromic suffix of this suffix starting at the last postfix\
    \ position\n        reversed = reversed\n            .iter()\n            .rposition(|c|\
    \ !c.is_ascii_alphanumeric())\n            .take_while(|i| i != suffix_length)\n\
    \            .rev()\n            .collect();\n\n        // Add this longest palindromic\
    \ suffix to the prefix of the supplied string\n        prefix_length = suffix_length;\n\
    \    }\n\n    // The longest palindromic prefix ends at this postfix position,\
    \ so the reverse of it\n    let reversed = reversed.iter().rposition(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \n    String::from(reversed + string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1t1h09e_.rs:26:21\n   |\n26 |         if reversed.iter().position(|c|\
    \ !c.is_ascii_alphanumeric()).is_none() {\n   |                     ^^^^ method\
    \ not found in `String`\n   |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n26 |         if reversed.chars().position(|c| !c.is_ascii_alphanumeric()).is_none()\
    \ {\n   |                     ~~~~~\n\nerror[E0599]: no method named `iter` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp1t1h09e_.rs:32:14\n\
    \   |\n32 |             .iter()\n   |              ^^^^ method not found in `String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n32 |             .chars()\n\
    \   |              ~~~~~\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp1t1h09e_.rs:43:29\n   |\n43 | \
    \    let reversed = reversed.iter().rposition(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \   |                             ^^^^ method not found in `String`\n   |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n   |\n43 |     let reversed = reversed.chars().rposition(|c|\
    \ !c.is_ascii_alphanumeric()).collect();\n   |                             ~~~~~\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut max_len = string.length();\n    let mut pos = 0;\n    while pos <\
    \ max_len {\n        let mut suffix;\n        if pos == max_len - 1 {\n      \
    \      suffix = &string[pos];\n        } else {\n            suffix = &string[pos..(pos\
    \ + 1)];\n        }\n        let mut reverse = suffix.chars().fold(String::new(),\
    \ |mut acc, c| {\n            let v = char::to_u32(c);\n            String::from_utf16(&v[..]).unwrap().reverse()\n\
    \        }).cloned();\n        reverse.append(suffix);\n        if reverse ==\
    \ &string[pos] {\n            return string.to_owned();\n        }\n        pos\
    \ += 1;\n    }\n    \"\".to_owned()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0nan6t6e.rs:12:30\n   |\n12 |     let mut max_len\
    \ = string.length();\n   |                              ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp0nan6t6e.rs:17:23\n\
    \   |\n17 |             suffix = &string[pos];\n   |                       ^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no function or associated item named `to_u32` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp0nan6t6e.rs:22:27\n   |\n\
    22 |             let v = char::to_u32(c);\n   |                           ^^^^^^\n\
    \   |                           |\n   |                           function or\
    \ associated item not found in `char`\n   |                           help: there\
    \ is an associated function with a similar name: `from_u32`\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp0nan6t6e.rs:23:49\n   |\n23 |             String::from_utf16(&v[..]).unwrap().reverse()\n\
    \   |                                                 ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reserve`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmp0nan6t6e.rs:24:12\n    |\n24  |         \
    \  }).cloned();\n    |              ^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is r"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // Find longest postfix that is palindrome in the original string\n    let\
    \ suffixes_with_palindrome = string.split_last_mut().filter(|s| s.is_palindromic());\n\
    \    let max_palindrome = suffixes_with_palindrome.last().unwrap();\n    let mut\
    \ min_len = 1;\n    for suffix in suffixes_with_palindrome[..] {\n        // Find\
    \ the shortest prefix that comes before this suffix\n        let suffix_length\
    \ = suffix.len();\n        let prefix_length = string.len() - suffix_length;\n\
    \        if prefix_length < min_len {\n            min_len = prefix_length;\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before palindromic suffix\n    string.append(&max_palindrome[..min_len]);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp8rrhaftu.rs:13:43\n   |\n13 |     let suffixes_with_palindrome\
    \ = string.split_last_mut().filter(|s| s.is_palindromic());\n   |            \
    \                               ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `split_at`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp8rrhaftu.rs:25:12\n\
    \   |\n25 |     string.append(&max_palindrome[..min_len]);\n   |            ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut longest_palindrome = string.to_string();\n    let mut longest_prefix_length\
    \ = 0;\n    let mut postfix_index = string.len();\n    while postfix_index > 0\
    \ {\n        if longest_prefix_length > postfix_index {\n            longest_palindrome\
    \ = longest_palindrome[..longest_palindrome.len() - longest_prefix_length];\n\
    \            longest_prefix_length = 0;\n        }\n        if longest_prefix_length\
    \ == postfix_index {\n            longest_palindrome = longest_palindrome[..postfix_index];\n\
    \            break;\n        }\n        let c = string[postfix_index..postfix_index];\n\
    \        let mut reversed_string = c;\n        for i in 0..c.len() {\n       \
    \     reversed_string[i] = ::std::char::reverse(c);\n        }\n        if longest_palindrome\
    \ == reversed_string {\n            break;\n        }\n        postfix_index -=\
    \ 1;\n        longest_prefix_length += 1;\n    }\n    longest_palindrome\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in module `std::char`\n  -->\
    \ /tmp/tmpziwlnnm_.rs:27:47\n   |\n27 |             reversed_string[i] = ::std::char::reverse(c);\n\
    \   |                                               ^^^^^^^ not found in `std::char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpziwlnnm_.rs:17:34\n   |\n12 |\
    \     let mut longest_palindrome = string.to_string();\n   |                 \
    \                 ------------------ expected due to this value\n...\n17 |   \
    \          longest_palindrome = longest_palindrome[..longest_palindrome.len()\
    \ - longest_prefix_length];\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                |\n   |                                  expected struct `String`,\
    \ found `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpziwlnnm_.rs:21:34\n\
    \   |\n12 |     let mut longest_palindrome = string.to_string();\n   |       \
    \                           ------------------ expected due to this value\n...\n\
    21 |             longest_palindrome = longest_palindrome[..postfix_index];\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \          |\n   |                                  expected struct `String`,\
    \ found `str`\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpziwlnnm_.rs:24:13\n   |\n24 |         let\
    \ c = string[postfix_index..postfix_index];\n   |             ^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n24 |         let c = &string[postfix_index..postfix_index];\n  \
    \ |                 +\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpziwlnnm_.rs:25:"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    make_palindrome_aux(string).to_string()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `make_palindrome_aux` in this scope\n\
    \  --> /tmp/tmph5hy1k1a.rs:12:5\n   |\n12 |     make_palindrome_aux(string).to_string()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix_string = string;\n    let mut suffix_string = string;\n\n\
    \    let suffix_length = suffix_string.len();\n    let prefix_length = prefix_string.len();\n\
    \n    while suffix_length > 0 && prefix_length > 0 {\n        let c = suffix_string[suffix_length\
    \ - 1];\n        let p = prefix_string[prefix_length - 1];\n        suffix_string.remove(suffix_length\
    \ - 1, 1);\n        prefix_string.remove(prefix_length - 1, 1);\n\n        if\
    \ p == c {\n            suffix_string.insert(0, p);\n            prefix_string.insert(0,\
    \ c);\n        }\n    }\n\n    prefix_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfhepg87p.rs:19:17\n\
    \   |\n19 |         let c = suffix_string[suffix_length - 1];\n   |          \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfhepg87p.rs:20:17\n   |\n20 |         let p = prefix_string[prefix_length\
    \ - 1];\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n    --> /tmp/tmpfhepg87p.rs:21:23\n     |\n21   |         suffix_string.remove(suffix_length\
    \ - 1, 1);\n     |                       ^^^^^^ -----------------  - supplied\
    \ 2 arguments\n     |                       |\n     |                       expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpfhepg87p.rs:22:23\n\
    \     |\n22   |         prefix_string.remove(prefix_length - 1, 1);\n     |  \
    \                     ^^^^^^ -----------------"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut palindrome_length = string.len();\n\
    \n    // find the longest postfix palindrome that starts with the input string\n\
    \    while palindrome_length >= 1 {\n        let start = palindrome.len() - 1;\n\
    \        let end = palindrome_length - 1;\n\n        // if we are at the start\
    \ of a palindrome\n        if palindrome[start] == palindrome[end] {\n       \
    \     // decrement the length\n            palindrome_length -= 1;\n         \
    \   // and decrement start by one\n            start -= 1;\n        } else {\n\
    \            break;\n        }\n\n        // found a palindrome\n        palindrome\
    \ = &palindrome[start..end];\n    }\n\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn0t4z7vi.rs:21:12\n\
    \   |\n21 |         if palindrome[start] == palindrome[end] {\n   |          \
    \  ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn0t4z7vi.rs:21:33\n   |\n21 |         if palindrome[start] == palindrome[end]\
    \ {\n   |                                 ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn0t4z7vi.rs:31:22\n\
    \   |\n12 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n31 |         palindrome = &palindrome[start..end];\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n31 |         palindrome\
    \ = (&palindrome[start..end]).to_string();\n   |                      +      \
    \                 +++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `r"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // Algorithm idea\n    // - Find the longest postfix of supplied string that\
    \ is a palindrome.\n    let postfix = string.find_last_eq_str(|x| x.is_lowercase());\n\
    \    if postfix.is_none() {\n        return string;\n    }\n    let postfix_length\
    \ = postfix.unwrap();\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    let mut postfix_string\
    \ = string.clone();\n    string.push_str(&string[postfix_length..]);\n    string.push_str(&string[..postfix_length]);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_last_eq_str` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpnzd6al6l.rs:14:26\n   |\n14 |     let postfix\
    \ = string.find_last_eq_str(|x| x.is_lowercase());\n   |                     \
    \     ^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix: String = string;\n    let mut suffix: String = string;\n\
    \    let mut postfix = string;\n\n    loop {\n        if suffix.is_empty() {\n\
    \            return prefix;\n        }\n\n        if prefix == suffix {\n    \
    \        // Found a palindrome without needing a further check.\n            postfix\
    \ += suffix;\n            suffix.clear();\n        } else {\n            suffix.reverse();\n\
    \            let len = prefix.len();\n            let mut index = len - 1;\n \
    \           while index >= 0 {\n                if postfix[index] != prefix[index]\
    \ {\n                    break;\n                }\n\n                index -=\
    \ 1;\n            }\n\n            if index == -1 {\n                postfix +=\
    \ suffix;\n            } else {\n                postfix.extend(&suffix[0..index]);\n\
    \                postfix.reverse();\n            }\n\n            prefix.clear();\n\
    \            prefix.extend(&postfix);\n        }\n    }\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu2nhuy49.rs:23:24\n   |\n\
    23 |             postfix += suffix;\n   |                        ^^^^^^\n   |\
    \                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&suffix`\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpu2nhuy49.rs:26:20\n   |\n26 |          \
    \   suffix.reverse();\n   |                    ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpu2nhuy49.rs:30:20\n   |\n30 |         \
    \        if postfix[index] != prefix[index] {\n   |                    ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu2nhuy49.rs:30:38\n   |\n30 |                 if postfix[index]\
    \ != prefix[index] {\n   |                                      ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0600]: cannot apply unary operator `-` to"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix: &str = &string[..string.len() / 2];\n    let mut suffix:\
    \ &str = &string[string.len() / 2 + 1..];\n    let mut result = string;\n    while\
    \ !prefix.is_empty() {\n        if suffix == make_palindrome_prefix(&prefix) {\n\
    \            result += prefix.reverse();\n            prefix = &prefix[..prefix.len()\
    \ / 2];\n            suffix = &suffix[..suffix.len() / 2];\n        }\n      \
    \  else {\n            prefix = &prefix[..prefix.len() / 2];\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `make_palindrome_prefix` in this scope\n\
    \  --> /tmp/tmpwnhanpcz.rs:16:22\n   |\n16 |         if suffix == make_palindrome_prefix(&prefix)\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `reverse` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpwnhanpcz.rs:17:30\n   |\n17 |             result += prefix.reverse();\n\
    \   |                              ^^^^^^^ method not found in `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_prefix: String;\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut longest_postfix\
    \ = std::collections::HashSet::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let mut postfix = &string[i..].to_string();\n        reversed_prefix.clear();\n\
    \        reversed_prefix.extend(postfix.iter().cloned());\n        if longest_postfix.insert(&reversed_prefix).is_err()\
    \ {\n            return string;\n        }\n        i += 1;\n    }\n    let mut\
    \ reversed_suffix;\n    if longest_postfix.iter().any(|&prefix| {\n        reversed_suffix\
    \ = &string[..i];\n        longest_postfix.insert(&reversed_suffix);\n       \
    \ true\n    }) {\n        longest_postfix.remove(&reversed_suffix);\n    }\n \
    \   longest_postfix.iter().filter(|&p| {\n        p.len() < i\n    }).fold(\n\
    \        \"\",\n        |acc, &prefix| {\n            acc.extend(&prefix[i..].to_string().iter().cloned());\n\
    \            acc\n        },\n    )\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpo3j8qoye.rs:22:40\n   |\n22 |         reversed_prefix.extend(postfix.iter().cloned());\n\
    \   |                                        ^^^^ method not found in `&String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n22 |         reversed_prefix.extend(postfix.chars().cloned());\n\
    \   |                                        ~~~~~\n\nerror[E0599]: no method\
    \ named `is_err` found for type `bool` in the current scope\n  --> /tmp/tmpo3j8qoye.rs:23:53\n\
    \   |\n23 |         if longest_postfix.insert(&reversed_prefix).is_err() {\n \
    \  |                                                     ^^^^^^ method not found\
    \ in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo3j8qoye.rs:31:32\n\
    \   |\n31 |         longest_postfix.insert(&reversed_suffix);\n   |          \
    \                      ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected reference `&String`\n              found reference\
    \ `&&str`\n\nerror[E0277]: the trait bound `&String: Borrow<&str>` is not satisfied\n\
    \   --> /tmp/tmpo3j8qoye.rs:34:25\n    |\n34  |         longest_postfix.remove(&reversed_suffix);\n\
    \    |                         ^^^^^^ the trait `Borrow<&str>` is not implemented\
    \ for `&String`\n    |\n    = help: the trait `Borrow<str>` is implemented for\
    \ `String`\nnote: required by a bound in `HashSet::<T, S>::remove`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo3j8qoye.rs:39:9\n   |\n39 |         \"\",\n\
    \   |         ^^- help: try using a conversion method: `.to_string()`\n   |  \
    \       |\n   |         expected struct `String`, found `&str`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpo3j8qoye.rs:41:49\n   |\n41 |             acc.extend(&prefix[i..].to_string().iter().cloned());\n\
    \   |                                                 ^^^^ method not found in\
    \ `String`\n   |\nhelp: because of the in-memory representation of `&str`, to\
    \ o"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut len = 0;\n\n    // Find postfix of\
    \ string.\n    while string.ends_with(&string[len..]) {\n        len += 1;\n \
    \   }\n\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    string = &string[..len];\n    let\
    \ mut reverse = string;\n    for i in (0..(len / 2).rev()).rev() {\n        string\
    \ = &string[..];\n        reverse = &reverse[..];\n    }\n\n    let mut postfix\
    \ = string;\n    while !postfix.is_empty() {\n        if postfix.starts_with(&reverse[..])\
    \ {\n            postfix = &postfix[..postfix.len()];\n        } else {\n    \
    \        break;\n        }\n    }\n\n    string.push_str(&postfix);\n\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpne9va0oo.rs:21:14\n   |\n\
    12 |     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n21 |     string = &string[..len];\n   |              ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n21 |     string = (&string[..len]).to_string();\n   |              +  \
    \            +++++++++++++\n\nerror[E0599]: `usize` is not an iterator\n  -->\
    \ /tmp/tmpne9va0oo.rs:23:28\n   |\n23 |     for i in (0..(len / 2).rev()).rev()\
    \ {\n   |                            ^^^ `usize` is not an iterator\n   |\n  \
    \ = note: the following trait bounds were not satisfied:\n           `usize: Iterator`\n\
    \           which is required by `&mut usize: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpne9va0oo.rs:24:18\n   |\n12 |     let mut string = string;\n\
    \   |                      ------ expected due to this value\n...\n24 |      \
    \   string = &string[..];\n   |                  ^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n24 |        \
    \ string = (&string[..]).to_string();\n   |                  +           +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpne9va0oo.rs:25:19\n   |\n22 |\
    \     let mut reverse = string;\n   |                       ------ expected due\
    \ to this value\n...\n25 |         reverse = &reverse[..];\n   |             \
    \      ^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n25 |         reverse = (&reverse[..]).to_string();\n\
    \   |                   +            +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpne9va0oo.rs:31:23\n   |\n28 |     let mut postfix = string;\n\
    \   |                       ------ expected due to this value\n...\n31 |     \
    \        postfix = &postfix[..postfix.len()];\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n31 |             postfix = (&postfix[..postfix.len()]).to_string();\n \
    \  |                    "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix = string.clone();\n    let mut suffix_index = string.length\
    \ - 1;\n    let mut suffix_palindrome = string.clone();\n    let mut suffix_palindrome_reversed\
    \ = string.clone();\n\n    while suffix_index <= string.length-1 {\n        suffix_palindrome_reversed\
    \ = suffix_palindrome_reversed.chars().collect();\n        suffix_palindrome =\
    \ suffix_palindrome.chars().collect();\n        let suffix_palindrome_reversed\
    \ = suffix_palindrome_reversed.join(\"\");\n\n        if suffix_palindrome_reversed\
    \ == prefix {\n            prefix.append(&suffix_palindrome_reversed);\n     \
    \       suffix_palindrome = suffix_palindrome[1..];\n            suffix_index\
    \ = suffix_index - 1;\n        } else {\n            suffix_index = suffix_index\
    \ - 1;\n        }\n    }\n\n    prefix\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmptkhh41y1.rs:13:35\n\
    \   |\n13 |     let mut suffix_index = string.length - 1;\n   |              \
    \                     ^^^^^^ unknown field\n\nerror[E0609]: no field `length`\
    \ on type `String`\n  --> /tmp/tmptkhh41y1.rs:17:34\n   |\n17 |     while suffix_index\
    \ <= string.length-1 {\n   |                                  ^^^^^^ unknown field\n\
    \nerror[E0599]: no method named `join` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmptkhh41y1.rs:20:69\n   |\n20 |         let suffix_palindrome_reversed\
    \ = suffix_palindrome_reversed.join(\"\");\n   |                             \
    \                                        ^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmptkhh41y1.rs:23:20\n   |\n23 |             prefix.append(&suffix_palindrome_reversed);\n\
    \   |                    ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptkhh41y1.rs:24:33\n   |\n14 |     let mut suffix_palindrome\
    \ = string.clone();\n   |                                 -------------- expected\
    \ due to this value\n...\n24 |             suffix_palindrome = suffix_palindrome[1..];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                 |\n\
    \   |                                 expected struct `String`, found `str`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() == 0 {\n        return string;\n    }\n    let mut longest\
    \ = 0;\n    let mut suffixes = Vec::new();\n    for c in string.chars() {\n  \
    \      let pos = string.char_indices(&c.to_string()).unwrap();\n        longest\
    \ = pos\n            .iter()\n            .map(|i| (c[i] + 'a' as u8).cmp(&c.to_string()[..i]))\n\
    \            .max()\n            .unwrap_or(0);\n        if longest == 0 {\n \
    \           suffixes.push((c, pos));\n        }\n    }\n    let mut pal = String::with_capacity(longest);\n\
    \    let mut suffix = String::new();\n    for (c, pos) in suffixes {\n       \
    \ for (i_pos, (i_x, i)) in pos.iter().enumerate() {\n            if i == 0 {\n\
    \                continue;\n            }\n            pal.push_str(&c.to_string()[i_x..i]);\n\
    \            pal.push_str(&c.to_string()[i_pos..]);\n            suffix = c.to_string()[i_pos..];\n\
    \        }\n    }\n    pal.push_str(&suffix);\n    pal.into_boxed_str()\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpl5vgvbgt.rs:18:26\n    |\n18  |         let pos = string.char_indices(&c.to_string()).unwrap();\n\
    \    |                          ^^^^^^^^^^^^ -------------- supplied 1 argument\n\
    \    |                          |\n    |                          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `unwrap` found for struct `CharIndices` in the current scope\n  --> /tmp/tmpl5vgvbgt.rs:18:55\n\
    \   |\n18 |         let pos = string.char_indices(&c.to_string()).unwrap();\n\
    \   |                                                       ^^^^^^ method not\
    \ found in `CharIndices<'_>`\n\nerror[E0608]: cannot index into a value of type\
    \ `char`\n  --> /tmp/tmpl5vgvbgt.rs:21:23\n   |\n21 |             .map(|i| (c[i]\
    \ + 'a' as u8).cmp(&c.to_string()[..i]))\n   |                       ^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpl5vgvbgt.rs:41:5\n   |\n11 | fn\
    \ make_palindrome(string: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n41 |     pal.into_boxed_str()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found struct `Box`\n   |\n   =\
    \ note: expected struct `String`\n              found struct `Box<str>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599, E0608.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffixes: Vec<&str> = string.split_ascii_lowercase().collect();\n\
    \    suffixes.reverse();\n    let mut prefix = string;\n    for suffix in suffixes\
    \ {\n        let mut prefix_len = prefix.len();\n        for _ in 0..(prefix_len\
    \ - suffix.len()) {\n            prefix += &String::from(\"a\");\n        }\n\
    \        if &prefix[prefix_len..prefix_len + suffix.len()] == &suffix[..] {\n\
    \            return prefix;\n        }\n    }\n    prefix.clone()\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_ascii_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpzkonfdit.rs:12:42\n   |\n12 | \
    \    let mut suffixes: Vec<&str> = string.split_ascii_lowercase().collect();\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    match string.chars() {\n        chars => make_palindrome_recursive(string[..chars.rev().find_last_mut().unwrap()]).to_owned(),\n\
    \        _ => String::new(),\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `make_palindrome_recursive` in this\
    \ scope\n  --> /tmp/tmpl2zk1809.rs:13:18\n   |\n13 |         chars => make_palindrome_recursive(string[..chars.rev().find_last_mut().unwrap()]).to_owned(),\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `find_last_mut` found for struct `Rev` in the current scope\n\
    \  --> /tmp/tmpl2zk1809.rs:13:65\n   |\n13 |         chars => make_palindrome_recursive(string[..chars.rev().find_last_mut().unwrap()]).to_owned(),\n\
    \   |                                                                 ^^^^^^^^^^^^^\
    \ method not found in `Rev<Chars<'_>>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        return string;\n    }\n\n    let mut left\
    \ = 0;\n    let mut right = 0;\n    let mut mid = string.len();\n\n    // Search\
    \ the longest postfix of supplied string that is a palindrome\n    while left\
    \ < mid && right < mid {\n        if string[left] != string[right] {\n       \
    \     break;\n        }\n        left += 1;\n        right += 1;\n    }\n    //\
    \ Make sure that postfix is longer than string\n    if left > mid {\n        mid\
    \ = left;\n    }\n    if right > mid {\n        mid = right;\n    }\n\n    //\
    \ Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix\n    let mut suffix = string;\n    let mut prefix = [0;\
    \ mid];\n    while left < mid && right < mid {\n        if string[left] != string[right]\
    \ {\n            break;\n        }\n        prefix[left] = string[left];\n   \
    \     left += 1;\n        right += 1;\n    }\n    prefix[left] = 0;\n    let mut\
    \ prefix_reversed = prefix.to_vec();\n    prefix_reversed.reverse();\n    suffix\
    \ += &prefix_reversed[0];\n\n    // Return the result of the process\n    return\
    \ suffix;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpsj8ujlgd.rs:38:26\n   |\n18 |     let mut mid = string.len();\n   |\
    \     ----------- help: consider using `const` instead of `let`: `const mid`\n\
    ...\n38 |     let mut prefix = [0; mid];\n   |                          ^^^ non-constant\
    \ value\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpsj8ujlgd.rs:22:12\n   |\n22 |         if string[left] != string[right]\
    \ {\n   |            ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsj8ujlgd.rs:22:28\n\
    \   |\n22 |         if string[left] != string[right] {\n   |                 \
    \           ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsj8ujlgd.rs:40:12\n   |\n40 |         if string[left] != string[right]\
    \ {\n   |            ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Ind"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // The longest postfix of supplied string that is a palindrome\n    let suffixes_of_string\
    \ = string\n        .split_ascii_lowercase()\n        .chain(string.split_ascii_uppercase())\n\
    \        .map(|x| {\n            if x.len() < 2 {\n                x.clone();\n\
    \            } else {\n                x.reverse();\n                x.clone()\
    \ + x\n            }\n        })\n        .collect::<Vec<String>>();\n    let\
    \ longest_postfix = suffixes_of_string.iter().max().unwrap();\n    let mut string\
    \ = String::from(string);\n    string.push_str(&longest_postfix);\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_ascii_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpqcopkb8j.rs:14:10\n   |\n14 | \
    \        .split_ascii_lowercase()\n   |          ^^^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `split_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpqcopkb8j.rs:15:23\n   |\n15 |         .chain(string.split_ascii_uppercase())\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_check = string;\n    let mut max_size = string_to_check.length();\n\
    \    let mut min_size = string_to_check.length();\n    while min_size > 0 {\n\
    \        let mut found = false;\n        let mut pos = string_to_check.rfind(&string_to_check[min_size\
    \ - 1]);\n        while !found && pos != string_to_check.len() - 1 {\n       \
    \     found = true;\n            let mut pos1 = pos - 1;\n            while pos1\
    \ > string_to_check.length() - 2 {\n                pos1 -= 1;\n            }\n\
    \            let mut pos2 = pos;\n            while pos2 > string_to_check.length()\
    \ - 2 {\n                pos2 -= 1;\n            }\n            if pos1 < pos2\
    \ {\n                string_to_check += &string_to_check[pos2];\n            \
    \    min_size -= 1;\n            } else {\n                string_to_check +=\
    \ &string_to_check[pos1];\n                max_size -= 1;\n            }\n   \
    \         pos = string_to_check.rfind(&string_to_check[min_size - 1]);\n     \
    \   }\n    }\n    return string_to_check;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp_13nwonw.rs:13:40\n   |\n13 |     let mut max_size\
    \ = string_to_check.length();\n   |                                        ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp_13nwonw.rs:14:40\n   |\n14 |     let mut min_size = string_to_check.length();\n\
    \   |                                        ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_13nwonw.rs:18:32\n   |\n18 |         while !found && pos != string_to_check.len()\
    \ - 1 {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         while !found && pos != Some(string_to_check.len() - 1) {\n\
    \   |                                +++++                         +\n\nerror[E0369]:\
    \ cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmp_13nwonw.rs:20:32\n\
    \   |\n20 |             let mut pos1 = pos - 1;\n   |                        \
    \    --- ^ - {integer}\n   |                            |\n   |              \
    \              Option<usize>\n\nerror[E0599]: no method named `length` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp_13nwonw.rs:21:42\n   |\n\
    21 |             while pos1 > string_to_check.length() - 2 {\n   |           \
    \                               ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp_13nwonw.rs:25:42\n   |\n25 | \
    \            while pos2 > string_to_check.length() - 2 {\n   |               \
    \                           ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `Option<us"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    palindrome.clone_parts_mut(..).reverse();\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `clone_parts_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpiygf8x52.rs:13:16\n   |\n13 |     palindrome.clone_parts_mut(..).reverse();\n\
    \   |                ^^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // find longest palindromic suffix\n    let max_len = string\n        .split_whitespace()\n\
    \        .windows(2)\n        .filter(|&w| w.is_ascii())\n        .map(|&w| w.len())\n\
    \        .max()\n        .unwrap();\n    let mut reverse = String::from(\"\");\n\
    \    for w in string.split_whitespace() {\n        let len = w.len();\n      \
    \  if len < max_len {\n            continue;\n        }\n        let mut suffix\
    \ = w.chars().skip_while(|c| !c.is_ascii()).collect::<String>();\n        reverse.extend(&suffix);\n\
    \        reverse.extend(&w.chars().skip_while(|c| c.is_ascii()).collect::<String>());\n\
    \        if len == max_len {\n            break;\n        }\n    }\n    reverse\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpjt18ebnm.rs:15:10\n   |\n15 |         .windows(2)\n\
    \   |          ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpjt18ebnm.rs:27:24\n    |\n27  |\
    \         reverse.extend(&suffix);\n    |                 ------ ^^^^^^^ `&String`\
    \ is not an iterator\n    |                 |\n    |                 required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `&String`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\nnote: required by a bound in `extend`\n\
    \nerror[E0277]: `&String` is not an iterator\n   --> /tmp/tmpjt18ebnm.rs:28:24\n\
    \    |\n28  |         reverse.extend(&w.chars().skip_while(|c| c.is_ascii()).collect::<String>());\n\
    \    |                 ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `&String` is not an iterator\n    |                 |\n    |               \
    \  required by a bound introduced by this call\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `&String`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\nnote: required by a bound in `extend`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string.clone();\n\n    // find the longest palindrome suffix\
    \ that is a palindrome\n    let mut max_len = string.len() - 1;\n    let mut found\
    \ = false;\n\n    while !found && max_len >= 0 {\n        found = check_palindrome(&mut\
    \ string, &max_len);\n        max_len -= 1;\n    }\n\n    found && string\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check_palindrome` in this scope\n \
    \ --> /tmp/tmp50e5srh3.rs:19:17\n   |\n19 |         found = check_palindrome(&mut\
    \ string, &max_len);\n   |                 ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp50e5srh3.rs:23:14\n \
    \  |\n23 |     found && string\n   |              ^^^^^^ expected `bool`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp50e5srh3.rs:23:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    23 |     found && string\n   |     ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `bool`\n   |\nhelp: try using a conversion method\n   |\n23 |     (found &&\
    \ string).to_string()\n   |     +               +++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffixes = vec![];\n    let mut reversed = string.clone();\n    let\
    \ mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length\
    \ = 0;\n\n    // If reverse string equals to original string, then it is a palindrome\n\
    \    while suffix_length < reversed.len() {\n        suffix_length = suffix_end\
    \ + 1;\n        let mut suffix_suffix;\n        let mut suffix_suffix_index =\
    \ 0;\n\n        // Find longest suffix\n        while suffix_suffix_index < suffix_length\
    \ && suffix_end < reversed.len() {\n            suffix_suffix = reversed[suffix_end..suffix_end+suffix_length];\n\
    \            if suffix_suffix != suffix_suffix {\n                break;\n   \
    \         }\n            suffix_suffix_index += 1;\n            suffix_end +=\
    \ 1;\n        }\n\n        // If current suffix is palindrome, add it to suffix\
    \ array\n        if suffix_suffix == suffix_suffix {\n            suffixes.push(suffix_suffix);\n\
    \        }\n\n        // Get index to rewrite current string\n        let reverse_index\
    \ = suffix_end - suffix_start;\n        // Get last character from reversed string\n\
    \        let mut reversed_suffix = reversed[reverse_index..];\n        let mut\
    \ reversed_suffix = reversed_suffix.chars().skip_while(|&c| *c == 0).collect::<String>();\n\
    \        let mut reversed_suffixed_index = reversed_suffix.len() - 1;\n\n    \
    \    // If current suffix is not palindrome (because it's shorter), append it\
    \ to reversed\n        while suffix_end + 1 < reversed.len() {\n            if\
    \ reversed[suffix_end..suffix_end+suffix_length] != suffix_suffix[..] {\n    \
    \            suffix_end = suffix_end + 1;\n                suffix_suffixed_index\
    \ -= 1;\n            } else {\n                break;\n            }\n       \
    \ }\n\n        // Rewrite current string from reversed string\n        reversed.set_chars(\n\
    \            reversed.chars().rev().skip_while(|&c| *c != *reversed_suffixed_index).cloned(),\n\
    \            suffix_end + 1,\n        );\n        reversed_suffix = reversed[reverse_index..];\n\
    \        reversed_suffix = reversed_suffix.chars().skip_while(|&c| *c == 0).collect::<String>();\n\
    \n        // If suffix is not palindrome, move it to end of reversed string\n\
    \        // if current prefix is not palindrome (because it's shorter), move it\
    \ before current prefix\n        while suffix_suffix[..reversed_suffixed_index]\
    \ != reversed_suffix {\n            suffi\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppkgtzlkl.rs:77:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n19 |     while suffix_length\
    \ < reversed.len() {\n   |                                          - unclosed\
    \ delimiter\n...\n66 |         while suffix_suffix[..reversed_suffixed_index]\
    \ != reversed_suffix {\n   |                                                 \
    \                          - this delimiter might not be properly closed...\n\
    67 |             suffi\n68 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n77 | }\n   |   ^\n\nerror[E0425]: cannot find value `suffix_suffixed_index`\
    \ in this scope\n  --> /tmp/tmppkgtzlkl.rs:50:17\n   |\n50 |                 suffix_suffixed_index\
    \ -= 1;\n   |                 ^^^^^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `suffix_suffix_index`\n\nerror[E0425]: cannot find value\
    \ `suffi` in this scope\n  --> /tmp/tmppkgtzlkl.rs:67:13\n   |\n67 |         \
    \    suffi\n   |             ^^^^^ not found in this scope\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n  --> /tmp/tmppkgtzlkl.rs:21:13\n\
    \   |\n21 |         let mut suffix_suffix;\n   |             ^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmppkgtzlkl.rs:26:13\n   |\n26 |             suffix_suffix = reversed[suffix_end..suffix_end+suffix_length];\n\
    \   |             ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  \
    \ |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: the\
    \ left-hand-side of an assignment must have a statically known size\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmppkgtzlkl.rs:36:27\n  "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut postfix_to_append = &string[..];\n    while let Some(postfix_to_append)\
    \ = postfix_to_append.rsplit(|c| c.is_ascii_lowercase()) {\n        if postfix_to_append\
    \ != &string[..] {\n            string.append(&String::from(&postfix_to_append));\n\
    \            return string;\n        }\n    }\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpcvt1_1ke.rs:13:67\n\
    \   |\n13 |     while let Some(postfix_to_append) = postfix_to_append.rsplit(|c|\
    \ c.is_ascii_lowercase()) {\n   |                                            \
    \                       ^ consider giving this closure parameter a type\n   |\n\
    \   = note: type must be known at this point\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcvt1_1ke.rs:13:15\n   |\n13 |     while let Some(postfix_to_append)\
    \ = postfix_to_append.rsplit(|c| c.is_ascii_lowercase()) {\n   |             \
    \  ^^^^^^^^^^^^^^^^^^^^^^^   ----------------------------------------------------\
    \ this expression has type `std::str::RSplit<'_, _>`\n   |               |\n \
    \  |               expected struct `std::str::RSplit`, found enum `Option`\n \
    \  |\n   = note: expected struct `std::str::RSplit<'_, _>`\n                found\
    \ enum `Option<_>`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpcvt1_1ke.rs:15:20\n   |\n15 | \
    \            string.append(&String::from(&postfix_to_append));\n   |         \
    \           ^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0282, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // If there is no input string, then return empty string.\n    match string\
    \ {\n        \"\" => String::from(\"\"),\n        s => s\n            .split_whitespace()\n\
    \            .filter(|&c| c != '*')\n            .map(|c| {\n                c\
    \ ^ !c.is_ascii_lowercase()\n            })\n            .unwrap_or(true)\n  \
    \          .reverse()\n            .join(\"\"),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgqmd2q85.rs:14:9\n   |\n\
    13 |     match string {\n   |           ------ this expression has type `String`\n\
    14 |         \"\" => String::from(\"\"),\n   |         ^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpgqmd2q85.rs:17:28\n\
    \   |\n17 |             .filter(|&c| c != '*')\n   |                         \
    \   ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0599]: no method named `is_ascii_lowercase`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpgqmd2q85.rs:19:24\n\
    \   |\n19 |                 c ^ !c.is_ascii_lowercase()\n   |                \
    \        ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmpgqmd2q85.rs:21:14\n   |\n\
    21 |             .unwrap_or(true)\n   |              ^^^^^^^^^ method not found\
    \ in `Map<Filter<SplitWhitespace<'_>, [closure@/tmp/tmpgqmd2q85.rs:17:21: 17:34]>,\
    \ _>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let string = string.to_string();\n    if string.is_empty() {\n        return\
    \ string;\n    }\n\n    let mut longest_palindrome_prefix: Vec<String> = vec![];\n\
    \    let mut suffix = \"\";\n    let mut suffix_index = 0;\n    let mut suffix_index\
    \ = 0;\n\n    while suffix_index < string.len() {\n        let char_index: usize\
    \ = (string.len() - suffix_index - 1) as usize;\n        let char = string.chars().nth(char_index).unwrap();\n\
    \        let mut new_suffix = suffix.to_owned();\n        new_suffix += char.to_string();\n\
    \        if new_suffix == new_suffix.rev() {\n            suffix_index = char_index;\n\
    \            suffix = new_suffix;\n        } else {\n            longest_palindrome_prefix.push(suffix);\n\
    \            suffix = new_suffix;\n        }\n    }\n    longest_palindrome_prefix.push(suffix);\n\
    \    let mut suffix_suffix = 0;\n    let mut suffix_suffix_index = string.len()\
    \ - 1;\n    while suffix_suffix_index >= 0 {\n        let char_index: usize =\
    \ (string.len() - suffix_suffix_index - 1) as usize;\n        let char = string.chars().nth(char_index).unwrap();\n\
    \        let mut new_suffix = suffix.to_owned();\n        new_suffix += char.to_string();\n\
    \        if new_suffix == new_suffix.rev() {\n            suffix_suffix = char_index;\n\
    \            suffix_suffix_index = char_index;\n        } else {\n           \
    \ longest_palindrome_prefix.push(suffix);\n            suffix = new_suffix;\n\
    \        }\n    }\n\n    longest_palindrome_prefix.reverse();\n    longest_palindrome_prefix.insert(0,\
    \ string);\n    longest_palindrome_prefix.reverse();\n\n    String::from(longest_palindrome_prefix[longest_palindrome_prefix.len()\
    \ - 1].to_string())\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnd2sh7s_.rs:26:23\n   |\n\
    26 |         new_suffix += char.to_string();\n   |                       ^^^^^^^^^^^^^^^^\n\
    \   |                       |\n   |                       expected `&str`, found\
    \ struct `String`\n   |                       help: consider borrowing here: `&char.to_string()`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpnd2sh7s_.rs:27:37\n\
    \    |\n27  |           if new_suffix == new_suffix.rev() {\n    |           \
    \                            ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnd2sh7s_.rs:29:22\n\
    \   |\n18 |     let mut suffix = \"\";\n   |                      -- expected\
    \ due to this value\n...\n29 |             suffix = new_suffix;\n   |        \
    \              ^^^^^^^^^^\n   |                      |\n   |                 \
    \     expected `&str`, found struct `String`\n   |                      help:\
    \ consider borrowing here: `&new_suffix`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpnd2sh7s_.rs:31:44\n   |\n31 |             longest_palindrome_prefix.push(suffix);\n\
    \   |                                            ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                            |\n\
    \   |                                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnd2sh7s_.rs:32:22\n\
    \   |\n18 |     let mut suffix = \"\";\n   |                      -- expected\
    \ due to this value\n...\n32 |             suffix = new_suffix;\n   |        \
    \              ^^^^^^^^^^\n   |                      |\n   |                 \
    \     expected `&str`, found struct `String`\n   |                      help:\
    \ consider borrowing here: `&new_suffix`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpnd2sh7s_.rs:35:36\n   |"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut prefix = string;\n\n    while !prefix.is_empty()\
    \ {\n        let index = palindrome.find_last_of(prefix);\n        palindrome\
    \ = &palindrome[..index];\n        prefix = &prefix[index..];\n    }\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_last_of` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1omwtzrl.rs:16:32\n   |\n16 |         let\
    \ index = palindrome.find_last_of(prefix);\n   |                             \
    \   ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1omwtzrl.rs:17:22\n   |\n12 |     let mut palindrome = string;\n\
    \   |                          ------ expected due to this value\n...\n17 |  \
    \       palindrome = &palindrome[..index];\n   |                      ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n17 |         palindrome = (&palindrome[..index]).to_string();\n   |   \
    \                   +                    +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1omwtzrl.rs:18:18\n   |\n13 |     let mut prefix = string;\n\
    \   |                      ------ expected due to this value\n...\n18 |      \
    \   prefix = &prefix[index..];\n   |                  ^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n18 |         prefix = (&prefix[index..]).to_string();\n   |            \
    \      +                +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // Find the longest postfix of string\n    let mut string = string;\n   \
    \ let mut reverse_str = \"\";\n    while !string.is_empty() {\n        reverse_str\
    \ = string[..].chars().rev().collect::<String>();\n        string = &string[1..];\n\
    \    }\n    // Append reverse of string prefix that comes before the palindromic\
    \ suffix\n    string = reverse_str.chars().rev().collect();\n    string.concat(string)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptuir0l54.rs:16:23\n   |\n\
    14 |     let mut reverse_str = \"\";\n   |                           -- expected\
    \ due to this value\n15 |     while !string.is_empty() {\n16 |         reverse_str\
    \ = string[..].chars().rev().collect::<String>();\n   |                      \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                       |\n\
    \   |                       expected `&str`, found struct `String`\n   |     \
    \                  help: consider borrowing here: `&string[..].chars().rev().collect::<String>()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptuir0l54.rs:17:18\n   |\n13 |\
    \     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n17 |         string = &string[1..];\n   |              \
    \    ^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n17 |         string = (&string[1..]).to_string();\n\
    \   |                  +            +++++++++++++\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmptuir0l54.rs:21:12\n\
    \   |\n21 |     string.concat(string)\n   |            ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // 1. Find the longest postfix of supplied string that is a palindrome.\n\
    \    let mut max_length = string.len();\n    let mut index = 0;\n    while index\
    \ < string.len() {\n        if string.chars().next().unwrap() != string.chars().nth(index).unwrap()\
    \ {\n            break;\n        }\n        max_length = std::cmp::max(max_length,\
    \ index);\n        index += 1;\n    }\n\n    // 2. Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    let\
    \ mut suffix = '_';\n    let mut index = max_length + 1;\n    while index > 0\
    \ {\n        if string.chars().next().unwrap() == suffix {\n            break;\n\
    \        }\n        suffix += string.chars().nth(index - 1).unwrap();\n      \
    \  index -= 1;\n    }\n\n    string.insert(0, suffix.to_owned()).to_string()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmpf1q5x_g2.rs:30:9\n   |\n30 |         suffix += string.chars().nth(index\
    \ - 1).unwrap();\n   |         ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `char`\n\nerror[E0599]:\
    \ `()` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpf1q5x_g2.rs:34:41\n\
    \   |\n34 |     string.insert(0, suffix.to_owned()).to_string()\n   |        \
    \                                 ^^^^^^^^^ `()` cannot be formatted with the\
    \ default formatter\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): std::fmt::Display`\n           which is required by `(): ToString`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut strings = vec![];\n    for (i, c) in string.chars().enumerate() {\n\
    \        if i <= 3 {\n            strings.push(String::from(&c.to_string()));\n\
    \        } else {\n            let mut start = i - 3;\n            let mut end\
    \ = i + 3;\n            while start >= 0 {\n                if strings[start].to_string()\
    \ != &c.to_string() {\n                    break;\n                }\n       \
    \         start -= 1;\n            }\n            while end < strings.len() {\n\
    \                if strings[end].to_string() != &c.to_string() {\n           \
    \         break;\n                }\n                end += 1;\n            }\n\
    \            strings.splice(end - start, end - start + 1, String::from(&c.to_string()));\n\
    \        }\n    }\n    strings[strings.len() - 1].clone()\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpammwc56p.rs:20:47\n\
    \   |\n20 |                 if strings[start].to_string() != &c.to_string() {\n\
    \   |                                               ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpammwc56p.rs:26:45\n   |\n26 |       \
    \          if strings[end].to_string() != &c.to_string() {\n   |             \
    \                                ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n    --> /tmp/tmpammwc56p.rs:31:21\n\
    \     |\n31   |             strings.splice(end - start, end - start + 1, String::from(&c.to_string()));\n\
    \     |                     ^^^^^^ -----------  ---------------  ----------------------------\
    \ supplied 3 arguments\n     |                     |\n     |                 \
    \    expected 2 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to 3 previou"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    loop {\n        let reverse = string.reverse();\n\
    \        if reverse.ends_with(string) {\n            break;\n        }\n     \
    \   string = string + reverse;\n    }\n    return string;\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpif8nry16.rs:14:30\n   |\n14 |         let reverse\
    \ = string.reverse();\n   |                              ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string.clone();\n    let mut end = string.len();\n    while\
    \ end > 0 {\n        let mid = (end - 1) / 2;\n        let mut first = mid + 1;\n\
    \        let mut last = mid;\n        loop {\n            if string.chars().nth(first).unwrap()\
    \ == string.chars().nth(last).unwrap() {\n                break;\n           \
    \ }\n            first += 1;\n            last -= 1;\n        }\n        string.push_str(&string[..last].reverse());\n\
    \        end = mid;\n    }\n    string\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpelmg_m1x.rs:25:41\n   |\n25 |         string.push_str(&string[..last].reverse());\n\
    \   |                                         ^^^^^^^ method not found in `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let len = string.len();\n    let mut palindrome = string;\n    let mut reverse_string\
    \ = \"\";\n    if len == 0 {\n        palindrome = \"\";\n        return palindrome;\n\
    \    }\n    let mut i = 0;\n    while i < len {\n        let mut j = len;\n  \
    \      while j > i {\n            palindrome.insert(0, string[j]);\n         \
    \   j--;\n        }\n        if palindrome == &string[i..] {\n            palindrome\
    \ = \"\";\n            reverse_string += string[i];\n            i += 1;\n   \
    \     }\n    }\n    String::from(reverse_string.reverse())\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpjqvuja9w.rs:24:16\n\
    \   |\n24 |             j--;\n   |                ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjqvuja9w.rs:16:22\n   |\n13 |     let mut palindrome\
    \ = string;\n   |                          ------ expected due to this value\n\
    ...\n16 |         palindrome = \"\";\n   |                      ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                      |\n   |\
    \                      expected struct `String`, found `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjqvuja9w.rs:23:34\n\
    \   |\n23 |             palindrome.insert(0, string[j]);\n   |               \
    \                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjqvuja9w.rs:27:26\n   |\n13 |     let mut palindrome\
    \ = string;\n   |                          ------ expected due to this value\n\
    ...\n27 |             palindrome = \"\";\n   |                          ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&str`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjqvuja9w.rs:28:31\n\
    \   |\n28 |             reverse_string += string[i];\n   |                   \
    \            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \       "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        String::from(\"\")\n    } else {\n      \
    \  let mut string = string;\n        let mut index = 0;\n        while index !=\
    \ 0 {\n            let len = string.len() - 1;\n            if string.chars().skip(len).find(|c|\
    \ !c.is_alphanumeric()) {\n                // String does not contain a palindrome.\n\
    \                let len = string.len() - 1;\n                string = string.chars().take(len).collect();\n\
    \                index = 0;\n            } else {\n                let len = string.len()\
    \ - 1;\n                string = string.chars().skip(len).collect();\n       \
    \         index = 0;\n            }\n        }\n        let mut last_char = string.chars().last();\n\
    \        let mut chars = string.chars();\n        let mut length = chars.len();\n\
    \        chars = chars.skip(length).collect();\n        let mut reverse = \"\"\
    ;\n        while chars.len() > 0 {\n            let c = chars.last();\n      \
    \      reverse += &c.to_string();\n            chars = chars.skip(1);\n      \
    \  }\n        reverse += &last_char.to_string();\n        reverse\n    }\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6odfx25y.rs:19:16\n   |\n\
    19 |             if string.chars().skip(len).find(|c| !c.is_alphanumeric()) {\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n       \
    \       found enum `Option<char>`\n\nerror[E0599]: no method named `len` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmp6odfx25y.rs:32:32\n \
    \  |\n32 |         let mut length = chars.len();\n   |                       \
    \         ^^^ method not found in `Chars<'_>`\n\nerror[E0277]: a value of type\
    \ `Chars<'_>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmp6odfx25y.rs:33:36\n     |\n33   |         chars = chars.skip(length).collect();\n\
    \     |                                    ^^^^^^^ value of type `Chars<'_>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Chars<'_>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0599]: no method named `len` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp6odfx25y.rs:35:21\n   |\n35 |         while\
    \ chars.len() > 0 {\n   |                     ^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmp6odfx25y.rs:37:27\n\
    \    |\n37  |               reverse += &c.to_string();\n    |                \
    \             ^^^^^^^^^ `Option<char>` cannot be formatted with the default formatter\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<char>: std::fmt::Display`\n            which is required by `Option<char>:\
    \ ToString`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6odfx25y.rs:38:21\n\
    \   |\n31 |         let mut chars = string.chars();\n   |                    \
    \     -------------- expected due to this value\n...\n38 |             chars =\
    \ chars.skip(1);\n   |                     ^^^^^^^^^^^^^ expected struct `Chars`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n        \
    \      found"
  stdout: ''
  timestamp: 1659976840
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debug_assert!(string.len() > 1);\n\n    let reverse = string.chars().rev().collect::<String>();\n\
    \n    if reverse == string[..] {\n        string\n    } else {\n        string\
    \ + &reverse\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: string.len() > 1'', /tmp/tmplh7e047l.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome_start = String::from(\"\");\n    let mut palindrome_end\
    \ = String::from(\"\");\n    for character in string.chars() {\n        let character\
    \ = character.to_uppercase();\n        let reversed_character = if character ==\
    \ 'A' {\n            character.to_ascii_lowercase()\n        } else {\n      \
    \      character.to_ascii_uppercase()\n        };\n        palindrome_end = palindrome_end.to_ascii_lowercase().append(&reversed_character).to_ascii_lowercase();\n\
    \        palindrome_start = palindrome_start.to_ascii_lowercase().append(&character).to_ascii_lowercase();\n\
    \    }\n    String::from(palindrome_end).append(palindrome_start)\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `ToUppercase`\n\
    \  --> /tmp/tmpa4qpv_9n.rs:16:47\n   |\n16 |         let reversed_character =\
    \ if character == 'A' {\n   |                                     --------- ^^\
    \ --- char\n   |                                     |\n   |                 \
    \                    ToUppercase\n\nerror[E0599]: no method named `to_ascii_lowercase`\
    \ found for struct `ToUppercase` in the current scope\n  --> /tmp/tmpa4qpv_9n.rs:17:23\n\
    \   |\n17 |             character.to_ascii_lowercase()\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^ method not found in `ToUppercase`\n\nerror[E0599]: no\
    \ method named `to_ascii_uppercase` found for struct `ToUppercase` in the current\
    \ scope\n  --> /tmp/tmpa4qpv_9n.rs:19:23\n   |\n19 |             character.to_ascii_uppercase()\n\
    \   |                       ^^^^^^^^^^^^^^^^^^ method not found in `ToUppercase`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpa4qpv_9n.rs:21:62\n   |\n21 |         palindrome_end =\
    \ palindrome_end.to_ascii_lowercase().append(&reversed_character).to_ascii_lowercase();\n\
    \   |                                                              ^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpa4qpv_9n.rs:22:66\n   |\n22 | \
    \        palindrome_start = palindrome_start.to_ascii_lowercase().append(&character).to_ascii_lowercase();\n\
    \   |                                                                  ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpa4qpv_9n.rs:24:34\n\
    \   |\n24 |     String::from(palindrome_end).append(palindrome_start)\n   |  \
    \                                ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    find_longest_palindrome(string)\n        .iter()\n        .find(|string|\
    \ string == string[..string.len() - string.len(string[..string.len()].len())].chars().collect::<String>())\n\
    \        .unwrap_or(string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome` in this scope\n\
    \  --> /tmp/tmp6m73a_q6.rs:12:5\n   |\n12 |     find_longest_palindrome(string)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut max_len = string\n        .chars()\n        .take_while(|&x| x ==\
    \ x)\n        .count();\n    string\n        .chars()\n        .take_while(|&x|\
    \ x != x)\n        .for_each(|x| if x > max_len { max_len = x; });\n    string\n\
    \        .appendf(&format!(\"{}{}\", &string[0..max_len], &string[max_len..]))\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp84_mjz4y.rs:19:30\n   |\n\
    19 |         .for_each(|x| if x > max_len { max_len = x; });\n   |           \
    \                   ^^^^^^^ expected `char`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp84_mjz4y.rs:19:50\n   |\n12 |       let mut max_len = string\n\
    \   |  _______________________-\n13 | |         .chars()\n14 | |         .take_while(|&x|\
    \ x == x)\n15 | |         .count();\n   | |________________- expected due to this\
    \ value\n...\n19 |           .for_each(|x| if x > max_len { max_len = x; });\n\
    \   |                                                    ^ expected `usize`, found\
    \ `char`\n\nerror[E0599]: no method named `appendf` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp84_mjz4y.rs:21:10\n   |\n21 |         .appendf(&format!(\"\
    {}{}\", &string[0..max_len], &string[max_len..]))\n   |          ^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let string_palindrome = make_palindrome_helper(string);\n    let result_string\
    \ = string_palindrome.to_string();\n    result_string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `make_palindrome_helper` in this scope\n\
    \  --> /tmp/tmpx2itvaxl.rs:12:29\n   |\n12 |     let string_palindrome = make_palindrome_helper(string);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut index = 0;\n    while !palindrome.starts_with(&string[index..])\
    \ {\n        index += 1;\n    }\n    index += 1;\n    while !palindrome.ends_with(&string[index..])\
    \ {\n        index += 1;\n    }\n    palindrome = &string[index..].rev();\n  \
    \  palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `str` is not an iterator\n  --> /tmp/tmpols1clx7.rs:21:35\n\
    \   |\n21 |     palindrome = &string[index..].rev();\n   |                   \
    \                ^^^ `str` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `str: Iterator`\n           which\
    \ is required by `&mut str: Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // Start with empty string\n    let mut reversed = string.to_string();\n\n\
    \    // Find the longest postfix of the string that is a palindrome\n    let mut\
    \ prefix = string;\n    let mut longest_postfix = 1;\n    while longest_postfix\
    \ > 0 {\n        let mut index = longest_postfix - 1;\n        let mut last_char\
    \ = prefix.chars().nth(index).unwrap();\n        while last_char == last_char.reverse()\
    \ {\n            index -= 1;\n            last_char = prefix.chars().nth(index).unwrap();\n\
    \        }\n        if index == 0 {\n            break;\n        }\n        longest_postfix\
    \ -= 1;\n        prefix = prefix.remove(index..);\n    }\n\n    // Append the\
    \ reverse of the string prefix before the palindromic suffix\n    reversed.append(prefix);\n\
    \    reversed.reverse();\n    String::from(reversed)\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4a2zgdua.rs:21:38\n   |\n21 |         while last_char ==\
    \ last_char.reverse() {\n   |                                      ^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4a2zgdua.rs:29:32\n\
    \   |\n29 |         prefix = prefix.remove(index..);\n   |                   \
    \             ^^^^^^^ expected `usize`, found struct `RangeFrom`\n   |\n   = note:\
    \ expected type `usize`\n            found struct `RangeFrom<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4a2zgdua.rs:29:18\n   |\n16 |     let mut prefix\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    29 |         prefix = prefix.remove(index..);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\n\
    \   |                  expected struct `String`, found `char`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp4a2zgdua.rs:33:14\n   |\n33 |     reversed.append(prefix);\n   |   \
    \           ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `reverse` found for struct `String` in the current scope\n  --> /tmp/tmp4a2zgdua.rs:34:14\n\
    \   |\n34 |     reversed.reverse();\n   |              ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut postfix_len\
    \ = string.len();\n    let mut postfix = &string[..postfix_len];\n    while postfix_len\
    \ > 1 {\n        let mut postfix_reverse = reverse(&postfix);\n        postfix.push_str(postfix_reverse);\n\
    \        postfix_len -= 1;\n    }\n    string.push_str(reverse(&string[postfix_len..]));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpo0wvb6i2.rs:18:35\n\
    \   |\n18 |         let mut postfix_reverse = reverse(&postfix);\n   |       \
    \                            ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `reverse` in this scope\n  --> /tmp/tmpo0wvb6i2.rs:22:21\n\
    \   |\n22 |     string.push_str(reverse(&string[postfix_len..]));\n   |      \
    \               ^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmpo0wvb6i2.rs:19:17\n\
    \   |\n19 |         postfix.push_str(postfix_reverse);\n   |                 ^^^^^^^^\
    \ method not found in `&str`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let length = string.chars().count();\n    let mut buffer = String::from(\"\
    \");\n\n    if length <= 1 {\n        return string;\n    }\n\n    for i in 0..(length\
    \ - 1) {\n        let last_char = &string[length - i - 1];\n        let next_char\
    \ = &string[i + 1 .. length - 1];\n        let reverse = last_char.rev();\n\n\
    \        buffer.push_str(reverse);\n        buffer.push_str(&next_char);\n   \
    \ }\n\n    buffer\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph3gb4ilc.rs:20:26\n\
    \   |\n20 |         let last_char = &string[length - i - 1];\n   |           \
    \               ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let len = string.len();\n    let mut str = string;\n    let mut suffix_found\
    \ = false;\n\n    for suffix in str.chars().rev().take(len - 1) {\n        let\
    \ prefix = str.chars().take(len - suffix - 1).collect();\n        let palindrom\
    \ = &str.chars().nth(len - suffix);\n\n        if palindrom.eq(prefix) {\n   \
    \         suffix_found = true;\n            str = str.drain(..);\n        }\n\
    \    }\n\n    if suffix_found {\n        str.to_owned()\n    } else {\n      \
    \  str\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `char` from `usize`\n  --> /tmp/tmpxoasw0kz.rs:17:43\n\
    \   |\n17 |         let prefix = str.chars().take(len - suffix - 1).collect();\n\
    \   |                                           ^ no implementation for `usize\
    \ - char`\n   |\n   = help: the trait `Sub<char>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ cannot subtract `char` from `usize`\n  --> /tmp/tmpxoasw0kz.rs:18:46\n   |\n\
    18 |         let palindrom = &str.chars().nth(len - suffix);\n   |           \
    \                                   ^ no implementation for `usize - char`\n \
    \  |\n   = help: the trait `Sub<char>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: a\
    \ value of type `&Option<char>` cannot be built from an iterator over elements\
    \ of type `char`\n    --> /tmp/tmpxoasw0kz.rs:17:57\n     |\n17   |         let\
    \ prefix = str.chars().take(len - suffix - 1).collect();\n     |             \
    \                                            ^^^^^^^ value of type `&Option<char>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `&Option<char>`\n    \
    \ = help: the trait `FromIterator<Option<A>>` is implemented for `Option<V>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxoasw0kz.rs:22:19\n   |\n13 |     let mut str ="
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = String::from(\"\");\n    let mut prefix = 0;\n\n    while\
    \ let Some(next_prefix) = string.prefix(prefix) {\n        reverse.push_str(&string[..next_prefix]);\n\
    \        reverse.push('_');\n        prefix = next_prefix;\n    }\n\n    reverse.push_str(&string[..]);\n\
    \n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `prefix` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpyx4r8ox7.rs:15:42\n   |\n15 |     while let Some(next_prefix)\
    \ = string.prefix(prefix) {\n   |                                          ^^^^^^\
    \ help: there is an associated function with a similar name: `strip_prefix`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    string\n        .iter()\n        .max_by_key(|&c| c.len())\n        .map(|c|\
    \ c.to_ascii_lowercase())\n        .fold(&string, (\"\".to_ascii_lowercase(),\
    \ \"\".to_ascii_lowercase()))\n        .map(|(suffix, suffix_reverse)| format!(\"\
    {}{}\", suffix, suffix_reverse))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4o0i8hpg.rs:13:10\n   |\n13 |         .iter()\n   |   \
    \       ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n13 |         .chars()\n   |          ~~~~~\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string;\n    let mut max_length = 0;\n    let mut suffix\
    \ = 0;\n\n    while !result.is_empty() {\n        let c = result.pop();\n    \
    \    max_length = max_length.checked_adding(c.len() as u32);\n        suffix =\
    \ suffix.checked_adding(c.chars().count() as u32);\n\n        if suffix.cmp(&max_length)\
    \ == 0 {\n            break;\n        }\n\n        if c.is_upper() {\n       \
    \     result = result.reverse_unwrap().to_owned();\n            result = result.append_str(&c.to_string());\n\
    \            max_length = max_length.checked_adding(c.len() as u32);\n       \
    \     suffix = suffix.checked_adding(c.chars().count() as u32);\n        } else\
    \ {\n            result = result.reverse_unwrap().to_owned();\n            result\
    \ = result.append_str(&c.to_string());\n            max_length = max_length.checked_adding(c.len()\
    \ as u32);\n            suffix = suffix.checked_adding(c.chars().count() as u32);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_adding` found for type `{integer}`\
    \ in the current scope\n  --> /tmp/tmpquzyj923.rs:18:33\n   |\n18 |         max_length\
    \ = max_length.checked_adding(c.len() as u32);\n   |                         \
    \        ^^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method\
    \ named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpquzyj923.rs:18:50\n\
    \   |\n18 |         max_length = max_length.checked_adding(c.len() as u32);\n\
    \   |                                                  ^^^ method not found in\
    \ `Option<char>`\n\nerror[E0599]: no method named `checked_adding` found for type\
    \ `{integer}` in the current scope\n  --> /tmp/tmpquzyj923.rs:19:25\n   |\n19\
    \ |         suffix = suffix.checked_adding(c.chars().count() as u32);\n   |  \
    \                       ^^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]:\
    \ no method named `chars` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpquzyj923.rs:19:42\n   |\n19 |         suffix = suffix.checked_adding(c.chars().count()\
    \ as u32);\n   |                                          ^^^^^ method not found\
    \ in `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquzyj923.rs:21:39\n\
    \   |\n21 |         if suffix.cmp(&max_length) == 0 {\n   |                  \
    \                     ^ expected enum `std::cmp::Ordering`, found integer\n\n\
    error[E0599]: no method named `is_upper` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpquzyj923.rs:25:14\n   |\n25 |         if c.is_upper() {\n\
    \   |              ^^^^^^^^ method not found in `Option<char>`\n\nerror[E0599]:\
    \ no method named `reverse_unwrap` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpquzyj923.rs:26:29\n   |\n26 |             result = result.reverse_unwrap().to_owned();\n\
    \   |                             ^^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append_str` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpquzyj923.rs:27:29\n   |\n27 |             result\
    \ = result.append_str(&c.to_string());\n   |                             ^^"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut postfix_length = string\n        .char_indices()\n        .map(|(char_index,\
    \ _)| char_index)\n        .max().unwrap()\n        + 1; // +1 because we already\
    \ have first char from original string\n\n    let mut reversed_string = string.clone();\n\
    \    reversed_string.split_off(1);\n\n    let mut index = postfix_length - 1;\n\
    \    while index >= 0 {\n        if reversed_string[index] == string[index] {\n\
    \            reversed_string.insert(index, string[index].to_ascii_lowercase());\n\
    \        } else {\n            break;\n        }\n        index -= 1;\n    }\n\
    \    reversed_string.insert((reversed_string.len() - 1).unwrap(), string[0]);\n\
    \    debug_assert!(reversed_string == string);\n\n    reversed_string\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptvsxudv8.rs:23:12\n\
    \   |\n23 |         if reversed_string[index] == string[index] {\n   |       \
    \     ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptvsxudv8.rs:23:38\n\
    \   |\n23 |         if reversed_string[index] == string[index] {\n   |       \
    \                               ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptvsxudv8.rs:24:43\n   |\n24 |             reversed_string.insert(index,\
    \ string[index].to_ascii_lowercase());\n   |                                 \
    \          ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n  "
  stdout: ''
  timestamp: 1659976839
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut len = string.len();\n    let mut result = String;\n    while len\
    \ > 0 {\n        let mut index = len - 1;\n        while index >= 0 {\n      \
    \      if string[index] != string[len - index] {\n                break;\n   \
    \         }\n            index -= 1;\n        }\n        result = result + &string[len\
    \ - index];\n        len -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found struct `String`\n   --> /tmp/tmpaxy689mn.rs:13:22\n\
    \    |\n13  |       let mut result = String;\n    |                        ^^^^^^\n\
    \    |\nhelp: use struct literal syntax instead\n    |\n13  |     let mut result\
    \ = String { vec: val };\n    |                      ~~~~~~~~~~~~~~~~~~~\nhelp:\
    \ a local variable with a similar name exists\n    |\n13  |     let mut result\
    \ = string;\n    |                      ~~~~~~\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpaxy689mn.rs:17:16\n   |\n17 |  \
    \           if string[index] != string[len - index] {\n   |                ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpaxy689mn.rs:17:33\n   |\n17 |             if string[index] != string[len\
    \ - index] {\n   |                                 ^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpaxy689mn.rs:22:28\n   |\n22 |         result = result + &string[len\
    \ - index];\n   |                         "
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffixes = vec![];\n\n    for pos in string.char_indices() {\n  \
    \      let suffix = string.suffix(pos).unwrap();\n        if suffix.is_empty()\
    \ {\n            suffixes.push(suffix);\n            continue;\n        }\n  \
    \      suffixes.push(suffix.to_ascii_lowercase());\n        suffixes.push(suffix);\n\
    \    }\n\n    let mut result_string = string;\n\n    for suffix in suffixes {\n\
    \        let mut suffix = suffix;\n        if suffix.is_empty() {\n          \
    \  continue;\n        }\n        let suffix = suffix.to_ascii_lowercase();\n \
    \       suffix[..suffix.len()].iter().for_each(|c| {\n            if !result_string.starts_with(c)\
    \ {\n                result_string.insert(0, c);\n            }\n        });\n\
    \    }\n\n    result_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `suffix` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmprrngxstz.rs:15:29\n   |\n15 |         let suffix\
    \ = string.suffix(pos).unwrap();\n   |                             ^^^^^^ help:\
    \ there is an associated function with a similar name: `strip_suffix`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_reverse = string;\n    let mut prefix_to_prepend = \"\"\
    ;\n    while !string_to_reverse.is_empty() {\n        let mut last_char = string_to_reverse.chars().last();\n\
    \        let mut new_char = String::new();\n        new_char.push(last_char.to_ascii_lowercase());\n\
    \        new_char.push(last_char.to_ascii_uppercase());\n        let mut suffix_to_prepend\
    \ = string_to_reverse.clone();\n        suffix_to_prepend.truncate(prefix_to_prepend.len());\n\
    \        suffix_to_prepend.push_str(prefix_to_prepend);\n        suffix_to_prepend.push_str(&new_char);\n\
    \        string_to_reverse = suffix_to_prepend.clone();\n        prefix_to_prepend\
    \ = suffix_to_prepend.clone();\n    }\n    string_to_reverse\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmp7nd15f6i.rs:17:33\n   |\n17 |         new_char.push(last_char.to_ascii_lowercase());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\
    \nerror[E0599]: no method named `to_ascii_uppercase` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmp7nd15f6i.rs:18:33\n   |\n18 |         new_char.push(last_char.to_ascii_uppercase());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7nd15f6i.rs:24:29\n   |\n13 |\
    \     let mut prefix_to_prepend = \"\";\n   |                                \
    \ -- expected due to this value\n...\n24 |         prefix_to_prepend = suffix_to_prepend.clone();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |            \
    \                 |\n   |                             expected `&str`, found struct\
    \ `String`\n   |                             help: consider borrowing here: `&suffix_to_prepend`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix: &str = &string[..];\n    while\
    \ !prefix.is_empty() {\n        let mut suffix: &str = &string[..prefix.len()];\n\
    \        while !suffix.is_empty() {\n            if suffix == reverse(&prefix[..])\
    \ {\n                break;\n            }\n            suffix = &suffix[..];\n\
    \        }\n        prefix = &prefix[..];\n    }\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpto3_i6f8.rs:17:26\n\
    \   |\n17 |             if suffix == reverse(&prefix[..]) {\n   |            \
    \              ^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix = string.clone();\n    let mut suffix = string.clone();\n\n\
    \    // find longest palindrome postfix\n    while suffix.chars().any(|&c| c !=\
    \ '.') {\n        let mut i = 1;\n        while i <= prefix.len() - 1 && prefix.chars().all(|&c|\
    \ c == suffix[i]) {\n            i += 1;\n        }\n        suffix = suffix[i..].to_owned();\n\
    \    }\n\n    // append reverse of postfix of prefix to suffix\n    suffix +=\
    \ &prefix.chars().fold(String::new(), |mut str, &c| {\n        str += &suffix[prefix.index(c)\
    \ - prefix.len()..];\n        str\n    });\n\n    suffix\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2l5cwrkq.rs:16:31\n   |\n\
    16 |     while suffix.chars().any(|&c| c != '.') {\n   |                     \
    \          ^--\n   |                               ||\n   |                  \
    \             |expected due to this\n   |                               expected\
    \ `char`, found reference\n   |                               help: did you mean\
    \ `c`: `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2l5cwrkq.rs:18:60\n  \
    \ |\n18 |         while i <= prefix.len() - 1 && prefix.chars().all(|&c| c ==\
    \ suffix[i]) {\n   |                                                         \
    \   ^--\n   |                                                            ||\n\
    \   |                                                            |expected due\
    \ to this\n   |                                                            expected\
    \ `char`, found reference\n   |                                              \
    \              help: did you mean `c`: `&char`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp2l5cwrkq.rs:18:69\n   |\n18 |         while\
    \ i <= prefix.len() - 1 && prefix.chars().all(|&c| c == suffix[i]) {\n   |   \
    \                                                                  ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2l5cwrkq.rs:25:61\n\
    \   |\n25 |     suffix += &prefix.chars().fold(String::new(), |mut str, &c| {\n\
    \   |                         "
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffixes: Vec<_> = Vec::new();\n    suffixes.push(string);\n    while\
    \ !suffixes.is_empty() {\n        let mut max_len = string\n            .chars()\n\
    \            .map(|c| if c.is_alpha() || c == '_' { 1 } else { 0 })\n        \
    \    .max();\n        for suffix in &suffixes[..max_len] {\n            if suffix.is_ascii_alphanumeric()\
    \ {\n                return suffix.to_owned();\n            }\n        }\n   \
    \     suffixes.pop();\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_alpha` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp356rpk0m.rs:17:27\n   |\n17 |             .map(|c| if c.is_alpha()\
    \ || c == '_' { 1 } else { 0 })\n   |                           ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_alphabetic`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `RangeTo<Option<{integer}>>`\n  -->\
    \ /tmp/tmp356rpk0m.rs:19:24\n   |\n19 |         for suffix in &suffixes[..max_len]\
    \ {\n   |                        ^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `RangeTo<Option<{integer}>>`\n   = help: the following\
    \ other types implement trait `SliceIndex<T>`:\n             <RangeTo<usize> as\
    \ SliceIndex<[T]>>\n             <RangeTo<usize> as SliceIndex<str>>\n   = note:\
    \ required because of the requirements on the impl of `Index<RangeTo<Option<{integer}>>>`\
    \ for `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let string = string.to_string();\n    let mut length = 0;\n\n    for i in\
    \ string.chars() {\n        if i.is_uppercase() {\n            length = length\
    \ + 1;\n        } else {\n            length = length + 2;\n        }\n    }\n\
    \n    let mut reverse_string = \"\";\n\n    for i in (0..length).rev() {\n   \
    \     reverse_string.push(string[i]);\n    }\n\n    reverse_string.insert(0, &string[..length\
    \ - 1]);\n\n    String::from(&reverse_string)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpclgtdek1.rs:26:24\n   |\n26 |         reverse_string.push(string[i]);\n\
    \   |                        ^^^^ method not found in `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpclgtdek1.rs:26:29\n\
    \   |\n26 |         reverse_string.push(string[i]);\n   |                    \
    \         ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `insert` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmpclgtdek1.rs:29:20\n   |\n29 |     reverse_string.insert(0, &string[..length\
    \ - 1]);\n   |                    ^^^^^^ method not found in `&str`\n\nerror[E0277]:\
    \ the trait bound `String: From<&&str>` is not satisfied\n  --> /tmp/tmpclgtdek1.rs:31:5\n\
    \   |\n31 |     String::from(&reverse_string)\n   |     ^^^^^^^^^^^^ the trait\
    \ `From<&&str>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut postfix = string.clone();\n    let mut reverse = string.clone();\n\
    \    let mut suffix = string.clone();\n    while !postfix.is_empty() {\n     \
    \   if postfix.chars().any(|c| !c.is_alphanumeric() || c != c.to_ascii_lowercase())\
    \ {\n            postfix = postfix.chars().collect::<String>().reverse();\n  \
    \      }\n        if suffix == reverse {\n            suffix = postfix.chars().collect::<String>();\n\
    \        }\n        reverse = suffix;\n        postfix.pop();\n    }\n    suffix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbjj4oxd6.rs:17:59\n   |\n17 |             postfix\
    \ = postfix.chars().collect::<String>().reverse();\n   |                     \
    \                                      ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string.reverse();\n    let mut palindrome = string;\n \
    \   while palindrome.is_prefix(&reverse) {\n        palindrome = palindrome.to_owned()\
    \ + reverse.as_str();\n        reverse = reverse.reverse();\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpcjafelq_.rs:12:30\n   |\n12 |     let mut reverse\
    \ = string.reverse();\n   |                              ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror[E0599]: no method\
    \ named `is_prefix` found for struct `String` in the current scope\n  --> /tmp/tmpcjafelq_.rs:14:22\n\
    \   |\n14 |     while palindrome.is_prefix(&reverse) {\n   |                 \
    \     ^^^^^^^^^ help: there is an associated function with a similar name: `strip_prefix`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut found_longest_palindrome = false;\n\
    \n    // Loop over all possible postfix of given string\n    while !string.is_empty()\
    \ {\n        // Find the postfix of the longest palindrome and check if it's a\
    \ palindrome\n        if let Some(mut suffix) = reverse_suffix(&string) {\n  \
    \          if found_longest_palindrome {\n                // Stop searching after\
    \ palindrome is found once\n                break;\n            } else {\n   \
    \             // Found a palindrome, append reverse of prefix to the suffix to\
    \ form the palindrome\n                let mut result_string = suffix;\n     \
    \           result_string.push_str(&mut prefix(&string));\n                string\
    \ = suffix;\n                // Reset flag\n                found_longest_palindrome\
    \ = true;\n            }\n        } else {\n            break;\n        }\n  \
    \  }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse_suffix` in this scope\n  -->\
    \ /tmp/tmp04fxkbwg.rs:18:35\n   |\n18 |         if let Some(mut suffix) = reverse_suffix(&string)\
    \ {\n   |                                   ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `prefix` in this scope\n  --> /tmp/tmp04fxkbwg.rs:25:45\n\
    \   |\n25 |                 result_string.push_str(&mut prefix(&string));\n  \
    \ |                                             ^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    loop {\n        let mut reverse = String::from(\"\
    \");\n        let mut index = string\n            .char_indices()\n          \
    \  .skip_while(|&index| !index.is_ascii_lowercase())\n            .next();\n \
    \       let mut start = 0;\n        while let Some(end) = index {\n          \
    \  if !end.is_ascii_lowercase() {\n                break;\n            }\n   \
    \         if string[end - 1] != string[end] {\n                break;\n      \
    \      }\n            reverse.push(*string.chars().nth(end).unwrap());\n     \
    \       start = end;\n            index = string.char_indices().skip_while(|&index|\
    \ !index.is_ascii_lowercase()).next();\n        }\n        if reverse == string\
    \ {\n            return string;\n        }\n        string = string.insert(start,\
    \ &reverse);\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for tuple `(usize,\
    \ char)` in the current scope\n  --> /tmp/tmpwwl5bwij.rs:17:41\n   |\n17 |   \
    \          .skip_while(|&index| !index.is_ascii_lowercase())\n   |           \
    \                              ^^^^^^^^^^^^^^^^^^ method not found in `(usize,\
    \ char)`\n\nerror[E0599]: no method named `is_ascii_lowercase` found for tuple\
    \ `(usize, char)` in the current scope\n  --> /tmp/tmpwwl5bwij.rs:21:21\n   |\n\
    21 |             if !end.is_ascii_lowercase() {\n   |                     ^^^^^^^^^^^^^^^^^^\
    \ method not found in `(usize, char)`\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `(usize, char)`\n  --> /tmp/tmpwwl5bwij.rs:24:27\n   |\n24 |          \
    \   if string[end - 1] != string[end] {\n   |                       --- ^ - {integer}\n\
    \   |                       |\n   |                       (usize, char)\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `(usize, char)`\n  --> /tmp/tmpwwl5bwij.rs:24:35\n\
    \   |\n24 |             if string[end - 1] != string[end] {\n   |            \
    \                       ^^^^^^^^^^^ `String` cannot be indexed by `(usize, char)`\n\
    \   |\n   = help: the trait `Index<(usize, char)>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwl5bwij.rs:27:46\n\
    \   |\n27 |             reverse.push(*string.chars().nth(end).unwrap());\n   |\
    \                                              ^^^ expected `usize`, found tuple\n\
    \   |\n   = note: expected type `usize`\n             found tuple `(usize, char)`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpwwl5bwij.rs:27:26\n\
    \   |\n27 |             reverse.push(*string.chars().nth(end).unwrap());\n   |\
    \       "
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n\n    let mut prefix_suffixes\
    \ = vec![];\n    for pos in (0..string.len()).rev() {\n        let suffix = (&string[..pos]).to_owned();\n\
    \        let start = match pos {\n            0 => prefix,\n            _ => &string[pos..],\n\
    \        };\n        prefix_suffixes.extend(start.to_owned().chars().chain(suffix.to_owned().chars()));\n\
    \    }\n\n    let suffix_string = prefix_suffixes.iter().map(|char| char.to_string()).collect();\n\
    \    let suffix_string = if suffix_string.len() >= string.len() / 2 {\n      \
    \  suffix_string\n    } else {\n        suffix_string.clone() + &string[string.len()\
    \ - suffix_string.len()..]\n    };\n    let suffix_string = suffix_string.to_string();\n\
    \    let start = &string[0..prefix_suffixes.len() - suffix_string.len()];\n  \
    \  start.append(suffix_string);\n    start\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `prefix` in this scope\n  --> /tmp/tmpfkhc1rbn.rs:20:18\n\
    \   |\n20 |             0 => prefix,\n   |                  ^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: no method named `append` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpfkhc1rbn.rs:34:11\n   |\n34 |     start.append(suffix_string);\n\
    \   |           ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfkhc1rbn.rs:35:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n35 |     start\n   |     ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_palindrome = string;\n    let mut palindrome = string;\n\
    \    let mut first_char_index = 0;\n    let mut last_char_index = string.len()\
    \ - 1;\n\n    while palindrome.len() != string_to_palindrome.len() {\n       \
    \ // Find the longest postfix that is a palindrome.\n        if first_char_index\
    \ == last_char_index {\n            break;\n        }\n        let mut longest\
    \ = 0;\n        let mut prefix_to_longest = &string_to_palindrome[first_char_index..];\n\
    \        for index in prefix_to_longest.rindex(b'a'..b'z') {\n            let\
    \ c = &prefix_to_longest[index];\n            if c != b'a' && c != b'z' && c !=\
    \ b'A' && c != b'Z' && c != b'_' {\n                longest = index;\n       \
    \     }\n        }\n        let mut suffix_to_longest = &palindrome[..longest];\n\
    \        let reverse_suffix_to_longest = suffix_to_longest.reverse();\n      \
    \  palindrome = &palindrome[longest..];\n        palindrome.push_str(reverse_suffix_to_longest);\n\
    \        first_char_index += 1;\n        last_char_index -= 1;\n        string_to_palindrome\
    \ = &string_to_palindrome[first_char_index..];\n        string_to_palindrome.push_str(reverse_suffix_to_longest);\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rindex` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpjra62_0q.rs:24:40\n   |\n24 |         for index\
    \ in prefix_to_longest.rindex(b'a'..b'z') {\n   |                            \
    \            ^^^^^^ help: there is an associated function with a similar name:\
    \ `find`\n\nerror[E0277]: can't compare `&_` with `u8`\n  --> /tmp/tmpjra62_0q.rs:26:18\n\
    \   |\n26 |             if c != b'a' && c != b'z' && c != b'A' && c != b'Z' &&\
    \ c != b'_' {\n   |                  ^^ no implementation for `&_ == u8`\n   |\n\
    \   = help: the trait `PartialEq<u8>` is not implemented for `&_`\n\nerror[E0277]:\
    \ can't compare `&_` with `u8`\n  --> /tmp/tmpjra62_0q.rs:26:31\n   |\n26 |  \
    \           if c != b'a' && c != b'z' && c != b'A' && c != b'Z' && c != b'_' {\n\
    \   |                               ^^ no implementation for `&_ == u8`\n   |\n\
    \   = help: the trait `PartialEq<u8>` is not implemented for `&_`\n\nerror[E0277]:\
    \ can't compare `&_` with `u8`\n  --> /tmp/tmpjra62_0q.rs:26:44\n   |\n26 |  \
    \           if c != b'a' && c != b'z' && c != b'A' && c != b'Z' && c != b'_' {\n\
    \   |                                            ^^ no implementation for `&_\
    \ == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented for `&_`\n\
    \nerror[E0277]: can't compare `&_` with `u8`\n  --> /tmp/tmpjra62_0q.rs:26:57\n\
    \   |\n26 |             if c != b'a' && c != b'z' && c != b'A' && c != b'Z' &&\
    \ c != b'_' {\n   |                                                         ^^\
    \ no implementation for `&_ == u8`\n   |\n   = help: the trait `PartialEq<u8>`\
    \ is not implemented for `&_`\n\nerror[E0277]: can't compare `&_` with `u8`\n\
    \  --> /tmp/tmpjra62_0q.rs:26:70\n   |\n26 |             if c != b'a' && c !=\
    \ b'z' && c != b'A' && c != b'Z' && c != b'_' {\n   |                        \
    \                                              ^^ no implementation for `&_ ==\
    \ u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented for `&_`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpjra62_0q.rs:25:22\n\
    \   |\n25 |             let c = &prefix_to_longest[ind"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // TODO: optimise\n    let mut string = string;\n    let mut reverse = string;\n\
    \    let mut last_postfix_index = 0;\n    let mut reverse_last_postfix_index =\
    \ 0;\n\n    let mut i = 0;\n\n    while i < string.len() {\n        // Find the\
    \ longest postfix that is a palindrome\n        while i <= string.len() && string[i]\
    \ == string[i - 1].cloned() {\n            i += 1;\n        }\n        last_postfix_index\
    \ = i;\n\n        // Append reverse of the string prefix that comes before the\
    \ palindromic suffix\n        if i == string.len() {\n            break;\n   \
    \     }\n        let mut j = i;\n        while j <= string.len() && string[j]\
    \ == string[j - 1].cloned() {\n            i += 1;\n            j += 1\n     \
    \   }\n        reverse_last_postfix_index = j;\n        reverse += &string[..reverse_last_postfix_index];\n\
    \    }\n\n    if string.len() == 0 {\n        string\n    } else {\n        string\
    \ + &reverse[..last_postfix_index]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpni0injax.rs:22:36\n\
    \   |\n22 |         while i <= string.len() && string[i] == string[i - 1].cloned()\
    \ {\n   |                                    ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpni0injax.rs:22:49\n   |\n22 |         while i <= string.len() &&\
    \ string[i] == string[i - 1].cloned() {\n   |                                \
    \                 ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpni0injax.rs:32:36\n\
    \   |\n32 |         while j <= string.len() && string[j] == string[j - 1].cloned()\
    \ {\n   |                                    ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n    "
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_reverse = String::new();\n    let mut suffixes_index =\
    \ -1;\n    for suffix in string.chars().rev() {\n        if suffix.to_ascii_lowercase()\
    \ == suffix.to_ascii_lowercase().rev() {\n            suffixes_index += 1;\n \
    \       }\n        string_to_reverse.push_str(&suffix);\n    }\n    // Putting\
    \ palindrome after suffix is not necessary, because there might be shorter palindromes\n\
    \    // with equal length.\n    // So we just reverse the whole string instead\
    \ of finding suffix and putting it to palindrome.\n    let mut string_to_palindrome\
    \ = String::from(string);\n    string_to_palindrome = string_to_palindrome.rev();\n\
    \    string_to_palindrome.push_str(&string_to_reverse);\n    string_to_palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmp8gdku5tc.rs:15:71\n\
    \   |\n15 |         if suffix.to_ascii_lowercase() == suffix.to_ascii_lowercase().rev()\
    \ {\n   |                                                                    \
    \   ^^^ `char` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `char: Iterator`\n           which is required\
    \ by `&mut char: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8gdku5tc.rs:18:36\n\
    \   |\n18 |         string_to_reverse.push_str(&suffix);\n   |               \
    \                     ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmp8gdku5tc.rs:24:49\n    |\n24  |       string_to_palindrome\
    \ = string_to_palindrome.rev();\n    |                                       \
    \            ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let reverse = string\n        .chars()\n        .map(|x| x.to_string())\n\
    \        .collect::<Vec<_>>()\n        .reverse()\n        .join(\"\");\n    string\
    \ + reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `join` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpx8rlqbop.rs:17:10\n   |\n17 |         .join(\"\");\n  \
    \ |          ^^^^ method not found in `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut str = string;\n    let mut start = 0;\n    let mut end = str.len()\
    \ - 1;\n\n    while start < end {\n        if str[start] == str[end] {\n     \
    \       end -= 1;\n        } else {\n            end += 1;\n            start\
    \ = end;\n        }\n    }\n\n    if str.len() > 1 {\n        str = &str.to_owned()[..start]\
    \ + &str[end..].to_owned()[start..];\n    }\n\n    str\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4_0ynkru.rs:17:12\n\
    \   |\n17 |         if str[start] == str[end] {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4_0ynkru.rs:17:26\n   |\n17 |         if str[start] == str[end]\
    \ {\n   |                          ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmp4_0ynkru.rs:26:40\n\
    \   |\n26 |         str = &str.to_owned()[..start] + &str[end..].to_owned()[start..];\n\
    \   |               ------------------------ ^ -------------------------------\
    \ &str\n   |               |                        |\n   |               |  \
    \                      `+` cannot be used to concatenate two `&str` strings\n\
    \   |               &str\n   |\n   = note: string concatenation requires an owned\
    \ `String` on the left\nhelp: remove the borrow to obtain an owned `String`\n\
    \   |\n26 -         str = &str.to_owned()[..start] + &str[end..].to_owned()[start..];\n\
    26 +         str = str.to_owned()[..start] + &str[end..].t"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut longest = string.len();\n    let mut suffix = [0u8; longest];\n\n\
    \    for &mut c in string.chars() {\n        if c.is_uppercase() {\n         \
    \   let mut i = 0;\n\n            while suffix[i] != c.as_u8() {\n           \
    \     suffix[i] += 1;\n                i += 1;\n            }\n        } else\
    \ {\n            let mut i = 0;\n\n            while suffix[i] != c.as_u8() {\n\
    \                suffix[i] += 1;\n                i += 1;\n            }\n   \
    \     }\n    }\n\n    if longest == 0 {\n        string.to_owned()\n    } else\
    \ {\n        let mut suffix_reversed = suffix;\n        for i in 0..suffix {\n\
    \            suffix_reversed[i] = suffix_reversed[i] - 1;\n        }\n\n     \
    \   string.push_str((&suffix_reversed[..]).reverse());\n    }\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpm2f9z8gf.rs:13:28\n   |\n12 |     let mut longest = string.len();\n\
    \   |     --------------- help: consider using `const` instead of `let`: `const\
    \ longest`\n13 |     let mut suffix = [0u8; longest];\n   |                  \
    \          ^^^^^^^ non-constant value\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpm2f9z8gf.rs:15:9\n   |\n15 |     for &mut c in string.chars() {\n  \
    \ |         ^^^^^^    -------------- this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found `&mut _`\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:         \
    \  expected type `char`\n           found mutable reference `&mut _`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm2f9z8gf.rs:35:12\n   |\n35 |       } else {\n\
    \   |  ____________^\n36 | |         let mut suffix_reversed = suffix;\n37 | |\
    \         for i in 0..suffix {\n38 | |             suffix_reversed[i] = suffix_reversed[i]\
    \ - 1;\n...  |\n41 | |         string.push_str((&suffix_reversed[..]).reverse());\n\
    42 | |     }\n   | |_____^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0435.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix_suffix_pos = string.rfind(&string[..]);\n    let suffix_length\
    \ = prefix_suffix_pos - 1;\n    let suffix_start = &string[prefix_suffix_pos +\
    \ 1..];\n    let mut suffix = (string.len() - suffix_length).reverse();\n    let\
    \ mut prefix = suffix.clone();\n    prefix.extend(&string[..prefix_suffix_pos\
    \ - 1]);\n\n    prefix.append(&mut suffix);\n\n    prefix.reverse()\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpypf5res5.rs:13:43\n\
    \   |\n13 |     let suffix_length = prefix_suffix_pos - 1;\n   |             \
    \            ----------------- ^ - {integer}\n   |                         |\n\
    \   |                         Option<usize>\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpypf5res5.rs:14:50\n   |\n14 |     let suffix_start\
    \ = &string[prefix_suffix_pos + 1..];\n   |                                -----------------\
    \ ^ - {integer}\n   |                                |\n   |                 \
    \               Option<usize>\n\nerror[E0369]: cannot subtract `{integer}` from\
    \ `Option<usize>`\n  --> /tmp/tmpypf5res5.rs:17:47\n   |\n17 |     prefix.extend(&string[..prefix_suffix_pos\
    \ - 1]);\n   |                             ----------------- ^ - {integer}\n \
    \  |                             |\n   |                             Option<usize>\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    fn prefix_suffix_of(string: String) -> Vec<String> {\n        let mut prefix\
    \ = vec![];\n        let mut suffix = vec![];\n        let mut prefix_len = string.len();\n\
    \        let mut suffix_len = 0;\n\n        let mut idx = 1;\n        while idx\
    \ < string.len() {\n            let c = string[idx as usize];\n            if\
    \ c == 'A' {\n                prefix.push(c);\n                suffix_len += 1;\n\
    \            } else {\n                suffix.push(c);\n                prefix_len\
    \ += 1;\n            }\n\n            if prefix_len > suffix_len {\n         \
    \       let mut suffix_len = prefix_len;\n                let mut idx = idx +\
    \ 1;\n            }\n            idx += 1;\n        }\n        (prefix, suffix)\n\
    \    }\n\n    let (prefix, suffix) = prefix_suffix_of(string);\n\n    let mut\
    \ reversed_prefix: String = prefix.clone();\n    let mut reversed_suffix: String\
    \ = suffix.clone();\n\n    for i in (0..prefix.len()).rev() {\n        reversed_prefix.insert(0,\
    \ prefix[i]);\n        reversed_suffix.insert(0, suffix[i]);\n    }\n\n    String::from(reversed_prefix\
    \ + &reversed_suffix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7galybav.rs:38:9\n   |\n\
    38 |     let (prefix, suffix) = prefix_suffix_of(string);\n   |         ^^^^^^^^^^^^^^^^\
    \   ------------------------ this expression has type `Vec<String>`\n   |    \
    \     |\n   |         expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<String>`\n               found tuple `(_, _)`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7galybav.rs:20:21\n\
    \   |\n20 |             let c = string[idx as usize];\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7galybav.rs:35:9\n\
    \   |\n12 |     fn prefix_suffix_of(string: String) -> Vec<String> {\n   |   \
    \                                         ----------- expected `Vec<String>` because\
    \ of return type\n...\n35 |         (prefix, suffix)\n   |         ^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \               found tuple `(Vec<_>, Vec<_>)`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut prefix = string[..].chars();\n\
    \    let mut suffix;\n    while let Some(suffix) = prefix.find(|x| *x == palindrome[..])\
    \ {\n        palindrome = palindrome[..suffix].to_string();\n        prefix.remove(suffix);\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe2e5r89y.rs:15:52\n   |\n\
    15 |     while let Some(suffix) = prefix.find(|x| *x == palindrome[..]) {\n  \
    \ |                                                    ^^^^^^^^^^^^^^ expected\
    \ `char`, found `str`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `RangeTo<char>`\n  --> /tmp/tmpe2e5r89y.rs:16:22\n   |\n16 |         palindrome\
    \ = palindrome[..suffix].to_string();\n   |                      ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeTo<char>`\n   |\n   = help: the trait `Index<RangeTo<char>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `remove` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpe2e5r89y.rs:17:16\n   |\n17 |         prefix.remove(suffix);\n\
    \   |                ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe2e5r89y.rs:19:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n19 |     prefix\n   |     ^^^^^^ expected\
    \ struct `String`, found struct `Chars`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // This loop will be executed until all possible postfix is found.\n    let\
    \ mut postfix = string;\n    let mut reverse = string.clone();\n    let mut suffix\
    \ = 0;\n    while postfix.len() != 0 {\n        let mut index = suffix.checked_sub(1).unwrap();\n\
    \        if reverse[index] != string[index] {\n            break;\n        }\n\
    \        if index == 0 {\n            suffix++;\n        }\n        let new_postfix\
    \ = &string[..index + 1];\n        let new_reverse = &reverse[..index + 1];\n\
    \        reverse = new_reverse;\n        postfix = new_postfix;\n    }\n    format!(\"\
    {}{}\", string, reverse)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpjpigbj94.rs:22:19\n\
    \   |\n22 |             suffix++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |             { let tmp =\
    \ suffix; suffix += 1; tmp };\n   |             +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n\
    22 -             suffix++;\n22 +             suffix += 1;\n   | \n\nerror[E0689]:\
    \ can't call method `checked_sub` on ambiguous numeric type `{integer}`\n  -->\
    \ /tmp/tmpjpigbj94.rs:17:32\n   |\n17 |         let mut index = suffix.checked_sub(1).unwrap();\n\
    \   |                                ^^^^^^^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n15 |     let mut suffix: i32 = 0;\n\
    \   |         ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjpigbj94.rs:26:19\n\
    \   |\n14 |     let mut reverse = string.clone();\n   |                      \
    \ -------------- expected due to this value\n...\n26 |         reverse = new_reverse;\n\
    \   |                   ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                   |\n   |                   expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjpigbj94.rs:27:19\n\
    \   |\n13 |     let mut postfix = string;\n   |                       ------ expected\
    \ due to this value\n...\n27 |         postfix = new_postfix;\n   |          \
    \         ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n \
    \  |                   |\n   |                   expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0689.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string == \"\" {\n        return string;\n    }\n\n    let mut reverse\
    \ = string[..].chars().collect::<Vec<_>>();\n    reverse.reverse();\n\n    let\
    \ mut string_palindrome = string;\n    for i in reverse.iter_mut() {\n       \
    \ string_palindrome.push(i);\n    }\n\n    string_palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpia9dwcw1.rs:21:32\n   |\n\
    21 |         string_palindrome.push(i);\n   |                                ^\
    \ expected `char`, found `&mut char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         string_palindrome.push(*i);\n   |                        \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string\n        .chars()\n        .cloned()\n        .enumerate()\n\
    \        .filter_map(|(idx, _)| {\n            let char: Char = match idx {\n\
    \                0 => string.chars().next().unwrap(),\n                n => string.chars()[n..n].next().unwrap(),\n\
    \            };\n            Some(match char {\n                c @ c' => {\n\
    \                    let new_char = char.into();\n                    match new_char\
    \ {\n                        c @ c' => {c' as char}\n                        _\
    \ => c,\n                    }\n                }\n                _ => {char}\n\
    \            })\n        })\n        .collect();\n    // The longest postfix is\
    \ given by reversing string.\n    let mut postfix = String::from(\"\");\n    let\
    \ mut suffix_idx = string.len() - 1;\n    while suffix_idx >= 0 {\n        let\
    \ char: Char = match suffix_idx {\n            n => string.chars()[n..n].next().unwrap(),\n\
    \            -1 => string.chars().last().unwrap(),\n        };\n        if char\
    \ == string[suffix_idx] {\n            postfix += char;\n        }\n        suffix_idx\
    \ -= 1;\n    }\n    string += postfix;\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpc46_kr44.rs:22:22\n\
    \   |\n22 |                 c @ c' => {\n   |                      ^^^^^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        string\n    } else {\n        let mut suffix:\
    \ String;\n        let mut suffix_len = 0;\n        let mut prefix = string;\n\
    \        let mut prefix_len = 0;\n        let mut current_substring = string;\n\
    \n        while let Ok(substring) = current_substring.reverse_iter() {\n     \
    \       if substring.starts_with(&prefix) {\n                current_substring\
    \ = &substring[prefix_len..];\n            }\n            if substring == &prefix\
    \ {\n                suffix_len = prefix_len;\n                suffix = substring[prefix_len..];\n\
    \                prefix_len += 1;\n            }\n            if suffix_len >\
    \ prefix_len {\n                break;\n            }\n        }\n        String::from(&prefix\
    \ + &suffix[..prefix_len][..suffix_len])\n    }\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse_iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpb4qyoxxk.rs:21:53\n   |\n21 |         while\
    \ let Ok(substring) = current_substring.reverse_iter() {\n   |               \
    \                                      ^^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0369]: cannot add `&str` to `&String`\n  --> /tmp/tmpb4qyoxxk.rs:34:30\n\
    \   |\n34 |         String::from(&prefix + &suffix[..prefix_len][..suffix_len])\n\
    \   |                      ------- ^ ----------------------------------- &str\n\
    \   |                      |       |\n   |                      |       `+` cannot\
    \ be used to concatenate two `&str` strings\n   |                      &String\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    help: remove the borrow to obtain an owned `String`\n   |\n34 -         String::from(&prefix\
    \ + &suffix[..prefix_len][..suffix_len])\n34 +         String::from(prefix + &suffix[..prefix_len][..suffix_len])\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    if palindrome.len() > 0 {\n        let\
    \ postfix = palindrome.chars().take_while(|c| c != palindrome.chars().last()).collect();\n\
    \        let reversed = palindrome\n            .chars()\n            .skip_while(palindrome.chars().any(|c|\
    \ c != palindrome.chars().last()))\n            .collect();\n        palindrome.push_str(reversed);\n\
    \        palindrome.push_str(postfix);\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `Option<char>`\n  --> /tmp/tmpgd5y5std.rs:14:59\n\
    \   |\n14 |         let postfix = palindrome.chars().take_while(|c| c != palindrome.chars().last()).collect();\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == Option<char>`\n   |\n   = help: the trait `PartialEq<Option<char>>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgd5y5std.rs:17:57\n\
    \   |\n17 |             .skip_while(palindrome.chars().any(|c| c != palindrome.chars().last()))\n\
    \   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0277]: expected a `FnMut<(&char,)>`\
    \ closure, found `bool`\n    --> /tmp/tmpgd5y5std.rs:17:25\n     |\n17   |   \
    \          .skip_while(palindrome.chars().any(|c| c != palindrome.chars().last()))\n\
    \     |              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `FnMut<(&char,)>` closure, found `bool`\n     |              |\n\
    \     |              required by a bound introduced by this call\n     |\n   \
    \  = help: the trait `for<'r> FnMut<(&'r char,)>` is not implemented for `bool`\n\
    note: required by a bound in `skip_while`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `SkipWhile<Chars<'_>, bool>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpgd5y5std.rs:18:14\n   |\n18 |               .collect();\n\
    \   |                ^^^^^^^ method cannot be called on `SkipWhile<Chars<'_>,\
    \ bool>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<bool as FnOnce<(&char,)>>::Output =\
    \ bool`\n           which is required by `SkipWhile<Chars<'_>, bool>: Iterator`\n\
    \           `bool: FnMut<(&char,)>`\n           which is required by `SkipWhile<Chars<'_>,\
    \ bool>: Iterator`\n           `SkipWhile<Chars<'_>, bool>: Iterator`\n      \
    \     which is required"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.len() < 2 {\n        String::from(\"\")\n    } else {\n       \
    \ let mut new_string = string;\n\n        let mut length = new_string.len();\n\
    \        let mut rev_idx = 1;\n        let mut rev_string = new_string.chars().nth(length\
    \ - 1);\n        let mut last_idx = length;\n        let mut last_string = new_string.chars().nth(length\
    \ - 1);\n\n        loop {\n            if last_string == rev_string {\n      \
    \          new_string = new_string\n                    .chars()\n           \
    \         .skip_while(|c| c == last_string).take(length).collect();\n\n      \
    \          last_idx -= 1;\n                if last_idx < 0 {\n               \
    \     break;\n                }\n                last_string = new_string.chars().nth(last_idx\
    \ - 1);\n            }\n\n            loop {\n                if rev_idx % 2 ==\
    \ 0 {\n                    new_string = new_string\n                        .chars()\n\
    \                        .skip_while(|c| c == rev_string).take(length).collect();\n\
    \                }\n\n                if rev_idx <= length - 1 {\n           \
    \         rev_idx -= 1;\n                    rev_string = new_string.chars().nth(rev_idx\
    \ - 1);\n                } else {\n                    break;\n              \
    \  }\n            }\n        }\n\n        String::from(new_string)\n    }\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `Option<char>`\n  --> /tmp/tmpvhad3fl1.rs:27:39\n\
    \   |\n27 |                     .skip_while(|c| c == last_string).take(length).collect();\n\
    \   |                                       ^^ no implementation for `&char ==\
    \ Option<char>`\n   |\n   = help: the trait `PartialEq<Option<char>>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `Option<char>`\n  --> /tmp/tmpvhad3fl1.rs:40:43\n\
    \   |\n40 |                         .skip_while(|c| c == rev_string).take(length).collect();\n\
    \   |                                           ^^ no implementation for `&char\
    \ == Option<char>`\n   |\n   = help: the trait `PartialEq<Option<char>>` is not\
    \ implemented for `&char`\n   = help: the trait `PartialEq` is implemented for\
    \ `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // TODO: check if string is empty\n    let mut result = string;\n    let\
    \ mut pos = string.len();\n    let mut last = 0;\n    while pos > 0 {\n      \
    \  // Find longest postfix palindrome\n        let mut palindrome = result;\n\
    \        let mut end = pos;\n        while end > 0 {\n            if end % 2 !=\
    \ 0 {\n                let char = result[end - 1];\n                let index\
    \ = palindrome.chars().position(|c| c == char).unwrap();\n                palindrome\
    \ = palindrome.insert(index, char);\n                end--;\n            } else\
    \ {\n                end--;\n            }\n        }\n        // Add reverse\
    \ of prefix part before the palindrome to the result\n        result = palindrome.clone();\n\
    \        last = result.len();\n        // Move position forward one step\n   \
    \     if pos > 1 {\n            pos = pos - 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpm70bkv64.rs:25:22\n\
    \   |\n25 |                 end--;\n   |                      ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmpm70bkv64.rs:27:22\n   |\n\
    27 |                 end--;\n   |                      ^ expected expression\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm70bkv64.rs:22:28\n\
    \   |\n22 |                 let char = result[end - 1];\n   |                \
    \            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm70bkv64.rs:24:30\n   |\n18 |         let mut\
    \ palindrome = result;\n   |                              ------ expected due\
    \ to this value\n...\n24 |                 palindrome = palindrome.insert(index,\
    \ char);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `insert` modifies its receiver\
    \ in-place\n  --> /tmp/tmpm70bkv64.rs:24:41\n   |\n24 |                 palindrome\
    \ = palindrome.insert(index, char);\n   |                              ----------\
    \ ^^^^^^ this call modifies `palindrome` in-place\n   |                      \
    \        |\n   |                              you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `insert`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix = string;\n    let mut suffix = string;\n    let mut reverse\
    \ = string;\n\n    while suffix.is_empty() {\n        let mut suffix = prefix.clone();\n\
    \        if let Some(suffix) = suffix.rev() {\n            prefix = prefix.to_owned()\
    \ + suffix;\n        } else {\n            break;\n        }\n    }\n\n    while\
    \ prefix.len() > 0 {\n        let mut suffix = prefix.clone();\n        if let\
    \ Some(suffix) = suffix.rev() {\n            reverse = reverse + suffix;\n   \
    \         prefix = prefix.to_owned() + suffix;\n        } else {\n           \
    \ break;\n        }\n    }\n\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpvop4ruwf.rs:18:38\n\
    \    |\n18  |           if let Some(suffix) = suffix.rev() {\n    |          \
    \                              ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpvop4ruwf.rs:27:38\n\
    \    |\n27  |           if let Some(suffix) = suffix.rev() {\n    |          \
    \                              ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = 0;\n    let mut suffixed_string = string;\n    let mut palindrome_start\
    \ = suffix;\n    let mut palindrome_end = suffix;\n\n    while palindrome_end\
    \ != string\n        .len()\n        .checked_sub(suffix)\n        .expect(\"\
    String length must be at least 1 longer\")\n    {\n        let mut prefix;\n \
    \       let mut reversed_prefix;\n        let mut palindrome_start = suffix;\n\
    \        while palindrome_start != 0\n            .checked_sub(suffix)\n     \
    \       .expect(\"String length must be at least 1 longer\")\n        {\n    \
    \        prefix = string.chars().nth(palindrome_start).unwrap();\n           \
    \ reversed_prefix = prefix.chars().nth(string::Reverse::reverse(prefix).len()).unwrap();\n\
    \            palindrome_start += 1;\n            palindrome_end += 1;\n      \
    \  }\n        palindrome_start = suffix;\n        palindrome_end = suffix;\n \
    \       suffixed_string = reversed_prefix + string;\n        suffix += 1;\n  \
    \  }\n\n    palindrome_start + suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmp2k9dw9xt.rs:30:58\n   |\n30 |             reversed_prefix = prefix.chars().nth(string::Reverse::reverse(prefix).len()).unwrap();\n\
    \   |                                                          ^^^^^^^ not found\
    \ in `string`\n   |\nhelp: consider importing this struct\n   |\n1  | use std::cmp::Reverse;\n\
    \   |\nhelp: if you import `Reverse`, refer to it directly\n   |\n30 -       \
    \      reversed_prefix = prefix.chars().nth(string::Reverse::reverse(prefix).len()).unwrap();\n\
    30 +             reversed_prefix = prefix.chars().nth(Reverse::reverse(prefix).len()).unwrap();\n\
    \   | \n\nerror[E0689]: can't call method `checked_sub` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmp2k9dw9xt.rs:26:14\n   |\n26 |             .checked_sub(suffix)\n\
    \   |              ^^^^^^^^^^^\n   |\nhelp: you must specify a concrete type for\
    \ this numeric value, like `i32`\n   |\n25 |         while palindrome_start !=\
    \ 0_i32\n   |                                   ~~~~~\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmp2k9dw9xt.rs:30:38\n\
    \   |\n30 |             reversed_prefix = prefix.chars().nth(string::Reverse::reverse(prefix).len()).unwrap();\n\
    \   |                                      ^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2k9dw9xt.rs:40:5\n   |\n11 | fn\
    \ make_palindrome(string: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n40 |     palindrome_start\
    \ + suffix\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `usize`\n   |\nhelp: try using a conversion method\n   |\n40 |     (palindrome_start\
    \ + suffix).to_string()\n   |     +                         +++++++++++++\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599, E0689.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_prefix: Vec<&str> = vec![];\n\
    \    let mut suffix: &str = string.clone();\n    let mut longest_postfix_length\
    \ = 0;\n\n    while suffix.len() > 0 {\n        let char = suffix[0];\n      \
    \  suffix.pop();\n        reversed_prefix.push(char.to_string());\n        longest_postfix_length\
    \ = reversed_prefix.len();\n        if longest_postfix_length == 0 {\n       \
    \     break;\n        }\n    }\n    longest_postfix_length\n        .checked_sub(suffix.len())\n\
    \        .expect(\"String is not a palindrome\");\n\n    string += &reversed_prefix[longest_postfix_length];\n\
    \    reversed_prefix[longest_postfix_length].to_string()\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5uxb77_v.rs:14:28\n   |\n\
    14 |     let mut suffix: &str = string.clone();\n   |                     ----\
    \   ^^^^^^^^^^^^^^\n   |                     |      |\n   |                  \
    \   |      expected `&str`, found struct `String`\n   |                     |\
    \      help: consider borrowing here: `&string`\n   |                     expected\
    \ due to this\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp5uxb77_v.rs:18:20\n   |\n18 |         let char = suffix[0];\n \
    \  |                    ^^^^^^^^^ string indices are ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n \
    \  = note: you can use `.chars().nth()` or `.bytes().nth()`\n           for more\
    \ information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0599]: no method named `pop` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmp5uxb77_v.rs:19:16\n   |\n19 |         suffix.pop();\n \
    \  |                ^^^ method not found in `&str`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debugln!(\"make_palindrome: {:?}\", string);\n\n    // Find longest common\
    \ prefix of string and reverse of string.\n    let mut prefix: String;\n    for\
    \ ch in string.chars() {\n        let index = string.char_indices()\n        \
    \    .skip_while(|&(i, _)| i < string.len())\n            .next()\n          \
    \  .unwrap()\n            .0;\n        debugln!(\"prefix: {:?}\", prefix);\n \
    \       prefix = string[index..].chars().rev().collect::<String>();\n        if\
    \ !is_palindrome(prefix) {\n            break;\n        }\n    }\n\n    // Find\
    \ longest common suffix of string and reverse of prefix.\n    let mut suffix:\
    \ String;\n    for ch in string.chars() {\n        let index = string.char_indices()\n\
    \            .skip_while(|&(i, _)| i < prefix.len())\n            .next()\n  \
    \          .unwrap()\n            .0;\n        debugln!(\"suffix: {:?}\", suffix);\n\
    \        suffix = string[index..].chars().rev().collect::<String>();\n       \
    \ if !is_palindrome(suffix) {\n            break;\n        }\n    }\n\n    //\
    \ Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    debugln!(\"final string: {:?}{}\", prefix, suffix);\n\
    \    string + &string[prefix.len()..suffix.len()].reverse()\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmp3hefm9cp.rs:12:5\n\
    \   |\n12 |     debugln!(\"make_palindrome: {:?}\", string);\n   |     ^^^^^^^\n\
    \nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmp3hefm9cp.rs:22:9\n\
    \   |\n22 |         debugln!(\"prefix: {:?}\", prefix);\n   |         ^^^^^^^\n\
    \nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmp3hefm9cp.rs:37:9\n\
    \   |\n37 |         debugln!(\"suffix: {:?}\", suffix);\n   |         ^^^^^^^\n\
    \nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmp3hefm9cp.rs:45:5\n\
    \   |\n45 |     debugln!(\"final string: {:?}{}\", prefix, suffix);\n   |    \
    \ ^^^^^^^\n\nerror[E0425]: cannot find function `is_palindrome` in this scope\n\
    \  --> /tmp/tmp3hefm9cp.rs:24:13\n   |\n24 |         if !is_palindrome(prefix)\
    \ {\n   |             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindrome` in this scope\n  --> /tmp/tmp3hefm9cp.rs:39:13\n\
    \   |\n39 |         if !is_palindrome(suffix) {\n   |             ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `reverse` found for\
    \ type `str` in the current scope\n  --> /tmp/tmp3hefm9cp.rs:46:50\n   |\n46 |\
    \     string + &string[prefix.len()..suffix.len()].reverse()\n   |           \
    \                                       ^^^^^^^ method not found in `str`\n\n\
    error: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let max_len = string.len();\n    string\n        .chars()\n        .take(max_len)\n\
    \        .enumerate()\n        .filter(|(_, i)| *i == 0)\n        .filter(|(_,\
    \ j)| j > 0 && string[j] != string[j - 1])\n        .map(|(_, j)| string[..j +\
    \ 1])\n        .collect::<Vec<_>>()\n        .join(\"\")\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiz81ym3p.rs:17:32\n   |\n\
    17 |         .filter(|(_, i)| *i == 0)\n   |                                ^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiz81ym3p.rs:18:30\n\
    \   |\n18 |         .filter(|(_, j)| j > 0 && string[j] != string[j - 1])\n  \
    \ |                              ^ expected `&char`, found integer\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `&char`\n  --> /tmp/tmpiz81ym3p.rs:18:35\n\
    \   |\n18 |         .filter(|(_, j)| j > 0 && string[j] != string[j - 1])\n  \
    \ |                                   ^^^^^^^^^ `String` cannot be indexed by\
    \ `&char`\n   |\n   = help: the trait `Index<&char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot subtract `{integer}` from `&char`\n  --> /tmp/tmpiz81ym3p.rs:18:57\n\
    \   |\n18 |         .filter(|(_, j)| j > 0 && string[j] != string[j - 1])\n  \
    \ |                                                       - ^ - {integer}\n  \
    \ |                                                       |\n   |            \
    \                                           &char\n\nerror[E0369]: cannot add\
    \ `{integer}` to `char`\n  --> /tmp/tmpiz81ym3p.rs:19:34\n   |\n19 |         .map(|(_,\
    \ j)| string[..j + 1])\n   |                                - ^ - {integer}\n\
    \   |                                |\n   |                                char\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpiz81ym3p.rs:19:14\n    |\n19  |         .map(|(_, j)| string[..j\
    \ + 1])\n    |          --- ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n    |          |\n    |          required by a bound introduced\
    \ by th"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.chars().count() == 0 {\n        String::from(\"\")\n    } else\
    \ {\n        let mut suffixes = [String::from(\"\")];\n        let mut suffixes_start\
    \ = 0;\n        for c in string.chars() {\n            let is_first_character\
    \ = c == string[suffixes_start];\n            let is_last_character = c == string[suffixes_start\
    \ + 1];\n            if is_first_character || is_last_character {\n          \
    \      let suffix = string[suffixes_start..];\n                suffixes.push(suffix);\n\
    \                suffixes_start += 1;\n            } else {\n                let\
    \ suffix_start = suffixes_start - 1;\n                let suffix_end = suffixes_start\
    \ + 1;\n                let suffix_mid = suffix_end - suffix_start + 1;\n    \
    \            let mut suffix = string[suffix_start..suffix_mid];\n            \
    \    suffix += string[suffix_mid..suffix_end].chars().collect::<String>();\n \
    \               suffixes.push(suffix);\n                suffixes_start = suffix_end\
    \ + 1;\n            }\n        }\n        let mut string_rev = String::from(\"\
    \");\n        for i in suffixes.iter_mut().rev() {\n            string_rev +=\
    \ i;\n        }\n        string_rev\n    }\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpl_rdi9px.rs:18:43\n   |\n18 |             let is_first_character = c\
    \ == string[suffixes_start];\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpl_rdi9px.rs:19:42\n   |\n19 |             let is_last_character\
    \ = c == string[suffixes_start + 1];\n   |                                   \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push` found for array `[String;\
    \ 1]` in the current scope\n  --> /tmp/tmpl_rdi9px.rs:22:26\n   |\n22 |      \
    \           suffixes.push(suffix);\n   |                          ^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpl_rdi9px.rs:21:21\n   |\n\
    21 |                 let suffix = string[suffixes_start..];\n   |            \
    \         ^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the "
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = \"\";\n    let mut last_postfix = \"\";\n    for\
    \ c in string.chars() {\n        if c != last_postfix[..c.len_utf8()].to_ascii_lowercase()\
    \ {\n            last_postfix = reversed_string.to_ascii_lowercase();\n      \
    \  }\n        reversed_string += c.to_ascii_lowercase();\n    }\n    last_postfix\
    \ = reversed_string.to_ascii_lowercase();\n    last_postfix\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn8_8wou9.rs:15:17\n   |\n\
    15 |         if c != last_postfix[..c.len_utf8()].to_ascii_lowercase() {\n   |\
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8_8wou9.rs:16:28\n\
    \   |\n13 |     let mut last_postfix = \"\";\n   |                           \
    \ -- expected due to this value\n...\n16 |             last_postfix = reversed_string.to_ascii_lowercase();\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |  \
    \                          |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&reversed_string.to_ascii_lowercase()`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpn8_8wou9.rs:18:9\n\
    \   |\n18 |         reversed_string += c.to_ascii_lowercase();\n   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn8_8wou9.rs:20:20\n   |\n13 |     let mut last_postfix\
    \ = \"\";\n   |                            -- expected due to this value\n...\n\
    20 |     last_postfix = reversed_string.to_ascii_lowercase();\n   |          \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                    |\n \
    \  |                    expected `&str`, found struct `String`\n   |         \
    \           help: consider borrowing here: `&reversed_string.to_ascii_lowercase()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn8_8wou9.rs:21:5\n   |\n11 | fn\
    \ make_palindrome(string: String) -> String {\n   |                          \
    \             ------ expected `String` because of return type\n...\n21 |     last_postfix\n\
    \   |     ^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rust"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut prefix_palindrome = string.clone();\n\n    if prefix_palindrome.len()\
    \ < 2 {\n        prefix_palindrome.push('a');\n    }\n\n    let suffix_palindrome\
    \ = prefix_palindrome.rev();\n    if suffix_palindrome.len() < 2 {\n        suffix_palindrome.push('a');\n\
    \    }\n\n    let postfix_palindrome = suffix_palindrome.rev();\n    if postfix_palindrome.len()\
    \ < 2 {\n        postfix_palindrome.push('a');\n    }\n\n    String::from(prefix_palindrome\
    \ + &postfix_palindrome)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpv5o4dw3w.rs:18:47\n\
    \    |\n18  |       let suffix_palindrome = prefix_palindrome.rev();\n    |  \
    \                                               ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut max_length = 0;\n    let mut prefix_length = 0;\n    let mut suffix_length\
    \ = 0;\n    for (i, c) in string.chars().enumerate() {\n        if i >= string.len()\
    \ / 2 {\n            break;\n        }\n        let pre_len = (string.chars()[prefix_length..i].count()\
    \ - 1) * 2;\n        let post_len = (string.chars()[i..suffix_length].count()\
    \ - 1) * 2;\n        let mut length = min(pre_len, post_len);\n        if length\
    \ > max_length {\n            max_length = length;\n            prefix_length\
    \ = i;\n            suffix_length = i + length;\n        }\n    }\n    string\n\
    \        .chars()\n        .clone()\n        .skip(prefix_length - 1)\n      \
    \  .rev()\n        .chain(string.chars().skip(suffix_length + 1))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp1k5gv4lr.rs:21:26\n\
    \   |\n21 |         let mut length = min(pre_len, post_len);\n   |           \
    \               ^^^\n...\n37 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    21 |         let mut length = main(pre_len, post_len);\n   |                 \
    \         ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp1k5gv4lr.rs:19:24\n\
    \   |\n19 |         let pre_len = (string.chars()[prefix_length..i].count() -\
    \ 1) * 2;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp1k5gv4lr.rs:20:25\n\
    \   |\n20 |         let post_len = (string.chars()[i..suffix_length].count() -\
    \ 1) * 2;\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmp1k5gv4lr.rs:32:10\n\
    \     |\n32   |         .rev()\n     |          ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Skip<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]: the\
    \ method `chain` exists for struct `Rev<Skip<Chars<'_>>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp1k5gv4lr.rs:33:10\n   |\n33 |            .chain(string.chars().skip(suffix_length\
    \ + 1))\n   |             ^^^^^ method cannot be called on `Rev<Skip<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not sati"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    debug!(\"Making palindrome for {}\", string);\n\n    let mut string = string.clone();\n\
    \    let mut reversed_string = string.clone();\n    let mut palindrome = String::from(\"\
    \");\n\n    // For every letter of the supplied string:\n    // 1. Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // 2. Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    for letter in string.chars() {\n        debug!(\"Letter is {}\", letter);\n\
    \n        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        let palindrome_end = longest_palindrome(&mut string, &letter);\n\n  \
    \      // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        string.push_str(&reversed_string[..palindrome_end]);\n\
    \        string.push_str(&letter);\n        reversed_string.push_reverse(&letter);\n\
    \    }\n\n    debug!(\"{} is palindrome\", string);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmp5d0mu_9l.rs:12:5\n\
    \   |\n12 |     debug!(\"Making palindrome for {}\", string);\n   |     ^^^^^\n\
    \nerror: cannot find macro `debug` in this scope\n  --> /tmp/tmp5d0mu_9l.rs:22:9\n\
    \   |\n22 |         debug!(\"Letter is {}\", letter);\n   |         ^^^^^\n\n\
    error: cannot find macro `debug` in this scope\n  --> /tmp/tmp5d0mu_9l.rs:33:5\n\
    \   |\n33 |     debug!(\"{} is palindrome\", string);\n   |     ^^^^^\n\nerror[E0425]:\
    \ cannot find function `longest_palindrome` in this scope\n  --> /tmp/tmp5d0mu_9l.rs:25:30\n\
    \   |\n25 |         let palindrome_end = longest_palindrome(&mut string, &letter);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5d0mu_9l.rs:29:25\n   |\n29 |\
    \         string.push_str(&letter);\n   |                         ^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0599]: no method named `push_reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp5d0mu_9l.rs:30:25\n\
    \   |\n30 |         reversed_string.push_reverse(&letter);\n   |             \
    \            ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push_str`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    fn palindrome_prefix(string: String) -> String {\n        let mut iter =\
    \ string.rbegin();\n        let mut prefix = iter.clone();\n        while let\
    \ Some(chr) = iter.next() {\n            if chr != iter.peek() {\n           \
    \     break;\n            }\n            iter.rev();\n            prefix.push(*iter);\n\
    \        }\n        prefix\n    }\n\n    fn palindrome_suffix(string: String)\
    \ -> String {\n        let mut iter = string.rbegin();\n        let mut suffix\
    \ = iter.clone();\n        while let Some(chr) = iter.next() {\n            if\
    \ chr != iter.peek() {\n                break;\n            }\n            iter.rev();\n\
    \            suffix.push(*iter);\n        }\n        suffix\n    }\n\n    fn is_palindrome(string:\
    \ String) -> bool {\n        let suffix = palindrome_suffix(string);\n       \
    \ let prefix = palindrome_prefix(string);\n        suffix.iter() == prefix.iter()\n\
    \    }\n\n    string\n        .split_whitespace()\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .filter(|&chr| chr != string.chars().last().unwrap())\n\
    \        .filter_map(is_palindrome)\n        .next()\n        .unwrap()\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmpwzc503u2.rs:48:28\n\
    \   |\n48 |         .filter(|&chr| chr != string.chars().last().unwrap())\n  \
    \ |                            ^^ no implementation for `&&str == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&&str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0631]: type mismatch\
    \ in function arguments\n   --> /tmp/tmpwzc503u2.rs:49:21\n    |\n38  |     fn\
    \ is_palindrome(string: String) -> bool {\n    |     ----------------------------------------\
    \ found signature of `fn(String) -> _`\n...\n49  |         .filter_map(is_palindrome)\n\
    \    |          ---------- ^^^^^^^^^^^^^ expected signature of `fn(&&str) -> _`\n\
    \    |          |\n    |          required by a bound introduced by this call\n\
    \    |\nnote: required by a bound in `filter_map`\n\nerror[E0599]: the method\
    \ `next` exists for struct `FilterMap<Filter<std::slice::Iter<'_, &str>, [closure@/tmp/tmpwzc503u2.rs:48:17:\
    \ 48:61]>, fn(String) -> bool {is_palindrome}>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpwzc503u2.rs:50:10\n   |\n50 |           .next()\n \
    \  |            ^^^^ method cannot be called on `FilterMap<Filter<std::slice::Iter<'_,\
    \ &str>, [closure@/tmp/tmpwzc503u2.rs:48:17: 48:61]>, fn(String) -> bool {is_palindrome}>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<fn(String) -> bool {is_palindrome} as FnOnce<(&&str,)>>::Output\
    \ = Option<_>`\n           which is required by `FilterMap<Filter<std::slice::Iter<'_,\
    \ &str>, [closure@/tmp/tmpwzc503u2.rs:48:17: 48:61]>, fn(String) -> bool {is_palindrome}>:\
    \ Iterator`\n         "
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut iter_palindrome = iter(string);\n    let mut reverse_suffix = [0u8;\
    \ string.len()];\n    let mut reverse_prefix = [0u8; string.len()];\n\n    reverse_prefix.copy_from_slice(&iter_palindrome.next());\n\
    \    reverse_suffix.copy_from_slice(&iter_palindrome.next());\n\n    for length\
    \ in 0..string.len() {\n        let mut reverse_prefix_slice = [0u8; string.len()\
    \ + 1];\n        reverse_prefix_slice.copy_from_slice(&reverse_prefix);\n    \
    \    reverse_prefix_slice[length..].copy_from_slice(&string);\n        let mut\
    \ reverse_remainder = [0u8; string.len() + 1];\n        reverse_remainder.copy_from_slice(&reverse_suffix);\n\
    \        reverse_remainder[length..].copy_from_slice(&string);\n\n        let\
    \ (prefix_slice, remainder_slice) = make_palindrome(String::from_utf8(reverse_prefix_slice));\n\
    \        let (reverse_remainder_slice, reverse_suffix_slice) = make_palindrome(String::from_utf8(reverse_remainder));\n\
    \n        if prefix_slice.iter().next().is_some() && remainder_slice.iter().next().is_some()\
    \ && reverse_suffix_slice.iter().next().is_some() {\n            let mut new_suffix\
    \ = String::from_utf8(reverse_suffix_slice);\n            new_suffix += reverse_suffix;\n\
    \            let mut new_prefix = String::from_utf8(reverse_prefix_slice);\n \
    \           new_prefix += reverse_prefix;\n            new_prefix += prefix_slice;\n\
    \            new_suffix += remainder_slice;\n            new_suffix += reverse_remainder_slice;\n\
    \            return new_prefix;\n        }\n    }\n    \"\".to_string()\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpnr4vxw3m.rs:13:36\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |                    ------ this would need to be a `const`\n12\
    \ |     let mut iter_palindrome = iter(string);\n13 |     let mut reverse_suffix\
    \ = [0u8; string.len()];\n   |                                    ^^^^^^\n\nerror[E0435]:\
    \ attempt to use a non-constant value in a constant\n  --> /tmp/tmpnr4vxw3m.rs:14:36\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ this would need to be a `const`\n...\n14 |     let mut reverse_prefix\
    \ = [0u8; string.len()];\n   |                                    ^^^^^^\n\nerror[E0435]:\
    \ attempt to use a non-constant value in a constant\n  --> /tmp/tmpnr4vxw3m.rs:20:46\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ this would need to be a `const`\n...\n20 |         let mut reverse_prefix_slice\
    \ = [0u8; string.len() + 1];\n   |                                           \
    \   ^^^^^^\n\nerror[E0435]: attempt to use a non-constant value in a constant\n\
    \  --> /tmp/tmpnr4vxw3m.rs:23:43\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                    ------ this would need to be a `const`\n\
    ...\n23 |         let mut reverse_remainder = [0u8; string.len() + 1];\n   | \
    \                                          ^^^^^^\n\nerror[E0425]: cannot find\
    \ function `iter` in this scope\n  --> /tmp/tmpnr4vxw3m.rs:12:31\n   |\n12 | \
    \    let mut iter_palindrome = iter(string);\n   |                           \
    \    ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnr4vxw3m.rs:22:56\n\
    \   |\n22 |         reverse_prefix_slice[length..].copy_from_slice(&string);\n\
    \   |                                                        ^^^^^^^ expected\
    \ slice `[u8]`, found struct `String`\n   |\n   = note: expected reference `&[u8]`\n\
    \              found reference `&String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpnr4vxw3m.rs:25:53\n   |\n25 |         reverse_remainder[length..].copy_from_slice(&s"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = String::from(\"\");\n\n    for char in &string {\n    \
    \    if char == char.as_str().rev().unwrap() {\n            reverse.push_str(&char);\n\
    \        }\n    }\n\n    reverse.push_str(&string);\n    reverse\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpnrefqx91.rs:14:17\n\
    \   |\n14 |     for char in &string {\n   |                 ^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    // TODO: Find a faster way to solve this.\n    // It seems like we need to\
    \ do a full search for each letter that comes after any letter in the string\n\
    \    // which makes the algorithm O(n^2).\n    // This is not ideal because if\
    \ the string is an exact palindromic palindrome, it takes O(n).\n\n    // The\
    \ palindrome should always start with the supplied string.\n    // So we start\
    \ by finding all the letters in the string that do not come before any letter\
    \ that comes after any letter in the string.\n    // For example, suppose we have\
    \ \"ab\" as an input string. We know that \"ab\" is not a palindrome\n    // because\
    \ if we start with \"ab\", we can't match \"a\" and \"b\" because it comes after\
    \ 'a' in the string.\n    // So we match \"a\" with \"\", \"b\" with \"a\" and\
    \ so on.\n    //\n    // Since \"ab\" is not a palindrome but \"a\" is a palindrome,\
    \ we can safely start with \"a\" as the initial string.\n    let mut string =\
    \ string;\n    let mut letters_to_check = [String::from(\"a\")];\n    while letters_to_check.len()\
    \ > 0 {\n        let mut letters_to_check = [String::from(\"\")];\n        for\
    \ (index, letter) in string.chars().enumerate() {\n            if letters_to_check.len()\
    \ > 0 && letters_to_check[0].starts_with(letter) {\n                letters_to_check[0]\
    \ = letter;\n            } else {\n                letters_to_check.push(letter);\n\
    \            }\n        }\n        string = &string[letters_to_check.len()];\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4hhdjibv.rs:30:39\n   |\n\
    30 |                 letters_to_check[0] = letter;\n   |                 -------------------\
    \   ^^^^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \         |                     |\n   |                 |                    \
    \ expected struct `String`, found `char`\n   |                 expected due to\
    \ the type of this binding\n\nerror[E0599]: no method named `push` found for array\
    \ `[String; 1]` in the current scope\n  --> /tmp/tmp4hhdjibv.rs:32:34\n   |\n\
    32 |                 letters_to_check.push(letter);\n   |                    \
    \              ^^^^ method not found in `[String; 1]`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp4hhdjibv.rs:35:19\n   |\n\
    35 |         string = &string[letters_to_check.len()];\n   |                 \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4hhdjibv.rs:35:18\n   |\n24 |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    35 |         string = &string[letters_to_check.len()];\n   |                 \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    help: consider removing the borrow\n   |\n35 -         string = &string[letters_to_check.len()];\n\
    35 +         string = string[letters_to_check.len()];\n   | \n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more inf"
  stdout: ''
  timestamp: 1659976840
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut suffix = \"_\";\n\n    for c in string.chars() {\n        if c.is_lower()\
    \ {\n            suffix = format!(\"{}{}\", c, suffix);\n        } else {\n  \
    \          suffix = format!(\"{}{}\", suffix.to_lowercase(), c);\n        }\n\
    \    }\n\n    if let Some(suffix) = suffix.split('.') {\n        // Prefix is\
    \ longer than suffix. Reverse suffix.\n        let mut reverse = suffix[..].reverse();\n\
    \n        // Prefix is longer than suffix. Add reverse to the postfix of prefix.\n\
    \        let prefix = &string[..suffix.len()].iter().rev().take(suffix.len() -\
    \ reverse.len());\n\n        if reverse == prefix {\n            return string;\n\
    \        }\n    }\n\n    // Prefix is equal to suffix.\n    suffix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lower` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbuk_5qki.rs:15:14\n   |\n15 |         if c.is_lower() {\n\
    \   |              ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuk_5qki.rs:16:22\n\
    \   |\n16 |             suffix = format!(\"{}{}\", c, suffix);\n   |         \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbuk_5qki.rs:18:22\n   |\n18 |             suffix = format!(\"{}{}\"\
    , suffix.to_lowercase(), c);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuk_5qki.rs:22:12\n \
    \  |\n22 |     if let Some(suffix) = suffix.split('.') {\n   |            ^^^^^^^^^^^^\
    \   ----------------- this expression has type `std::str::Split<'_, char>`\n \
    \  |            |\n   |            expected struct `std::str::Split`, found enum\
    \ `Option`\n   |\n   = note: expected struct `std::str::Split<'_, char>`\n   \
    \             found enum `Option<_>`\n\nerror[E0599]: no method named `iter` found\
    \ for type `str` in the current scope\n  --> /tmp/tmpbuk_5qki.rs:27:46\n   |\n\
    27 |         let prefix = &string[..suffix.len()].iter().rev().take(suffix.len()\
    \ - reverse.len());\n   |                                              ^^^^ method\
    \ not found in `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuk_5qki.rs:35:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    35 |     suffix\n   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to"
  stdout: ''
  timestamp: 1659976840
