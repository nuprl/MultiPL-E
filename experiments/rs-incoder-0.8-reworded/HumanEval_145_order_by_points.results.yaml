language: rs
name: HumanEval_145_order_by_points
results:
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_vec = vec![];\n    for idx in 0..nums.len() {\n        let mut i = idx;\n\
    \        let mut tmp = 0;\n        while i >= 0 && nums[i] > tmp {\n         \
    \   i -= 1;\n        }\n        let j = idx;\n        while j < nums.len() &&\
    \ nums[j] < tmp {\n            j += 1;\n        }\n        if j > i {\n      \
    \      sorted_vec.push(nums[i]);\n            sorted_vec.push(nums[j]);\n    \
    \    }\n    }\n    sorted_vec\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpimilrc7i.rs:14:13\n\
    \   |\n14 |         let mut tmp = 0;\n   |             ----^^^\n   |         \
    \    |\n   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign twice to immutable variable `j`\n\
    \  --> /tmp/tmpimilrc7i.rs:20:13\n   |\n18 |         let j = idx;\n   |      \
    \       -\n   |             |\n   |             first assignment to `j`\n   |\
    \             help: consider making this binding mutable: `mut j`\n19 |      \
    \   while j < nums.len() && nums[j] < tmp {\n20 |             j += 1;\n   |  \
    \           ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_vec = nums.clone();\n    let mut sum_of_digits = vec![];\n\n    for i\
    \ in sorted_vec.iter() {\n        sum_of_digits.push(*i / 10);\n        *i /=\
    \ 10;\n    }\n    \n    sum_of_digits.sort_unstable();\n    sorted_vec.sort_unstable();\n\
    \    \n    for i in sorted_vec.iter() {\n        sorted_vec[i] = sum_of_digits[*i];\n\
    \    }\n    \n    return sorted_vec;\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt1kh3bf7.rs:23:9\n\
    \   |\n23 |         sorted_vec[i] = sum_of_digits[*i];\n   |         ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpt1kh3bf7.rs:23:25\n\
    \   |\n23 |         sorted_vec[i] = sum_of_digits[*i];\n   |                 \
    \        ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 101
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum = nums.iter().sum();\n    let mut v = Vec::<isize>::with_capacity(nums.len());\n\
    \    let mut index = 0;\n    let mut done = false;\n    while !done {\n      \
    \  let i = index / 10;\n        let j = index - i * 10;\n        if i != sum {\n\
    \            v.push(i);\n            sum += i;\n        } else {\n           \
    \ v.push(j);\n            sum += j;\n            done = true;\n        }\n   \
    \     index += 1;\n    }\n    v.reverse();\n    v\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`,\n right:\
    \ `[-1, -11, 1, -12, 11]`', /tmp/tmpxo5okbmp.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result: Vec<isize> = Vec::with_capacity(nums.len());\n    let mut index = 0;\n\
    \    for n in nums {\n        if n == 0 {\n            result[index] = 0;\n  \
    \      } else if n < 0 {\n            result[index] = -1;\n        } else {\n\
    \            let mut sum_of_digits = 0;\n            while n >= 10 {\n       \
    \         sum_of_digits += n % 10;\n                n /= 10;\n            }\n\
    \            result[index] = sum_of_digits;\n            index +=1;\n        }\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmp0xpc0gms.rs:22:17\n\
    \   |\n13 |     for n in nums {\n   |         -\n   |         |\n   |        \
    \ first assignment to `n`\n   |         help: consider making this binding mutable:\
    \ `mut n`\n...\n22 |                 n /= 10;\n   |                 ^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_iter = nums.iter();\n    let mut nums_sum: isize = 0;\n    let mut nums_sum_map:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut sorted_nums = nums.clone();\n\
    \n    while nums_iter.any(|n| n == nums_sum) {\n        nums_sum += *nums_iter.next();\n\
    \        nums_sum_map.insert(nums_sum, nums_iter.index());\n    }\n\n    sorted_nums.sort_by_key(|&x|\
    \ {\n        nums_sum_map.get(&x).unwrap_or(nums_sum)\n    });\n\n    sorted_nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpzsuwu8ig.rs:13:27\n\
    \   |\n13 |     let mut nums_sum_map: HashMap<isize, isize> = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpzsuwu8ig.rs:13:51\n\
    \   |\n13 |     let mut nums_sum_map: HashMap<isize, isize> = HashMap::new();\n\
    \   |                                                   ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpzsuwu8ig.rs:16:31\n\
    \   |\n16 |     while nums_iter.any(|n| n == nums_sum) {\n   |               \
    \                ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpzsuwu8ig.rs:17:21\n\
    \   |\n17 |         nums_sum += *nums_iter.next();\n   |                     ^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `index` found for struct `std::slice::Iter` in\
    \ the current scope\n  --> /tmp/tmpzsuwu8ig.rs:18:49\n   |\n18 |         nums_sum_map.insert(nums_sum,\
    \ nums_iter.index());\n   |                                                 ^^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0412, E0433,\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = nums.clone();\n    let mut totals = vec![];\n\n    for n in sorted_nums.iter()\
    \ {\n        totals.push(n as isize);\n    }\n\n    sorted_nums.sort_unstable_by_key(|n|\
    \ {\n        let mut total_sum = 0;\n        for d in totals.iter() {\n      \
    \      total_sum += d as isize;\n        }\n        total_sum - n\n    });\n\n\
    \    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp9fa4p8iq.rs:15:21\n\
    \   |\n15 |         totals.push(n as isize);\n   |                     -^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&isize` as\
    \ `isize`\n   |                     help: dereference the expression: `*n`\n\n\
    error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp9fa4p8iq.rs:21:26\n\
    \   |\n21 |             total_sum += d as isize;\n   |                       \
    \   -^^^^^^^^^\n   |                          |\n   |                        \
    \  cannot cast `&isize` as `isize`\n   |                          help: dereference\
    \ the expression: `*d`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by_key(|x|\
    \ x.checked_digit().unwrap());\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_digit` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpjcge8mcu.rs:11:37\n   |\n11 |     nums.sort_unstable_by_key(|x|\
    \ x.checked_digit().unwrap());\n   |                                     ^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `checked_div`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // TODO:\
    \ use better data structure, e.g. use BTreeMap instead of Vec to keep track of\
    \ sums\n    let mut sums: Vec<isize> = nums.into_iter().map(|x| x + x).collect();\n\
    \    sums.sort_unstable_by(|a, b| {\n        match a.cmp(&b) {\n            Ordering::Less\
    \ => -1,\n            Ordering::Greater => 1,\n            _ => 0,\n        }\n\
    \    });\n    sums.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmppphtru_c.rs:15:13\n   |\n15 |             Ordering::Less => -1,\n  \
    \ |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmppphtru_c.rs:16:13\n\
    \   |\n16 |             Ordering::Greater => 1,\n   |             ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppphtru_c.rs:15:31\n\
    \   |\n15 |             Ordering::Less => -1,\n   |                          \
    \     ^^ expected enum `std::cmp::Ordering`, found integer\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // To keep\
    \ track of indices whose sum are equal\n    let mut index = vec![0; nums.len()];\n\
    \    // To keep track of indices of identical sums\n    let mut index_duplicate\
    \ = vec![0; nums.len()];\n    // Keep track of the sum of digits of nums\n   \
    \ let mut sum_of_digits = vec![0; nums.len()];\n    // For each num in nums vector\n\
    \    for i in 0..nums.len() {\n        // Accumulated sum\n        let accumulated_sum\
    \ = 0;\n        // The ith digit in nums\n        let digit = nums[i] as usize;\n\
    \        // For each index\n        for j in 0..nums.len() {\n            // If\
    \ the ith digit in nums is equal to the jth digit in nums,\n            // then\
    \ sum the two sums\n            if digit == nums[j] {\n                // Sum\
    \ of digit so far\n                accumulated_sum += sum_of_digits[j];\n    \
    \            // The ith index\n                index[i] = j;\n               \
    \ // The jth index\n                index_duplicate[j] = i;\n                //\
    \ The ith sum\n                sum_of_digits[i] = accumulated_sum;\n         \
    \       break;\n            }\n        }\n    }\n    // Sort the nums vector based\
    \ on index\n    nums.iter().cloned().sort_by_key(|i| {\n        // Get the ith\
    \ index in nums\n        let index = index[i];\n        // Get the ith sum\n \
    \       let sum = sum_of_digits[index];\n        // Get the ith digit\n      \
    \  let digit = nums[index];\n        // Calculate the ith digit - sum\n      \
    \  let result = digit - sum;\n        // If result is not zero, return result\
    \ as sort key\n        result\n    })\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxyql1w17.rs:27:25\n   |\n\
    27 |             if digit == nums[j] {\n   |                         ^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n27 |             if digit\
    \ == nums[j].try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpxyql1w17.rs:41:26\n   |\n41 |     nums.iter().cloned().sort_by_key(|i|\
    \ {\n   |                          ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        let mut num_map = HashMap::new();\n \
    \       for num in nums.iter() {\n            let mut sum = 0;\n            while\
    \ num > 0 {\n                sum += *num % 10;\n                num /= 10;\n \
    \           }\n            num_map.insert(sum, num);\n        }\n        let mut\
    \ sorted_nums = vec![];\n        for (i, (sum, num)) in num_map.iter().enumerate()\
    \ {\n            sorted_nums.push(*num);\n            if i < nums.len() - 1 {\n\
    \                sorted_nums.push(*(sum + num_map[i + 1]));\n            }\n \
    \       }\n        sorted_nums\n    }\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5zgdcp5j.rs:14:27\n   |\n14 |         let mut num_map = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5zgdcp5j.rs:17:25\n   |\n17 |             while\
    \ num > 0 {\n   |                         ^\n   |                         |\n\
    \   |                         expected `&isize`, found integer\n   |         \
    \                help: consider borrowing here: `&0`\n\nerror[E0368]: binary assignment\
    \ operation `/=` cannot be applied to type `&isize`\n  --> /tmp/tmp5zgdcp5j.rs:19:17\n\
    \   |\n19 |                 num /= 10;\n   |                 ---^^^^^^\n   | \
    \                |\n   |                 cannot use `/=` on type `&isize`\n  \
    \ |\nhelp: `/=` can be used on `isize`, you can dereference `num`\n   |\n19 |\
    \                 *num /= 10;\n   |                 +\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .map(|x| x.to_digit())\n        .group_by(|&x| x)\n \
    \       .rfold(vec![], |mut acc1, &(mut acc2, x)| {\n            acc2.push(x.to_digit());\n\
    \            acc1.sort_by(|a, b| b.partial_cmp(&a.0).unwrap());\n            acc2\n\
    \        })\n        .flatten()\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpdqfppnz6.rs:13:20\n   |\n13 |         .map(|x|\
    \ x.to_digit())\n   |                    ^^^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `group_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpdqfppnz6.rs:14:10\n   |\n14 |         .group_by(|&x| x)\n\
    \   |          ^^^^^^^^ method not found in `Map<std::slice::Iter<'_, isize>,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums = nums;\n    let mut sum = nums.reduce(0, |s, i| s + i);\n    nums.sort();\n\
    \    nums.reverse();\n    nums.dedup();\n    nums.sort_by_key(|num| {\n      \
    \  sum -= num;\n        sum\n    });\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp4mp4jx6u.rs:12:24\n\
    \    |\n12  |       let mut sum = nums.reduce(0, |s, i| s + i);\n    |       \
    \                   ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by(|a,\
    \ b| sum_digits(a) - sum_digits(b));\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_digits` in this scope\n  --> /tmp/tmph0dq0dk5.rs:11:34\n\
    \   |\n11 |     nums.sort_unstable_by(|a, b| sum_digits(a) - sum_digits(b));\n\
    \   |                                  ^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `sum_digits` in this scope\n  --> /tmp/tmph0dq0dk5.rs:11:50\n\
    \   |\n11 |     nums.sort_unstable_by(|a, b| sum_digits(a) - sum_digits(b));\n\
    \   |                                                  ^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n\n    let mut nums_copy = nums.clone();\n\n\
    \    // calculate sum of digits in each element in nums\n    // and sort them\
    \ in descending order\n    for i in nums_copy.iter_mut() {\n        i.to_digits().iter().fold(i,\
    \ |t, c| t += c);\n    }\n    nums_copy.sort_by_key(|x| x.to_digits().iter().sum::<usize>().unwrap());\n\
    \n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for mutable reference `&mut\
    \ isize` in the current scope\n  --> /tmp/tmpy0s5zs4_.rs:20:11\n   |\n20 |   \
    \      i.to_digits().iter().fold(i, |t, c| t += c);\n   |           ^^^^^^^^^\
    \ method not found in `&mut isize`\n\nerror[E0599]: no method named `to_digits`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpy0s5zs4_.rs:22:33\n\
    \   |\n22 |     nums_copy.sort_by_key(|x| x.to_digits().iter().sum::<usize>().unwrap());\n\
    \   |                                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ total_points = nums.iter().fold(0, |a, b| a + b);\n    let mut nums_copy = nums.clone();\n\
    \    sort_by_sum(&mut nums_copy, &mut total_points);\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_by_sum` in this scope\n  --> /tmp/tmplm5lr8k5.rs:13:5\n\
    \   |\n13 |     sort_by_sum(&mut nums_copy, &mut total_points);\n   |     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .cloned()\n        .filter(|&x| x > 0)\n        .cloned()\n\
    \        .sort_unstable_by_key(|x| {\n            x.to_string().chars().filter(|&x|\
    \ **x == '-').count()\n                + x.to_string().chars().filter(|&x| **x\
    \ == '+').count()\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n  --> /tmp/tmpjlvo8hz9.rs:15:10\n   |\n15 |       \
    \  .cloned()\n   |          ^^^^^^ expected reference, found `isize`\n   |\n \
    \  = note: expected reference `&&_`\n              found reference `&isize`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\n   = note: 1 redundant requirement hidden\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpjlvo8hz9.rs:14:17:\
    \ 14:27]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmpjlvo8hz9.rs:15:10\n\
    \   |\n14 |         .filter(|&x| x > 0)\n   |                 ---------- found\
    \ signature of `for<'r> fn(&'r isize) -> _`\n15 |         .cloned()\n   |    \
    \      ^^^^^^ expected signature of `for<'r> fn(&'r &_) -> _`\n   |\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpjlvo8hz9.rs:14:17: 14:27]>`\n\nerror[E0599]: no method\
    \ named `sort_unstable_by_key` found for struct `Cloned` in the current scope\n\
    \  --> /tmp/tmpjlvo8hz9.rs:16:10\n   |\n16 |         .sort_unstable_by_key(|x|\
    \ {\n   |          ^^^^^^^^^^^^^^^^^^^^ method not found in `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpjlvo8hz9.rs:14:17: 14:27]>>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0599,\
    \ E0631.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .cloned()\n        .sort_by(|x, y| {\n            let\
    \ mut sum = 0;\n            for (i, &x) in nums.iter().enumerate() {\n       \
    \         let y = nums.iter().skip(i + 1).fold(0, |sum, x| sum + x);\n       \
    \         if y > x {\n                    return y - x;\n                }\n \
    \               sum += x;\n            }\n            sum\n        })\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpjn578vao.rs:14:10\n   |\n14 |         .sort_by(|x,\
    \ y| {\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = nums.clone();\n    sorted_nums.sort();\n\n    let mut sorted_sums\
    \ = nums.clone();\n    sorted_sums.sort_by_key(|x| x.to_digit());\n\n    for &num\
    \ in sorted_sums {\n        sorted_nums.insert(nums.iter().position(|n| n == num).unwrap(),\
    \ num);\n    }\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmprsjso_kq.rs:15:35\n   |\n15 |     sorted_sums.sort_by_key(|x|\
    \ x.to_digit());\n   |                                   ^^^^^^^^ method not found\
    \ in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprsjso_kq.rs:17:9\n\
    \   |\n17 |     for &num in sorted_sums {\n   |         ^^^^    ----------- this\
    \ expression has type `Option<isize>`\n   |         |\n   |         expected `isize`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `num`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmprsjso_kq.rs:18:55\n\
    \   |\n18 |         sorted_nums.insert(nums.iter().position(|n| n == num).unwrap(),\
    \ num);\n   |                                                       ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ res = nums.clone();\n    let mut sum_of_digits = Vec::new();\n    for &num in\
    \ nums {\n        let mut cur_sum = 0;\n        for digit in num {\n         \
    \   cur_sum += digit;\n        }\n        sum_of_digits.push(cur_sum);\n    }\n\
    \    sum_of_digits.sort();\n    for &sum in sum_of_digits {\n        let mut idx\
    \ = -1;\n        for &num in nums {\n            if sum == num {\n           \
    \     idx = nums.iter().position(|&num| num == sum).unwrap();\n            }\n\
    \        }\n        if idx > -1 {\n            res[idx] = sum;\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6xmn95ci.rs:13:9\n   |\n\
    13 |     for &num in nums {\n   |         ^^^^    ---- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6xmn95ci.rs:21:9\n   |\n21 |     for &sum in\
    \ sum_of_digits {\n   |         ^^^^    ------------- this expression has type\
    \ `Option<{integer}>`\n   |         |\n   |         expected integer, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `sum`\n   |\n\
    \   = note:   expected type `{integer}`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6xmn95ci.rs:23:13\n   |\n23 |         for &num\
    \ in nums {\n   |             ^^^^    ---- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp6xmn95ci.rs:22:23\n\
    \   |\n22 |         let mut idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmp6xmn95ci.rs:28:18\n   |\n28 |  \
    \       if idx > -1 {\n   |                  ^^\n   |                  |\n   |\
    \                  cannot apply unary operator `-`\n   |                  help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, "
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .sort((|(n1, _1), (n2, _2)| n1.checked_add(n2)\
    \ as Ordering))\n        .map(|(n, _)| *n)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Ordering` in this scope\n  --> /tmp/tmp_x4843wz.rs:14:59\n\
    \   |\n14 |         .sort((|(n1, _1), (n2, _2)| n1.checked_add(n2) as Ordering))\n\
    \   |                                                           ^^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::cmp::Ordering;\n   |\n1  | use std::sync::atomic::Ordering;\n   |\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmp_x4843wz.rs:14:15\n\
    \   |\n14 |         .sort((|(n1, _1), (n2, _2)| n1.checked_add(n2) as Ordering))\n\
    \   |               ^                                                   ^\n  \
    \ |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n14 -         .sort((|(n1, _1), (n2, _2)| n1.checked_add(n2) as Ordering))\n\
    14 +         .sort(|(n1, _1), (n2, _2)| n1.checked_add(n2) as Ordering)\n   |\
    \ \n\nerror[E0599]: no method named `sort` found for struct `Enumerate` in the\
    \ current scope\n  --> /tmp/tmp_x4843wz.rs:14:10\n   |\n14 |         .sort((|(n1,\
    \ _1), (n2, _2)| n1.checked_add(n2) as Ordering))\n   |          ^^^^ method not\
    \ found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to\
    \ 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums;\n    let mut total_sum = 0;\n    for num in nums_copy {\n\
    \        total_sum += num;\n    }\n    nums_copy.sort_by_key(|num| {\n       \
    \ let mut digits = 0;\n        while num > 0 {\n            digits = num % 10;\n\
    \            num = num / 10;\n        }\n        total_sum - digits;\n    });\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjl38rnpk.rs:18:21\n   |\n\
    18 |         while num > 0 {\n   |                     ^\n   |               \
    \      |\n   |                     expected `&isize`, found integer\n   |    \
    \                 help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjl38rnpk.rs:20:19\n   |\n16 |     nums_copy.sort_by_key(|num|\
    \ {\n   |                            --- expected due to this parameter type\n\
    ...\n20 |             num = num / 10;\n   |                   ^^^^^^^^\n   | \
    \                  |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&(num / 10)`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    fn helper(mut\
    \ nums: Vec<isize>, sum: usize, i: usize, index: usize) -> Vec<isize> {\n    \
    \    if nums[i] + nums[index] >= sum {\n            nums[i] = nums[i] + nums[index];\n\
    \            nums[i] = nums[i] as isize;\n            nums[index] = nums[index]\
    \ as isize;\n        }\n        nums[index] += nums[i];\n        nums[i] = nums[index]\
    \ as isize;\n        nums[index] += nums[i];\n        return nums[index] as Vec<isize>;\n\
    \    }\n    if nums.is_empty() {\n        return nums;\n    }\n    let mut sum_\
    \ = 0;\n    for i in 0..nums.len() {\n        sum_ += nums[i] as usize;\n    }\n\
    \    let mut sorted_vec: Vec<isize> = vec![];\n    for i in 0..nums.len() {\n\
    \        sorted_vec = helper(nums, sum_, i, i);\n    }\n    sorted_vec\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjrol7_63.rs:12:37\n   |\n\
    12 |         if nums[i] + nums[index] >= sum {\n   |                         \
    \            ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    12 |         if nums[i] + nums[index] >= sum.try_into().unwrap() {\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0605]: non-primitive\
    \ cast: `isize` as `Vec<isize>`\n  --> /tmp/tmpjrol7_63.rs:20:16\n   |\n20 | \
    \        return nums[index] as Vec<isize>;\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .sort_by(|(i, e)| {\n         \
    \   if let Some(pos) = nums.iter().position(|e| e == *e) {\n                Some(*pos)\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .map(|(i, e)| i)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp89jl9yxk.rs:14:10\n   |\n14 |         .sort_by(|(i,\
    \ e)| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp89jl9yxk.rs:15:59\n\
    \   |\n15 |             if let Some(pos) = nums.iter().position(|e| e == *e) {\n\
    \   |                                                           ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0614]: type `usize` cannot be\
    \ dereferenced\n  --> /tmp/tmp89jl9yxk.rs:16:22\n   |\n16 |                 Some(*pos)\n\
    \   |                      ^^^^\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Sort\
    \ by sum of its digits\n    vec![nums[0]].iter().cloned().chain(\n        nums\n\
    \            .iter()\n            .enumerate()\n            .map(|(i, &v)| {\n\
    \                if v < 0 {\n                    if v == 0 {\n               \
    \         vec![i]\n                    } else {\n                        vec![i]\
    \ + (-i * v)\n                    }\n                } else {\n              \
    \      vec![i] + (v % 10 + i * v)\n                }\n            })\n       \
    \     .collect(),\n    )\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp92_dj_pq.rs:21:36\n\
    \   |\n21 |                         vec![i] + (-i * v)\n   |                 \
    \                   ^^ cannot apply unary operator `-`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp92_dj_pq.rs:21:41\n\
    \   |\n21 |                         vec![i] + (-i * v)\n   |                 \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ multiply `usize` by `isize`\n  --> /tmp/tmp92_dj_pq.rs:21:39\n   |\n21 |   \
    \                      vec![i] + (-i * v)\n   |                              \
    \         ^ no implementation for `usize * isize`\n   |\n   = help: the trait\
    \ `Mul<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n    \
    \         <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n      \
    \       <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n          \
    \   <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a\
    \ isize as Mul<isize>>\n           and 49 others\n\nerror[E0369]: cannot add `usize`\
    \ to `Vec<usize>`\n  --> /tmp/tmp92_dj_pq.rs:21:33\n   |\n21 |               \
    \          vec![i] + (-i * v)\n   |                         ------- ^ --------\
    \ usize\n   |                         |\n   |                         Vec<usize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp92_dj_pq.rs:24:45\n   |\n24 |\
    \                     vec![i] + (v % 10 + i * v)\n   |                       \
    \                      ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ multiply `usize` by `isize`\n  --> /tmp/tmp92_dj_pq.rs:24:43\n   |\n24 |   \
    \                  vec![i] + (v % 10 + i * v)\n   |                          \
    \                 ^ no implementation for `usize * isize`\n   |\n   = help: the\
    \ trait `Mul<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 "
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .sorted()\n        .filter_map(|(i,\
    \ num)| {\n            if num % 10 == 0 {\n                Some(i - 1)\n     \
    \       } else {\n                None\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpduqzn6u3.rs:14:10\n   |\n14 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_map = nums.into_iter().cloned().collect::<HashMap<_, _>>();\n    for num\
    \ in nums {\n        let mut sum = 0;\n        for digit in num {\n          \
    \  sum += digit as isize;\n        }\n        nums_map.insert(sum, num);\n   \
    \ }\n    nums_map.into_iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp957u9zty.rs:11:60\n\
    \   |\n11 |     let mut nums_map = nums.into_iter().cloned().collect::<HashMap<_,\
    \ _>>();\n   |                                                            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0271]: type mismatch resolving\
    \ `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n    --> /tmp/tmp957u9zty.rs:11:41\n\
    \     |\n11   |     let mut nums_map = nums.into_iter().cloned().collect::<HashMap<_,\
    \ _>>();\n     |                                         ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected reference `&_`\n              \
    \       found type `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp957u9zty.rs:11:50\n \
    \  |\n11 |       let mut nums_map = nums.into_iter().cloned().collect::<HashMap<_,\
    \ _>>();\n   |                                                    ^^^^^^^ method\
    \ cannot be called on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<std::vec::IntoIter<isize> as Iterator>::Item = &_`\n           which\
    \ is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           which is required by `&mut Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n\nerror[E0277]: `isize` is not an iterator\n  --> /tmp/tmp957u9zty.rs:14:22\n\
    \   |\n14 |         for digit in num {\n   |                      ^^^ `isize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror: aborting due "
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum = nums.iter().map(|n| n % 10).sum::<isize>();\n    if sum == 0 {\n     \
    \   vec![]\n    } else {\n        nums\n            .iter()\n            .enumerate()\n\
    \            .filter(|(i, _)| nums[i] != 0)\n            .sort_by_key(|(_, ix)|\
    \ sum - nums[ix] as isize)\n            .map(|(_, ix)| ix as isize)\n        \
    \    .collect()\n    }\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&usize`\n  --> /tmp/tmpv8oxgum9.rs:18:30\n\
    \   |\n18 |             .filter(|(i, _)| nums[i] != 0)\n   |                 \
    \             ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&usize>` for `Vec<isize>`\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmpv8oxgum9.rs:19:14\n   |\n19 |             .sort_by_key(|(_,\
    \ ix)| sum - nums[ix] as isize)\n   |              ^^^^^^^^^^^ method not found\
    \ in `Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpv8oxgum9.rs:18:21:\
    \ 18:42]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Convert\
    \ each element to corresponding digit sum\n    let mut sums = Vec::with_capacity(nums.len());\n\
    \    for n in nums {\n        let mut sum_digits = 0;\n        while n > 0 {\n\
    \            sum_digits += n % 10;\n            n /= 10;\n        }\n        sums.push(sum_digits);\n\
    \    }\n\n    // Sort by sum\n    sums.sort_unstable_by_key(|n| {\n        //\
    \ Return the sum of digits in descending order\n        n % 10\n    });\n    //\
    \ Return original vector with sorted elements\n    nums\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpsrvg3f52.rs:17:13\n\
    \   |\n13 |     for n in nums {\n   |         -\n   |         |\n   |        \
    \ first assignment to `n`\n   |         help: consider making this binding mutable:\
    \ `mut n`\n...\n17 |             n /= 10;\n   |             ^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0382]: use of moved value: `nums`\n  \
    \ --> /tmp/tmpsrvg3f52.rs:28:5\n    |\n10  | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n    |                    ---- move occurs because `nums` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n13  |   \
    \  for n in nums {\n    |              ---- `nums` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28  |     nums\n    |     ^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n13  |     for n in &nums\
    \ {\n    |              +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0384.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = vec![];\n    for i in nums {\n        let digits = i.to_digits();\n\
    \        let mut sum = 0;\n        for d in &digits {\n            sum += *d;\n\
    \        }\n        result.push(i);\n        result.push(sum);\n    }\n    result.sort_unstable_by_key(|&(idx,\
    \ sum)| sum);\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpgr88ykpq.rs:13:24\n   |\n13 |         let digits\
    \ = i.to_digits();\n   |                        ^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgr88ykpq.rs:21:35\n\
    \   |\n21 |     result.sort_unstable_by_key(|&(idx, sum)| sum);\n   |        \
    \                           ^^^^^^^^^-\n   |                                 \
    \  |        |\n   |                                   |        expected due to\
    \ this\n   |                                   expected `isize`, found tuple\n\
    \   |\n   = note: expected type `isize`\n             found tuple `(_, _)`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums = nums.clone();\n    let mut max: usize = 0;\n\n    while nums.len() >\
    \ 0 {\n        // Find position of maximum sum\n        let max_idx = nums.iter().enumerate().max_by(|(_,\
    \ num), (idx, _)| {\n            if nums.len() == 0 {\n                false\n\
    \            } else if nums.last() <= num {\n                false\n         \
    \   } else if num < nums.last() {\n                true\n            } else {\n\
    \                num - nums.last()\n            }\n        }).1;\n\n        //\
    \ Get maximum sum value\n        let max_num = nums[max_idx];\n\n        // Remove\
    \ it from nums\n        nums.remove(max_idx);\n\n        // Find position of minimum\
    \ sum\n        let min_idx = nums.iter().enumerate().min_by(|(_, num), (idx, _)|\
    \ {\n            if nums.len() == 0 {\n                false\n            } else\
    \ if num < nums.last() {\n                false\n            } else if num - nums.last()\
    \ > 0 {\n                true\n            } else {\n                num - nums.last()\n\
    \            }\n        }).1;\n\n        // Add it to min\n        nums.push(nums[min_idx]\
    \ + max_num);\n    }\n\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmyj31_oc.rs:18:17\n   |\n\
    18 |                 false\n   |                 ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyj31_oc.rs:19:38\n\
    \   |\n19 |             } else if nums.last() <= num {\n   |                 \
    \                     ^^^ expected enum `Option`, found `&&isize`\n   |\n   =\
    \ note:   expected enum `Option<&isize>`\n           found reference `&&isize`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |             } else if\
    \ nums.last() <= Some(num) {\n   |                                      +++++\
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyj31_oc.rs:20:17\n   |\n\
    20 |                 false\n   |                 ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyj31_oc.rs:21:29\n\
    \   |\n21 |             } else if num < nums.last() {\n   |                  \
    \           ^^^^^^^^^^^ expected `&&isize`, found enum `Option`\n   |\n   = note:\
    \ expected reference `&&isize`\n                   found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmyj31_oc.rs:22:17\n   |\n22 |\
    \                 true\n   |                 ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0369]: cannot subtract `Option<&isize>` from `&&isize`\n\
    \  --> /tmp/tmpmyj31_oc.rs:24:21\n   |\n24 |                 num - nums.last()\n\
    \   |                 --- ^ ----------- Option<&isize>\n   |                 |\n\
    \   |                 &&isize\n\nerror[E0609]: no field `1` on type `Option<(usize,\
    \ &isize)>`\n  --> /tmp/tmpmyj31_oc.rs:26:12\n   |\n26 |         }).1;\n   | \
    \           ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyj31_oc.rs:37:17\n\
    \   |\n37 |                 false\n   |                 ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyj31_oc.rs:38:29\n\
    \   |\n38 |             } else if num < nums.last() {\n   |                  \
    \           ^^^^^^^^^^^ expected `&&isize`, found enum `Option`\n   |\n   = note:\
    \ expected reference `&&isize`"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Step\
    \ 1: Construct a map of sums by digits.\n    let mut digit_sums: HashMap<isize,\
    \ isize> = nums\n        .iter()\n        .map(|x| x.checked_digits())\n     \
    \   .fold(HashMap::new(), |mut sum, digits| {\n            sum.entry(digits[0])\n\
    \                .or_insert_with(|| 0)\n                += digits[1];\n      \
    \      sum\n        });\n\n    // Step 2: Sort by the sums.\n    nums.sort_by_key(|x|\
    \ {\n        digit_sums\n            .get(x.checked_digits())\n            .unwrap_or(0)\n\
    \    });\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpf06o10pm.rs:12:25\n\
    \   |\n12 |     let mut digit_sums: HashMap<isize, isize> = nums\n   |       \
    \                  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpf06o10pm.rs:15:15\n\
    \   |\n15 |         .fold(HashMap::new(), |mut sum, digits| {\n   |          \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]: no method named\
    \ `checked_digits` found for reference `&isize` in the current scope\n  --> /tmp/tmpf06o10pm.rs:14:20\n\
    \   |\n14 |         .map(|x| x.checked_digits())\n   |                    ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `checked_div`\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpf06o10pm.rs:18:17\n\
    \   |\n16 | /             sum.entry(digits[0])\n17 | |                 .or_insert_with(||\
    \ 0)\n   | |_____________________________________- cannot assign to this expression\n\
    18 |                   += digits[1];\n   |                   ^^\n\nerror[E0599]:\
    \ no method named `checked_digits` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpf06o10pm.rs:25:20\n   |\n25 |             .get(x.checked_digits())\n\
    \   |                    ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `checked_div`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0412, E0433, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Initialize\
    \ a map to store sum for each digit\n    let mut digit_sums = vec![0];\n    for\
    \ (idx, _) in nums.iter().enumerate() {\n        digit_sums += nums[idx].to_string().chars().collect();\n\
    \    }\n\n    // Sort using map data structure\n    let mut nums_sorted = vec![];\n\
    \    let mut last_sum = digit_sums[0];\n    for (idx, _) in nums.iter().enumerate()\
    \ {\n        let sum = digit_sums[idx] + nums[idx];\n        if sum > last_sum\
    \ {\n            nums_sorted += nums[idx];\n        } else {\n            let\
    \ mut i = idx;\n            while i > 0 && (digit_sums[i - 1] == sum) {\n    \
    \            nums_sorted += nums[i - 1];\n                i -= 1;\n          \
    \  }\n        }\n        last_sum = sum;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<{integer}>`\n  --> /tmp/tmpvmb717n4.rs:14:9\n   |\n14 |         digit_sums\
    \ += nums[idx].to_string().chars().collect();\n   |         ----------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `Vec<{integer}>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpvmb717n4.rs:23:13\n\
    \   |\n23 |             nums_sorted += nums[idx];\n   |             -----------^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpvmb717n4.rs:27:17\n\
    \   |\n27 |                 nums_sorted += nums[i - 1];\n   |                \
    \ -----------^^^^^^^^^^^^^^^\n   |                 |\n   |                 cannot\
    \ use `+=` on type `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .sort_by(|(idx, _), &x| x.checked_sub(x.digits_sum()).unwrap())\n\
    \        .map(|(_, x)| x)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmppag91089.rs:14:10\n   |\n14 |         .sort_by(|(idx,\
    \ _), &x| x.checked_sub(x.digits_sum()).unwrap())\n   |          ^^^^^^^ method\
    \ not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_vec = Vec::new();\n    let mut sorted_index = Vec::new();\n    for idx\
    \ in 0..nums.len() {\n        let current_sum = nums[idx].to_digits();\n     \
    \   sorted_vec.push(nums[idx]);\n        sorted_index.push(idx);\n        for\
    \ other_idx in 0..sorted_vec.len() {\n            let other_sum = sorted_vec[other_idx].to_digits();\n\
    \            if current_sum == other_sum {\n                sorted_vec[other_idx]\
    \ = nums[idx];\n                sorted_index.swap(idx, other_idx);\n         \
    \       break;\n            }\n        }\n    }\n    sorted_vec.sort_unstable();\n\
    \    sorted_index.sort_unstable();\n    sorted_vec.iter().zip(sorted_index.iter()).map(|(&x,\
    \ &y)| y).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpw5z72rcy.rs:14:37\n   |\n14 |         let current_sum\
    \ = nums[idx].to_digits();\n   |                                     ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `to_digits` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpw5z72rcy.rs:18:51\n   |\n\
    18 |             let other_sum = sorted_vec[other_idx].to_digits();\n   |    \
    \                                               ^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw5z72rcy.rs:28:5\n\
    \   |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                  ---------- expected `Vec<isize>` because of\
    \ return type\n...\n28 |     sorted_vec.iter().zip(sorted_index.iter()).map(|(&x,\
    \ &y)| y).collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    debug_assert!(nums.len()\
    \ > 0);\n\n    let mut nums_size = nums.len();\n\n    let mut nums_sum = nums.iter().sum::<usize>();\n\
    \n    // Sort the numbers in ascending order\n    while nums_size > 0 {\n    \
    \    // If current number is greater than the sum of its digits\n        // then\
    \ swap them\n        if nums_sum > nums[nums_size - 1].to_digits(nums_size).unwrap()\
    \ {\n            let (mut x, mut y) = (nums[nums_size - 1], nums[nums_size - 1]);\n\
    \            nums_size -= 1;\n            nums_sum -= x.to_digits(nums_size).unwrap();\n\
    \n            // Swap the numbers at correct position\n            nums[nums_size\
    \ - 1] = y;\n            nums[nums_size - 1 + nums_size] = x;\n        } else\
    \ {\n            // Otherwise remove the first number from the vector\n      \
    \      nums.pop_back();\n        }\n    }\n\n    // Return the resulting vector\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Sum<&isize>` is not satisfied\n \
    \   --> /tmp/tmpk6ss2hjw.rs:15:36\n     |\n15   |     let mut nums_sum = nums.iter().sum::<usize>();\n\
    \     |                                    ^^^ the trait `Sum<&isize>` is not\
    \ implemented for `usize`\n     |\n     = help: the following other types implement\
    \ trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n               <f32 as\
    \ Sum>\n               <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n  \
    \             <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n        \
    \       <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n             and 20\
    \ others\nnote: required by a bound in `std::iter::Iterator::sum`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpk6ss2hjw.rs:21:43\n   |\n21 |         if nums_sum > nums[nums_size -\
    \ 1].to_digits(nums_size).unwrap() {\n   |                                   \
    \        ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `to_digits` found for type `isize` in the current scope\n  --> /tmp/tmpk6ss2hjw.rs:24:27\n\
    \   |\n24 |             nums_sum -= x.to_digits(nums_size).unwrap();\n   |   \
    \                        ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpk6ss2hjw.rs:31:18\n   |\n31 |             nums.pop_back();\n  \
    \ |                  ^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sums: Vec<isize> = nums.iter().cloned().map(|x| x.to_digits()).collect();\n\
    \    let mut sorted = nums.iter().cloned().map(|x| x.to_digits()).collect();\n\
    \    sorted.sort_unstable_by_key(|&x| sums[x]);\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpcnbwjz1_.rs:11:63\n   |\n11 |     let mut sums:\
    \ Vec<isize> = nums.iter().cloned().map(|x| x.to_digits()).collect();\n   |  \
    \                                                             ^^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `to_digits` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpcnbwjz1_.rs:12:53\n   |\n12\
    \ |     let mut sorted = nums.iter().cloned().map(|x| x.to_digits()).collect();\n\
    \   |                                                     ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = nums.clone();\n    sorted_nums.sort();\n\n    for x in nums {\n\
    \        let mut sum_of_digits = x.to_string().chars().map(|x| *x).sum();\n  \
    \      sum_of_digits = sum_of_digits as isize;\n        for x in nums {\n    \
    \        if x != x {\n                if sum_of_digits == x.to_string().chars().map(|x|\
    \ *x).sum() {\n                    sorted_nums.swap(x + 1, x);\n             \
    \       break;\n                }\n            }\n        }\n    }\n    return\
    \ sorted_nums;\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmprtdb614b.rs:15:63\n\
    \   |\n15 |         let mut sum_of_digits = x.to_string().chars().map(|x| *x).sum();\n\
    \   |                                                               ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmprtdb614b.rs:19:67\n   |\n\
    19 |                 if sum_of_digits == x.to_string().chars().map(|x| *x).sum()\
    \ {\n   |                                                                   ^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprtdb614b.rs:20:38\n   |\n20 |\
    \                     sorted_nums.swap(x + 1, x);\n   |                      \
    \                ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    20 |                     sorted_nums.swap((x + 1).try_into().unwrap(), x);\n \
    \  |                                      +     +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprtdb614b.rs:20:45\n   |\n20 |              \
    \       sorted_nums.swap(x + 1, x);\n   |                                    \
    \         ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n20 |      \
    \               sorted_nums.swap(x + 1, x.try_into().unwrap());\n   |        \
    \                                      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut nums_sum = nums.iter().sum();\n\
    \    let mut nums_digit = nums.iter().map(|x| x as i64).collect::<Vec<_>>();\n\
    \n    let mut nums_sorted = vec![];\n    while nums_sum != 0 {\n        let mut\
    \ index = nums_sum % 10;\n        nums_sum /= 10;\n        let mut nums_sum =\
    \ nums_sum.to_string().chars().sum();\n\n        let mut nums_digit = nums_digit.iter().cloned().skip(index).collect();\n\
    \        nums_digit.push(i);\n        nums_digit.push(j);\n\n        if nums_sum\
    \ == 0 {\n            nums_sorted = nums_digit.iter().cloned().collect();\n  \
    \          break;\n        }\n    }\n\n    if nums_sorted != nums {\n        nums_sorted.sort();\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpq0510apz.rs:25:25\n\
    \   |\n25 |         nums_digit.push(i);\n   |                         ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpq0510apz.rs:26:25\n\
    \   |\n26 |         nums_digit.push(j);\n   |                         ^ not found\
    \ in this scope\n\nerror[E0282]: type annotations needed\n  --> /tmp/tmpq0510apz.rs:22:28\n\
    \   |\n15 |     let mut nums_sum = nums.iter().sum();\n   |         ------------\
    \ consider giving `nums_sum` a type\n...\n22 |         let mut nums_sum = nums_sum.to_string().chars().sum();\n\
    \   |                            ^^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0606]: casting `&isize` as `i64`\
    \ is invalid\n  --> /tmp/tmpq0510apz.rs:16:46\n   |\n16 |     let mut nums_digit\
    \ = nums.iter().map(|x| x as i64).collect::<Vec<_>>();\n   |                 \
    \                             -^^^^^^^\n   |                                 \
    \             |\n   |                                              cannot cast\
    \ `&isize` as `i64`\n   |                                              help: dereference\
    \ the expression: `*x`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0282, E0425, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum = Vec::new();\n    let mut nums_sorted = vec![];\n\n    for num in nums\
    \ {\n        sum.push(num);\n    }\n\n    for num in nums {\n        if num !=\
    \ 0 {\n            let mut sum_rem = 0;\n            let mut num_rem = num;\n\n\
    \            for num2 in sum.iter() {\n                sum_rem += num2;\n    \
    \            num_rem %= num2;\n            }\n\n            if sum_rem != 0 {\n\
    \                let mut index = 0;\n\n                for num2 in sum.iter()\
    \ {\n                    if sum_rem == num2 {\n                        break;\n\
    \                    }\n\n                    index += num2;\n               \
    \ }\n\n                nums_sorted.push(num);\n                nums_sorted.push(index);\n\
    \            } else {\n                nums_sorted.push(num);\n            }\n\
    \        }\n    }\n\n    debug_assert!(&nums_sorted.len() == nums.len());\n\n\
    \    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4u19va41.rs:32:35\n   |\n\
    32 |                     if sum_rem == num2 {\n   |                          \
    \         ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |                     if sum_rem == *num2 {\n   |     \
    \                              +\n\nerror[E0277]: can't compare `&usize` with\
    \ `usize`\n  --> /tmp/tmp4u19va41.rs:47:38\n   |\n47 |     debug_assert!(&nums_sorted.len()\
    \ == nums.len());\n   |                                      ^^ no implementation\
    \ for `&usize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&usize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .sort_by(|&(i, &n)| {\n       \
    \     let mut s = n.to_digits();\n            (s.into_iter().sum::<usize>(), i)\n\
    \        })\n        .map(|&(i, &n)| n)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp4haoxgwg.rs:14:10\n   |\n14 |         .sort_by(|&(i,\
    \ &n)| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result: Vec<isize> = nums.clone();\n    let mut sorted_by_sum: Vec<isize> =\
    \ vec![];\n\n    for x in result.iter_mut() {\n        let mut sum_digit = 0;\n\
    \        for x in nums.iter() {\n            let digit = *x / 10 as isize;\n \
    \           sum_digit += digit;\n            *x = *x % 10;\n        }\n\n    \
    \    if sum_digit > result.len() {\n            sorted_by_sum.push(x);\n     \
    \   }\n    }\n\n    for i in result.iter() {\n        if sorted_by_sum.remove(i)\
    \ {\n            result.swap(i, sorted_by_sum.last());\n        }\n    }\n\n \
    \   result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpewmed5aw.rs:22:24\n   |\n\
    22 |         if sum_digit > result.len() {\n   |                        ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |         if\
    \ sum_digit > result.len().try_into().unwrap() {\n   |                       \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpewmed5aw.rs:23:32\n\
    \   |\n23 |             sorted_by_sum.push(x);\n   |                         \
    \       ^ expected `isize`, found `&mut isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |             sorted_by_sum.push(*x);\n   |           \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpewmed5aw.rs:28:33\n\
    \   |\n28 |         if sorted_by_sum.remove(i) {\n   |                       \
    \          ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpewmed5aw.rs:28:12\n   |\n28 |         if sorted_by_sum.remove(i)\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpewmed5aw.rs:29:25\n   |\n29 |  \
    \           result.swap(i, sorted_by_sum.last());\n   |                      \
    \   ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpewmed5aw.rs:29:28\n   |\n29 |             result.swap(i, sorted_by_sum.last());\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<&isize>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sums = Vec::new();\n    for i in 0..nums.len() {\n        sums.push(i);\n  \
    \  }\n    sums.sort_unstable_by(|a, b| {\n        let a = nums[a];\n        let\
    \ b = nums[b];\n        a - b\n    });\n    for i in 0..sums.len() {\n       \
    \ nums.push(sums[i]);\n    }\n    nums\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&usize`\n  --> /tmp/tmplydb11bv.rs:16:17\n\
    \   |\n16 |         let a = nums[a];\n   |                 ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&usize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&usize`\n  --> /tmp/tmplydb11bv.rs:17:17\n   |\n17 |        \
    \ let b = nums[b];\n   |                 ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `&usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&usize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplydb11bv.rs:21:19\n\
    \   |\n21 |         nums.push(sums[i]);\n   |                   ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |         nums.push(sums[i].try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_clone = nums.clone();\n    let mut nums_clone = nums_clone.sort_unstable();\n\
    \    let mut nums_clone = nums_clone.dedup();\n    nums_clone\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `dedup` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpsi3ot1oo.rs:13:37\n   |\n13 |     let mut nums_clone =\
    \ nums_clone.dedup();\n   |                                     ^^^^^ method not\
    \ found in `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        let mut sorted_nums = nums;\n       \
    \ sorted_nums.sort();\n        for i in 0..sorted_nums.len() {\n            sorted_nums[i]\
    \ -= sorted_nums[i].abs().unwrap_or(0);\n        }\n        sorted_nums\n    }\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpbuaaqexo.rs:17:52\n   |\n17 |             sorted_nums[i]\
    \ -= sorted_nums[i].abs().unwrap_or(0);\n   |                                \
    \                    ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ min_sum = 0;\n    let mut cur_sum = nums.iter().map(|x| *x).sum::<isize>();\n\
    \    while cur_sum < min_sum {\n        min_sum = cur_sum;\n        cur_sum =\
    \ nums.iter().map(|x| *x).sum::<isize>();\n    }\n\n    let mut min_idx = nums.iter().cloned().collect::<Vec<_>>().len();\n\
    \    while cur_sum > min_sum {\n        min_idx = cur_sum;\n        cur_sum =\
    \ nums.iter().map(|x| *x).sum::<isize>();\n    }\n    cur_sum -= min_sum;\n  \
    \  cur_sum -= nums[min_idx];\n    cur_sum -= 1;\n    nums.sort();\n    nums[min_idx..]\
    \ = nums[0..min_idx].iter().cloned();\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyestwueu.rs:20:19\n   |\n\
    18 |     let mut min_idx = nums.iter().cloned().collect::<Vec<_>>().len();\n \
    \  |                       ---------------------------------------------- expected\
    \ due to this value\n19 |     while cur_sum > min_sum {\n20 |         min_idx\
    \ = cur_sum;\n   |                   ^^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyestwueu.rs:27:23\n   |\n27 |\
    \     nums[min_idx..] = nums[0..min_idx].iter().cloned();\n   |     ---------------\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected slice `[isize]`, found struct `Cloned`\n\
    \   |     |\n   |     expected due to the type of this binding\n   |\n   = note:\
    \ expected slice `[isize]`\n             found struct `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0277]: the size for values of type `[isize]` cannot be known\
    \ at compilation time\n  --> /tmp/tmpyestwueu.rs:27:5\n   |\n27 |     nums[min_idx..]\
    \ = nums[0..min_idx].iter().cloned();\n   |     ^^^^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[isize]`\n   = note: the left-hand-side of an assignment must have a statically\
    \ known size\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut nums_copy = nums;\n    let mut digits\
    \ = nums_copy.len() * nums_copy.len() / 10;\n    let mut nums_len_max = nums.iter().map(|&num|\
    \ num.len()).max();\n    let mut maxs = nums.iter().map(|&num| num.clone()).collect::<Vec<isize>>();\n\
    \    for i in 0..nums_len_max {\n        for j in 0..nums.len() {\n          \
    \  let sum = 0;\n            for k in 0..nums.len() {\n                sum +=\
    \ nums[j] % 10 + nums[k] % 10;\n                nums[k] /= 10;\n            }\n\
    \            if sum < digits[j] {\n                maxs[j] = i;\n            \
    \    digits[j] = sum;\n            }\n        }\n    }\n    for i in 0..nums_copy.len()\
    \ {\n        let mut num_copy = nums_copy.clone();\n        let nums = num_copy.iter().map(|&num|\
    \ num.clone()).collect::<Vec<isize>>();\n        for j in 0..nums.len() {\n  \
    \          let index = 0;\n            let mut index = maxs[j];\n            for\
    \ k in 0..nums.len() {\n                if k == index {\n                    continue;\n\
    \                }\n                nums[k] *= 10;\n                nums[j] /=\
    \ 10;\n                if nums[j] > nums[k] {\n                    index = k;\n\
    \                }\n            }\n            num_copy[j] = nums[j];\n      \
    \  }\n        nums_copy = num_copy;\n    }\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpn9jlmf3q.rs:16:55\n   |\n16 |     let mut nums_len_max\
    \ = nums.iter().map(|&num| num.len()).max();\n   |                           \
    \                            ^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn9jlmf3q.rs:18:17\n   |\n18 |     for i in 0..nums_len_max\
    \ {\n   |                 ^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<_>`\n\
    \nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpn9jlmf3q.rs:25:22\n\
    \   |\n25 |             if sum < digits[j] {\n   |                      ^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpn9jlmf3q.rs:27:17\n\
    \   |\n27 |                 digits[j] = sum;\n   |                 ^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn9jlmf3q.rs:38:25\n   |\n38 |\
    \                 if k == index {\n   |                         ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n38 |                 if\
    \ k == index.try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn9jlmf3q.rs:44:29\n   |\n36 |\
    \             let mut index = maxs[j];\n   |                             -------\
    \ expected due to this value\n...\n44 |                     index = k;\n   | \
    \                            ^ expected `isize`, found `usize`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ num_sums: Vec<isize> = nums.iter().cloned().collect();\n    num_sums.sort();\n\
    \    let mut new_vec: Vec<isize> = nums.iter().cloned().collect();\n    new_vec.sort_by_key(|x|\
    \ num_sums[x]);\n    new_vec\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp5db2h11z.rs:14:29\n\
    \   |\n14 |     new_vec.sort_by_key(|x| num_sums[x]);\n   |                  \
    \           ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n\n    let mut sum = nums.iter().sum();\n   \
    \ if sum % 10 == 0 {\n        nums.sort();\n        return nums;\n    }\n\n  \
    \  sum = sum / 10;\n    let mut digits = Vec::new();\n    for (i, &n) in nums.iter().enumerate()\
    \ {\n        let mut sum: isize = 0.0;\n        for digit in n.to_string().chars().skip(1)\
    \ {\n            sum += digit;\n        }\n        if sum == sum {\n         \
    \   digits.push(i);\n        }\n    }\n\n    nums.sort();\n    digits.sort_by_key(|n|\
    \ nums[*n]);\n    nums.iter().zip(digits.iter()).cloned().collect();\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe2ji_nq0.rs:24:30\n   |\n\
    24 |         let mut sum: isize = 0.0;\n   |                      -----   ^^^\
    \ expected `isize`, found floating-point number\n   |                      |\n\
    \   |                      expected due to this\n\nerror[E0277]: cannot add-assign\
    \ `char` to `isize`\n  --> /tmp/tmpe2ji_nq0.rs:26:17\n   |\n26 |             sum\
    \ += digit;\n   |                 ^^ no implementation for `isize += char`\n \
    \  |\n   = help: the trait `AddAssign<char>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0271]: type mismatch resolving `<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ usize>> as Iterator>::Item == &_`\n    --> /tmp/tmpe2ji_nq0.rs:35:36\n     |\n\
    35   |     nums.iter().zip(digits.iter()).cloned().collect();\n     |        \
    \                            ^^^^^^ expected reference, found tuple\n     |\n\
    \     = note: expected reference `&_`\n                    found tuple `(&isize,\
    \ &usize)`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ usize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpe2ji_nq0.rs:35:45\n\
    \   |\n35 |        nums.iter().zip(digits.iter()).cloned().collect();\n   |  \
    \                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, usize>>>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ usize>> as Iterator>::Item = &_`\n           which is required by `Cloned<Zip<std::slice::Iter<'_,\
    \ isize>, std::sl"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Initialize\
    \ result vector\n    let mut new_list = Vec::new();\n    let mut index = 0;\n\n\
    \    for num in nums {\n        let num_str = num.to_string();\n        // Check\
    \ if num is already in the result vector\n        // If so, append its index to\
    \ result vector\n        // Otherwise, append num to result vector\n        if\
    \ new_list.iter().any(|&i| i == num_str) {\n            new_list.push(index);\n\
    \        } else {\n            new_list.push(num);\n            index += 1;\n\
    \        }\n    }\n\n    new_list\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `{integer}` with `String`\n  --> /tmp/tmpn4j9z811.rs:20:39\n\
    \   |\n20 |         if new_list.iter().any(|&i| i == num_str) {\n   |        \
    \                               ^^ no implementation for `{integer} == String`\n\
    \   |\n   = help: the trait `PartialEq<String>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    std::env::remove_all(&nums_copy);\n    nums_copy.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &d in &nums_copy {\n            sum\
    \ += d as isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `remove_all` in module `std::env`\n\
    \   --> /tmp/tmpie0pmhwe.rs:12:15\n    |\n12  |     std::env::remove_all(&nums_copy);\n\
    \    |               ^^^^^^^^^^ help: a function with a similar name exists: `remove_var`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: -1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums.clone();\n    }\n    let mut nums_copy = nums.clone();\n   \
    \ let mut nums_sorted = nums_copy.clone();\n    while nums_sorted.len() > 1 {\n\
    \        let mut cur_num: isize = 0;\n        let mut cur_num_sum = 0;\n     \
    \   let mut idx = 0;\n        while idx < nums_sorted.len() {\n            cur_num\
    \ = nums_sorted[idx] + cur_num;\n            cur_num_sum += cur_num;\n       \
    \     idx += 1;\n            if cur_num_sum >= 0 {\n                cur_num_sum\
    \ -= cur_num;\n                nums_sorted[idx] = cur_num;\n                idx\
    \ += 1;\n            } else {\n                break;\n            }\n       \
    \ }\n        nums_sorted.truncate(idx);\n    }\n    nums_sorted.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976144
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // calculate\
    \ sum of digits in the original vector\n    let mut sum_nums = nums.iter().map(|x|\
    \ x.checked_mul(10).unwrap()).sum();\n    if nums.len() != sum_nums.checked_mul(10).unwrap()\
    \ {\n        let diff = sum_nums.checked_sub(nums.len());\n        sum_nums +=\
    \ diff;\n    }\n    // sort ascending according to sum_nums\n    nums.iter().sort_by(|x,\
    \ y| sum_nums.partial_cmp(&x.checked_mul(10).unwrap()).unwrap());\n    nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpdqha0_eb.rs:13:22\n\
    \   |\n12 |     let mut sum_nums = nums.iter().map(|x| x.checked_mul(10).unwrap()).sum();\n\
    \   |         ------------ consider giving `sum_nums` a type\n13 |     if nums.len()\
    \ != sum_nums.checked_mul(10).unwrap() {\n   |                      ^^^^^^^^ cannot\
    \ infer type\n   |\n   = note: type must be known at this point\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `std::slice::Iter` in the current\
    \ scope\n  --> /tmp/tmpdqha0_eb.rs:18:17\n   |\n18 |     nums.iter().sort_by(|x,\
    \ y| sum_nums.partial_cmp(&x.checked_mul(10).unwrap()).unwrap());\n   |      \
    \           ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0599.\nFor more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums;\n    let mut sum = nums[0];\n\n    for &num in nums.iter().rev()\
    \ {\n        if num > 0 {\n            sum += num;\n        }\n    }\n\n    nums_copy.sort_by_key(|&num|\
    \ {\n        sum.wrapping_add(num).unwrap()\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpowptmp5v.rs:21:31\n   |\n21 |         sum.wrapping_add(num).unwrap()\n\
    \   |                               ^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // If there\
    \ are several items with similar sum of their digits,\n    // order them based\
    \ on their index in original vector.\n    let mut result = nums;\n    let mut\
    \ current_total = 0;\n    let mut last_index = 0;\n    let mut temp_sum = 0;\n\
    \n    while current_total < 100 {\n        // Calculate the sum of digits and\
    \ insert it into temporary sum.\n        for index in 0..result.len() {\n    \
    \        temp_sum += result[index];\n        }\n        // Find the index of that\
    \ temporary sum in the original vector.\n        let index = temp_sum.find_index(|&x|\
    \ x == temp_sum);\n        // If index is not equal to the last index,\n     \
    \   // insert into the sorted vector.\n        if index != last_index {\n    \
    \        result.insert(index, temp_sum.clone());\n        }\n        // Update\
    \ temporary sum.\n        temp_sum = 0;\n        // If there are still some items\
    \ in the original vector.\n        // Calculate the sum of digits and insert it\
    \ into the temporary sum.\n        for index in 0..result.len() {\n          \
    \  temp_sum += result[index];\n        }\n        // Find the index of that temporary\
    \ sum in the original vector.\n        let index = temp_sum.find_index(|&x| x\
    \ == temp_sum);\n        // If index is not equal to the last index,\n       \
    \ // insert into the sorted vector.\n        if index != last_index {\n      \
    \      result.insert(index, temp_sum.clone());\n        }\n        // Update temporary\
    \ sum.\n        temp_sum = 0;\n        // Update current total and last index.\n\
    \        current_total += last_index;\n        last_index = index;\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_index` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmprkshdu1f.rs:24:30\n   |\n24 |         let index\
    \ = temp_sum.find_index(|&x| x == temp_sum);\n   |                           \
    \   ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `find_index`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmprkshdu1f.rs:38:30\n\
    \   |\n38 |         let index = temp_sum.find_index(|&x| x == temp_sum);\n   |\
    \                              ^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Create\
    \ vector which stores indices whose sums of digits are the lowest.\n    let mut\
    \ sum_of_digits: Vec<isize> = nums.into_iter().map(|n| n * 10).sum().collect();\n\
    \    let mut sort_index: Vec<isize> = vec![0; nums.len()];\n    sum_of_digits.iter().enumerate().filter(|&(i,\
    \ &v)| v == i).for_each(|(i, &v)| {\n        // If sum of digits of this index's\
    \ element is less than sums\n        // of digits of the previous indices, then\
    \ this index is a\n        // candidate for sorting its element\n        if v\
    \ < sum_of_digits[i-1] {\n            // Store the index and swap it with the\
    \ previous index\n            sort_index[i-1] = i;\n            sort_index[i]\
    \ = i-1;\n        }\n    });\n    // Sort the elements of vector based on their\
    \ indices.\n    nums.into_iter().enumerate().filter(|&(i, _)| sort_index[i] ==\
    \ i).for_each(|(i, &v)| {\n        nums[i] = v;\n    });\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp1qmnn0h9.rs:12:74\n\
    \   |\n12 |     let mut sum_of_digits: Vec<isize> = nums.into_iter().map(|n| n\
    \ * 10).sum().collect();\n   |                                               \
    \                           ^^^ cannot infer type for type parameter `S` declared\
    \ on the associated function `sum`\n   |\n   = note: type must be known at this\
    \ point\nhelp: consider specifying the type argument in the method call\n   |\n\
    12 |     let mut sum_of_digits: Vec<isize> = nums.into_iter().map(|n| n * 10).sum::<S>().collect();\n\
    \   |                                                                        \
    \     +++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qmnn0h9.rs:14:61\n\
    \   |\n14 |     sum_of_digits.iter().enumerate().filter(|&(i, &v)| v == i).for_each(|(i,\
    \ &v)| {\n   |                                                             ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |     sum_of_digits.iter().enumerate().filter(|&(i,\
    \ &v)| v == i.try_into().unwrap()).for_each(|(i, &v)| {\n   |                \
    \                                              ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1qmnn0h9.rs:20:31\n   |\n20 |             sort_index[i-1]\
    \ = i;\n   |             ---------------   ^ expected `isize`, found `usize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1qmnn0h9.rs:21:29\n   |\n21 |\
    \             sort_index[i] = i-1;\n   |             -------------   ^^^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qmnn0h9.rs:25:68\n\
    \   |\n25 |     nums.into_iter().enumerate().filter(|&(i, _)| sort_index[i] ==\
    \ i).for_each(|(i, &v)| {\n   |                                              \
    \                      ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted "
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums;\n    let mut num_sum = 0;\n    for &x in &nums_copy {\n  \
    \      num_sum += x;\n    }\n    let mut num_sorted = Vec::new();\n    let mut\
    \ index = 0;\n    while index < nums.len() {\n        let mut index_add = 0;\n\
    \        for &x in &nums_copy {\n            if x > 0 {\n                num_sorted.push(x\
    \ - num_sum);\n                index_add++;\n            }\n        }\n      \
    \  index += index_add;\n    }\n    &num_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp5lfbd_qp.rs:23:26\n\
    \   |\n23 |                 index_add++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23 |       \
    \          { let tmp = index_add; index_add += 1; tmp };\n   |               \
    \  +++++++++++          ~~~~~~~~~~~~~~~~~~~~~~~\n23 -                 index_add++;\n\
    23 +                 index_add += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5lfbd_qp.rs:28:5\n   |\n10 | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n28 |     &num_sorted\n   |     ^^^^^^^^^^^\
    \ expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found reference `&Vec<isize>`\nhelp: consider removing\
    \ the borrow\n   |\n28 -     &num_sorted\n28 +     num_sorted\n   | \n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut min_val = nums.iter().min();\n \
    \   let mut min_sum = nums.iter().filter(|&x| x != min_val).sum();\n    for (i,\
    \ val) in nums.iter().enumerate() {\n        let sum = val - min_val;\n      \
    \  if sum < min_sum {\n            min_sum = sum;\n            min_val = val;\n\
    \        }\n    }\n    let mut sorted_nums = nums.iter().filter(|&x| x != min_val).collect::<Vec<_>>();\n\
    \    sorted_nums.sort_by(|x, y| x - y);\n    sorted_nums\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpkdphwp76.rs:15:49\n\
    \   |\n15 |     let mut min_sum = nums.iter().filter(|&x| x != min_val).sum();\n\
    \   |                                                 ^^ no implementation for\
    \ `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: cannot subtract `Option<&isize>`\
    \ from `&isize`\n  --> /tmp/tmpkdphwp76.rs:17:23\n   |\n17 |         let sum =\
    \ val - min_val;\n   |                       ^ no implementation for `&isize -\
    \ Option<&isize>`\n   |\n   = help: the trait `Sub<Option<&isize>>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkdphwp76.rs:20:23\n\
    \   |\n14 |     let mut min_val = nums.iter().min();\n   |                   \
    \    ----------------- expected due to this value\n...\n20 |             min_val\
    \ = val;\n   |                       ^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n20 |          \
    \   min_val = Some(val);\n   |                       +++++   +\n\nerror[E0277]:\
    \ can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpkdphwp76.rs:23:53\n\
    \   |\n23 |     let mut sorted_nums = nums.iter().filter(|&x| x != min_val).collect::<Vec<_>>();\n\
    \   |                                                     ^^ no implementation\
    \ for `&isize == Option"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    nums_copy.sort_by_key(|&x| {\n        let mut\
    \ sum = 0;\n        for &y in &nums_copy {\n            sum += y;\n        }\n\
    \        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp1zn525i8.rs:12:29\n   |\n\
    12 |     nums_copy.sort_by_key(|&x| {\n   |                             ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmp1zn525i8.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|&x| {\n   |       -         -----------\
    \ ^^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|    \
    \     mutable borrow later used by call\n   | |\n13 | |         let mut sum =\
    \ 0;\n14 | |         for &y in &nums_copy {\n   | |                    ---------\
    \ second borrow occurs due to use of `nums_copy` in closure\n15 | |          \
    \   sum += y;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ mutable borrow occurs here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum = nums.iter().sum();\n    nums.sort_by(|a, b| sum.partial_cmp(&a.checked_add(&b).unwrap()).unwrap());\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp97n6kvi7.rs:12:25\n\
    \   |\n11 |     let mut sum = nums.iter().sum();\n   |         ------- consider\
    \ giving `sum` a type\n12 |     nums.sort_by(|a, b| sum.partial_cmp(&a.checked_add(&b).unwrap()).unwrap());\n\
    \   |                         ^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp97n6kvi7.rs:12:56\n\
    \   |\n12 |     nums.sort_by(|a, b| sum.partial_cmp(&a.checked_add(&b).unwrap()).unwrap());\n\
    \   |                                                        ^^ expected `isize`,\
    \ found `&&isize`\n   |\nhelp: consider removing the `&` and dereferencing the\
    \ borrow instead\n   |\n12 |     nums.sort_by(|a, b| sum.partial_cmp(&a.checked_add(*b).unwrap()).unwrap());\n\
    \   |                                                        ~\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = nums.clone();\n    let mut sum_of_nums: Vec<isize> = vec![0; nums.len()];\n\
    \    for i in 0..nums.len() {\n        sum_of_nums[i] = sum_of_nums[i] || 0i32;\n\
    \        sum_of_nums[i] += nums[i];\n    }\n    sorted_nums = sorted_nums.iter().sorted(|a,\
    \ b| {\n        let a_digits = a % 10 as isize;\n        let b_digits = b as isize;\n\
    \        b_digits < a_digits\n    }).collect();\n    for i in 0..nums.len() {\n\
    \        let index = sorted_nums.iter().position(|num| num == nums[i]);\n    \
    \    sorted_nums.insert(index, nums[i]);\n    }\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb_hsx3za.rs:14:26\n   |\n\
    14 |         sum_of_nums[i] = sum_of_nums[i] || 0i32;\n   |                  \
    \        ^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb_hsx3za.rs:14:44\n   |\n14 |         sum_of_nums[i] =\
    \ sum_of_nums[i] || 0i32;\n   |                                            ^^^^\
    \ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb_hsx3za.rs:14:26\n\
    \   |\n14 |         sum_of_nums[i] = sum_of_nums[i] || 0i32;\n   |         --------------\
    \   ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `bool`\n   |         |\n  \
    \ |         expected due to the type of this binding\n\nerror[E0599]: no method\
    \ named `sorted` found for struct `std::slice::Iter` in the current scope\n  -->\
    \ /tmp/tmpb_hsx3za.rs:17:38\n   |\n17 |     sorted_nums = sorted_nums.iter().sorted(|a,\
    \ b| {\n   |                                      ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpb_hsx3za.rs:23:59\n\
    \   |\n23 |         let index = sorted_nums.iter().position(|num| num == nums[i]);\n\
    \   |                                                           ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb_hsx3za.rs:24:28\n   |\n24 |         sorted_nums.insert(index, nums[i]);\n\
    \   |                            ^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by(|a,\
    \ b| {\n        digits(a).iter().zip(digits(b).iter()).all(|(a, b)| a < b)\n \
    \   })\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digits` in this scope\n  --> /tmp/tmprw_4beia.rs:12:9\n\
    \   |\n12 |         digits(a).iter().zip(digits(b).iter()).all(|(a, b)| a < b)\n\
    \   |         ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `digits` in this scope\n  --> /tmp/tmprw_4beia.rs:12:30\n   |\n12 |        \
    \ digits(a).iter().zip(digits(b).iter()).all(|(a, b)| a < b)\n   |           \
    \                   ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprw_4beia.rs:11:5\n   |\n10 |   fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          \
    \ ---------- expected `Vec<isize>` because of return type\n11 | /     nums.sort_unstable_by(|a,\
    \ b| {\n12 | |         digits(a).iter().zip(digits(b).iter()).all(|(a, b)| a <\
    \ b)\n13 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Create\
    \ a map to store index by sum of digits of each number\n    // and get the min\
    \ max sum to sort the numbers by their sum of digits\n    let mut map: Vec<isize>\
    \ = nums.iter().map(|x| x.checked_mul(10).unwrap()).collect();\n    map.sort_by_key(|x|\
    \ x.checked_add(&map[0]).unwrap());\n    // Sort by map values\n    map.iter().cloned().sorted().collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzoh0cb6z.rs:14:39\n   |\n\
    14 |     map.sort_by_key(|x| x.checked_add(&map[0]).unwrap());\n   |         \
    \                              ^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider removing the borrow\n   |\n14 -     map.sort_by_key(|x| x.checked_add(&map[0]).unwrap());\n\
    14 +     map.sort_by_key(|x| x.checked_add(map[0]).unwrap());\n   | \n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Cloned` in the current scope\n  -->\
    \ /tmp/tmpzoh0cb6z.rs:16:25\n   |\n16 |     map.iter().cloned().sorted().collect()\n\
    \   |                         ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Find\
    \ the minimum sum of digits in the vector\n    let mut min_sum = nums.iter().fold(0,\
    \ |min_sum, i| min_sum + i);\n    loop {\n        // Find first element in nums\
    \ whose sum of digits is less than\n        // min_sum\n        let mut i1 = nums.iter().position(|i|\
    \ i < min_sum).unwrap();\n        // Find first element in nums whose sum of digits\
    \ is greater\n        // than min_sum\n        let mut i2 = nums.iter().position(|i|\
    \ i > min_sum).unwrap();\n        if i2 == i1 {\n            break;\n        }\n\
    \        // Swap the elements\n        let tmp = nums[i1];\n        nums[i1] =\
    \ nums[i2];\n        nums[i2] = tmp;\n        // Update the min_sum\n        min_sum\
    \ = nums.iter().fold(0, |min_sum, i| min_sum + i);\n    }\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7wud9gdz.rs:16:51\n   |\n\
    16 |         let mut i1 = nums.iter().position(|i| i < min_sum).unwrap();\n  \
    \ |                                                   ^^^^^^^\n   |          \
    \                                         |\n   |                            \
    \                       expected `&isize`, found `isize`\n   |               \
    \                                    help: consider borrowing here: `&min_sum`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7wud9gdz.rs:19:51\n   |\n19 |\
    \         let mut i2 = nums.iter().position(|i| i > min_sum).unwrap();\n   | \
    \                                                  ^^^^^^^\n   |             \
    \                                      |\n   |                               \
    \                    expected `&isize`, found `isize`\n   |                  \
    \                                 help: consider borrowing here: `&min_sum`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        let mut nums_sum = 0;\n        let mut\
    \ sorted_indices = vec![];\n        for index in nums.iter() {\n            nums_sum\
    \ += *index;\n            sorted_indices.push(*index);\n        }\n        sorted_indices.sort();\n\
    \n        nums.par_sort_unstable_by(|a, b| {\n            let a_index = *a;\n\
    \            let b_index = *b;\n            let a_sum = a_index.to_digit(10);\n\
    \            let b_sum = b_index.to_digit(10);\n            a_sum.cmp(&b_sum)\n\
    \        });\n\n        nums_sum.par_sort_unstable_by(|a, b| {\n            let\
    \ a_index = *a;\n            let b_index = *b;\n            let a_sum = a_index.to_digit(10);\n\
    \            let b_sum = b_index.to_digit(10);\n            a_sum.cmp(&b_sum)\n\
    \        });\n\n        sorted_indices.into_iter().map(|index| nums[index]).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `par_sort_unstable_by` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmphcqvvw7e.rs:22:14\n   |\n22 |         nums.par_sort_unstable_by(|a,\
    \ b| {\n   |              ^^^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `sort_unstable`\n\nerror[E0599]: no method named `par_sort_unstable_by`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmphcqvvw7e.rs:30:18\n\
    \   |\n30 |         nums_sum.par_sort_unstable_by(|a, b| {\n   |             \
    \     ^^^^^^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphcqvvw7e.rs:38:48\n  \
    \ |\n38 |         sorted_indices.into_iter().map(|index| nums[index]).collect()\n\
    \   |                                                ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_sorted = nums.clone();\n    if nums.is_empty() {\n        return vec![];\n\
    \    }\n    let mut digits = vec![];\n    for i in 0..nums.len() {\n        digits.push(nums[i]\
    \ % 10);\n    }\n    let mut min = std::i32::MAX;\n    let mut pos = 0;\n    let\
    \ mut current_min = 0;\n    let mut current_pos = 0;\n    for i in 0..digits.len()\
    \ {\n        let d = digits[i] as usize;\n        if d == 0 {\n            continue;\n\
    \        }\n        let d_pos = std::i32::from(d * 10) + digits[pos + 1];\n  \
    \      let d_min = std::i32::MAX;\n        if d_pos < min {\n            min =\
    \ d_pos;\n            current_min = std::i32::MAX;\n            current_pos =\
    \ 0;\n        }\n        if d != current_min {\n            pos = current_pos;\n\
    \            current_min = d;\n        }\n        pos = pos + 1;\n        current_pos\
    \ = d_pos + digits[pos];\n    }\n    if nums_sorted.len() > pos {\n        let\
    \ mut i = pos;\n        while i > 0 && nums_sorted[i] == nums_sorted[i - 1] {\n\
    \            i -= 1;\n        }\n        nums_sorted.swap(i, nums_sorted.len());\n\
    \    }\n    nums_sorted.sort_unstable();\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `from` in module `std::i32`\n  --> /tmp/tmpt6cknbr8.rs:28:31\n\
    \   |\n28 |         let d_pos = std::i32::from(d * 10) + digits[pos + 1];\n  \
    \ |                               ^^^^ not found in `std::i32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt6cknbr8.rs:35:17\n   |\n35 |         if d !=\
    \ current_min {\n   |                 ^^^^^^^^^^^ expected `usize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |         if d != current_min.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt6cknbr8.rs:37:27\n   |\n21 |     let mut current_min =\
    \ 0;\n   |                           - expected due to this value\n...\n37 | \
    \            current_min = d;\n   |                           ^ expected `i32`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt6cknbr8.rs:40:31\n\
    \   |\n40 |         current_pos = d_pos + digits[pos];\n   |                 \
    \              ^^^^^^^^^^^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt6cknbr8.rs:40:23\n   |\n22 |     let mut current_pos =\
    \ 0;\n   |                           - expected due to this value\n...\n40 | \
    \        current_pos = d_pos + digits[pos];\n   |                       ^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n\nerror[E0277]: cannot add `isize` to `i32`\n\
    \  --> /tmp/tmpt6cknbr8.rs:40:29\n   |\n40 |         current_pos = d_pos + digits[pos];\n\
    \   |                             ^ no implementation for `i32 + isize`\n   |\n\
    \   = help: the trait `Add<isize>` is not implemented for `i32`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome erro"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum: usize = 0;\n    let mut idx: usize = 0;\n    for n in nums {\n        sum\
    \ += n % 10;\n        idx += n / 10;\n    }\n\n    debug_assert!(idx < nums.len());\n\
    \n    if sum == 0 {\n        nums.sort();\n        return nums;\n    }\n\n   \
    \ debug_assert!(nums.len() >= 2);\n\n    // find the place with smallest sum\n\
    \    let mut min_sum = nums[0];\n    let mut min_idx = 0;\n    for n in nums {\n\
    \        if n % 10 == min_sum / 10 {\n            min_sum += n % 10;\n       \
    \     min_idx += n / 10;\n        }\n    }\n\n    // move smallest sum to its\
    \ place\n    nums[idx] -= min_sum;\n    nums[idx] %= 10;\n\n    nums[min_idx]\
    \ += min_sum;\n    nums[min_idx] %= 10;\n\n    nums.sort();\n    return nums;\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0hcg8d8.rs:14:16\n   |\n\
    14 |         sum += n % 10;\n   |                ^^^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpk0hcg8d8.rs:14:13\n\
    \   |\n14 |         sum += n % 10;\n   |             ^^ no implementation for\
    \ `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk0hcg8d8.rs:15:16\n\
    \   |\n15 |         idx += n / 10;\n   |                ^^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpk0hcg8d8.rs:15:13\n\
    \   |\n15 |         idx += n / 10;\n   |             ^^ no implementation for\
    \ `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpk0hcg8d8.rs:41:5\n   |\n41 |     nums[min_idx] += min_sum;\n  \
    \ |     ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // The sum\
    \ of the digits is represented as two digits, the\n    // least significant digit\
    \ in the first place, and the most\n    // significant digit in the second place.\n\
    \    let mut digits = [0, 0];\n\n    for &n in nums {\n        for d in n.to_string().chars().map(|c|\
    \ c.to_digit(10)) {\n            digits[d] += 1;\n        }\n    }\n\n    let\
    \ mut nums_sorted = nums.clone();\n    for d in 0..(digits[0] + 1) {\n       \
    \ let i = nums_sorted.binary_search(&d + digits[1]);\n        if i > 0 {\n   \
    \         nums_sorted.swap(i, nums_sorted.len() - 1);\n        }\n    }\n\n  \
    \  nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ha4xu55.rs:16:9\n   |\n\
    16 |     for &n in nums {\n   |         ^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2ha4xu55.rs:24:43\n   |\n24 |         let i = nums_sorted.binary_search(&d\
    \ + digits[1]);\n   |                                           ^^^^^^^^^^^^^^\n\
    \   |                                           |\n   |                      \
    \                     expected `&isize`, found integer\n   |                 \
    \                          help: consider borrowing here: `&(&d + digits[1])`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2ha4xu55.rs:25:16\n   |\n25 |\
    \         if i > 0 {\n   |                ^ expected enum `Result`, found integer\n\
    \   |\n   = note: expected enum `Result<usize, usize>`\n              found type\
    \ `{integer}`\nhelp: try wrapping the expression in a variant of `Result`\n  \
    \ |\n25 |         if i > Ok(0) {\n   |                +++ +\n25 |         if i\
    \ > Err(0) {\n   |                ++++ +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp2ha4xu55.rs:26:30\n   |\n26 |             nums_sorted.swap(i, nums_sorted.len()\
    \ - 1);\n   |                              ^ expected `usize`, found enum `Result`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Result<usize,\
    \ usize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ n = nums.len();\n    let mut sorted_nums = Vec::with_capacity(n);\n    let mut\
    \ total_sum = nums.iter().sum::<isize>();\n    sorted_nums.push(total_sum);\n\
    \    for i in 0..n {\n        let cur_sum = nums[i] + total_sum;\n        if cur_sum\
    \ < sorted_nums.last_mut().unwrap() {\n            // reorder\n            sorted_nums.push(cur_sum);\n\
    \        } else if cur_sum > sorted_nums.last_mut().unwrap() {\n            sorted_nums.last_mut().unwrap().swap(i);\n\
    \        }\n    }\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6_1ll6ly.rs:17:22\n   |\n\
    17 |         if cur_sum < sorted_nums.last_mut().unwrap() {\n   |            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&mut isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |         if cur_sum\
    \ < *sorted_nums.last_mut().unwrap() {\n   |                      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6_1ll6ly.rs:20:29\n   |\n20 |         } else\
    \ if cur_sum > sorted_nums.last_mut().unwrap() {\n   |                       \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&mut isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |         } else if cur_sum\
    \ > *sorted_nums.last_mut().unwrap() {\n   |                             +\n\n\
    error[E0599]: no method named `swap` found for mutable reference `&mut isize`\
    \ in the current scope\n  --> /tmp/tmp6_1ll6ly.rs:21:45\n   |\n21 |          \
    \   sorted_nums.last_mut().unwrap().swap(i);\n   |                           \
    \                  ^^^^ method not found in `&mut isize`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        let mut max_sum_so_far: isize = nums.iter().reduce(|a,\
    \ b| {\n            a.checked_add(b).unwrap()\n        }).unwrap();\n        let\
    \ mut result: Vec<isize> = nums.clone();\n        for n in nums.iter() {\n   \
    \         let sum = (*n % 10).checked_add(*n / 10).unwrap();\n            if sum\
    \ < max_sum_so_far {\n                *n = sum * 10;\n                let mut\
    \ idx = nums.iter().enumerate().find(|&(_, v)| v == n).unwrap();\n           \
    \     nums[idx] = sum;\n                result.push(*n);\n                max_sum_so_far\
    \ = *n;\n            } else {\n                let mut idx = nums.iter().enumerate().find(|&(_,\
    \ v)| v == n).unwrap();\n                nums[idx] = max_sum_so_far;\n       \
    \         result.push(*n);\n                max_sum_so_far = *n;\n           \
    \ }\n        }\n        result\n    }\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoxg2ec_c.rs:15:27\n   |\n\
    15 |             a.checked_add(b).unwrap()\n   |                           ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    15 |             a.checked_add(*b).unwrap()\n   |                           +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoxg2ec_c.rs:15:13\n   |\n15 |\
    \             a.checked_add(b).unwrap()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             expected `&isize`, found `isize`\n   | \
    \            help: consider borrowing here: `&a.checked_add(b).unwrap()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoxg2ec_c.rs:14:41\n   |\n14 |           let\
    \ mut max_sum_so_far: isize = nums.iter().reduce(|a, b| {\n   |  _________________________________-----___^\n\
    \   | |                                 |\n   | |                            \
    \     expected due to this\n15 | |             a.checked_add(b).unwrap()\n16 |\
    \ |         }).unwrap();\n   | |___________________^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |         let mut max_sum_so_far:\
    \ isize = *nums.iter().reduce(|a, b| {\n   |                                 \
    \        +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `(usize, &isize)`\n\
    \  --> /tmp/tmpoxg2ec_c.rs:23:17\n   |\n23 |                 nums[idx] = sum;\n\
    \   |                 ^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `(usize, &isize)`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `(Bound<usize>, Bound<usize>)`\n   = note: required because of the requirements\
    \ on the impl of `Index<(usize, &isize)>` for `Vec<isize>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `(usize, &isize)`\n  --> /tmp/tmpoxg2ec_c.rs:28:17\n\
    \   |\n28 |                 nums[idx] = max_sum_so_far;\n   |                \
    \ ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<[isize]>` is not implemented for `(usize, &is"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums = nums.clone();\n    nums.sort_by(|&a, &b| {\n        if a < b {\n    \
    \        -a\n        } else {\n            a\n        }\n    });\n    nums\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfc84eq2y.rs:14:13\n   |\n\
    14 |             -a\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfc84eq2y.rs:16:13\n\
    \   |\n16 |             a\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_sorted = nums.clone();\n    let mut current_sum = 0;\n\n    for &num in\
    \ nums_sorted {\n        let num_as_string = num.to_string();\n        let mut\
    \ digits = String::new();\n        let mut digit_sum = 0;\n\n        for c in\
    \ num_as_string {\n            digits.push(c.to_string());\n            digit_sum\
    \ += c.to_digit(10);\n        }\n\n        if current_sum < digit_sum {\n    \
    \        current_sum = digit_sum;\n        }\n    }\n\n    for i in 0..nums.len()\
    \ {\n        nums_sorted[i] = nums[i];\n    }\n    nums_sorted.sort_by_key(|num|\
    \ {\n        let mut num_as_string = num.to_string();\n        let mut digits\
    \ = String::new();\n        let mut digit_sum = 0;\n\n        for c in num_as_string\
    \ {\n            digits.push(c.to_string());\n            digit_sum += c.to_digit(10);\n\
    \        }\n        digit_sum\n    });\n\n    for num in nums_sorted {\n     \
    \   nums.push(num);\n    }\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9el4wkfv.rs:14:9\n   |\n\
    14 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0277]: `String` is not an iterator\n  --> /tmp/tmp9el4wkfv.rs:37:18\n \
    \  |\n37 |         for c in num_as_string {\n   |                  ^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .clone()\n        .map(|x| x.checked_mul(10).ok())\n\
    \        .enumerate()\n        .filter_map(|(i, x)| {\n            let mut n =\
    \ x.to_owned();\n            n.sort_by_key(|x| x.checked_mul(10).ok());\n    \
    \        Ok((i, *n))\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp90dylatj.rs:14:36\n   |\n14 |         .map(|x| x.checked_mul(10).ok())\n\
    \   |                                    ^^ help: there is an associated function\
    \ with a similar name: `or`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp90dylatj.rs:19:13\n\
    \   |\n19 |             Ok((i, *n))\n   |             ^^^^^^^^^^^ expected enum\
    \ `Option`, found enum `Result`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found enum `Result<_, _>`\nhelp: try wrapping the expression in\
    \ `Some`\n   |\n19 |             Some(Ok((i, *n)))\n   |             +++++   \
    \        +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_vec: Vec<isize> = nums.clone();\n    let mut sums = nums.clone();\n \
    \   for i in sorted_vec.iter() {\n        sums.iter().for_each(|&x| {\n      \
    \      *x = *x + *x;\n        });\n        let mut min = sums.iter().min().unwrap();\n\
    \        for i in sums.iter() {\n            if *i == min {\n                *i\
    \ -= 1;\n            }\n        }\n        *i -= 1;\n    }\n    sorted_vec\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmppbaehux4.rs:15:13\n\
    \   |\n15 |             *x = *x + *x;\n   |             ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmppbaehux4.rs:15:18\n   |\n15 |\
    \             *x = *x + *x;\n   |                  ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmppbaehux4.rs:15:23\n   |\n15 |        \
    \     *x = *x + *x;\n   |                       ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppbaehux4.rs:19:22\n   |\n19 |             if *i == min\
    \ {\n   |                      ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |             if *i == *min {\n\
    \   |                      +\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // The map\
    \ function builds a map from digit sum to index \n    // (the index denotes the\
    \ order of the sorted array)\n    let mut map = nums.iter().map(|x| {\n      \
    \  if x < 0 {\n            std::cmp::Ordering::Less \n        } else {\n     \
    \       std::cmp::Ordering::Greater\n        }\n    }).collect();\n\n    // Sort\
    \ the map by its value\n    map.sort_by(|a, b| a.cmp(b));\n\n    // Copy the sorted\
    \ index back to the original array\n    nums[map.iter().cloned().cloned()] = map.into_iter().cloned();\n\
    \n    return nums;\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu0igkdi8.rs:14:16\n   |\n\
    14 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n\n    // Sort the list based on the total sum\
    \ of digits.\n    // To achieve this, we sort by digits in reverse order\n   \
    \ // and sum up the digits to obtain total sum.\n    // Then we sort the list\
    \ based on the sum.\n    let mut sum: isize = 0;\n    let mut sorted_nums = nums.into_iter().rev();\n\
    \    sorted_nums.for_each(|&n| {\n        sum += n;\n    });\n    sorted_nums.sort_by_key(|&n|\
    \ sum);\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7hd9td79.rs:21:27\n   |\n\
    21 |     sorted_nums.for_each(|&n| {\n   |                           ^--\n   |\
    \                           ||\n   |                           |expected due to\
    \ this\n   |                           expected `isize`, found reference\n   |\
    \                           help: did you mean `n`: `&isize`\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0599]: no\
    \ method named `sort_by_key` found for struct `Rev` in the current scope\n  -->\
    \ /tmp/tmp7hd9td79.rs:24:17\n   |\n24 |     sorted_nums.sort_by_key(|&n| sum);\n\
    \   |                 ^^^^^^^^^^^ method not found in `Rev<std::vec::IntoIter<isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7hd9td79.rs:25:5\n   |\n10 | fn\
    \ order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |                    \
    \                     ---------- expected `Vec<isize>` because of return type\n\
    ...\n25 |     sorted_nums\n   |     ^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `Rev`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Rev<std::vec::IntoIter<isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ n = nums.len();\n    let mut sum_of_digits = 0;\n    let mut order = 0;\n  \
    \  let mut index = nums.len() as usize;\n    // loop through each digit\n    while\
    \ index > 0 {\n        sum_of_digits += nums[order as usize - 1] % 10;\n     \
    \   order /= 10;\n        n -= 1;\n        index -= 1;\n    }\n\n    vec![n..]\n\
    \        .iter()\n        .map(|n| nums[n - 1] + sum_of_digits as isize)\n   \
    \     .sort_unstable()\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `&RangeFrom<usize>`\n  -->\
    \ /tmp/tmpjbglp4a7.rs:25:25\n   |\n25 |         .map(|n| nums[n - 1] + sum_of_digits\
    \ as isize)\n   |                       - ^ - {integer}\n   |                \
    \       |\n   |                       &RangeFrom<usize>\n\nerror[E0599]: no method\
    \ named `sort_unstable` found for struct `Map` in the current scope\n  --> /tmp/tmpjbglp4a7.rs:26:10\n\
    \   |\n26 |         .sort_unstable()\n   |          ^^^^^^^^^^^^^ method not found\
    \ in `Map<std::slice::Iter<'_, RangeFrom<usize>>, _>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|&n|\
    \ {\n        let mut sum = 0;\n        let mut tmp = n;\n        while tmp > 0\
    \ {\n            sum += tmp % 10;\n            tmp /= 10;\n        }\n       \
    \ sum\n    })\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkx0knoyw.rs:11:5\n   |\n\
    10 |   fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |            \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n11 | /     nums.sort_by_key(|&n| {\n12 | |         let mut sum = 0;\n\
    13 | |         let mut tmp = n;\n14 | |         while tmp > 0 {\n...  |\n18 |\
    \ |         sum\n19 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Use std::cmp::min/max\
    \ to sort using less or equal\n    // comparison operator instead of default operator==\n\
    \    // because the items are very small integers\n    vec![(nums.iter().map(|x|\
    \ x).min(Ordering::Less))\n        .collect::<Vec<isize>>()\n    ]\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp22r0q6a5.rs:14:38\n   |\n14 |     vec![(nums.iter().map(|x| x).min(Ordering::Less))\n\
    \   |                                      ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp22r0q6a5.rs:14:34\n     |\n14   |     vec![(nums.iter().map(|x|\
    \ x).min(Ordering::Less))\n     |                                  ^^^ --------------\
    \ supplied 1 argument\n     |                                  |\n     |     \
    \                             expected 0 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: the method `collect` exists for enum `Option<&isize>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmp22r0q6a5.rs:15:10\n\
    \    |\n15  |           .collect::<Vec<isize>>()\n    |            ^^^^^^^ method\
    \ cannot be called on `Option<&isize>` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<&isize>:\
    \ Iterator`\n            which is required by `&mut Option<&isize>: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum_of_digits = nums\n        .iter()\n        .map(|n| n % 10)\n        .sum();\n\
    \    nums.sort_by_key(|n| sum_of_digits);\n    nums\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp8h9n43jo.rs:11:9\n\
    \   |\n11 |     let mut sum_of_digits = nums\n   |         ^^^^^^^^^^^^^^^^^ consider\
    \ giving `sum_of_digits` a type\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut result = vec![];\n    let mut sum\
    \ = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut max_sum\
    \ = nums.iter().max().unwrap();\n    for i in nums.iter() {\n        sum += *i;\n\
    \        let max_num = if *i > max_sum { *i } else { *i };\n        let min_num\
    \ = if *i < min_sum { *i } else { *i };\n        if sum == 0 {\n            result.push(i);\n\
    \        } else {\n            let mut j = 0;\n            while j < i && sum\
    \ > 0 {\n                let k = nums.iter().nth(j + 1).unwrap();\n          \
    \      let tmp_sum = (*k) + (*j);\n                if tmp_sum > sum {\n      \
    \              break;\n                } else if tmp_sum == sum {\n          \
    \          result.push(k);\n                    result.push(j);\n            \
    \        break;\n                }\n                sum += *k;\n             \
    \   j += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp810x8f8n.rs:20:31\n   |\n\
    20 |         let max_num = if *i > max_sum { *i } else { *i };\n   |         \
    \                      ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |         let max_num = if *i > *max_sum\
    \ { *i } else { *i };\n   |                               +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp810x8f8n.rs:21:31\n   |\n21 |         let min_num = if\
    \ *i < min_sum { *i } else { *i };\n   |                               ^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         let min_num = if *i < *min_sum { *i } else { *i };\n   | \
    \                              +\n\nerror[E0277]: can't compare `isize` with `&isize`\n\
    \  --> /tmp/tmp810x8f8n.rs:26:21\n   |\n26 |             while j < i && sum >\
    \ 0 {\n   |                     ^ no implementation for `isize < &isize` and `isize\
    \ > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp810x8f8n.rs:27:41\n\
    \   |\n27 |                 let k = nums.iter().nth(j + 1).unwrap();\n   |   \
    \                                      ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |                 let k = nums.iter().nth((j + 1).try_into().unwrap()).unwrap();\n\
    \   |                                         +     +++++++++++++++++++++\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp810x8f8n.rs:28:38\n\
    \   |\n28 |                 let tmp_sum = (*k) + (*j);\n   |                 \
    \                     ^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp810x8f8n.rs:33:33\n\
    \   |\n33 |                     result.push(j);\n   |                        \
    \         "
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ num_sum: isize = 0;\n    for i in nums {\n        num_sum += i;\n    }\n   \
    \ num_sum\n        .iter()\n        .cloned()\n        .sort();\n    nums\n  \
    \      .iter()\n        .clone()\n        .sort_by_key(|i| num_sum.binary_repr().unwrap().parse::<isize>().unwrap());\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmppxct04wb.rs:16:10\n   |\n16 |         .iter()\n   |   \
    \       ^^^^ method not found in `isize`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmppxct04wb.rs:22:10\n\
    \   |\n22 |         .sort_by_key(|i| num_sum.binary_repr().unwrap().parse::<isize>().unwrap());\n\
    \   |          ^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror[E0599]: no method named `binary_repr` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmppxct04wb.rs:22:34\n   |\n22 |         .sort_by_key(|i|\
    \ num_sum.binary_repr().unwrap().parse::<isize>().unwrap());\n   |           \
    \                       ^^^^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppxct04wb.rs:10:41\n   |\n10 | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |    ---------------                      ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .map(|num| num.digits())\n        .flatten()\n      \
    \  .sorted_by_key(|num| num.iter().sum::<usize>())\n        .map(|num| num.clone())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpmr409pcv.rs:13:24\n   |\n13 |         .map(|num|\
    \ num.digits())\n   |                        ^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `sorted_by_key` found for struct `Flatten` in\
    \ the current scope\n  --> /tmp/tmpmr409pcv.rs:15:10\n   |\n15 |         .sorted_by_key(|num|\
    \ num.iter().sum::<usize>())\n   |          ^^^^^^^^^^^^^ method not found in\
    \ `Flatten<Map<std::slice::Iter<'_, isize>, _>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = vec![];\n\n    for i in nums.iter() {\n        let mut cur_digit =\
    \ 0;\n        for j in nums.iter() {\n            if j == i {\n              \
    \  continue;\n            }\n            cur_digit += *j;\n        }\n\n     \
    \   let cmp = cur_digit;\n        result.push(i);\n        result.push(cmp);\n\
    \    }\n\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpebtp2180.rs:24:21\n   |\n\
    24 |         result.push(cmp);\n   |                     ^^^\n   |           \
    \          |\n   |                     expected `&isize`, found `isize`\n   |\
    \                     help: consider borrowing here: `&cmp`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpebtp2180.rs:28:5\n   |\n10 | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n28 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n   \
    \           found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum: isize = 0;\n    let mut max_sum: isize = 0;\n    let mut idx = 0;\n   \
    \ let mut rev_nums = nums.rev();\n    while idx < rev_nums.len() {\n        let\
    \ mut cur = rev_nums.get(idx);\n        sum += cur;\n        max_sum = max(max_sum,\
    \ sum);\n        idx += 1;\n    }\n    let mut rev_sums = rev_nums.iter().cloned().collect::<Vec<isize>>();\n\
    \    rev_sums.reverse();\n    let mut idx = 0;\n    while idx < rev_sums.len()\
    \ {\n        let mut cur = rev_sums.get(idx);\n        if cur == max_sum {\n \
    \           break;\n        }\n        let pos = idx;\n        while pos < rev_sums.len()\
    \ && rev_sums[pos] == cur {\n            pos += 1;\n        }\n        rev_sums.remove(pos);\n\
    \        idx += 1;\n    }\n    rev_sums.reverse();\n    rev_sums.retain(|&i| i\
    \ != 0);\n    rev_sums.sort_unstable();\n    rev_sums\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpxzgdst7w.rs:18:19\n\
    \   |\n18 |         max_sum = max(max_sum, sum);\n   |                   ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmpxzgdst7w.rs:14:29\n    |\n14  |       let mut rev_nums = nums.rev();\n\
    \    |                               ^^^ `Vec<isize>` is not an iterator\n   \
    \ |\n    = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.iter().cloned().sort_by(|&x,\
    \ &y| {\n        if x > y {\n            x.to_digits().iter().cloned().chain(y.to_digits().iter().cloned())\n\
    \                .sum::<isize>()\n                .partial_cmp(y.to_digits().iter().cloned().sum::<isize>())\n\
    \                .unwrap()\n                .unwrap()\n                .zero()\n\
    \        } else {\n            y.to_digits().iter().cloned().chain(x.to_digits().iter().cloned())\n\
    \                .sum::<isize>()\n                .partial_cmp(x.to_digits().iter().cloned().sum::<isize>())\n\
    \                .unwrap()\n                .unwrap()\n                .zero()\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpmv9pyezj.rs:11:26\n   |\n11 |     nums.iter().cloned().sort_by(|&x,\
    \ &y| {\n   |                          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ s = nums.iter().cloned().collect::<Vec<_>>();\n    s.sort_by_key(|x| num2bin(x));\n\
    \    s\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num2bin` in this scope\n  --> /tmp/tmpzkq5j_nj.rs:12:23\n\
    \   |\n12 |     s.sort_by_key(|x| num2bin(x));\n   |                       ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|i| {\n        let\
    \ num: Vec<usize> = i.to_digits();\n        vec!num\n            .iter()\n   \
    \         .sum::<usize>()\n            .unwrap()\n    });\n    sorted_nums\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `num`\n  --> /tmp/tmpa_yt8shy.rs:14:13\n\
    \   |\n14 |         vec!num\n   |             ^^^ expected one of `(`, `[`, or\
    \ `{`\n\nerror[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpa_yt8shy.rs:13:33\n   |\n13 |         let\
    \ num: Vec<usize> = i.to_digits();\n   |                                 ^^^^^^^^^\
    \ method not found in `&isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_vec: Vec<isize> = vec![];\n    let mut min_sum = nums.reduce((0, vec![]));\n\
    \n    for num in nums {\n        let digits = num % 10;\n        let sum_of_digits\
    \ = digits.iter().sum::<isize>();\n\n        if sum_of_digits < min_sum.1 {\n\
    \            sorted_vec.push(num);\n            min_sum = (sum_of_digits, sorted_vec);\n\
    \        }\n    }\n    sorted_vec\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp6wkt08lq.rs:12:28\n\
    \    |\n12  |       let mut min_sum = nums.reduce((0, vec![]));\n    |       \
    \                       ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmp6wkt08lq.rs:16:36\n\
    \   |\n16 |         let sum_of_digits = digits.iter().sum::<isize>();\n   |  \
    \                                  ^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ vec = nums.clone();\n    vec.sort_unstable_by(|a, b| {\n        let a_digit\
    \ = a % 10;\n        let b_digit = b % 10;\n        if a_digit == b_digit {\n\
    \            a < b\n        } else {\n            a_digit < b_digit\n        }\n\
    \    });\n    vec\n}\n\nfn main() {\n    let candidate = order_by_points;\n  \
    \  assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2mh2v0g7.rs:16:13\n   |\n\
    16 |             a < b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2mh2v0g7.rs:18:13\n\
    \   |\n18 |             a_digit < b_digit\n   |             ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum_vec: Vec<isize> = Vec::new();\n    for i in nums.iter() {\n        sum_vec.push(i).unwrap();\n\
    \    }\n    sum_vec.sort_unstable();\n    let mut temp_vec: Vec<isize> = Vec::new();\n\
    \    for i in sum_vec.iter() {\n        if !temp_vec.contains(&i) {\n        \
    \    temp_vec.push(i);\n        }\n    }\n    temp_vec.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeg3u0xg1.rs:13:22\n   |\n\
    13 |         sum_vec.push(i).unwrap();\n   |                      ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |  \
    \       sum_vec.push(*i).unwrap();\n   |                      +\n\nerror[E0599]:\
    \ no method named `unwrap` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpeg3u0xg1.rs:13:25\n   |\n13 |         sum_vec.push(i).unwrap();\n  \
    \ |                         ^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeg3u0xg1.rs:19:27\n   |\n19 |             temp_vec.push(i);\n\
    \   |                           ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |             temp_vec.push(*i);\n\
    \   |                           +\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_cloned = nums;\n    let mut sum = 0;\n\n    while nums_cloned.len() > 0\
    \ {\n        sum += nums_cloned.last().unwrap();\n        nums_cloned.pop();\n\
    \    }\n\n    nums_cloned.sort_by_key(|&a| {\n        let mut sum = 0;\n     \
    \   for &n in a.iter() {\n            sum += n.to_digits().unwrap();\n       \
    \ }\n\n        sum\n    });\n    nums_cloned\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpaspgu347.rs:21:21\n   |\n21 |         for &n in a.iter()\
    \ {\n   |                     ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums.clone();\n    }\n    let mut cur = 0;\n    let mut cur_nums:\
    \ Vec<isize> = Vec::new();\n    cur_nums.push(0);\n    cur_nums.push(0);\n   \
    \ for (i, &num) in nums.iter().enumerate() {\n        if i > 0 {\n           \
    \ cur_nums.push(num as isize - cur_nums[i - 1]);\n        }\n        cur += num\
    \ as isize;\n        if cur > 0 {\n            cur_nums.push(cur);\n         \
    \   cur = 0;\n        }\n    }\n    let mut cur_sum = 0;\n    for &num in &cur_nums\
    \ {\n        cur_sum += num;\n    }\n    cur_nums.sort_unstable_by_key(|&num|\
    \ num.cmp(&cur_sum));\n    cur_nums.clone().reverse().collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmps2_88b7j.rs:33:32\n\
    \   |\n33 |     cur_nums.clone().reverse().collect()\n   |                   \
    \             ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_sorted = vec![];\n    for num in nums {\n        let mut index = 0;\n \
    \       let mut max_num: isize = 0;\n        while index != nums_sorted.len()\
    \ {\n            if nums_sorted[index] > num {\n                break;\n     \
    \       } else if nums_sorted[index] == num {\n                max_num = num;\n\
    \                break;\n            } else {\n                index += 1;\n \
    \           }\n        }\n        if index != nums_sorted.len() {\n          \
    \  nums_sorted.push(num);\n        }\n        if max_num != 0 {\n            for\
    \ idx in 0..nums_sorted.len() {\n                if nums_sorted[idx] > max_num\
    \ {\n                    nums_sorted.swap(idx, nums_sorted.len() - 1);\n     \
    \               break;\n                }\n            }\n        }\n    }\n \
    \   nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `nums_sorted` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmpe8moj7xk.rs:31:43\n   |\n31 |           \
    \          nums_sorted.swap(idx, nums_sorted.len() - 1);\n   |               \
    \      ----------------------^^^^^^^^^^^^^^^^^-----\n   |                    \
    \ |           |         |\n   |                     |           |         immutable\
    \ borrow occurs here\n   |                     |           mutable borrow later\
    \ used by call\n   |                     mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmpe8moj7xk.rs:31:43\n\
    \   |\n31 |                     nums_sorted.swap(idx, nums_sorted.len() - 1);\n\
    \   |                                           ^^^^^^^^^^^^^^^^^\nhelp: ...and\
    \ then using that local as the argument to this call\n  --> /tmp/tmpe8moj7xk.rs:31:21\n\
    \   |\n31 |                     nums_sorted.swap(idx, nums_sorted.len() - 1);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ counter = nums.iter().cloned().map(|x| x).collect::<Vec<isize>>();\n    for\
    \ (i, &v) in counter.iter().enumerate() {\n        if *v > 0 {\n            counter[i]\
    \ = *v + 1;\n        }\n    }\n    counter.sort_unstable_by_key(|&x| *x);\n  \
    \  let mut res = vec![];\n    for &v in counter {\n        res.push(v);\n    }\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpk76j31hg.rs:13:12\n\
    \   |\n13 |         if *v > 0 {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpk76j31hg.rs:14:26\n   |\n14 |        \
    \     counter[i] = *v + 1;\n   |                          ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpk76j31hg.rs:17:39\n   |\n\
    17 |     counter.sort_unstable_by_key(|&x| *x);\n   |                        \
    \               ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk76j31hg.rs:19:9\n\
    \   |\n19 |     for &v in counter {\n   |         ^^    ------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `v`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ max_sum = nums[0].checked_mul(nums[0].checked_add(nums[1])).unwrap();\n    for\
    \ num in nums[1..] {\n        let sum = num.checked_mul(num.checked_add(max_sum)).unwrap();\n\
    \        if sum > max_sum {\n            max_sum = sum;\n        }\n    }\n  \
    \  Vec::from(nums).sort_by(|a, b| a.checked_sub(b.checked_mul(max_sum))\n    \
    \    .unwrap().clone());\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphn2cmcj3.rs:11:43\n   |\n\
    11 |     let mut max_sum = nums[0].checked_mul(nums[0].checked_add(nums[1])).unwrap();\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0277]: the size for values of type\
    \ `[isize]` cannot be known at compilation time\n  --> /tmp/tmphn2cmcj3.rs:12:16\n\
    \   |\n12 |     for num in nums[1..] {\n   |                ^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[isize]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[isize]`\nhelp: consider borrowing here\n\
    \   |\n12 |     for num in &nums[1..] {\n   |                +\n12 |     for num\
    \ in &mut nums[1..] {\n   |                ++++\n\nerror[E0277]: `[isize]` is\
    \ not an iterator\n  --> /tmp/tmphn2cmcj3.rs:12:16\n   |\n12 |     for num in\
    \ nums[1..] {\n   |                ^^^^^^^^^ expected an implementor of trait\
    \ `IntoIterator`\n   |\n   = note: the trait bound `[isize]: IntoIterator` is\
    \ not satisfied\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `[isize]`\nhelp: consider borrowing here\n   |\n12 |    \
    \ for num in &nums[1..] {\n   |                +\n12 |     for num in &mut nums[1..]\
    \ {\n   |                ++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphn2cmcj3.rs:18:50\n\
    \   |\n18 |     Vec::from(nums).sort_by(|a, b| a.checked_sub(b.checked_mul(max_sum))\n\
    \   |                                                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphn2cmcj3.rs:18:36\n   |\n18 |       Vec::from(nums).sort_by(|a,\
    \ b| a.checked_sub(b.checked_mul(max_sum))\n   |  ____________________________________^\n\
    19 | |         .unwrap().clone());\n   | |_________________________^ expected\
    \ enum `std::cmp::Ordering`, f"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums\n    }\n\n    let mut nums_sorted = vec![];\n    let\
    \ mut index_sorted = vec![];\n\n    let mut max_sum = 0;\n    for num in nums.iter()\
    \ {\n        let num = num % 10;\n        let sum = num + num;\n        if sum\
    \ > max_sum {\n            max_sum = sum;\n        }\n    }\n\n    for i in nums.iter()\
    \ {\n        let i = i % 10;\n        if i == 0 {\n            continue;\n   \
    \     }\n        let index = i + i;\n        let num = i / 10;\n        let sum\
    \ = num + num;\n        if sum < max_sum {\n            break;\n        }\n  \
    \      if sum == max_sum {\n            nums_sorted.push(i);\n            index_sorted.push(index);\n\
    \        } else {\n            if index > index_sorted.len() {\n             \
    \   nums_sorted.push(num);\n                index_sorted.push(index);\n      \
    \      } else {\n                while index_sorted.len() < index {\n        \
    \            index_sorted.push(0);\n                }\n                nums_sorted.push(num);\n\
    \                index_sorted.push(index);\n            }\n        }\n    }\n\n\
    \    if nums_sorted.len() > nums.len() {\n        nums_sorted = nums_sorted.to_vec();\n\
    \        index_sorted = index_sorted.to_vec();\n    }\n\n    nums_sorted.sort();\n\
    \    index_sorted.sort();\n    nums_sorted.into_iter().cloned()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1g5qh4v1.rs:42:24\n   |\n\
    42 |             if index > index_sorted.len() {\n   |                       \
    \ ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    42 |             if index > index_sorted.len().try_into().unwrap() {\n   |   \
    \                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1g5qh4v1.rs:46:44\n   |\n46 |              \
    \   while index_sorted.len() < index {\n   |                                 \
    \           ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    46 |                 while index_sorted.len() < index.try_into().unwrap() {\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp1g5qh4v1.rs:62:29\n     |\n62   |     nums_sorted.into_iter().cloned()\n\
    \     |                             ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1g5qh4v1.rs:62:5\n   |\n10 | fn order_by_points(nums: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n62 |     nums_sorted.into_iter().cloned()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Cloned<std::vec::IntoIter<isize>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0271, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut ans = nums.clone();\n    let mut\
    \ sum: isize = 0;\n    for &num in &ans {\n        sum += num;\n    }\n    let\
    \ mut sum: isize = 1;\n    for &num in &ans {\n        sum += num;\n        let\
    \ j = *nums.binary_search_index(sum);\n        ans[j] = num;\n    }\n    return\
    \ ans;\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `binary_search_index` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpjus5tg5h.rs:22:23\n   |\n22 |         let\
    \ j = *nums.binary_search_index(sum);\n   |                       ^^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `binary_search`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Get sum\
    \ of each digits\n    let mut sums = nums.iter().map(|x| x.checked_mul(10).unwrap()).sum();\n\
    \n    // Sort based on the sums\n    nums.sort_unstable_by(|a, b| {\n        let\
    \ a_sum = a.checked_mul(10).unwrap();\n        let b_sum = b.checked_mul(10).unwrap();\n\
    \n        if a_sum == b_sum {\n            a.checked_mul(10).unwrap().cmp(&b.checked_mul(10).unwrap())\n\
    \        } else {\n            a_sum.cmp(&b_sum)\n        }\n    });\n\n    nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpqre9wnyj.rs:12:9\n\
    \   |\n12 |     let mut sums = nums.iter().map(|x| x.checked_mul(10).unwrap()).sum();\n\
    \   |         ^^^^^^^^ consider giving `sums` a type\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by(|a,\
    \ b| {\n        a.iter().sum::<usize>() - b.iter().sum::<usize>()\n    })\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpoejfn774.rs:12:11\n   |\n12 |         a.iter().sum::<usize>()\
    \ - b.iter().sum::<usize>()\n   |           ^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpoejfn774.rs:12:37\n   |\n12 |         a.iter().sum::<usize>()\
    \ - b.iter().sum::<usize>()\n   |                                     ^^^^ method\
    \ not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoejfn774.rs:11:5\n\
    \   |\n10 |   fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |     \
    \                                      ---------- expected `Vec<isize>` because\
    \ of return type\n11 | /     nums.sort_unstable_by(|a, b| {\n12 | |         a.iter().sum::<usize>()\
    \ - b.iter().sum::<usize>()\n13 | |     })\n   | |______^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sums: Vec<isize> = nums.iter().map(|n| n % 10).collect();\n    sums.sort_unstable();\n\
    \    nums.iter().map(|n| sums[n] * (n as usize) as isize).collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp6yt1v07_.rs:13:25\n\
    \   |\n13 |     nums.iter().map(|n| sums[n] * (n as usize) as isize).collect()\n\
    \   |                         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0606]: casting `&isize` as `usize` is invalid\n \
    \ --> /tmp/tmp6yt1v07_.rs:13:35\n   |\n13 |     nums.iter().map(|n| sums[n] *\
    \ (n as usize) as isize).collect()\n   |                                   ^-^^^^^^^^^^\n\
    \   |                                   ||\n   |                             \
    \      |help: dereference the expression: `*n`\n   |                         \
    \          cannot cast `&isize` as `usize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n\n    let mut min_sum = nums[0] as isize;\n\
    \    let mut max_sum = nums[0] as isize;\n\n    for i in 1..nums.len() {\n   \
    \     let sum_of_digits = nums[i] as isize;\n        if sum_of_digits < min_sum\
    \ {\n            min_sum = sum_of_digits;\n        }\n        if sum_of_digits\
    \ > max_sum {\n            max_sum = sum_of_digits;\n        }\n    }\n\n    let\
    \ mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x| {\n       \
    \ if x == -1 {\n            x\n        } else if x == 1 {\n            x\n   \
    \     } else {\n            let mut xs = x;\n            let mut ys = x;\n   \
    \         let mut z = x;\n            let mut q = x;\n            while ys < 10\
    \ {\n                if z == 0 {\n                    ys -= 1;\n             \
    \       z = 1;\n                } else if z == 1 {\n                    z -= 1;\n\
    \                } else {\n                    z -= 1;\n                    q\
    \ -= 1;\n                }\n            }\n            q -= 1;\n            while\
    \ ys > 10 {\n                if q == 0 {\n                    ys += 1;\n     \
    \               z = 1;\n                } else if q == 1 {\n                 \
    \   q += 1;\n                } else {\n                    q += 1;\n         \
    \           z -= 1;\n                }\n            }\n            (z * 10 + q)\
    \ as isize\n        }\n    });\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpw2j58k1k.rs:30:14\n\
    \   |\n30 |         if x == -1 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpw2j58k1k.rs:32:21\n   |\n32 |         } else if x == 1 {\n   |\
    \                     ^^ no implementation for `&isize == {integer}`\n   |\n \
    \  = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2j58k1k.rs:39:24\n\
    \   |\n39 |             while ys < 10 {\n   |                        ^^\n   |\
    \                        |\n   |                        expected `&isize`, found\
    \ integer\n   |                        help: consider borrowing here: `&10`\n\n\
    error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpw2j58k1k.rs:40:22\n\
    \   |\n40 |                 if z == 0 {\n   |                      ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpw2j58k1k.rs:41:21\n \
    \  |\n41 |                     ys -= 1;\n   |                     --^^^^^\n  \
    \ |                     |\n   |                     ca"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // initialize\
    \ result vector\n    let mut res: Vec<isize> = nums.clone();\n\n    // sort according\
    \ to sum of digits\n    for i in 1..res.len() {\n        // get sum digit and\
    \ compare with current element\n        let digit = res.iter().map(|x| x % 10).sum();\n\
    \        if digit > res[i - 1].to_digit() {\n            std::swap(res[i - 1],\
    \ res[i]);\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in crate `std`\n  --> /tmp/tmpib6kxd2e.rs:19:18\n\
    \   |\n19 |             std::swap(res[i - 1], res[i]);\n   |                 \
    \ ^^^^ not found in `std`\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\nhelp: if\
    \ you import `swap`, refer to it directly\n   |\n19 -             std::swap(res[i\
    \ - 1], res[i]);\n19 +             swap(res[i - 1], res[i]);\n   | \n\nerror[E0599]:\
    \ no method named `to_digit` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpib6kxd2e.rs:18:31\n   |\n18 |         if digit > res[i - 1].to_digit()\
    \ {\n   |                               ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ map = nums.iter().map(|&x| x).collect::<Vec<isize>>();\n\n    if map.len() ==\
    \ 0 {\n        vec![]\n    }\n    else {\n        let mut sum: isize = 0;\n  \
    \      map.sort_unstable_by(|&x, &y| {\n            sum += x.digits() + y.digits();\n\
    \            sum\n        });\n        map\n    }\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpk8crptis.rs:19:22\n   |\n19 |             sum += x.digits()\
    \ + y.digits();\n   |                      ^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpk8crptis.rs:19:35\n   |\n19 |             sum += x.digits()\
    \ + y.digits();\n   |                                   ^^^^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk8crptis.rs:20:13\n\
    \   |\n20 |             sum\n   |             ^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result: Vec<isize> = vec![];\n    for i in nums {\n        match i {\n     \
    \       i if i < 10 => {\n                result.push(i);\n            }\n   \
    \         _ => {\n                if let Some(found) = result.iter().find(|x|\
    \ x != i && x / 10 == i / 10) {\n                    result.swap(0, found);\n\
    \                } else {\n                    result.push(i);\n             \
    \   }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&isize` with `isize`\n  --> /tmp/tmpimkaldhj.rs:18:63\n\
    \   |\n18 |                 if let Some(found) = result.iter().find(|x| x != i\
    \ && x / 10 == i / 10) {\n   |                                               \
    \                ^^ no implementation for `&&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0369]: cannot divide `&&isize` by `{integer}`\n  --> /tmp/tmpimkaldhj.rs:18:73\n\
    \   |\n18 |                 if let Some(found) = result.iter().find(|x| x != i\
    \ && x / 10 == i / 10) {\n   |                                               \
    \                        - ^ -- {integer}\n   |                              \
    \                                         |\n   |                            \
    \                                           &&isize\n   |\nhelp: `/` can be used\
    \ on `isize`, you can dereference `x`\n   |\n18 |                 if let Some(found)\
    \ = result.iter().find(|x| x != i && *x / 10 == i / 10) {\n   |              \
    \                                                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpimkaldhj.rs:19:36\n   |\n19 |                     result.swap(0,\
    \ found);\n   |                                    ^^^^^ expected `usize`, found\
    \ `&isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 101
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ ordering = vec![];\n    let mut cur_sum = 0;\n    let mut cur_len = 0;\n   \
    \ let mut cur_pos = 0;\n    let mut cur_max = 0;\n    for n in nums.iter() {\n\
    \        let d = n % 10;\n        cur_sum += d;\n        cur_len = *n as usize;\n\
    \        if cur_sum > cur_max {\n            cur_max = cur_sum;\n            cur_pos\
    \ = cur_len;\n        }\n        cur_sum = cur_sum % 10;\n        ordering.push(*n);\n\
    \    }\n    ordering.push(nums[cur_pos]);\n    ordering.sort();\n    ordering.reverse();\n\
    \    ordering\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 11'', /tmp/tmpsheul9f0.rs:27:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum: isize = nums.iter().cloned().sum();\n    let mut nums_rev: Vec<isize> =\
    \ nums.clone();\n    nums_rev.sort();\n    for (idx, n) in nums_rev.iter().enumerate()\
    \ {\n        sum += n.unwrap() as isize;\n        if sum < 0 {\n            sum\
    \ = 0;\n            idx += 1;\n        }\n        nums[idx] = n;\n    }\n    nums_rev\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpqs4rapm1.rs:15:18\n   |\n15 |         sum +=\
    \ n.unwrap() as isize;\n   |                  ^^^^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqs4rapm1.rs:20:21\n   |\n20 |\
    \         nums[idx] = n;\n   |         ---------   ^ expected `isize`, found `&isize`\n\
    \   |         |\n   |         expected due to the type of this binding\n   |\n\
    help: consider dereferencing the borrow\n   |\n20 |         nums[idx] = *n;\n\
    \   |                     +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        // find the maximum digit\n        let\
    \ max_digit = nums.iter().filter_map(|x| x.to_string().chars()).max().unwrap().to_string();\n\
    \        // find the position of the digit which has maximum sum\n        let\
    \ idx = nums.iter().position(|x| x.to_string().chars().count() > max_digit.chars().count());\n\
    \n        // get the digits in the given position\n        let mut sorted_nums\
    \ = nums.iter().skip(idx).copied().collect::<Vec<_>>();\n        // add up their\
    \ digits\n        for &n in nums {\n            sorted_nums.iter_mut().enumerate().for_each(|(_,\
    \ v)| {\n                *v += n.to_string().chars().count() - max_digit.chars().count();\n\
    \            });\n        }\n        // reverse the order of the elements in the\
    \ given position\n        for &n in sorted_nums[..idx] {\n            n.to_owned().reverse();\n\
    \        }\n        sorted_nums\n    }\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvuzxidyi.rs:15:52\n   |\n\
    15 |         let max_digit = nums.iter().filter_map(|x| x.to_string().chars()).max().unwrap().to_string();\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `Chars`\n   |\n   = note: expected enum\
    \ `Option<_>`\n            found struct `Chars<'_>`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n15 |         let max_digit = nums.iter().filter_map(|x| Some(x.to_string().chars())).max().unwrap().to_string();\n\
    \   |                                                    +++++               \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvuzxidyi.rs:20:48\n\
    \   |\n20 |         let mut sorted_nums = nums.iter().skip(idx).copied().collect::<Vec<_>>();\n\
    \   |                                                ^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvuzxidyi.rs:22:13\n\
    \   |\n22 |         for &n in nums {\n   |             ^^    ---- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `n`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \  --> /tmp/tmpvuzxidyi.rs:28:19\n   |\n28 |         for &n in sorted_nums[..idx]\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `RangeTo<Option<usize>>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeTo<usize> as SliceIndex<[T]>>\n\
    \             <RangeTo<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeTo<Option<usize>>>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanation"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sums = Vec::new();\n    for i in nums.iter() {\n        sums.push(i.checksum_digits()!);\n\
    \    }\n\n    sums.sort_by_key(|sum| nums.iter().position(|&i| sum == i).unwrap());\n\
    \n    nums.iter().filter(|&x| sums.iter().position(|&y| y == x).unwrap_or(-1)\
    \ == x).collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n  \
    \  assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `!`\n\
    \  --> /tmp/tmpfa69jbs3.rs:13:38\n   |\n13 |         sums.push(i.checksum_digits()!);\n\
    \   |                                      ^ expected one of `)`, `,`, `.`, `?`,\
    \ or an operator\n\nerror[E0599]: no method named `checksum_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpfa69jbs3.rs:13:21\n \
    \  |\n13 |         sums.push(i.checksum_digits()!);\n   |                    \
    \ ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `checked_div`\n\
    \nerror[E0277]: can't compare `&_` with `isize`\n  --> /tmp/tmpfa69jbs3.rs:16:58\n\
    \   |\n16 |     sums.sort_by_key(|sum| nums.iter().position(|&i| sum == i).unwrap());\n\
    \   |                                                          ^^ no implementation\
    \ for `&_ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&_`\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpfa69jbs3.rs:18:73\n   |\n18 |     nums.iter().filter(|&x| sums.iter().position(|&y|\
    \ y == x).unwrap_or(-1) == x).collect()\n   |                                \
    \                                         ^^\n   |                           \
    \                                              |\n   |                       \
    \                                                  cannot apply unary operator\
    \ `-`\n   |                                                                  \
    \       help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfa69jbs3.rs:18:80\n   |\n18 |     nums.iter().filter(|&x|\
    \ sums.iter().position(|&y| y == x).unwrap_or(-1) == x).collect()\n   |      \
    \                                                                          ^ expected\
    \ `usize`, found `&isize`\n\nerror[E0277]: a value of type `Vec<isize>` cannot\
    \ be built from an iterator over elements of type `&isize`\n    --> /tmp/tmpfa69jbs3.rs:18:83\n\
    \     |\n18   |     nums.iter().filter(|&x| sums.iter().position(|&y| y == x).unwra"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_sorted = nums;\n    if nums.len() == 0 {\n        nums_sorted = vec![];\n\
    \    }\n\n    // Add all digits as strings to our temporary sorted vector\n  \
    \  for i in 0..(nums.len() - 1) {\n        let mut num = nums[i];\n        let\
    \ mut s = String::new();\n        while num > 0 {\n            s.push((num % 10)\
    \ as char);\n            num /= 10;\n        }\n        nums_sorted.push(s.len()\
    \ as isize);\n    }\n\n    // Sort our temporary sorted vector by sum of digits\
    \ descending\n    nums_sorted.sort();\n\n    // Copy back sorted numbers to our\
    \ original vector\n    for i in 0..(nums.len() - 1) {\n        nums[i] = nums_sorted[i]\
    \ as isize;\n    }\n\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpw56ugyei.rs:21:20\n\
    \   |\n21 |             s.push((num % 10) as char);\n   |                    ^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpw56ugyei.rs:21:20\n   |\n21 |             s.push((num % 10) as char);\n\
    \   |                    ^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums = nums;\n    let mut total = 0;\n    for x in nums {\n        total +=\
    \ x;\n    }\n    nums.sort();\n    let mut reversed_nums = nums.clone();\n   \
    \ reversed_nums.reverse();\n    reversed_nums.sort();\n    let mut index = 0;\n\
    \    let mut i = 0;\n    while i < reversed_nums.len() {\n        if total - reversed_nums[i]\
    \ < total {\n            index = i;\n            i += 1;\n        } else {\n \
    \           index += 1;\n            i -= 1;\n        }\n    }\n    nums[index..nums.len()].sort();\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpc12rsrpo.rs:16:5\n\
    \    |\n11  |     let mut nums = nums;\n    |         -------- move occurs because\
    \ `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n12\
    \  |     let mut total = 0;\n13  |     for x in nums {\n    |              ----\
    \ `nums` moved due to this implicit call to `.into_iter()`\n...\n16  |     nums.sort();\n\
    \    |     ^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n13  |     for x in &nums {\n    |              +\n\nerror[E0502]: cannot\
    \ borrow `nums` as immutable because it is also borrowed as mutable\n  --> /tmp/tmpc12rsrpo.rs:31:17\n\
    \   |\n31 |     nums[index..nums.len()].sort();\n   |     ------------^^^^^^^^^^-\n\
    \   |     |           |\n   |     |           immutable borrow occurs here\n \
    \  |     mutable borrow occurs here\n   |     mutable borrow later used here\n\
    \   |\nhelp: try adding a local storing this...\n  --> /tmp/tmpc12rsrpo.rs:31:17\n\
    \   |\n31 |     nums[index..nums.len()].sort();\n   |                 ^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpc12rsrpo.rs:31:5\n   |\n\
    31 |     nums[index..nums.len()].sort();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0502.\nFor more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = nums.clone();\n\n    sorted_nums.sort_by_key(|x| {\n        order_by_digits(&x.to_string())\n\
    \    });\n\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `order_by_digits` in this scope\n  -->\
    \ /tmp/tmpjbb4ze5m.rs:14:9\n   |\n14 |         order_by_digits(&x.to_string())\n\
    \   |         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut nums_set = nums.iter().cloned().collect::<BTreeSet<_>>();\n\
    \    nums_set.sort();\n    for num in nums.iter() {\n        nums[nums.iter().position(|el|\
    \ el == num).unwrap()] = nums_set.remove(&num);\n    }\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n  --> /tmp/tmp_ylim9zn.rs:14:55\n\
    \   |\n14 |     let mut nums_set = nums.iter().cloned().collect::<BTreeSet<_>>();\n\
    \   |                                                       ^^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::BTreeSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort();\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `nums` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp1yi7van8.rs:11:5\n   |\n10 | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                    ---- help: consider changing\
    \ this to be mutable: `mut nums`\n11 |     nums.sort();\n   |     ^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    }\n    else {\n        let mut index = 0;\n        let\
    \ mut current_sum = 0;\n        let mut current_sum_investor = isize::MAX;\n \
    \       for num in nums {\n            index += num;\n            current_sum\
    \ += num;\n            current_sum_investor = isize::max(current_sum_investor,\
    \ current_sum);\n        }\n        let mut sorted_nums = nums.iter().cloned().collect();\n\
    \        if current_sum_investor == isize::MAX {\n            for num in nums\
    \ {\n                sorted_nums.insert(index, num);\n                index +=\
    \ num;\n            }\n        } else {\n            let mut min_pos = 0;\n  \
    \          let mut max_pos = sorted_nums.len();\n            loop {\n        \
    \        if current_sum_investor < isize::MAX - sorted_nums[min_pos] {\n     \
    \               break;\n                }\n                let pos = min_pos;\n\
    \                while pos + 1 < max_pos && isize::MAX - sorted_nums[pos + 1]\
    \ > current_sum_investor {\n                    pos += 1;\n                }\n\
    \                sorted_nums[pos] = sorted_nums[pos];\n                sorted_nums.swap(pos,\
    \ min_pos);\n                max_pos = pos;\n                min_pos += 1;\n \
    \           }\n        }\n        sorted_nums\n    }\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpf8uobu32.rs:26:17\n\
    \   |\n23 |         let mut sorted_nums = nums.iter().cloned().collect();\n  \
    \ |             --------------- consider giving `sorted_nums` a type\n...\n26\
    \ |                 sorted_nums.insert(index, num);\n   |                 ^^^^^^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums: Vec<isize> = nums.iter().cloned().collect();\n    let mut min_val: isize\
    \ = nums.iter().cloned().min_by_key(|x| {\n        nums.iter().filter(|&x| x >=\
    \ x).sum::<isize>()\n    }).unwrap();\n    let mut max_val: isize = nums.iter().cloned().max_by_key(|x|\
    \ {\n        nums.iter().filter(|&x| x >= x).sum::<isize>()\n    }).unwrap();\n\
    \    let mut nums = nums.iter().cloned().collect();\n    for x in nums {\n   \
    \     x.set_zero();\n        nums = nums.iter().cloned().collect();\n        if\
    \ x < min_val {\n            min_val = x;\n        }\n        if x > max_val {\n\
    \            max_val = x;\n        }\n    }\n    let mut nums = nums.iter().cloned().collect();\n\
    \    nums.sort_unstable_by(|a, b| {\n        let a1 = a.checked_mul(10).unwrap();\n\
    \        let a2 = a.checked_div(10).unwrap();\n        let b1 = b.checked_mul(10).unwrap();\n\
    \        let b2 = b.checked_div(10).unwrap();\n        let mut c = a1.checked_add(b1).unwrap();\n\
    \        if a2 < b2 {\n            c = c.checked_sub(b2).unwrap();\n        }\n\
    \        c.ok()\n    });\n    return nums.into_iter().map(|x| x.unwrap()).collect::<Vec<_>>();\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp7mofos5z.rs:20:9\n\
    \   |\n19 |     for x in nums {\n   |              ---- the element type for this\
    \ iterator is not specified\n20 |         x.set_zero();\n   |         ^ cannot\
    \ infer type\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|a,\
    \ b| {\n        Self::count_digits(a) - Self::count_digits(b)\n    });\n\n   \
    \ nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Self`\n  --> /tmp/tmphfhabdih.rs:12:9\n\
    \   |\n12 |         Self::count_digits(a) - Self::count_digits(b)\n   |      \
    \   ^^^^ use of undeclared type `Self`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Self`\n  --> /tmp/tmphfhabdih.rs:12:33\n   |\n12 |     \
    \    Self::count_digits(a) - Self::count_digits(b)\n   |                     \
    \            ^^^^ use of undeclared type `Self`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // We need\
    \ a vector with size at least as large as the\n    // smallest element in the\
    \ original vector\n    let mut results: Vec<isize> = Vec::with_capacity(nums.len());\n\
    \    let mut sorted_nums = nums;\n\n    loop {\n        // Take the sum of the\
    \ current elements digits\n        let mut sum = 0;\n        for n in &mut sorted_nums\
    \ {\n            sum += *n as isize;\n        }\n\n        // If this sum is different\
    \ from the current largest sum,\n        // we found a new largest sum; store\
    \ the new sum\n        // and remove it from the current list\n        if sum\
    \ != results.last().unwrap() {\n            results.push(sum);\n            sorted_nums.remove(0).unwrap();\n\
    \        }\n        // If there are no more elements to process, we done\n   \
    \     if sorted_nums.is_empty() {\n            break;\n        }\n    }\n\n  \
    \  results\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpccxj3vnu.rs:26:19\n   |\n\
    26 |         if sum != results.last().unwrap() {\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n26 |         if sum != *results.last().unwrap() {\n   |               \
    \    +\n\nerror[E0599]: no method named `unwrap` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpccxj3vnu.rs:28:35\n   |\n28 |             sorted_nums.remove(0).unwrap();\n\
    \   |                                   ^^^^^^ method not found in `isize`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = vec![];\n    let mut digit_sum = 0;\n    for (i, &num) in nums.iter().enumerate()\
    \ {\n        if num > 0 {\n            digit_sum += num as isize;\n        }\n\
    \        if i < nums.len() - 1 && num == nums[(i + 1) as usize] {\n          \
    \  result.append(nums.len() - i - 1);\n        }\n    }\n    if digit_sum > 0\
    \ {\n        result.sort();\n        result.iter().for_each(|i| nums[i] = nums.iter().skip(i).next().unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxzwsw277.rs:18:27\n   |\n\
    18 |             result.append(nums.len() - i - 1);\n   |                    \
    \       ^^^^^^^^^^^^^^^^^^ expected `&mut Vec<_>`, found `usize`\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                           found type\
    \ `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&_`\n  -->\
    \ /tmp/tmpxzwsw277.rs:23:36\n   |\n23 |         result.iter().for_each(|i| nums[i]\
    \ = nums.iter().skip(i).next().unwrap());\n   |                              \
    \      ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `&_`\n   =\
    \ note: required because of the requirements on the impl of `Index<&_>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxzwsw277.rs:23:63\n   |\n23 |\
    \         result.iter().for_each(|i| nums[i] = nums.iter().skip(i).next().unwrap());\n\
    \   |                                                               ^ expected\
    \ `usize`, found reference\n   |\n   = note:   expected type `usize`\n       \
    \    found reference `&_`\nhelp: consider dereferencing the borrow\n   |\n23 |\
    \         result.iter().for_each(|i| nums[i] = nums.iter().skip(*i).next().unwrap());\n\
    \   |                                                               +\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums\n    }\n\n    // Create an array with sum of each number\
    \ in nums\n    let mut sums: Vec<_> = nums.iter().map(|x| x.to_digit()).collect();\n\
    \n    // Find max index\n    let max_idx = sums.iter().max_by_key(|&x| x).unwrap();\n\
    \n    // Sort the numbers from max index to 0\n    for i in max_idx..0 {\n   \
    \     sums[i] = -sums[i];\n    }\n\n    // Return sorted vectors\n    sums.iter().map(|x|\
    \ x as isize).collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpm_irfod_.rs:16:50\n   |\n16 |     let mut sums:\
    \ Vec<_> = nums.iter().map(|x| x.to_digit()).collect();\n   |                \
    \                                  ^^^^^^^^ method not found in `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm_irfod_.rs:22:23\n   |\n22 |     for i in max_idx..0\
    \ {\n   |                       ^\n   |                       |\n   |        \
    \               expected reference, found integer\n   |                      \
    \ help: consider borrowing here: `&0`\n   |\n   = note: expected reference `&_`\n\
    \                   found type `{integer}`\n\nerror[E0277]: the trait bound `&_:\
    \ Step` is not satisfied\n  --> /tmp/tmpm_irfod_.rs:22:14\n   |\n22 |     for\
    \ i in max_idx..0 {\n   |              ^^^^^^^^^^ the trait `Step` is not implemented\
    \ for `&_`\n   |\n   = help: the following other types implement trait `Step`:\n\
    \             char\n             i128\n             i16\n             i32\n  \
    \           i64\n             i8\n             isize\n             u128\n    \
    \       and 5 others\n   = note: required because of the requirements on the impl\
    \ of `Iterator` for `std::ops::Range<&_>`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `std::ops::Range<&_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `&_`\n  --> /tmp/tmpm_irfod_.rs:23:9\n \
    \  |\n23 |         sums[i] = -sums[i];\n   |         ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&_`\n   = note: required because of the requirements\
    \ on the impl of `Index<&_>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot\
    \ be indexed by `&_`\n  --> /tmp/tmpm_irfod_.rs:23:20\n   |\n23 |         sums[i]\
    \ = -sums[i];\n   |                    ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&_`\n   = note: required because of the requirements on the impl of `Index<&_>`\
    \ for `Vec<_>`\n\nerror: aborting d"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ res = nums;\n    let mut sum = nums.iter().fold(0, |s, &x| s + x);\n    res.sort_by_key(|x|\
    \ match x % sum {\n        0 => Ordering::Less,\n        d => Ordering::Greater(*d\
    \ as u64, sum),\n    });\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp8eld_8zp.rs:14:14\n   |\n14 |         0 => Ordering::Less,\n   |   \
    \           ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp8eld_8zp.rs:15:14\n\
    \   |\n15 |         d => Ordering::Greater(*d as u64, sum),\n   |            \
    \  ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::cmp::Ordering;\n   |\n1  | use std::sync::atomic::Ordering;\n\
    \   |\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp8eld_8zp.rs:15:32\n\
    \   |\n15 |         d => Ordering::Greater(*d as u64, sum),\n   |            \
    \                    ^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0433, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Create\
    \ a map that has index as the sum of digits as key and original number as value.\n\
    \    let mut index_to_nums: HashMap<isize, isize> = nums.iter().cloned().collect();\n\
    \    let mut nums_without_index = 0;\n    // Sort numbers based on the sum of\
    \ their digits to their original order in original vector.\n    let mut sorted_nums:\
    \ Vec<isize> = Vec::new();\n    while nums_without_index < nums.len() {\n    \
    \    // Sum up the digits and save it as the index for later sorting.\n      \
    \  let index = index_to_nums\n            .iter()\n            .map(|i| i.0.checked_add(i.1.checked_mul(10usize).ok_or(nums.len()).unwrap()).ok_or(nums.len()).unwrap())\n\
    \            .sum::<isize>()\n            .unwrap();\n        // If index is the\
    \ last number in original vector, break the loop and return the sorted vector.\n\
    \        if nums_without_index == nums.len() {\n            sorted_nums = nums.iter().cloned().collect();\n\
    \            break;\n        }\n        // Add next number with its index to the\
    \ sorted vector.\n        sorted_nums.push(nums[nums_without_index]);\n      \
    \  index_to_nums.remove(&index);\n        nums_without_index += 1;\n    }\n  \
    \  sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp7l5utzci.rs:12:28\n\
    \   |\n12 |     let mut index_to_nums: HashMap<isize, isize> = nums.iter().cloned().collect();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 101
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ index = 0;\n    let mut sum = 0;\n    let mut vec: Vec<isize> = nums.clone();\n\
    \    loop {\n        sum += vec[index];\n        index += 1;\n        if sum ==\
    \ 0 {\n            break;\n        }\n    }\n    vec\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpcfrrnxvp.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_clone = nums.clone();\n    let mut sorted_nums = nums.clone();\n    let\
    \ mut current_sum = 0;\n    let mut index = 0;\n    loop {\n        if nums_clone.is_empty()\
    \ {\n            return sorted_nums;\n        }\n        if current_sum > 0 {\n\
    \            // update index in sorted list from nums\n            sorted_nums[index]\
    \ = nums_clone.iter().find(|&x| x % 10 == current_sum % 10).unwrap();\n      \
    \  } else {\n            // update index in sorted list from nums\n          \
    \  sorted_nums[index] = nums_clone.iter().find(|&x| x > 0).unwrap();\n       \
    \ }\n        index += 1;\n        current_sum += nums_clone.iter().find(|&x| x\
    \ % 10 == 0).unwrap();\n    }\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpapt3fw1g.rs:21:34\n   |\n\
    21 |             sorted_nums[index] = nums_clone.iter().find(|&x| x % 10 == current_sum\
    \ % 10).unwrap();\n   |             ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |             sorted_nums[index] = *nums_clone.iter().find(|&x| x %\
    \ 10 == current_sum % 10).unwrap();\n   |                                  +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpapt3fw1g.rs:24:66\n   |\n24 |\
    \             sorted_nums[index] = nums_clone.iter().find(|&x| x > 0).unwrap();\n\
    \   |                                                                  ^\n   |\
    \                                                                  |\n   |   \
    \                                                               expected `&isize`,\
    \ found integer\n   |                                                        \
    \          help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpapt3fw1g.rs:24:34\n   |\n24 |             sorted_nums[index] =\
    \ nums_clone.iter().find(|&x| x > 0).unwrap();\n   |             ------------------\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |             sorted_nums[index]\
    \ = *nums_clone.iter().find(|&x| x > 0).unwrap();\n   |                      \
    \            +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 101
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = Vec::new();\n    let mut sum = 0;\n\n    for n in nums.iter().cloned()\
    \ {\n        sum += n;\n        sorted_nums.push(n);\n    }\n\n    sorted_nums.sort_by_key(|n|\
    \ {\n        sum -= n;\n        sum\n    });\n\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -12, -11, -1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpngz8uf_c.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ cur = 0;\n    let mut res = nums.clone();\n    for n in nums {\n        while\
    \ cur < n {\n            cur += res.iter().take(cur.to_digits().len() + 1).sum::<isize>()\
    \ as isize;\n            if cur == n {\n                res.swap(cur, 0);\n  \
    \              cur = 0;\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpbsst2r9u.rs:15:40\n   |\n15 |             cur +=\
    \ res.iter().take(cur.to_digits().len() + 1).sum::<isize>() as isize;\n   |  \
    \                                      ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbsst2r9u.rs:17:26\n   |\n17 |\
    \                 res.swap(cur, 0);\n   |                          ^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |                 res.swap(cur.try_into().unwrap(),\
    \ 0);\n   |                             ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        let mut digit_sum = nums.iter().map(|n|\
    \ {\n            n % 10\n        }).sum();\n\n        let mut i = 0;\n       \
    \ nums.sort_by(|a, b| {\n            match a + b {\n                a if a < 0\
    \ || b < 0 => {\n                    std::cmp::Ordering::Less\n              \
    \  }\n                a if b >= 0 => {\n                    std::cmp::Ordering::Greater\n\
    \                }\n                b => {\n                    let diff = a -\
    \ b as isize;\n                    std::cmp::Ordering::Greater if diff > digit_sum\
    \ => {\n                        digit_sum += diff;\n                        a\
    \ - b\n                    }\n                    a if a > b => {\n          \
    \              digit_sum += b;\n                        b - a\n              \
    \      }\n                }\n            }\n        });\n        nums\n    }\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmplzso8bo4.rs:29:49\n   |\n29 |            \
    \         std::cmp::Ordering::Greater if diff > digit_sum => {\n   |         \
    \                                        ^^ expected one of 8 possible tokens\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplzso8bo4.rs:21:35\n   |\n21 |\
    \                 a if a < 0 || b < 0 => {\n   |                             \
    \      ^\n   |                                   |\n   |                     \
    \              expected `&isize`, found integer\n   |                        \
    \           help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplzso8bo4.rs:24:27\n   |\n24 |                 a if b >= 0 => {\n\
    \   |                           ^\n   |                           |\n   |    \
    \                       expected `&isize`, found integer\n   |               \
    \            help: consider borrowing here: `&0`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ res = nums.clone();\n    let mut min_sum = nums.iter().fold(0, |a, b| a + b);\n\
    \    let mut min_idx = nums.iter().cloned().collect::<Vec<_>>().len();\n    for\
    \ &i in nums.iter() {\n        let tmp_sum = i.checked_mul(&min_sum).unwrap();\n\
    \        if tmp_sum < min_sum {\n            min_sum = tmp_sum;\n            min_idx\
    \ = i;\n        }\n    }\n    let mut reversed = Vec::<isize>::new();\n    reversed.extend_from_slice(&nums.iter().rev());\n\
    \    res.swap_remove(reversed);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkth013ob.rs:15:37\n   |\n\
    15 |         let tmp_sum = i.checked_mul(&min_sum).unwrap();\n   |           \
    \                          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n15 -         let tmp_sum = i.checked_mul(&min_sum).unwrap();\n\
    15 +         let tmp_sum = i.checked_mul(min_sum).unwrap();\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkth013ob.rs:18:23\n   |\n13 |     let mut min_idx\
    \ = nums.iter().cloned().collect::<Vec<_>>().len();\n   |                    \
    \   ---------------------------------------------- expected due to this value\n\
    ...\n18 |             min_idx = i;\n   |                       ^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkth013ob.rs:22:32\n\
    \   |\n22 |     reversed.extend_from_slice(&nums.iter().rev());\n   |        \
    \                        ^^^^^^^^^^^^^^^^^^ expected slice `[isize]`, found struct\
    \ `Rev`\n   |\n   = note: expected reference `&[isize]`\n              found reference\
    \ `&Rev<std::slice::Iter<'_, isize>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkth013ob.rs:23:21\n   |\n23 |     res.swap_remove(reversed);\n   | \
    \                    ^^^^^^^^ expected `usize`, found struct `Vec`\n   |\n   =\
    \ note: expected type `usize`\n            found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 101
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ ret: Vec<isize> = nums.clone();\n    let mut sum: isize = 0;\n\n    for i in\
    \ ret.iter() {\n        sum += i;\n    }\n\n    for i in ret.iter_mut() {\n  \
    \      *i += *i / sum;\n    }\n\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpultywnpk.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = vec![];\n    let mut max_sum_with_points = nums[0];\n    let mut pos\
    \ = 0;\n    for num in nums {\n        if num < 0 {\n            result.push(num);\n\
    \            pos = 0;\n            continue;\n        }\n        let sum_with_points\
    \ = sum_of_digits(&num);\n        if sum_with_points > max_sum_with_points {\n\
    \            max_sum_with_points = sum_with_points;\n            pos = num;\n\
    \        } else {\n            result.push(pos);\n            pos = num;\n   \
    \     }\n    }\n    result.push(pos);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_of_digits` in this scope\n  -->\
    \ /tmp/tmp4yoxycmh.rs:20:31\n   |\n20 |         let sum_with_points = sum_of_digits(&num);\n\
    \   |                               ^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sums: Vec<isize> = nums.into_iter().map(|x| x.to_string().chars().sum()).collect();\n\
    \    sums.sort_unstable();\n    sums.into_iter().map(|x| nums.iter().position(|&i|\
    \ i == x).unwrap()).collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `isize: Sum<char>` is not satisfied\n   \
    \ --> /tmp/tmpu_ysx2yp.rs:11:79\n     |\n11   |     let mut sums: Vec<isize> =\
    \ nums.into_iter().map(|x| x.to_string().chars().sum()).collect();\n     |   \
    \                                                                            ^^^\
    \ the trait `Sum<char>` is not implemented for `isize`\n     |\n     = help: the\
    \ following other types implement trait `Sum<A>`:\n               <f32 as Sum<&'a\
    \ f32>>\n               <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n \
    \              <f64 as Sum>\n               <i128 as Sum<&'a i128>>\n        \
    \       <i128 as Sum>\n               <i16 as Sum<&'a i16>>\n               <i16\
    \ as Sum>\n             and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpu_ysx2yp.rs:13:74\n     |\n13\
    \   |     sums.into_iter().map(|x| nums.iter().position(|&i| i == x).unwrap()).collect()\n\
    \     |                                                                      \
    \    ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=usize>`\n\
    \     |\n     = help: the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ total_sum = 0;\n    for i in nums.iter() {\n        let digit = i as usize;\n\
    \        total_sum += digit;\n    }\n    nums.sort_by_key(|i| {\n        let digit\
    \ = i as usize;\n        total_sum - digit\n    });\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmpiionz5fr.rs:13:21\n\
    \   |\n13 |         let digit = i as usize;\n   |                     -^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&isize` as\
    \ `usize`\n   |                     help: dereference the expression: `*i`\n\n\
    error[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmpiionz5fr.rs:17:21\n\
    \   |\n17 |         let digit = i as usize;\n   |                     -^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&isize` as\
    \ `usize`\n   |                     help: dereference the expression: `*i`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for i in 0..(x.len() - 1) {\n         \
    \   sum += x[i];\n        }\n        sum\n    });\n    nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmp18jn4yqa.rs:13:24\n   |\n13 |         for i in\
    \ 0..(x.len() - 1) {\n   |                        ^^^ method not found in `&isize`\n\
    \nerror[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp18jn4yqa.rs:14:20\n\
    \   |\n14 |             sum += x[i];\n   |                    ^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .map(|x| {\n            if x > 0 {\n                x.checked_div(10).unwrap()\n\
    \            } else {\n                0\n            }\n        })\n        .filter(|x|\
    \ x > 0)\n        .sum::<usize>()\n        .unwrap()\n        + 1\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb6abjmjr.rs:14:20\n   |\n\
    14 |             if x > 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&isize`, found integer\n   |        \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb6abjmjr.rs:20:25\n   |\n20 |         .filter(|x| x > 0)\n   |\
    \                         ^\n   |                         |\n   |            \
    \             expected `&isize`, found integer\n   |                         help:\
    \ consider borrowing here: `&0`\n\nerror[E0277]: the trait bound `usize: Sum<isize>`\
    \ is not satisfied\n    --> /tmp/tmpb6abjmjr.rs:21:10\n     |\n21   |        \
    \ .sum::<usize>()\n     |          ^^^ the trait `Sum<isize>` is not implemented\
    \ for `usize`\n     |\n     = help: the following other types implement trait\
    \ `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n\
    \               <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n         \
    \      <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16\
    \ as Sum<&'a i16>>\n               <i16 as Sum>\n             and 20 others\n\
    note: required by a bound in `std::iter::Iterator::sum`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpb6abjmjr.rs:22:10\n\
    \   |\n22 |         .unwrap()\n   |          ^^^^^^ method not found in `usize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    std::mem::swap(&mut nums_copy, &mut nums.rev());\n\
    \    let mut new_nums = nums.clone();\n    new_nums.sort();\n    new_nums.reverse();\n\
    \    nums_copy.extend(&mut new_nums);\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpcfhbhjae.rs:12:46\n\
    \    |\n12  |       std::mem::swap(&mut nums_copy, &mut nums.rev());\n    |  \
    \                                              ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0277]: the trait bound `Vec<isize>: Extend<&mut\
    \ isize>` is not satisfied\n  --> /tmp/tmpcfhbhjae.rs:16:22\n   |\n16 |     nums_copy.extend(&mut\
    \ new_nums);\n   |               ------ ^^^^^^^^^^^^^ the trait `Extend<&mut isize>`\
    \ is not implemented for `Vec<isize>`\n   |               |\n   |            \
    \   required by a bound introduced by this call\n   |\n   = help: the following\
    \ other types implement trait `Extend<A>`:\n             <Vec<T, A> as Extend<&'a\
    \ T>>\n             <Vec<T, A> as Extend<T>>\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum: usize = 0;\n\n    for i in nums {\n        if i > 0 {\n            sum\
    \ += i as usize;\n        }\n    }\n\n    let mut result: Vec<isize> = nums.clone();\n\
    \    result.sort();\n    for n in result {\n        if n == sum {\n          \
    \  result.swap(0, result.iter().position(|&n| n == sum)).unwrap();\n        }\
    \ else {\n            sum += n as usize;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgjcbz553.rs:22:17\n   |\n\
    22 |         if n == sum {\n   |                 ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |         if n == sum.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgjcbz553.rs:23:61\n   |\n23 |             result.swap(0, result.iter().position(|&n|\
    \ n == sum)).unwrap();\n   |                                                 \
    \            ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    23 |             result.swap(0, result.iter().position(|&n| n == sum.try_into().unwrap())).unwrap();\n\
    \   |                                                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgjcbz553.rs:23:28\n   |\n23 |\
    \             result.swap(0, result.iter().position(|&n| n == sum)).unwrap();\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<usize>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpgjcbz553.rs:23:67\n\
    \   |\n23 |             result.swap(0, result.iter().position(|&n| n == sum)).unwrap();\n\
    \   |                                                                   ^^^^^^\
    \ method not found in `()`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = vec![];\n    let mut counts = vec![];\n\n    for num in nums {\n  \
    \      let mut count = 0;\n        while num > 0 {\n            count += num %\
    \ 10;\n            num /= 10;\n        }\n        counts.push(count);\n    }\n\
    \n    for (i, count) in counts.iter().enumerate() {\n        let index = nums.iter().skip(i).find(|x|\
    \ x >= count);\n        result.push(nums[index]);\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpex1ygile.rs:24:55\n   |\n\
    24 |         let index = nums.iter().skip(i).find(|x| x >= count);\n   |     \
    \                                                  ^^^^^ expected `&isize`, found\
    \ `isize`\n   |\n   = note: expected reference `&&isize`\n              found\
    \ reference `&isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `Option<&isize>`\n  --> /tmp/tmpex1ygile.rs:25:21\n   |\n25 |         result.push(nums[index]);\n\
    \   |                     ^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `Option<&isize>`\n   = note: required because of the requirements on the\
    \ impl of `Index<Option<&isize>>` for `Vec<isize>`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ num_with_zeros = Vec::new();\n    let mut num_without_zeros = Vec::new();\n\n\
    \    for n in nums {\n        if n % 10 == 0 {\n            num_with_zeros.push(n);\n\
    \        } else {\n            num_without_zeros.push(n);\n        }\n    }\n\n\
    \    if num_with_zeros.is_empty() {\n        return num_without_zeros;\n    }\n\
    \    if num_without_zeros.is_empty() {\n        return num_with_zeros;\n    }\n\
    \n    let mut min_sum = num_with_zeros.iter().map(|n| n * 10).sum::<isize>();\n\
    \    let mut max_sum = num_without_zeros.iter().map(|n| n * 10).sum::<isize>();\n\
    \n    let mut min_val = num_with_zeros.iter().take(1).unwrap();\n    let mut max_val\
    \ = num_without_zeros.iter().take(1).unwrap();\n\n    for i in 0..num_with_zeros.len()\
    \ {\n        let max_val_digit = max_val % 10;\n        let min_val_digit = min_val\
    \ % 10;\n\n        if min_val_digit < max_val_digit {\n            if min_sum\
    \ < max_sum {\n                min_sum = min_sum + min_val % 10;\n           \
    \     min_val = min_val / 10;\n            }\n            if max_sum < min_sum\
    \ {\n                max_sum = max_sum + max_val % 10;\n                max_val\
    \ = max_val / 10;\n            }\n        } else {\n            if min_sum < max_sum\
    \ {\n                max_sum = max_sum - min_val % 10;\n                max_val\
    \ = max_val / 10;\n            }\n            if max_sum < min_sum {\n       \
    \         min_sum = min_sum - min_val % 10;\n                min_val = min_val\
    \ / 10;\n            }\n        }\n    }\n\n    let mut sorted_nums = Vec::new();\n\
    \n    for i in 0..num_with_zeros.len() {\n        sorted_nums.push((i + min_sum).abs());\n\
    \    }\n\n    for i in 0..num_without_zeros.len() {\n        sorted_nums.push((i\
    \ + max_sum).abs());\n    }\n\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmplr74zi9t.rs:32:53\n   |\n32 |     let mut\
    \ min_val = num_with_zeros.iter().take(1).unwrap();\n   |                    \
    \                                 ^^^^^^ method not found in `std::iter::Take<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `unwrap` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmplr74zi9t.rs:33:56\n   |\n33 |     let mut\
    \ max_val = num_without_zeros.iter().take(1).unwrap();\n   |                 \
    \                                       ^^^^^^ method not found in `std::iter::Take<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplr74zi9t.rs:63:31\n\
    \   |\n63 |         sorted_nums.push((i + min_sum).abs());\n   |             \
    \                  ^^^^^^^ expected `usize`, found `isize`\n\nerror[E0599]: no\
    \ method named `abs` found for type `usize` in the current scope\n  --> /tmp/tmplr74zi9t.rs:63:40\n\
    \   |\n63 |         sorted_nums.push((i + min_sum).abs());\n   |             \
    \                           ^^^ method not found in `usize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmplr74zi9t.rs:63:29\n   |\n63 |        \
    \ sorted_nums.push((i + min_sum).abs());\n   |                             ^ no\
    \ implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplr74zi9t.rs:67:31\n\
    \   |\n67 |         sorted_nums.push((i + max_sum).abs());\n   |             \
    \                  ^^^^^^^ expected `usize`, found `isize`\n\nerror[E0599]: no\
    \ method named `abs` found for type `usize` in the current scope\n  --> /tmp/"
  stdout: ''
  timestamp: 1659976139
- exit_code: -1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_len = nums.len();\n    if nums_len == 0 {\n        return vec![];\n   \
    \ }\n    let mut res = vec![];\n    let mut i = 0;\n    while i < nums_len {\n\
    \        let mut min_point = i;\n        let mut min_sum = 0;\n        for j in\
    \ 0..nums_len {\n            if min_sum > nums[j] {\n                min_point\
    \ = j;\n                min_sum = nums[j];\n            }\n        }\n       \
    \ res.push(nums[min_point]);\n        for j in (i + 1..nums_len).rev() {\n   \
    \         let next_sum = nums[j];\n            if next_sum > nums[min_point] {\n\
    \                min_point = j;\n                min_sum = next_sum;\n       \
    \     }\n        }\n        i = min_point;\n    }\n    res.reverse();\n    return\
    \ res;\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976144
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums = nums.to_owned();\n\n    let mut i = 0;\n    while i < nums.len() {\n\
    \        let mut j = i;\n\n        while j < nums.len() && nums[j] % 10 == 0 {\n\
    \            j += 1; // skip zeros\n        }\n        let sum = nums[j].checked_mul(10).checked_add(nums[i]).unwrap();\n\
    \n        i += 1;\n        while i < nums.len() && sum == nums[i].checked_mul(10).checked_add(nums[j]).unwrap()\
    \ {\n            i += 1;\n            j += 1;\n        }\n\n        if i < nums.len()\
    \ {\n            nums[i].checked_sub(sum).unwrap();\n        }\n    }\n\n    nums.to_owned()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpavg2ebay.rs:20:43\n   |\n20 |         let sum\
    \ = nums[j].checked_mul(10).checked_add(nums[i]).unwrap();\n   |             \
    \                              ^^^^^^^^^^^ method not found in `Option<isize>`\n\
    \nerror[E0599]: no method named `checked_add` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpavg2ebay.rs:23:64\n   |\n23 |         while i < nums.len()\
    \ && sum == nums[i].checked_mul(10).checked_add(nums[j]).unwrap() {\n   |    \
    \                                                            ^^^^^^^^^^^ method\
    \ not found in `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum: usize = 0;\n    let mut indexes = vec![];\n\n    // For each item in nums\n\
    \    for n in nums {\n        // Get sum of its digits\n        sum += n % 10;\n\
    \        // Insert its index to the vector\n        indexes.push(n);\n    }\n\n\
    \    // Sort indexes according to their sum of digits\n    indexes.sort_by_key(|x|\
    \ sum % 10);\n\n    // Return indexes in ascending order\n    indexes.iter()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuu70a4k3.rs:17:16\n   |\n\
    17 |         sum += n % 10;\n   |                ^^^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpuu70a4k3.rs:17:13\n\
    \   |\n17 |         sum += n % 10;\n   |             ^^ no implementation for\
    \ `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuu70a4k3.rs:26:5\n\
    \   |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                  ---------- expected `Vec<isize>` because of\
    \ return type\n...\n26 |     indexes.iter()\n   |     ^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `std::slice::Iter`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `std::slice::Iter<'_, isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted = nums.clone();\n    sorted.sort_by_key(|x| sum_digits(x) as isize);\n\
    \    sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_digits` in this scope\n  --> /tmp/tmpjsexvqsv.rs:12:28\n\
    \   |\n12 |     sorted.sort_by_key(|x| sum_digits(x) as isize);\n   |        \
    \                    ^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        nums.into_iter().cloned()\n         \
    \   .map(|n| {\n                let mut digits: Vec<isize> = vec![0; 10];\n  \
    \              digits.extend_from_slice(&n.to_string().chars().take(3));\n   \
    \             digits.sort_unstable();\n                let mut ans = 0.;\n   \
    \             for digit in digits {\n                    ans += digit;\n     \
    \           }\n                ans as isize\n            })\n            .collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpka1opkxb.rs:14:26\n     |\n14   |         nums.into_iter().cloned()\n\
    \     |                          ^^^^^^ expected reference, found `isize`\n  \
    \   |\n     = note: expected reference `&_`\n                     found type `isize`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `map` exists\
    \ for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpka1opkxb.rs:15:14\n   |\n15 |               .map(|n|\
    \ {\n   |                ^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `{float}`\n  --> /tmp/tmpka1opkxb.rs:21:25\n  \
    \ |\n21 |                     ans += digit;\n   |                         ^^ no\
    \ implementation for `{float} += isize`\n   |\n   = help: the trait `AddAssign<isize>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0271, E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted = nums.iter().cloned().collect();\n    for &num in &sorted {\n      \
    \  let mut sum_of_digits = 0;\n        for d in nums.iter().cloned().collect::<Vec<isize>>()\
    \ {\n            sum_of_digits += *d as usize;\n        }\n        sorted.swap(sorted.iter().filter(|&x|\
    \ *x == *num).cloned().collect::<Vec<_>>(), |x, y| x.cmp(&y).unwrap());\n    }\n\
    \    sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmprilubfmh.rs:15:30\n\
    \   |\n15 |             sum_of_digits += *d as usize;\n   |                  \
    \            ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ counter: isize = 0;\n    let mut nums_temp = nums.clone();\n    let mut min:\
    \ isize = nums[0];\n    let mut max = nums[0];\n    let mut min_index: usize =\
    \ nums[0];\n    let mut max_index: usize = nums[0];\n    for n in nums.iter()\
    \ {\n        counter += n;\n        if counter < min {\n            min = counter;\n\
    \            min_index = n;\n        }\n        if counter > max {\n         \
    \   max = counter;\n            max_index = n;\n        }\n    }\n    nums_temp.sort_unstable_by_key(|n|\
    \ n.checked_add(&min).checked_sub(&max).unwrap());\n    nums_temp.swap(0, min_index);\n\
    \    nums_temp.swap(min_index, max_index);\n    nums_temp\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbha7tuzd.rs:15:32\n   |\n\
    15 |     let mut min_index: usize = nums[0];\n   |                        -----\
    \   ^^^^^^^ expected `usize`, found `isize`\n   |                        |\n \
    \  |                        expected due to this\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    15 |     let mut min_index: usize = nums[0].try_into().unwrap();\n   |       \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbha7tuzd.rs:16:32\n   |\n16 |     let mut max_index: usize\
    \ = nums[0];\n   |                        -----   ^^^^^^^ expected `usize`, found\
    \ `isize`\n   |                        |\n   |                        expected\
    \ due to this\n   |\nhelp: you can convert an `isize` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |     let mut max_index: usize = nums[0].try_into().unwrap();\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbha7tuzd.rs:21:25\n   |\n15 |     let mut min_index:\
    \ usize = nums[0];\n   |                        ----- expected due to this type\n\
    ...\n21 |             min_index = n;\n   |                         ^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbha7tuzd.rs:25:25\n\
    \   |\n16 |     let mut max_index: usize = nums[0];\n   |                    \
    \    ----- expected due to this type\n...\n25 |             max_index = n;\n \
    \  |                         ^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbha7tuzd.rs:28:54\n   |\n28 |     nums_temp.sort_unstable_by_key(|n|\
    \ n.checked_add(&min).checked_sub(&max).unwrap());\n   |                     \
    \                                 ^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider removing the borrow\n   |\n28 -     nums_temp.sort_unstable_by_key(|n|\
    \ n.checked_add(&min).checked_sub(&max).unwrap());\n28 +     nums_temp.sort_unstable_by_key(|n|\
    \ n.checked_add(min).checked_sub(&max).unwrap());\n   | \n\nerror[E0"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by_key(|x|\
    \ {\n        x.checked_mul(10).unwrap().powf(10)\n            .checked_add(&nums.iter().filter_map(|&x|\
    \ x.checked_mul(10).unwrap().powf(10)).sum()).unwrap()\n    });\n    nums\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `powf` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpce3awso6.rs:12:36\n   |\n12 |         x.checked_mul(10).unwrap().powf(10)\n\
    \   |                                    ^^^^ help: there is an associated function\
    \ with a similar name: `pow`\n\nerror[E0599]: no method named `powf` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpce3awso6.rs:13:82\n   |\n13\
    \ |             .checked_add(&nums.iter().filter_map(|&x| x.checked_mul(10).unwrap().powf(10)).sum()).unwrap()\n\
    \   |                                                                        \
    \          ^^^^ help: there is an associated function with a similar name: `pow`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 101
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ s = nums.iter().sum::<isize>();\n    let mut idx = 0;\n    let mut res = vec![nums[idx]];\
    \ \n    while s < nums[idx].checked_add(1).unwrap() {\n        idx += 1;\n   \
    \     res.insert(0, nums[idx]);\n        s = nums[idx].checked_add(1).unwrap();\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpn4b06apa.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_unstable_by_key(|&num|\
    \ num.iter().cloned().map(|&n| n as i32).sum());\n    nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmplum6415t.rs:11:42\n   |\n11 |     nums.sort_unstable_by_key(|&num|\
    \ num.iter().cloned().map(|&n| n as i32).sum());\n   |                       \
    \                   ^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .sort_by_key(|(n, _)| {\n     \
    \       let mut accum: isize = 0;\n            for &n in nums[..n].iter() {\n\
    \                accum = accum + n % 10;\n            }\n            accum\n \
    \       })\n        .map(|(n, &x)| x)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Enumerate`\
    \ in the current scope\n  --> /tmp/tmp9qy0uz11.rs:14:10\n   |\n14 |         .sort_by_key(|(n,\
    \ _)| {\n   |          ^^^^^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 101
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_clone = nums.clone();\n    let mut sum = 0;\n    let mut last_sum = 0;\n\
    \    let mut min_idx = vec![0];\n    let mut max_idx = vec![0];\n    for i in\
    \ 0..nums_clone.len() {\n        sum += nums_clone[i];\n        if sum > last_sum\
    \ {\n            last_sum = sum;\n            min_idx[0] = i;\n        }\n   \
    \     if sum < last_sum {\n            last_sum = sum;\n            max_idx[0]\
    \ = i;\n        }\n    }\n    for i in 0..min_idx.len() {\n        nums_clone[min_idx[i]]\
    \ = nums[min_idx[i]];\n    }\n    for i in 0..max_idx.len() {\n        nums_clone[max_idx[i]]\
    \ = nums[max_idx[i]];\n    }\n    nums_clone\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpaw1wp9m2.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // initialize\
    \ sum variable\n    let mut sum: usize = 0;\n    // initialize index variable\n\
    \    let mut idx: usize = 0;\n\n    // traverse through all numbers\n    for n\
    \ in nums {\n        // add digits of current number to sum\n        sum += n.to_digits();\n\
    \        // check if sum of digits of current number is higher than previous's\n\
    \        if sum > 0 {\n            // swap numbers\n            swap(&mut nums[idx],\
    \ &mut nums[nums.len() - 1]);\n            // update index to last element of\
    \ original vector\n            idx += 1;\n        }\n    }\n\n    // return sorted\
    \ vector\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp4e7_w24_.rs:23:13\n\
    \   |\n23 |             swap(&mut nums[idx], &mut nums[nums.len() - 1]);\n   |\
    \             ^^^^ not found in this scope\n   |\nhelp: consider importing one\
    \ of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp4e7_w24_.rs:19:18\n   |\n19 |         sum += n.to_digits();\n\
    \   |                  ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut s = nums.iter().sum::<isize>();\n\
    \    let mut nums = nums.clone();\n    let mut swapped = false;\n\n    while !nums.is_empty()\
    \ {\n        if s == nums.iter().sum::<isize>() {\n            // Same sum, break\
    \ ties by comparing indices\n            if swapped {\n                nums.swap_remove(0);\n\
    \            } else {\n                nums.remove(0).unwrap();\n            }\n\
    \        } else {\n            // Different sums, add and swap to make them in\
    \ order\n            s.push(*nums.iter().max().unwrap());\n            swapped\
    \ = nums.is_empty();\n        }\n        s = nums.iter().sum::<isize>();\n   \
    \ }\n\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpcgo6dmp3.rs:25:32\n   |\n25 |                 nums.remove(0).unwrap();\n\
    \   |                                ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `push` found for type `isize` in the current scope\n  --> /tmp/tmpcgo6dmp3.rs:29:15\n\
    \   |\n29 |             s.push(*nums.iter().max().unwrap());\n   |           \
    \    ^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .filter(|(_, x)| x.1 % 10 != 0)\n\
    \        .map(|(_, x)| x.0)\n        .collect::<Vec<_>>()\n        .sort_unstable_by(|a,\
    \ b| a.partial_cmp(&b).unwrap())\n        .collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `&&isize`\n  --> /tmp/tmpfpd29izh.rs:14:28\n\
    \   |\n14 |         .filter(|(_, x)| x.1 % 10 != 0)\n   |                    \
    \        ^\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpfpd29izh.rs:15:25\n\
    \   |\n15 |         .map(|(_, x)| x.0)\n   |                         ^\n\nerror[E0599]:\
    \ `()` is not an iterator\n  --> /tmp/tmpfpd29izh.rs:18:10\n   |\n18 |       \
    \  .collect::<Vec<_>>()\n   |          ^^^^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0599, E0609.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    debug_assert!(nums.len()\
    \ == nums.iter().map(|x| x as isize).sum::<isize>() != 0);\n    let mut counter\
    \ = nums.iter().cloned().map(|x| x as isize).sum();\n    counter = counter % 10;\n\
    \    if counter == 0 {\n        counter = 10;\n    }\n    nums\n        .iter()\n\
    \        .map(|x| x as isize)\n        .map(|x| x % 10)\n        .enumerate()\n\
    \        .map(|(i, x)| {\n            if i > 0\n                && ((counter +\
    \ (*x).abs() % 10) as isize) <= (i as isize)\n            {\n                nums.swap(i\
    \ - 1, i);\n            }\n            x\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpzw3afjwj.rs:11:30\n\
    \   |\n11 |     debug_assert!(nums.len() == nums.iter().map(|x| x as isize).sum::<isize>()\
    \ != 0);\n   |                              ^^                               \
    \                 ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzw3afjwj.rs:11:33\n\
    \   |\n11 |     debug_assert!(nums.len() == nums.iter().map(|x| x as isize).sum::<isize>()\
    \ != 0);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n11 |     debug_assert!(nums.len()\
    \ == nums.iter().map(|x| x as isize).sum::<isize>().try_into().unwrap() != 0);\n\
    \   |                                                                        \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzw3afjwj.rs:11:83\n\
    \   |\n11 |     debug_assert!(nums.len() == nums.iter().map(|x| x as isize).sum::<isize>()\
    \ != 0);\n   |                                                               \
    \                    ^ expected `bool`, found integer\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpzw3afjwj.rs:24:32\n   |\n24 |        \
    \         && ((counter + (*x).abs() % 10) as isize) <= (i as isize)\n   |    \
    \                            ^^^^\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpzw3afjwj.rs:11:53\n   |\n11 |     debug_assert!(nums.len()\
    \ == nums.iter().map(|x| x as isize).sum::<isize>() != 0);\n   |             \
    \                                        -^^^^^^^^^\n   |                    \
    \                                 |\n   |                                    \
    \                 cannot cast `&isize` as `isize`\n   |                      \
    \                               help: dereference the expression: `*x`\n\nerror[E0606]:\
    \ casting `&isize` as `isize` is invalid\n  --> /tmp/tmpzw3afjwj.rs:19:18\n  \
    \ |\n19 |         .map(|x| x as isize)\n   |                  -^^^^^^^^^\n   |\
    \                  |\n   |                  cannot ca"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|&x|\
    \ {\n        let mut sum = 0;\n        for digit in x.to_string().chars() {\n\
    \            sum += digit;\n        }\n        sum\n    });\n    nums\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `char` to `{integer}`\n  --> /tmp/tmpj_xeopz1.rs:14:17\n\
    \   |\n14 |             sum += digit;\n   |                 ^^ no implementation\
    \ for `{integer} += char`\n   |\n   = help: the trait `AddAssign<char>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = vec![];\n\n    nums\n        .iter()\n        .enumerate()\n      \
    \  .sort_by(|(i, _)| {\n            compute_sum(&nums[i..]).0\n        })\n  \
    \      .for_each(|(i, _)| {\n            result.push(nums[i]);\n        });\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `compute_sum` in this scope\n  --> /tmp/tmp80df003j.rs:17:13\n\
    \   |\n17 |             compute_sum(&nums[i..]).0\n   |             ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `sort_by` found for\
    \ struct `Enumerate` in the current scope\n  --> /tmp/tmp80df003j.rs:16:10\n \
    \  |\n16 |         .sort_by(|(i, _)| {\n   |          ^^^^^^^ method not found\
    \ in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_len = nums.len();\n    while nums_len > 1 {\n        let mut mid = nums_len\
    \ / 2;\n        let left_sum = nums[mid];\n        let right_sum = nums[mid];\n\
    \n        while nums_len > mid {\n            nums[mid] = nums[mid - 1];\n   \
    \         mid = mid / 2;\n        }\n        nums[mid] = left_sum - right_sum;\n\
    \        nums_len = mid - 1;\n    }\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `nums` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp5s13tw7e.rs:18:13\n   |\n10 | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                    ---- help: consider changing\
    \ this to be mutable: `mut nums`\n...\n18 |             nums[mid] = nums[mid -\
    \ 1];\n   |             ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `nums` as mutable, as it is not declared as mutable\n  --> /tmp/tmp5s13tw7e.rs:21:9\n\
    \   |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \             ---- help: consider changing this to be mutable: `mut nums`\n...\n\
    21 |         nums[mid] = left_sum - right_sum;\n   |         ^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    debug_assert!(nums.len()\
    \ >= 1);\n    let mut min_num = nums[0];\n    let mut max_num = nums[0];\n\n \
    \   for n in nums.iter().rev() {\n        debug_assert!(n > 0);\n        debug_assert!(n\
    \ >= min_num);\n        debug_assert!(n < max_num);\n        let diff = n - min_num;\n\
    \        let new_min = min_num + diff / 10;\n        let new_max = max_num - diff\
    \ / 10;\n        min_num = new_min;\n        max_num = new_max;\n    }\n\n   \
    \ if nums.len() == 1 {\n        return nums;\n    }\n\n    debug_assert!(min_num\
    \ > 0);\n    debug_assert!(max_num < 10);\n\n    let mut ans = vec![];\n\n   \
    \ for (i, n) in nums.iter().enumerate() {\n        let diff = n - min_num;\n \
    \       if diff < 0 {\n            ans.push(max_num - diff / 10);\n        } else\
    \ {\n            ans.push(min_num + diff / 10);\n        }\n    }\n\n    ans\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0he97s83.rs:16:27\n   |\n\
    16 |         debug_assert!(n > 0);\n   |                           ^\n   |   \
    \                        |\n   |                           expected `&isize`,\
    \ found integer\n   |                           help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0he97s83.rs:17:28\n  \
    \ |\n17 |         debug_assert!(n >= min_num);\n   |                         \
    \   ^^^^^^^\n   |                            |\n   |                         \
    \   expected `&isize`, found `isize`\n   |                            help: consider\
    \ borrowing here: `&min_num`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0he97s83.rs:18:27\n\
    \   |\n18 |         debug_assert!(n < max_num);\n   |                        \
    \   ^^^^^^^\n   |                           |\n   |                          \
    \ expected `&isize`, found `isize`\n   |                           help: consider\
    \ borrowing here: `&max_num`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    use std::cmp::Ordering;\n\
    \n    let mut sorted_idxs = vec![0; nums.len()];\n    let mut nums_sum: usize\
    \ = 0;\n    for n in nums {\n        nums_sum += n;\n        sorted_idxs[nums_sum\
    \ - n] = n;\n    }\n\n    let mut idxs = vec![];\n    for i in 0..nums_sum {\n\
    \        idxs.push(i);\n    }\n\n    for i in sorted_idxs.iter().rev() {\n   \
    \     idxs.remove(i);\n    }\n\n    idxs.iter().cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp4x4wnxqp.rs:11:9\n\
    \   |\n11 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4x4wnxqp.rs:16:21\n   |\n16 |         nums_sum += n;\n\
    \   |                     ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add-assign `isize` to `usize`\n  --> /tmp/tmp4x4wnxqp.rs:16:18\n   |\n16 | \
    \        nums_sum += n;\n   |                  ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4x4wnxqp.rs:17:32\n\
    \   |\n17 |         sorted_idxs[nums_sum - n] = n;\n   |                     \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract\
    \ `isize` from `usize`\n  --> /tmp/tmp4x4wnxqp.rs:17:30\n   |\n17 |         sorted_idxs[nums_sum\
    \ - n] = n;\n   |                              ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4x4wnxqp.rs:26:21\n   |\n26 |         idxs.remove(i);\n\
    \   |                     ^ expected `usize`, found `&isize`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built fr"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum = 0;\n    for n in nums.iter() {\n        sum += *n;\n    }\n    nums.sort();\n\
    \    for n in nums.iter() {\n        *n -= sum;\n    }\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `nums` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_oqbmiwm.rs:15:5\n   |\n10 | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                    ---- help: consider changing\
    \ this to be mutable: `mut nums`\n...\n15 |     nums.sort();\n   |     ^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0594]: cannot assign to `*n`, which is behind\
    \ a `&` reference\n  --> /tmp/tmp_oqbmiwm.rs:17:9\n   |\n16 |     for n in nums.iter()\
    \ {\n   |              ----------- this iterator yields `&` references\n17 | \
    \        *n -= sum;\n   |         ^^^^^^^^^ `n` is a `&` reference, so the data\
    \ it refers to cannot be written\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0594, E0596.\nFor more information\
    \ about an error, try `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut sum: Vec<isize> = nums\n     \
    \   .iter()\n        .map(|x| x.digits(10))\n        .collect();\n    for i in\
    \ 0..nums.len() {\n        for j in i..nums.len() {\n            if sum[j] >=\
    \ sum[i] {\n                let tmp = sum[j];\n                sum[j] = sum[i];\n\
    \                sum[i] = tmp;\n            }\n        }\n    }\n    nums.iter().map(|x|\
    \ sum.iter().filter(|&y| x == y).unwrap()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpmehx98tv.rs:16:20\n   |\n16 |         .map(|x|\
    \ x.digits(10))\n   |                    ^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `unwrap` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpmehx98tv.rs:27:56\n   |\n27 |     nums.iter().map(|x| sum.iter().filter(|&y|\
    \ x == y).unwrap()).collect()\n   |                                          \
    \              ^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmpmehx98tv.rs:27:43: 27:54]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut vec = vec![];\n    let mut totals\
    \ = vec![0; nums.len()];\n\n    for &num in nums {\n        for &digits in &nums\
    \ {\n            totals[digits] += digits;\n        }\n    }\n\n    for &num in\
    \ nums {\n        for &digits in &nums {\n            if totals[digits] >= num\
    \ {\n                vec.push(num);\n                vec.push(digits);\n     \
    \           totals[digits] -= num;\n            }\n        }\n    }\n\n    vec\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6uacxbky.rs:18:9\n   |\n\
    18 |     for &num in nums {\n   |         ^^^^    ---- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6uacxbky.rs:20:13\n\
    \   |\n20 |             totals[digits] += digits;\n   |             ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6uacxbky.rs:24:9\n   |\n24 |     for &num in\
    \ nums {\n   |         ^^^^    ---- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `num`\n   |\n   = note: \
    \  expected type `isize`\n           found reference `&_`\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6uacxbky.rs:26:16\n\
    \   |\n26 |             if totals[digits] >= num {\n   |                ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6uacxbky.rs:29:17\n\
    \   |\n29 |                 totals[digits] -= num;\n   |                 ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `Sli"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // sort\
    \ the original vector according to the sum of their digits\n    let mut nums_sorted\
    \ = nums.clone();\n    nums_sorted.sort_by(|a, b| {\n        a + b\n    });\n\
    \    // sort the indexes of sorted items according to their original position\n\
    \    nums_sorted.sort_by(|a, b| {\n        nums[a]\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp726wcjw4.rs:14:9\n   |\n\
    14 |         a + b\n   |         ^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmp726wcjw4.rs:18:9\n   |\n18 |         nums[a]\n   |         ^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .cloned()\n        .enumerate()\n        .sort_by(|(i,\
    \ &item)| {\n            if item.checked_add(i).abs() < 0 {\n                Some(item.checked_sub(i).abs())\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .map(|(i, item)| item.checked_add(i))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmp469jfq0l.rs:15:10\n   |\n15 |         .sort_by(|(i,\
    \ &item)| {\n   |          ^^^^^^^ method not found in `Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum_nums: isize = 0;\n    for num in nums {\n        sum_nums += num as isize;\n\
    \    }\n    let mut new_nums = vec![];\n    let mut i = 0;\n    while sum_nums\
    \ > 0 {\n        if sum_nums > 1 {\n            if sum_nums % 10 == 0 {\n    \
    \            new_nums.push(i);\n            }\n            i += 1;\n         \
    \   sum_nums /= 10;\n        }\n        sum_nums -= 1;\n    }\n    new_nums.swap(vec![],\
    \ nums);\n    new_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw32hoyn7.rs:27:19\n   |\n\
    27 |     new_nums.swap(vec![], nums);\n   |                   ^^^^^^ expected\
    \ `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n      \
    \      found struct `Vec<_>`\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw32hoyn7.rs:27:27\n   |\n27 |     new_nums.swap(vec![],\
    \ nums);\n   |                           ^^^^ expected `usize`, found struct `Vec`\n\
    \   |\n   = note: expected type `usize`\n            found struct `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.iter().rev().enumerate().filter(|(_,\
    \ i)| {\n        i != 0 && nums.iter().map(|&x| x.pow(nums.len() - i - 1).unwrap()).sum().abs()\
    \ < nums.iter().map(|&x| x.pow(nums.len() - i).unwrap()).sum().abs()\n    }).collect().reverse().clone()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&isize` with `{integer}`\n  --> /tmp/tmp3zc08rft.rs:12:11\n\
    \   |\n12 | ...   i != 0 && nums.iter().map(|&x| x.pow(nums.len() - i - 1).unwrap()).sum().abs()\
    \ < nums.iter().map(|&x| x.pow(nums.len() - i).unwrap(...\n   |         ^^ no\
    \ implementation for `&&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: cannot subtract `&&isize`\
    \ from `usize`\n  --> /tmp/tmp3zc08rft.rs:12:57\n   |\n12 | ...   i != 0 && nums.iter().map(|&x|\
    \ x.pow(nums.len() - i - 1).unwrap()).sum().abs() < nums.iter().map(|&x| x.pow(nums.len()\
    \ - i).unwrap(...\n   |                                                      \
    \ ^ no implementation for `usize - &&isize`\n   |\n   = help: the trait `Sub<&&isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp3zc08rft.rs:12:66\n   |\n12 | ...\
    \   i != 0 && nums.iter().map(|&x| x.pow(nums.len() - i - 1).unwrap()).sum().abs()\
    \ < nums.iter().map(|&x| x.pow(nums.len() - i).unwrap(...\n   |              \
    \                                                  ^^^^^^ method not found in\
    \ `isize`\n\nerror[E0277]: cannot subtract `&&isize` from `usize`\n  --> /tmp/tmp3zc08rft.rs:12:128\n\
    \   |\n12 | ...abs() < nums.iter().map(|&x| x.pow(nums.len() - i).unwrap()).sum().abs()\n\
    \   |                                                  ^ no implementation for\
    \ `usize - &&isize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_sum = nums.iter().map(|x| *x).sum();\n    let mut max_val = nums.iter().max().unwrap_or(0);\n\
    \    while nums_sum != max_val {\n        max_val = nums.iter().max().unwrap_or(0);\n\
    \        let mut pos = max_val;\n        for val in nums.iter() {\n          \
    \  if val > pos {\n                break;\n            }\n            pos = val\
    \ + max_val as isize;\n        }\n        nums_sum = pos.saturating_add(nums.iter().map(|x|\
    \ *x).sum());\n    }\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg26e73q2.rs:12:51\n   |\n\
    12 |     let mut max_val = nums.iter().max().unwrap_or(0);\n   |             \
    \                                      ^\n   |                               \
    \                    |\n   |                                                 \
    \  expected `&isize`, found integer\n   |                                    \
    \               help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg26e73q2.rs:14:47\n   |\n14 |         max_val = nums.iter().max().unwrap_or(0);\n\
    \   |                                               ^\n   |                  \
    \                             |\n   |                                        \
    \       expected `&isize`, found integer\n   |                               \
    \                help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg26e73q2.rs:20:19\n   |\n15 |         let mut pos = max_val;\n\
    \   |                       ------- expected due to this value\n...\n20 |    \
    \         pos = val + max_val as isize;\n   |                   ^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&(val + max_val as isize)`\n\
    \nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpg26e73q2.rs:13:20\n\
    \   |\n13 |     while nums_sum != max_val {\n   |                    ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpg26e73q2.rs:20:25\n   |\n20 |             pos = val\
    \ + max_val as isize;\n   |                         -------^^^^^^^^^\n   |   \
    \                      |\n   |                         cannot cast `&isize` as\
    \ `isize`\n   |                  "
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut points: Vec<isize> = Vec::new();\n\
    \    for i in nums.iter() {\n        let digit = i as usize;\n        let index\
    \ = digits.index((digit as u32).abs());\n        points.push(index);\n    }\n\
    \    points.sort();\n    let mut new_points = Vec::<isize>::new();\n    for i\
    \ in points.iter() {\n        new_points.push(nums[i]);\n    }\n    return new_points;\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `digits` in this scope\n  --> /tmp/tmp_dlcj1hy.rs:17:21\n\
    \   |\n17 |         let index = digits.index((digit as u32).abs());\n   |    \
    \                 ^^^^^^ help: a local variable with a similar name exists: `digit`\n\
    \nerror[E0599]: no method named `abs` found for type `u32` in the current scope\n\
    \  --> /tmp/tmp_dlcj1hy.rs:17:49\n   |\n17 |         let index = digits.index((digit\
    \ as u32).abs());\n   |                                                 ^^^ method\
    \ not found in `u32`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `&isize`\n  --> /tmp/tmp_dlcj1hy.rs:23:25\n   |\n23 |         new_points.push(nums[i]);\n\
    \   |                         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0606]: casting `&isize` as `usize` is invalid\n \
    \ --> /tmp/tmp_dlcj1hy.rs:16:21\n   |\n16 |         let digit = i as usize;\n\
    \   |                     -^^^^^^^^^\n   |                     |\n   |       \
    \              cannot cast `&isize` as `usize`\n   |                     help:\
    \ dereference the expression: `*i`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425, E0599, E0606.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .filter(|(_, x)| x > 0)\n     \
    \   .map(|(_, x)| x)\n        .sort_by(|a, b| a.partial_cmp(b).unwrap_or(a.cmp(b)))\n\
    \        .map(|x| x.0)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpayw6f_55.rs:14:30\n   |\n\
    14 |         .filter(|(_, x)| x > 0)\n   |                              ^ expected\
    \ `&&isize`, found integer\n\nerror[E0599]: no method named `sort_by` found for\
    \ struct `Map` in the current scope\n  --> /tmp/tmpayw6f_55.rs:16:10\n   |\n16\
    \ |         .sort_by(|a, b| a.partial_cmp(b).unwrap_or(a.cmp(b)))\n   |      \
    \    ^^^^^^^ method not found in `Map<Filter<Enumerate<std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpayw6f_55.rs:14:17: 14:31]>, [closure@/tmp/tmpayw6f_55.rs:15:14:\
    \ 15:24]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut sorted_nums = nums.clone();\n\
    \    let mut sum = 0;\n    let mut smallest = sorted_nums.iter().min();\n    let\
    \ mut largest = sorted_nums.iter().max();\n\n    while smallest != largest {\n\
    \        // Find the sum of digits of the remaining numbers\n        let digits\
    \ = sorted_nums.iter().filter(|&n| n % 10 == 0).count() + 1;\n        // Sort\
    \ the remaining numbers using the sum of the digits as the sorting key\n     \
    \   sorted_nums.sort_by(|a, b| {\n            sum.saturating_sub(a.to_digits())\
    \ <=> sum.saturating_sub(b.to_digits())\n        });\n        // Find the index\
    \ of the remaining smallest number\n        let mut index = sorted_nums.iter().position(|&n|\
    \ n == smallest);\n        // If the sum of digits of the remaining numbers is\
    \ smaller\n        // than the smallest number, put the smallest number at the\
    \ first\n        // position of the sorted numbers\n        if sum < smallest\
    \ {\n            smallest = sorted_nums[0];\n            index = 0;\n        }\n\
    \        // If the sum of digits of the remaining numbers is bigger\n        //\
    \ than the largest number, put the largest number at the last\n        // position\
    \ of the sorted numbers\n        if sum > largest {\n            largest = sorted_nums[sorted_nums.len()\
    \ - 1];\n            index = sorted_nums.len() - 1;\n        }\n        // Add\
    \ the remaining numbers to the sorted numbers\n        sorted_nums.drain(..index,\
    \ |&n| {\n            sorted_nums.push_back(n);\n        });\n        // Add the\
    \ smallest number to the sorted numbers\n        sorted_nums.insert(index, smallest);\n\
    \        // Add the remaining digits of the sum to the sum\n        sum += digits.saturating_sub(1);\n\
    \    }\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: invalid comparison operator `<=>`\n  --> /tmp/tmpd962mcve.rs:24:47\n\
    \   |\n24 |             sum.saturating_sub(a.to_digits()) <=> sum.saturating_sub(b.to_digits())\n\
    \   |                                               ^^^ `<=>` is not a valid comparison\
    \ operator, use `std::cmp::Ordering`\n\nerror[E0689]: can't call method `saturating_sub`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpd962mcve.rs:24:17\n   |\n\
    24 |             sum.saturating_sub(a.to_digits()) <=> sum.saturating_sub(b.to_digits())\n\
    \   |                 ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n15 |     let mut sum: i32 = 0;\n   |       \
    \  ~~~~~~~~~~~~\n\nerror[E0599]: no method named `to_digits` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpd962mcve.rs:24:34\n   |\n24 | \
    \            sum.saturating_sub(a.to_digits()) <=> sum.saturating_sub(b.to_digits())\n\
    \   |                                  ^^^^^^^^^ method not found in `&isize`\n\
    \nerror[E0689]: can't call method `saturating_sub` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpd962mcve.rs:24:55\n   |\n24 |             sum.saturating_sub(a.to_digits())\
    \ <=> sum.saturating_sub(b.to_digits())\n   |                                \
    \                       ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n15 |     let mut sum: i32 = 0;\n   |       \
    \  ~~~~~~~~~~~~\n\nerror[E0599]: no method named `to_digits` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpd962mcve.rs:24:72\n   |\n24 | \
    \            sum.saturating_sub(a.to_digits()) <=> sum.saturating_sub(b.to_digits())\n\
    \   |                                                                        ^^^^^^^^^\
    \ method not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd962mcve.rs:24:13\n\
    \   |\n24 |             sum.saturating_sub(a.to_digits()) <=> sum.saturating_sub(b.to_digits())\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        nums\n    } else {\n        let mut smallest = nums.iter().min();\n\
    \        let mut largest = nums.iter().max();\n        let mut i = 0;\n      \
    \  while i < nums.len() {\n            let mut sum_digits = nums[i] / 10 + nums[i]\
    \ % 10;\n            let mut smallest_digits = nums[smallest] / 10 + nums[smallest]\
    \ % 10;\n            let mut largests_digits = nums[largest] / 10 + nums[largest]\
    \ % 10;\n\n            if sum_digits < smallest_digits {\n                smallest\
    \ = i;\n            } else {\n                largest = i;\n            }\n\n\
    \            i += 1;\n        }\n\n        nums.swap_remove(smallest);\n     \
    \   nums.swap_remove(largest);\n        nums\n    }\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `Option<&isize>`\n\
    \  --> /tmp/tmpkdrbhs46.rs:19:39\n   |\n19 |             let mut smallest_digits\
    \ = nums[smallest] / 10 + nums[smallest] % 10;\n   |                         \
    \              ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `Option<&isize>`\n\
    \   = note: required because of the requirements on the impl of `Index<Option<&isize>>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `Option<&isize>`\n\
    \  --> /tmp/tmpkdrbhs46.rs:19:61\n   |\n19 |             let mut smallest_digits\
    \ = nums[smallest] / 10 + nums[smallest] % 10;\n   |                         \
    \                                    ^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<&isize>`\n   = note: required because of the\
    \ requirements on the impl of `Index<Option<&isize>>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `Option<&isize>`\n  --> /tmp/tmpkdrbhs46.rs:20:39\n\
    \   |\n20 |             let mut largests_digits = nums[largest] / 10 + nums[largest]\
    \ % 10;\n   |                                       ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<&isize>`\n   = note: required because of the\
    \ requirements on the impl of `Index<Option<&isize>>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `Option<&isize>`\n  --> /tmp/tmpkdrbhs46.rs:20:60\n\
    \   |\n20 |             let mut largests_digits = nums[largest] / 10 + nums[largest]\
    \ % 10;\n   |                                                            ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<&isize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<&isize>>`\
    \ for `Vec<isize>`\n\nerror[E0308"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Get the\
    \ digits of the sum of each number in the list\n    let mut nums_digits = nums.iter().map(|x|\
    \ x.digits()).collect::<Vec<_>>();\n    let mut counter = 0;\n    let mut nums_sum_digits\
    \ = 0;\n    // Find the index of the smallest sum\n    for num in nums {\n   \
    \     nums_digits += num.digits();\n        let prev_sum_digits = nums_sum_digits;\n\
    \        nums_sum_digits += prev_sum_digits + num.digits();\n        counter +=\
    \ 1;\n        if nums_sum_digits == prev_sum_digits {\n            continue;\n\
    \        }\n        let mut smallest_sum = prev_sum_digits - nums_sum_digits;\n\
    \        for i in nums.iter().skip(counter).enumerate() {\n            if nums[i].digits()\
    \ < smallest_sum {\n                smallest_sum = nums[i].digits();\n       \
    \     }\n        }\n        // If the previous smallest sum is equal to the current\
    \ one,\n        // move it to the last position in the list\n        if nums_sum_digits\
    \ == smallest_sum {\n            nums.remove(counter);\n        }\n    }\n   \
    \ nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmprnrr3lnv.rs:12:49\n   |\n12 |     let mut nums_digits\
    \ = nums.iter().map(|x| x.digits()).collect::<Vec<_>>();\n   |               \
    \                                  ^^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmprnrr3lnv.rs:17:28\n   |\n17 |         nums_digits += num.digits();\n\
    \   |                            ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmprnrr3lnv.rs:19:50\n   |\n19 |         nums_sum_digits += prev_sum_digits\
    \ + num.digits();\n   |                                                  ^^^^^^\
    \ method not found in `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `(usize, &isize)`\n  --> /tmp/tmprnrr3lnv.rs:26:16\n   |\n26 |          \
    \   if nums[i].digits() < smallest_sum {\n   |                ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `(usize, &isize)`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `(Bound<usize>, Bound<usize>)`\n   = note: required because\
    \ of the requirements on the impl of `Index<(usize, &isize)>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `(usize, &isize)`\n  -->\
    \ /tmp/tmprnrr3lnv.rs:27:32\n   |\n27 |                 smallest_sum = nums[i].digits();\n\
    \   |                                ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `(usize, &isize)`\n   = help: the trait `SliceIndex<[T]>` is\
    \ implemented for `(Bound<usize>, Bound<usize>)`\n   = note: required because\
    \ of the requirements on the impl of `Index<(usize, &isize)>` for `Vec<isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum_of_digits: isize = 0;\n    for n in nums.iter() {\n        let digit = nums[n].log10().expect(\"\
    num must be non-negative\");\n        sum_of_digits += digit;\n    }\n    let\
    \ mut res = vec![nums.iter().cloned().collect::<Vec<_>>()];\n    for n in nums.iter()\
    \ {\n        let digit = nums[n].log10().expect(\"num must be non-negative\");\n\
    \        let pos = *n as usize;\n        res[pos] = if sum_of_digits < digit {\n\
    \            pos\n        } else {\n            pos\n        };\n        sum_of_digits\
    \ -= digit;\n    }\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp7tn2ix0v.rs:13:21\n\
    \   |\n13 |         let digit = nums[n].log10().expect(\"num must be non-negative\"\
    );\n   |                     ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmp7tn2ix0v.rs:18:21\n   |\n18 |         let digit = nums[n].log10().expect(\"\
    num must be non-negative\");\n   |                     ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7tn2ix0v.rs:21:13\n\
    \   |\n21 |             pos\n   |             ^^^ expected struct `Vec`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7tn2ix0v.rs:23:13\n\
    \   |\n23 |             pos\n   |             ^^^ expected struct `Vec`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7tn2ix0v.rs:27:5\n\
    \   |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |       \
    \                                  ---------- expected `Vec<isize>` because of\
    \ return type\n...\n27 |     res\n   |     ^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<Vec<isize>>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ res = nums.clone();\n\n    let mut s = nums.iter().fold(0, |acc, n| acc + (n\
    \ % 10) as isize);\n    res.sort_by(|a, b| s.partial_cmp(&b.into_inner()).unwrap());\n\
    \n    res.clone()\n}\n\nfn main() {\n    let candidate = order_by_points;\n  \
    \  assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_inner` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmprd1nduqq.rs:14:41\n   |\n14 |     res.sort_by(|a,\
    \ b| s.partial_cmp(&b.into_inner()).unwrap());\n   |                         \
    \                ^^^^^^^^^^ method not found in `&isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums = nums;\n    let mut dig = vec![0; nums.len()];\n    let mut min_val =\
    \ nums[0];\n    let mut max_val = nums[0];\n    for i in 0..nums.len() {\n   \
    \     if nums[i] < min_val {\n            min_val = nums[i];\n        }\n    \
    \    if nums[i] > max_val {\n            max_val = nums[i];\n        }\n     \
    \   dig[i] = nums[i] / 10;\n    }\n    for i in 0..nums.len() {\n        if dig[i]\
    \ != 0 {\n            nums[i] = (nums[i] - 10 * dig[i]) as isize;\n        }\n\
    \    }\n    for num in nums.iter() {\n        if num > max_val {\n           \
    \ nums.swap(i, nums.iter().filter(|&num| *num >= max_val).last().unwrap().unwrap()\
    \ + 1);\n        }\n    }\n    nums.sort_unstable_by(|&num| num.iter().sum::<isize>());\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp5t4p5hry.rs:31:23\n\
    \   |\n31 |             nums.swap(i, nums.iter().filter(|&num| *num >= max_val).last().unwrap().unwrap()\
    \ + 1);\n   |                       ^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5t4p5hry.rs:30:18\n   |\n30 |         if num\
    \ > max_val {\n   |                  ^^^^^^^\n   |                  |\n   |  \
    \                expected `&isize`, found `isize`\n   |                  help:\
    \ consider borrowing here: `&max_val`\n\nerror[E0599]: no method named `unwrap`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp5t4p5hry.rs:31:85\n\
    \   |\n31 |             nums.swap(i, nums.iter().filter(|&num| *num >= max_val).last().unwrap().unwrap()\
    \ + 1);\n   |                                                                \
    \                     ^^^^^^ method not found in `&isize`\n\nerror[E0593]: closure\
    \ is expected to take 2 arguments, but it takes 1 argument\n  --> /tmp/tmp5t4p5hry.rs:34:10\n\
    \   |\n34 |     nums.sort_unstable_by(|&num| num.iter().sum::<isize>());\n   |\
    \          ^^^^^^^^^^^^^^^^ ------ takes 1 argument\n   |          |\n   |   \
    \       expected closure that takes 2 arguments\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0593, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut nums_sum = nums.iter().filter(|&n|\
    \ n % 10 == 0).sum::<usize>();\n    nums.sort_unstable_by(|a, b| {\n        if\
    \ nums_sum - b.iter().filter(|&n| n % 10 == 0).sum::<usize>() < nums_sum - a.iter().filter(|&n|\
    \ n % 10 == 0).sum::<usize>() {\n            Ordering::Ascending\n        } else\
    \ {\n            Ordering::Descending\n        }\n    });\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp3lz6uhf5.rs:17:13\n   |\n17 |             Ordering::Ascending\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp3lz6uhf5.rs:19:13\n\
    \   |\n19 |             Ordering::Descending\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0277]: the trait bound `usize: Sum<&isize>`\
    \ is not satisfied\n    --> /tmp/tmp3lz6uhf5.rs:14:61\n     |\n14   |     let\
    \ mut nums_sum = nums.iter().filter(|&n| n % 10 == 0).sum::<usize>();\n     |\
    \                                                             ^^^ the trait `Sum<&isize>`\
    \ is not implemented for `usize`\n     |\n     = help: the following other types\
    \ implement trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n          \
    \     <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n               <f64\
    \ as Sum>\n               <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n\
    \               <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n         \
    \    and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\n\
    error[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmp3lz6uhf5.rs:16:25\n   |\n16 |         if nums_sum - b.iter().filter(|&n|\
    \ n % 10 == 0).sum::<usize>() < nums_sum - a.iter().filter(|&n| n % 10 == 0).sum::<usize>()\
    \ {\n   |                         ^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&isize` in the current scope\n \
    \ --> /tmp/tmp3lz6uhf5.rs:16:87\n   |\n16 |         if nums_sum - b.iter().filter(|&n|\
    \ n % 10 == 0).sum::<usize>() < nums_sum - a.iter().filter(|&n| n % 10 == 0).sum::<usize>()\
    \ {\n   |                                                                    \
    \                   ^^^^ method not found in `&isize`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .cloned()\n        .map(|n| {\n            fn subdigits(n:\
    \ isize) -> isize {\n                let mut sum = 0;\n                while n\
    \ > 0 {\n                    sum += n % 10;\n                    n /= 10;\n  \
    \              }\n                sum\n            }\n            std::mem::swap(sum,\
    \ subdigits(n))\n        })\n        .cloned()\n        .sorted()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `sum` in this scope\n  --> /tmp/tmpmak0pdzc.rs:23:28\n\
    \   |\n23 |             std::mem::swap(sum, subdigits(n))\n   |              \
    \              ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmak0pdzc.rs:23:33\n   |\n23 |             std::mem::swap(sum, subdigits(n))\n\
    \   |                                 ^^^^^^^^^^^^\n   |                     \
    \            |\n   |                                 expected `&mut _`, found\
    \ `isize`\n   |                                 help: consider mutably borrowing\
    \ here: `&mut subdigits(n)`\n   |\n   = note: expected mutable reference `&mut\
    \ _`\n                           found type `isize`\n\nerror[E0271]: type mismatch\
    \ resolving `<[closure@/tmp/tmpmak0pdzc.rs:14:14: 24:10] as FnOnce<(isize,)>>::Output\
    \ == &_`\n    --> /tmp/tmpmak0pdzc.rs:25:10\n     |\n25   |         .cloned()\n\
    \     |          ^^^^^^ expected reference, found `()`\n     |\n     = note: expected\
    \ reference `&_`\n                found unit type `()`\n     = note: required\
    \ because of the requirements on the impl of `Iterator` for `Map<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpmak0pdzc.rs:14:14: 24:10]>`\nnote: required by a bound\
    \ in `cloned`\n\nerror[E0599]: no method named `sorted` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpmak0pdzc.rs:26:10\n   |\n26 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `Cloned<Map<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpmak0pdzc.rs:14:14: 24:10]>>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum = 0;\n    let mut counter = nums.len();\n    let mut res = vec![];\n   \
    \ while counter > 0 {\n        if counter > 1 {\n            sum += nums[counter\
    \ / 2].unwrap() * 10 + nums[counter / 2].unwrap();\n        } else {\n       \
    \     sum += nums[counter / 2].unwrap();\n        }\n        res.push(sum);\n\
    \        counter -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp464svi4s.rs:16:38\n   |\n16 |             sum += nums[counter\
    \ / 2].unwrap() * 10 + nums[counter / 2].unwrap();\n   |                     \
    \                 ^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmp464svi4s.rs:16:72\n\
    \   |\n16 |             sum += nums[counter / 2].unwrap() * 10 + nums[counter\
    \ / 2].unwrap();\n   |                                                       \
    \                 ^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmp464svi4s.rs:18:38\n\
    \   |\n18 |             sum += nums[counter / 2].unwrap();\n   |             \
    \                         ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_by_key(|num|\
    \ {\n        digits_sum(num).expect(\"digits sum not positive\")\n    });\n  \
    \  nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digits_sum` in this scope\n  --> /tmp/tmp8af_ji8j.rs:12:9\n\
    \   |\n12 |         digits_sum(num).expect(\"digits sum not positive\")\n   |\
    \         ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    let mut points: Vec<isize> = nums.iter().cloned().collect();\n\
    \    let mut cur_digit: Vec<isize> = nums.iter().cloned().collect();\n    let\
    \ mut cur_sum: Vec<isize> = nums.iter().cloned().collect();\n    loop {\n    \
    \    if cur_sum[0] < cur_digit[0] {\n            points.swap(0, 1);\n        \
    \    cur_sum.swap(0, 1);\n            cur_digit.swap(0, 1);\n        }\n     \
    \   let cur = cur_sum.iter().cloned().sum();\n        let len = cur_sum.len();\n\
    \        if cur == cur_digit[len] {\n            cur_digit = &cur_digit[len..];\n\
    \            cur_sum = &cur_sum[len..];\n            points.swap(0, 1);\n    \
    \        cur_sum.swap(0, 1);\n            cur_digit.swap(0, 1);\n        }\n \
    \       if points.len() == 1 {\n            break;\n        }\n    }\n    points\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3pip5eky.rs:26:25\n   |\n\
    15 |     let mut cur_digit: Vec<isize> = nums.iter().cloned().collect();\n   |\
    \                        ---------- expected due to this type\n...\n26 |     \
    \        cur_digit = &cur_digit[len..];\n   |                         ^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&[isize]`\nhelp: try using a conversion method\n\
    \   |\n26 |             cur_digit = (&cur_digit[len..]).to_vec();\n   |      \
    \                   +                 ++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pip5eky.rs:27:23\n   |\n16 |     let mut cur_sum: Vec<isize> =\
    \ nums.iter().cloned().collect();\n   |                      ---------- expected\
    \ due to this type\n...\n27 |             cur_sum = &cur_sum[len..];\n   |   \
    \                    ^^^^^^^^^^^^^^^ expected struct `Vec`, found `&[isize]`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found reference `&[isize]`\n\
    help: try using a conversion method\n   |\n27 |             cur_sum = (&cur_sum[len..]).to_vec();\n\
    \   |                       +               ++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_ = nums;\n    sort_into_buckets(&mut nums_);\n    nums_\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_into_buckets` in this scope\n\
    \  --> /tmp/tmpflx9__bq.rs:12:5\n   |\n12 |     sort_into_buckets(&mut nums_);\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_sorted = nums.clone();\n    let mut last_num: isize = 0;\n    while nums_sorted.len()\
    \ > 0 {\n        last_num = nums_sorted.len() - 1;\n        let mut curSum = 0;\n\
    \        for &i in &nums_sorted {\n            curSum += *i;\n            if curSum\
    \ != last_num {\n                swap(&mut nums_sorted, last_num, curSum);\n \
    \           }\n            last_num = curSum;\n        }\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp7uqhtmi8.rs:19:17\n\
    \   |\n19 |                 swap(&mut nums_sorted, last_num, curSum);\n   |  \
    \               ^^^^ not found in this scope\n   |\nhelp: consider importing one\
    \ of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7uqhtmi8.rs:14:20\n   |\n\
    12 |     let mut last_num: isize = 0;\n   |                       ----- expected\
    \ due to this type\n13 |     while nums_sorted.len() > 0 {\n14 |         last_num\
    \ = nums_sorted.len() - 1;\n   |                    ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp7uqhtmi8.rs:17:23\n   |\n17 |             curSum += *i;\n   | \
    \                      ^^\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sum: isize = 0;\n    for n in nums {\n        sum += nums[n];\n    }\n    order_by_digits(&nums,\
    \ &mut sum);\n    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `order_by_digits` in this scope\n  -->\
    \ /tmp/tmpoc7eean2.rs:15:5\n   |\n15 |     order_by_digits(&nums, &mut sum);\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpoc7eean2.rs:13:16\n   |\n13 |  \
    \       sum += nums[n];\n   |                ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    debug_assert!(nums.is_sorted());\n\
    \    let mut sum: isize = 0;\n    let mut index = 0;\n    let mut sorted_nums\
    \ = Vec::new();\n    while index < nums.len() {\n        sum += nums[index];\n\
    \        sorted_nums.push((nums[index], index));\n        index += 1;\n    }\n\
    \    sorted_nums.sort_by_key(|&(k, _)| sum);\n    let mut result: Vec<isize> =\
    \ Vec::new();\n    sorted_nums.for_each(|(val, ind)| {\n        result.push(val);\n\
    \        result.push(ind);\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmpwvijs4wn.rs:11:24\n   |\n11 |     debug_assert!(nums.is_sorted());\n\
    \   |                        ^^^^^^^^^\n   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0599]: `Vec<(isize, usize)>` is not an iterator\n\
    \   --> /tmp/tmpwvijs4wn.rs:22:17\n    |\n22  |       sorted_nums.for_each(|(val,\
    \ ind)| {\n    |                   ^^^^^^^^ `Vec<(isize, usize)>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<(isize, usize)>: Iterator`\n            which is required by `&mut Vec<(isize,\
    \ usize)>: Iterator`\n            `[(isize, usize)]: Iterator`\n            which\
    \ is required by `&mut [(isize, usize)]: Iterator`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0599, E0658.\nFor\
    \ more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut map = HashMap::<isize, usize>::new();\n\
    \    for &x in nums.iter() {\n        if !map.contains_key(x) {\n            map.insert(x,\
    \ 0);\n        }\n        map.entry(x).or_insert(0) += x;\n    }\n    let mut\
    \ res = vec![];\n    for (key, value) in map.iter() {\n        if value != 0 {\n\
    \            let mut tmp = vec![];\n            for i in 0..value {\n        \
    \        tmp.push(key);\n            }\n            res.push(*tmp);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpgzvuta22.rs:14:19\n   |\n14 |     let mut map = HashMap::<isize, usize>::new();\n\
    \   |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpgzvuta22.rs:19:35\n   |\n\
    19 |         map.entry(x).or_insert(0) += x;\n   |         -------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0277]:\
    \ the size for values of type `[_]` cannot be known at compilation time\n   -->\
    \ /tmp/tmpgzvuta22.rs:28:22\n    |\n28  |             res.push(*tmp);\n    | \
    \                ---- ^^^^ doesn't have a size known at compile-time\n    |  \
    \               |\n    |                 required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `Sized` is not implemented for `[_]`\nnote:\
    \ required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values\
    \ of type `[_]` cannot be known at compilation time\n   --> /tmp/tmpgzvuta22.rs:21:19\n\
    \    |\n21  |     let mut res = vec![];\n    |                   ^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `[_]`\nnote: required by a bound in `Vec::<T>::new`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `[_]` cannot be\
    \ known at compilation time\n   --> /tmp/tmpgzvuta22.rs:21:19\n    |\n21  |  \
    \   let mut res = vec![];\n    |                   ^^^^^^ doesn't have a size\
    \ known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `[_]`\nnote: required by a bound in `Vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgzvuta22.rs:31:5\n  \
    \ |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                ---"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .sort_by(|(idx, &n), &(x,)| {\n\
    \            assert!(x.to_digits() == n.to_digits());\n            idx\n     \
    \   })\n        .map(|(_, x)| x)\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpv7fb3nnh.rs:14:10\n   |\n14 |         .sort_by(|(idx,\
    \ &n), &(x,)| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Sort\
    \ the given vector in ascending order\n    // according to the sum of their digits.\n\
    \    vec!\n        .iter()\n        .cloned()\n        .sort_by(|a, b| {\n   \
    \         // Calculate the sum of digits using Sum function\n            let a1:\
    \ isize = (a as isize).to_digits();\n            let b1: isize = (b as isize).to_digits();\n\
    \n            // Calculate the sum using Sum function\n            let sum1: isize\
    \ = a1.to_digits() + b1.to_digits();\n\n            // Return 1 if two elements\
    \ have the same sum of digits\n            if sum1 == 0 {\n                0\n\
    \            } else {\n                // Return 1 if a < b\n                if\
    \ a1 < b1 {\n                    -1\n                } else {\n              \
    \      1\n                }\n            }\n        })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `.`\n  --> /tmp/tmpmh2oms3n.rs:14:9\n\
    \   |\n13 |     vec!\n   |         - expected one of `(`, `[`, or `{`\n14 |  \
    \       .iter()\n   |         ^ unexpected token\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut total = 0;\n    let mut ans = Vec::new();\n\
    \    while nums_copy.len() > 0 {\n        total += nums_copy.pop();\n        if\
    \ nums_copy.len() == 0 {\n            ans.push(total as isize);\n            total\
    \ = 0;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmpiw2xcbsr.rs:15:15\n\
    \   |\n15 |         total += nums_copy.pop();\n   |               ^^ no implementation\
    \ for `{integer} += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ counter = 0;\n    for num in nums {\n        counter += num as isize;\n    }\n\
    \    let mut result = Vec::new();\n    for num in nums {\n        if num as isize\
    \ < 0 {\n            num = -num as isize;\n            counter = -counter;\n \
    \       }\n        result.push(num);\n    }\n    if counter > 0 {\n        result\
    \ = result.into_iter().filter(|num| num as isize == counter).collect();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmpo7j1s21g.rs:17:25\n   |\n17 |         if num\
    \ as isize < 0 {\n   |                         ^ --- interpreted as generic arguments\n\
    \   |                         |\n   |                         not interpreted\
    \ as comparison\n   |\nhelp: try comparing the cast value\n   |\n17 |        \
    \ if (num as isize) < 0 {\n   |            +            +\n\nerror[E0606]: casting\
    \ `&isize` as `isize` is invalid\n  --> /tmp/tmpo7j1s21g.rs:24:50\n   |\n24 |\
    \         result = result.into_iter().filter(|num| num as isize == counter).collect();\n\
    \   |                                                  ---^^^^^^^^^\n   |    \
    \                                              |\n   |                       \
    \                           cannot cast `&isize` as `isize`\n   |            \
    \                                      help: dereference the expression: `*num`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums = nums.clone();\n    nums.sort_by_key(|x| {\n        let mut acc = 0;\n\
    \        for x in nums {\n            acc += x;\n        }\n        acc\n    });\n\
    \    nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpgetsv0hf.rs:12:23\n   |\n\
    12 |     nums.sort_by_key(|x| {\n   |                       ^ help: if this is\
    \ intentional, prefix it with an underscore: `_x`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0507]: cannot move out of `nums`, a captured variable\
    \ in an `FnMut` closure\n   --> /tmp/tmpgetsv0hf.rs:14:18\n    |\n11  |      \
    \ let mut nums = nums.clone();\n    |           -------- captured outer variable\n\
    12  |       nums.sort_by_key(|x| {\n    |  ______________________-\n13  | |  \
    \       let mut acc = 0;\n14  | |         for x in nums {\n    | |           \
    \       ^^^^\n    | |                  |\n    | |                  `nums` moved\
    \ due to this implicit call to `.into_iter()`\n    | |                  move occurs\
    \ because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n\
    15  | |             acc += x;\n16  | |         }\n17  | |         acc\n18  | |\
    \     });\n    | |_____- captured by this `FnMut` closure\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n14  |         for x in &nums {\n    |                  +\n\nerror[E0505]:\
    \ cannot move out of `nums` because it is borrowed\n  --> /tmp/tmpgetsv0hf.rs:12:22\n\
    \   |\n12 |       nums.sort_by_key(|x| {\n   |       -                ^^^ move\
    \ out of `nums` occurs here\n   |  _____|\n   | |\n13 | |         let mut acc\
    \ = 0;\n14 | |         for x in nums {\n   | |                  ---- move occurs\
    \ due to use in closure\n15 | |             acc += x;\n16 | |         }\n17 |\
    \ |         acc\n18 | |     });\n   | |______- borrow of `nums` occurs here\n\n\
    error[E0382]: use of moved value: `nums`\n  --> /tmp/tmpgetsv0hf.rs:19:5\n   |\n\
    11 |     let mut nums = nums.clone();\n   |         -------- move occurs because\
    \ `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n12\
    \ |     nums.sort_by_key(|x| {\n   |                      --- value moved into\
    \ closure here\n13 |         let mut acc ="
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    // Use map\
    \ to transform the vector into a new vector of same size and\n    // different\
    \ elements\n    let mut new_nums = nums.iter().map(|x| x as isize).collect();\n\
    \    let mut sum: isize = 0;\n    // Sum the digits of every new element\n   \
    \ new_nums.iter().for_each(|x| {\n        sum += x;\n    });\n    // Sort based\
    \ on their sum in ascending order\n    new_nums.sort_unstable_by(|a, b| sum -\
    \ a - b);\n    new_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpmyl161jf.rs:16:5\n\
    \   |\n13 |     let mut new_nums = nums.iter().map(|x| x as isize).collect();\n\
    \   |         ------------ consider giving `new_nums` a type\n...\n16 |     new_nums.iter().for_each(|x|\
    \ {\n   |     ^^^^^^^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  -->\
    \ /tmp/tmpmyl161jf.rs:13:44\n   |\n13 |     let mut new_nums = nums.iter().map(|x|\
    \ x as isize).collect();\n   |                                            -^^^^^^^^^\n\
    \   |                                            |\n   |                     \
    \                       cannot cast `&isize` as `isize`\n   |                \
    \                            help: dereference the expression: `*x`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0606.\nFor more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .cloned()\n        .sort_by_key(|&x| {\n            let\
    \ mut t = 0;\n            let mut s = x;\n            while s < 10 {\n       \
    \         t += s % 10;\n                s /= 10;\n            }\n            t\n\
    \        })\n        .cloned()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpywdlvu94.rs:14:10\n   |\n14 |         .sort_by_key(|&x|\
    \ {\n   |          ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.sort_by(|x,\
    \ y| {\n        if x == y {\n            x.partial_cmp(y)\n        } else {\n\
    \            x.partial_cmp(y).unwrap()\n        }\n    });\n    nums\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppaiq9jn9.rs:13:13\n   |\n\
    13 |             x.partial_cmp(y)\n   |             ^^^^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected enum\
    \ `std::cmp::Ordering`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976140
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums.iter().enumerate().sort().map(|(i,\
    \ item)| item)\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Enumerate` in the\
    \ current scope\n  --> /tmp/tmp45u79r67.rs:11:29\n   |\n11 |     nums.iter().enumerate().sort().map(|(i,\
    \ item)| item)\n   |                             ^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    debugln!(\"\
    order by points: {}\", nums);\n    let mut nums_without_zeros = nums;\n    let\
    \ mut new_nums = Vec::new();\n    for &n in nums_without_zeros {\n        if n\
    \ % 10 != 0 {\n            new_nums.push(n - n % 10);\n        } else {\n    \
    \        new_nums.push(n);\n        }\n    }\n    new_nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmpnyuz4gqa.rs:11:5\n\
    \   |\n11 |     debugln!(\"order by points: {}\", nums);\n   |     ^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnyuz4gqa.rs:14:9\n   |\n14 |   \
    \  for &n in nums_without_zeros {\n   |         ^^    ------------------ this\
    \ expression has type `Option<isize>`\n   |         |\n   |         expected `isize`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `n`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ sorted_nums = nums.clone();\n    let mut digits = nums.iter().map(|i| *i as\
    \ usize).collect::<Vec<usize>>();\n    digits.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\
    \    let mut total_digits = digits.length;\n    while total_digits > 1 {\n   \
    \     let mut min_digits = Vec::new();\n        for d in digits.iter() {\n   \
    \         if *d < 0 {\n                min_digits.push(- *d);\n            } else\
    \ {\n                min_digits.push(*d);\n            }\n        }\n        sorted_nums.sort_unstable_by(|a,\
    \ b| a.partial_cmp(&b).unwrap());\n        for d in min_digits.iter() {\n    \
    \        sorted_nums.remove(&d);\n            digits.insert(digits.iter().position(|&x|\
    \ x == d).unwrap(), d);\n            total_digits -= 1;\n        }\n    }\n  \
    \  sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `Vec<usize>`\n  --> /tmp/tmp5y4r86_k.rs:14:35\n\
    \   |\n14 |     let mut total_digits = digits.length;\n   |                  \
    \                 ^^^^^^ unknown field\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmp5y4r86_k.rs:19:33\n   |\n19 |           \
    \      min_digits.push(- *d);\n   |                                 ^^^^ cannot\
    \ apply unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5y4r86_k.rs:26:32\n   |\n26 |\
    \             sorted_nums.remove(&d);\n   |                                ^^\
    \ expected `usize`, found `&&usize`\n   |\nhelp: consider removing the `&` and\
    \ dereferencing the borrow instead\n   |\n26 |             sorted_nums.remove(*d);\n\
    \   |                                ~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5y4r86_k.rs:27:60\n   |\n27 |             digits.insert(digits.iter().position(|&x|\
    \ x == d).unwrap(), d);\n   |                                                \
    \            ^ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |             digits.insert(digits.iter().position(|&x|\
    \ x == *d).unwrap(), d);\n   |                                               \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5y4r86_k.rs:27:73\n\
    \   |\n27 |             digits.insert(digits.iter().position(|&x| x == d).unwrap(),\
    \ d);\n   |                                                                  \
    \       ^ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |             digits.insert(digits.iter().position(|&x|\
    \ x == d).unwrap(), *d);\n   |                                               \
    \                          +\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0600, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ points = Vec::new();\n    nums.sort_by_key(|x| {\n        let mut sum: isize\
    \ = 0;\n        let mut i: isize = 0;\n        while i < x {\n            sum\
    \ += *i as isize;\n            i += 1;\n        }\n        if sum < 0 {\n    \
    \        sum + 10000\n        } else {\n            sum\n        }\n    });\n\
    \    for n in nums {\n        points.push(n);\n    }\n    points\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdp1k8w9g.rs:15:19\n   |\n\
    15 |         while i < x {\n   |                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |         while i < *x\
    \ {\n   |                   +\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpdp1k8w9g.rs:16:20\n   |\n16 |             sum += *i as isize;\n\
    \   |                    ^^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_clone = nums.clone();\n    nums_clone.sort_by_key(|x| nums_clone.iter().enumerate().find(|&(idx,\
    \ _)| x != x).unwrap_or(Ok(vec![])))\n        .cloned()\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_lpyw1u.rs:12:97\n   |\n\
    12 |     nums_clone.sort_by_key(|x| nums_clone.iter().enumerate().find(|&(idx,\
    \ _)| x != x).unwrap_or(Ok(vec![])))\n   |                                   \
    \                                                              ^^^^^^^^^^ expected\
    \ tuple, found enum `Result`\n   |\n   = note: expected tuple `(usize, &isize)`\n\
    \               found enum `Result<Vec<_>, _>`\n\nerror[E0599]: `()` is not an\
    \ iterator\n  --> /tmp/tmp8_lpyw1u.rs:13:10\n   |\n13 |         .cloned()\n  \
    \ |          ^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    nums\n \
    \       .iter()\n        .enumerate()\n        .fold(vec![], |mut acc, (i, &mut\
    \ n| *n).to_digits()\n            .iter()\n            .cloned()\n           \
    \ .fold(acc, |mut acc, x| {\n                if *x != 0 {\n                  \
    \  let digit = (*x % 10) as isize;\n                    *x /= 10;\n          \
    \          acc.push(digit);\n                } else {\n                    *acc\
    \ = acc\n                        .iter()\n                        .cloned()\n\
    \                        .filter(|&x| x == (*acc as isize).clone())\n        \
    \                .collect::<Vec<_>>()\n                        .unwrap_or(&**acc);\n\
    \                    acc.clear();\n                }\n                acc\n  \
    \          })\n            .to_vec());\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `*`\n  --> /tmp/tmppgcs__hx.rs:14:45\n \
    \  |\n14 |         .fold(vec![], |mut acc, (i, &mut n| *n).to_digits()\n   | \
    \                                    ------  ^ expected pattern\n   |        \
    \                             |\n   |                                     while\
    \ parsing this or-pattern starting here\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ ans = nums.clone();\n    for &n in &mut ans {\n        if n == 0 {\n       \
    \     n = -n - 1;\n        }\n        *n += n ** (1.0 / 8.0);\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp25qqz3io.rs:12:9\n   |\n\
    12 |     for &n in &mut ans {\n   |         ^^    -------- this expression has\
    \ type `Option<&mut isize>`\n   |         |\n   |         types differ in mutability\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0614]: type `{float}` cannot be dereferenced\n  -->\
    \ /tmp/tmp25qqz3io.rs:16:18\n   |\n16 |         *n += n ** (1.0 / 8.0);\n   |\
    \                  ^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976139
- exit_code: 1
  program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ num_points: usize = 0;\n    let mut min_num: isize = 0;\n    let mut max_num:\
    \ isize = 0;\n    for num in nums {\n        if num > 0 {\n            num_points\
    \ *= 10;\n            num_points += num % 10;\n        }\n    }\n    if num_points\
    \ == 0 {\n        return nums;\n    }\n    min_num += num_points;\n    for num\
    \ in nums {\n        if num > 0 {\n            max_num = max(max_num, num % 10);\n\
    \        }\n    }\n    let mut sorted_nums = vec![];\n    for num in nums {\n\
    \        if num == 0 {\n            sorted_nums.push(num);\n            continue;\n\
    \        }\n        let mut cur = num;\n        for _ in 0..(max_num - min_num\
    \ + 1) {\n            let point = cur % 10;\n            cur = cur / 10;\n   \
    \         if point > 0 {\n                sorted_nums.push(point);\n         \
    \   } else {\n                sorted_nums.push(num);\n            }\n        }\n\
    \    }\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpcmfqtpl6.rs:26:23\n\
    \   |\n26 |             max_num = max(max_num, num % 10);\n   |              \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcmfqtpl6.rs:17:27\n   |\n17 |             num_points += num % 10;\n\
    \   |                           ^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmpcmfqtpl6.rs:17:24\n   |\n\
    17 |             num_points += num % 10;\n   |                        ^^ no implementation\
    \ for `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcmfqtpl6.rs:23:16\n\
    \   |\n23 |     min_num += num_points;\n   |                ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `isize`\n\
    \  --> /tmp/tmpcmfqtpl6.rs:23:13\n   |\n23 |     min_num += num_points;\n   |\
    \             ^^ no implementation for `isize += usize`\n   |\n   = help: the\
    \ trait `AddAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0425.\n\
    For more information about an er"
  stdout: ''
  timestamp: 1659976139
